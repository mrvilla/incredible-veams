require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _handlebarsBase = require('./handlebars/base');

var base = _interopRequireWildcard(_handlebarsBase);

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)

var _handlebarsSafeString = require('./handlebars/safe-string');

var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

var _handlebarsException = require('./handlebars/exception');

var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

var _handlebarsUtils = require('./handlebars/utils');

var Utils = _interopRequireWildcard(_handlebarsUtils);

var _handlebarsRuntime = require('./handlebars/runtime');

var runtime = _interopRequireWildcard(_handlebarsRuntime);

var _handlebarsNoConflict = require('./handlebars/no-conflict');

var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
function create() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = _handlebarsSafeString2['default'];
  hb.Exception = _handlebarsException2['default'];
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;

  hb.VM = runtime;
  hb.template = function (spec) {
    return runtime.template(spec, hb);
  };

  return hb;
}

var inst = create();
inst.create = create;

_handlebarsNoConflict2['default'](inst);

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];


},{"./handlebars/base":2,"./handlebars/exception":5,"./handlebars/no-conflict":15,"./handlebars/runtime":16,"./handlebars/safe-string":17,"./handlebars/utils":18}],2:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _helpers = require('./helpers');

var _decorators = require('./decorators');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var VERSION = '4.0.11';
exports.VERSION = VERSION;
var COMPILER_REVISION = 7;

exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0'
};

exports.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials, decorators) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators || {};

  _helpers.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}

HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: _logger2['default'],
  log: _logger2['default'].log,

  registerHelper: function registerHelper(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple helpers');
      }
      _utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },

  registerPartial: function registerPartial(name, partial) {
    if (_utils.toString.call(name) === objectType) {
      _utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },

  registerDecorator: function registerDecorator(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple decorators');
      }
      _utils.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  }
};

var log = _logger2['default'].log;

exports.log = log;
exports.createFrame = _utils.createFrame;
exports.logger = _logger2['default'];


},{"./decorators":3,"./exception":5,"./helpers":6,"./logger":14,"./utils":18}],3:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _decoratorsInline = require('./decorators/inline');

var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}


},{"./decorators/inline":4}],4:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerDecorator('inline', function (fn, props, container, options) {
    var ret = fn;
    if (!props.partials) {
      props.partials = {};
      ret = function (context, options) {
        // Create a new partials stack frame prior to exec.
        var original = container.partials;
        container.partials = _utils.extend({}, original, props.partials);
        var ret = fn(context, options);
        container.partials = original;
        return ret;
      };
    }

    props.partials[options.args[0]] = options.fn;

    return ret;
  });
};

module.exports = exports['default'];


},{"../utils":18}],5:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var loc = node && node.loc,
      line = undefined,
      column = undefined;
  if (loc) {
    line = loc.start.line;
    column = loc.start.column;

    message += ' - ' + line + ':' + column;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  /* istanbul ignore else */
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Exception);
  }

  try {
    if (loc) {
      this.lineNumber = line;

      // Work around issue under safari where we can't directly set the column value
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(this, 'column', {
          value: column,
          enumerable: true
        });
      } else {
        this.column = column;
      }
    }
  } catch (nop) {
    /* Ignore if the browser is very particular */
  }
}

Exception.prototype = new Error();

exports['default'] = Exception;
module.exports = exports['default'];


},{}],6:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultHelpers = registerDefaultHelpers;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _helpersBlockHelperMissing = require('./helpers/block-helper-missing');

var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

var _helpersEach = require('./helpers/each');

var _helpersEach2 = _interopRequireDefault(_helpersEach);

var _helpersHelperMissing = require('./helpers/helper-missing');

var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

var _helpersIf = require('./helpers/if');

var _helpersIf2 = _interopRequireDefault(_helpersIf);

var _helpersLog = require('./helpers/log');

var _helpersLog2 = _interopRequireDefault(_helpersLog);

var _helpersLookup = require('./helpers/lookup');

var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

var _helpersWith = require('./helpers/with');

var _helpersWith2 = _interopRequireDefault(_helpersWith);

function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);
  _helpersEach2['default'](instance);
  _helpersHelperMissing2['default'](instance);
  _helpersIf2['default'](instance);
  _helpersLog2['default'](instance);
  _helpersLookup2['default'](instance);
  _helpersWith2['default'](instance);
}


},{"./helpers/block-helper-missing":7,"./helpers/each":8,"./helpers/helper-missing":9,"./helpers/if":10,"./helpers/log":11,"./helpers/lookup":12,"./helpers/with":13}],7:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('blockHelperMissing', function (context, options) {
    var inverse = options.inverse,
        fn = options.fn;

    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (_utils.isArray(context)) {
      if (context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }

        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data && options.ids) {
        var data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
        options = { data: data };
      }

      return fn(context, options);
    }
  });
};

module.exports = exports['default'];


},{"../utils":18}],8:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('../utils');

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('each', function (context, options) {
    if (!options) {
      throw new _exception2['default']('Must pass iterator to #each');
    }

    var fn = options.fn,
        inverse = options.inverse,
        i = 0,
        ret = '',
        data = undefined,
        contextPath = undefined;

    if (options.data && options.ids) {
      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }

    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    if (options.data) {
      data = _utils.createFrame(options.data);
    }

    function execIteration(field, index, last) {
      if (data) {
        data.key = field;
        data.index = index;
        data.first = index === 0;
        data.last = !!last;

        if (contextPath) {
          data.contextPath = contextPath + field;
        }
      }

      ret = ret + fn(context[field], {
        data: data,
        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
      });
    }

    if (context && typeof context === 'object') {
      if (_utils.isArray(context)) {
        for (var j = context.length; i < j; i++) {
          if (i in context) {
            execIteration(i, i, i === context.length - 1);
          }
        }
      } else {
        var priorKey = undefined;

        for (var key in context) {
          if (context.hasOwnProperty(key)) {
            // We're running the iterations one step out of sync so we can detect
            // the last iteration without have to scan the object twice and create
            // an itermediate keys array.
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          }
        }
        if (priorKey !== undefined) {
          execIteration(priorKey, i - 1, true);
        }
      }
    }

    if (i === 0) {
      ret = inverse(this);
    }

    return ret;
  });
};

module.exports = exports['default'];


},{"../exception":5,"../utils":18}],9:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('helperMissing', function () /* [args, ]options */{
    if (arguments.length === 1) {
      // A missing field in a {{foo}} construct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    }
  });
};

module.exports = exports['default'];


},{"../exception":5}],10:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('if', function (conditional, options) {
    if (_utils.isFunction(conditional)) {
      conditional = conditional.call(this);
    }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function (conditional, options) {
    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
  });
};

module.exports = exports['default'];


},{"../utils":18}],11:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('log', function () /* message, options */{
    var args = [undefined],
        options = arguments[arguments.length - 1];
    for (var i = 0; i < arguments.length - 1; i++) {
      args.push(arguments[i]);
    }

    var level = 1;
    if (options.hash.level != null) {
      level = options.hash.level;
    } else if (options.data && options.data.level != null) {
      level = options.data.level;
    }
    args[0] = level;

    instance.log.apply(instance, args);
  });
};

module.exports = exports['default'];


},{}],12:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('lookup', function (obj, field) {
    return obj && obj[field];
  });
};

module.exports = exports['default'];


},{}],13:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('with', function (context, options) {
    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    var fn = options.fn;

    if (!_utils.isEmpty(context)) {
      var data = options.data;
      if (options.data && options.ids) {
        data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
      }

      return fn(context, {
        data: data,
        blockParams: _utils.blockParams([context], [data && data.contextPath])
      });
    } else {
      return options.inverse(this);
    }
  });
};

module.exports = exports['default'];


},{"../utils":18}],14:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('./utils');

var logger = {
  methodMap: ['debug', 'info', 'warn', 'error'],
  level: 'info',

  // Maps a given level value to the `methodMap` indexes above.
  lookupLevel: function lookupLevel(level) {
    if (typeof level === 'string') {
      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
      if (levelMap >= 0) {
        level = levelMap;
      } else {
        level = parseInt(level, 10);
      }
    }

    return level;
  },

  // Can be overridden in the host environment
  log: function log(level) {
    level = logger.lookupLevel(level);

    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
      var method = logger.methodMap[level];
      if (!console[method]) {
        // eslint-disable-line no-console
        method = 'log';
      }

      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        message[_key - 1] = arguments[_key];
      }

      console[method].apply(console, message); // eslint-disable-line no-console
    }
  }
};

exports['default'] = logger;
module.exports = exports['default'];


},{"./utils":18}],15:[function(require,module,exports){
(function (global){
/* global window */
'use strict';

exports.__esModule = true;

exports['default'] = function (Handlebars) {
  /* istanbul ignore next */
  var root = typeof global !== 'undefined' ? global : window,
      $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function () {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
    return Handlebars;
  };
};

module.exports = exports['default'];


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],16:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.checkRevision = checkRevision;
exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _utils = require('./utils');

var Utils = _interopRequireWildcard(_utils);

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _base = require('./base');

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = _base.COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    }
  }
}

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
  }

  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }

    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var result = env.VM.invokePartial.call(this, partial, context, options);

    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, options);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }

          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name) {
      if (!(name in obj)) {
        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
      }
      return obj[name];
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        if (depths[i] && depths[i][name] != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },

    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },

    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    merge: function merge(param, common) {
      var obj = param || common;

      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }

      return obj;
    },
    // An empty object to use as replacement for null-contexts
    nullContext: Object.seal({}),

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var data = options.data;

    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
        blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }

    function main(context /*, options*/) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }
  ret.isTop = true;

  ret._setup = function (options) {
    if (!options.partial) {
      container.helpers = container.merge(options.helpers, env.helpers);

      if (templateSpec.usePartial) {
        container.partials = container.merge(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = container.merge(options.decorators, env.decorators);
      }
    } else {
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
    }
  };

  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _exception2['default']('must pass block params');
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception2['default']('must pass parent depths');
    }

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}

function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var currentDepths = depths;
    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
      currentDepths = [context].concat(depths);
    }

    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
  }

  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      partial = options.data['partial-block'];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}

function invokePartial(partial, context, options) {
  // Use the current closure context to save the partial-block if this partial
  var currentPartialBlock = options.data && options.data['partial-block'];
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }

  var partialBlock = undefined;
  if (options.fn && options.fn !== noop) {
    (function () {
      options.data = _base.createFrame(options.data);
      // Wrapper function to get access to currentPartialBlock from the closure
      var fn = options.fn;
      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        // Restore the partial-block from the closure for the execution of the block
        // i.e. the part inside the block of the partial call.
        options.data = _base.createFrame(options.data);
        options.data['partial-block'] = currentPartialBlock;
        return fn(context, options);
      };
      if (fn.partials) {
        options.partials = Utils.extend({}, options.partials, fn.partials);
      }
    })();
  }

  if (partial === undefined && partialBlock) {
    partial = partialBlock;
  }

  if (partial === undefined) {
    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}

function noop() {
  return '';
}

function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}

function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }
  return prog;
}


},{"./base":2,"./exception":5,"./utils":18}],17:[function(require,module,exports){
// Build out our basic SafeString type
'use strict';

exports.__esModule = true;
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  return '' + this.string;
};

exports['default'] = SafeString;
module.exports = exports['default'];


},{}],18:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.extend = extend;
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.createFrame = createFrame;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
};

var badChars = /[&<>"'`=]/g,
    possible = /[&<>"'`=]/;

function escapeChar(chr) {
  return escape[chr];
}

function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }

  return obj;
}

var toString = Object.prototype.toString;

exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  exports.isFunction = isFunction = function (value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
exports.isFunction = isFunction;

/* eslint-enable func-style */

/* istanbul ignore next */
var isArray = Array.isArray || function (value) {
  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
};

exports.isArray = isArray;
// Older IE versions do not directly support indexOf so we must implement our own, sadly.

function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}

function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }

  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}

function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}

function blockParams(params, ids) {
  params.path = ids;
  return params;
}

function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}


},{}],19:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime')['default'];

},{"./dist/cjs/handlebars.runtime":1}],20:[function(require,module,exports){
//! moment.js
//! version : 2.18.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
        // even if its not own property I'd still call it non-empty
        return false;
    }
    return true;
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

var some$1 = some;

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var keys$1 = keys;

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid()) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

var indexOf$1 = indexOf;

function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            require('./locale/' + name);
            // because defineLocale currently also sets the global locale, we
            // want to undo that for lazy loaded locales
            getSetGlobalLocale(oldLocale);
        } catch (e) { }
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys$1(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var string, match, dayFormat,
        dateFormat, timeFormat, tzFormat;
    var timezones = {
        ' GMT': ' +0000',
        ' EDT': ' -0400',
        ' EST': ' -0500',
        ' CDT': ' -0500',
        ' CST': ' -0600',
        ' MDT': ' -0600',
        ' MST': ' -0700',
        ' PDT': ' -0700',
        ' PST': ' -0800'
    };
    var military = 'YXWVUTSRQPONZABCDEFGHIKLM';
    var timezone, timezoneIndex;

    string = config._i
        .replace(/\([^\)]*\)|[\n\t]/g, ' ') // Remove comments and folding whitespace
        .replace(/(\s\s+)/g, ' ') // Replace multiple-spaces with a single space
        .replace(/^\s|\s$/g, ''); // Remove leading and trailing spaces
    match = basicRfcRegex.exec(string);

    if (match) {
        dayFormat = match[1] ? 'ddd' + ((match[1].length === 5) ? ', ' : ' ') : '';
        dateFormat = 'D MMM ' + ((match[2].length > 10) ? 'YYYY ' : 'YY ');
        timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');

        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        if (match[1]) { // day of week given
            var momentDate = new Date(match[2]);
            var momentDay = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][momentDate.getDay()];

            if (match[1].substr(0,3) !== momentDay) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return;
            }
        }

        switch (match[5].length) {
            case 2: // military
                if (timezoneIndex === 0) {
                    timezone = ' +0000';
                } else {
                    timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;
                    timezone = ((timezoneIndex < 0) ? ' -' : ' +') +
                        (('' + timezoneIndex).replace(/^-?/, '0')).match(/..$/)[0] + '00';
                }
                break;
            case 4: // Zone
                timezone = timezones[match[5]];
                break;
            default: // UT or +/-9999
                timezone = timezones[' GMT'];
        }
        match[5] = timezone;
        config._i = match.splice(1).join('');
        tzFormat = ' ZZ';
        config._f = dayFormat + dateFormat + timeFormat + tzFormat;
        configFromStringAndFormat(config);
        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
            output = output / 3;
        } else if (units === 'year') {
            output = output / 12;
        }
    } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : // 1000
            units === 'minute' ? delta / 6e4 : // 1000 * 60
            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
            delta;
    }
    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString() {
    if (!this.isValid()) {
        return null;
    }
    var m = this.clone().utc();
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        return this.toDate().toISOString();
    }
    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    return (total < 0 ? '-' : '') +
        'P' +
        (Y ? Y + 'Y' : '') +
        (M ? M + 'M' : '') +
        (D ? D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? h + 'H' : '') +
        (m ? m + 'M' : '') +
        (s ? s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.18.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));

},{}],21:[function(require,module,exports){
/*!
 * Pikaday
 *
 * Copyright  2014 David Bushell | BSD & MIT license | https://github.com/dbushell/Pikaday
 */

(function (root, factory)
{
    'use strict';

    var moment;
    if (typeof exports === 'object') {
        // CommonJS module
        // Load moment.js as an optional dependency
        try { moment = require('moment'); } catch (e) {}
        module.exports = factory(moment);
    } else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(function (req)
        {
            // Load moment.js as an optional dependency
            var id = 'moment';
            try { moment = req(id); } catch (e) {}
            return factory(moment);
        });
    } else {
        root.Pikaday = factory(root.moment);
    }
}(this, function (moment)
{
    'use strict';

    /**
     * feature detection and helper functions
     */
    var hasMoment = typeof moment === 'function',

    hasEventListeners = !!window.addEventListener,

    document = window.document,

    sto = window.setTimeout,

    addEvent = function(el, e, callback, capture)
    {
        if (hasEventListeners) {
            el.addEventListener(e, callback, !!capture);
        } else {
            el.attachEvent('on' + e, callback);
        }
    },

    removeEvent = function(el, e, callback, capture)
    {
        if (hasEventListeners) {
            el.removeEventListener(e, callback, !!capture);
        } else {
            el.detachEvent('on' + e, callback);
        }
    },

    trim = function(str)
    {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g,'');
    },

    hasClass = function(el, cn)
    {
        return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
    },

    addClass = function(el, cn)
    {
        if (!hasClass(el, cn)) {
            el.className = (el.className === '') ? cn : el.className + ' ' + cn;
        }
    },

    removeClass = function(el, cn)
    {
        el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));
    },

    isArray = function(obj)
    {
        return (/Array/).test(Object.prototype.toString.call(obj));
    },

    isDate = function(obj)
    {
        return (/Date/).test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
    },

    isWeekend = function(date)
    {
        var day = date.getDay();
        return day === 0 || day === 6;
    },

    isLeapYear = function(year)
    {
        // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    },

    getDaysInMonth = function(year, month)
    {
        return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
    },

    setToStartOfDay = function(date)
    {
        if (isDate(date)) date.setHours(0,0,0,0);
    },

    compareDates = function(a,b)
    {
        // weak date comparison (use setToStartOfDay(date) to ensure correct result)
        return a.getTime() === b.getTime();
    },

    extend = function(to, from, overwrite)
    {
        var prop, hasProp;
        for (prop in from) {
            hasProp = to[prop] !== undefined;
            if (hasProp && typeof from[prop] === 'object' && from[prop] !== null && from[prop].nodeName === undefined) {
                if (isDate(from[prop])) {
                    if (overwrite) {
                        to[prop] = new Date(from[prop].getTime());
                    }
                }
                else if (isArray(from[prop])) {
                    if (overwrite) {
                        to[prop] = from[prop].slice(0);
                    }
                } else {
                    to[prop] = extend({}, from[prop], overwrite);
                }
            } else if (overwrite || !hasProp) {
                to[prop] = from[prop];
            }
        }
        return to;
    },

    fireEvent = function(el, eventName, data)
    {
        var ev;

        if (document.createEvent) {
            ev = document.createEvent('HTMLEvents');
            ev.initEvent(eventName, true, false);
            ev = extend(ev, data);
            el.dispatchEvent(ev);
        } else if (document.createEventObject) {
            ev = document.createEventObject();
            ev = extend(ev, data);
            el.fireEvent('on' + eventName, ev);
        }
    },

    adjustCalendar = function(calendar) {
        if (calendar.month < 0) {
            calendar.year -= Math.ceil(Math.abs(calendar.month)/12);
            calendar.month += 12;
        }
        if (calendar.month > 11) {
            calendar.year += Math.floor(Math.abs(calendar.month)/12);
            calendar.month -= 12;
        }
        return calendar;
    },

    /**
     * defaults and localisation
     */
    defaults = {

        // bind the picker to a form field
        field: null,

        // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
        bound: undefined,

        // position of the datepicker, relative to the field (default to bottom & left)
        // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
        position: 'bottom left',

        // automatically fit in the viewport even if it means repositioning from the position option
        reposition: true,

        // the default output format for `.toString()` and `field` value
        format: 'YYYY-MM-DD',

        // the toString function which gets passed a current date object and format
        // and returns a string
        toString: null,

        // used to create date object from current input string
        parse: null,

        // the initial date to view when first opened
        defaultDate: null,

        // make the `defaultDate` the initial selected value
        setDefaultDate: false,

        // first day of week (0: Sunday, 1: Monday etc)
        firstDay: 0,

        // the default flag for moment's strict date parsing
        formatStrict: false,

        // the minimum/earliest date that can be selected
        minDate: null,
        // the maximum/latest date that can be selected
        maxDate: null,

        // number of years either side, or array of upper/lower range
        yearRange: 10,

        // show week numbers at head of row
        showWeekNumber: false,

        // Week picker mode
        pickWholeWeek: false,

        // used internally (don't config outside)
        minYear: 0,
        maxYear: 9999,
        minMonth: undefined,
        maxMonth: undefined,

        startRange: null,
        endRange: null,

        isRTL: false,

        // Additional text to append to the year in the calendar title
        yearSuffix: '',

        // Render the month after year in the calendar title
        showMonthAfterYear: false,

        // Render days of the calendar grid that fall in the next or previous month
        showDaysInNextAndPreviousMonths: false,

        // Allows user to select days that fall in the next or previous month
        enableSelectionDaysInNextAndPreviousMonths: false,

        // how many months are visible
        numberOfMonths: 1,

        // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
        // only used for the first display or when a selected date is not visible
        mainCalendar: 'left',

        // Specify a DOM element to render the calendar in
        container: undefined,

        // Blur field when date is selected
        blurFieldOnSelect : true,

        // internationalization
        i18n: {
            previousMonth : 'Previous Month',
            nextMonth     : 'Next Month',
            months        : ['January','February','March','April','May','June','July','August','September','October','November','December'],
            weekdays      : ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
            weekdaysShort : ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']
        },

        // Theme Classname
        theme: null,

        // events array
        events: [],

        // callback function
        onSelect: null,
        onOpen: null,
        onClose: null,
        onDraw: null
    },


    /**
     * templating functions to abstract HTML rendering
     */
    renderDayName = function(opts, day, abbr)
    {
        day += opts.firstDay;
        while (day >= 7) {
            day -= 7;
        }
        return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
    },

    renderDay = function(opts)
    {
        var arr = [];
        var ariaSelected = 'false';
        if (opts.isEmpty) {
            if (opts.showDaysInNextAndPreviousMonths) {
                arr.push('is-outside-current-month');

                if(!opts.enableSelectionDaysInNextAndPreviousMonths) {
                    arr.push('is-selection-disabled');
                }

            } else {
                return '<td class="is-empty"></td>';
            }
        }
        if (opts.isDisabled) {
            arr.push('is-disabled');
        }
        if (opts.isToday) {
            arr.push('is-today');
        }
        if (opts.isSelected) {
            arr.push('is-selected');
            ariaSelected = 'true';
        }
        if (opts.hasEvent) {
            arr.push('has-event');
        }
        if (opts.isInRange) {
            arr.push('is-inrange');
        }
        if (opts.isStartRange) {
            arr.push('is-startrange');
        }
        if (opts.isEndRange) {
            arr.push('is-endrange');
        }
        return '<td data-day="' + opts.day + '" class="' + arr.join(' ') + '" aria-selected="' + ariaSelected + '">' +
                 '<button class="pika-button pika-day" type="button" ' +
                    'data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' +
                        opts.day +
                 '</button>' +
               '</td>';
    },

    renderWeek = function (d, m, y) {
        // Lifted from http://javascript.about.com/library/blweekyear.htm, lightly modified.
        var onejan = new Date(y, 0, 1),
            weekNum = Math.ceil((((new Date(y, m, d) - onejan) / 86400000) + onejan.getDay()+1)/7);
        return '<td class="pika-week">' + weekNum + '</td>';
    },

    renderRow = function(days, isRTL, pickWholeWeek, isRowSelected)
    {
        return '<tr class="pika-row' + (pickWholeWeek ? ' pick-whole-week' : '') + (isRowSelected ? ' is-selected' : '') + '">' + (isRTL ? days.reverse() : days).join('') + '</tr>';
    },

    renderBody = function(rows)
    {
        return '<tbody>' + rows.join('') + '</tbody>';
    },

    renderHead = function(opts)
    {
        var i, arr = [];
        if (opts.showWeekNumber) {
            arr.push('<th></th>');
        }
        for (i = 0; i < 7; i++) {
            arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + '</abbr></th>');
        }
        return '<thead><tr>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</tr></thead>';
    },

    renderTitle = function(instance, c, year, month, refYear, randId)
    {
        var i, j, arr,
            opts = instance._o,
            isMinYear = year === opts.minYear,
            isMaxYear = year === opts.maxYear,
            html = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">',
            monthHtml,
            yearHtml,
            prev = true,
            next = true;

        for (arr = [], i = 0; i < 12; i++) {
            arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' +
                (i === month ? ' selected="selected"': '') +
                ((isMinYear && i < opts.minMonth) || (isMaxYear && i > opts.maxMonth) ? 'disabled="disabled"' : '') + '>' +
                opts.i18n.months[i] + '</option>');
        }

        monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join('') + '</select></div>';

        if (isArray(opts.yearRange)) {
            i = opts.yearRange[0];
            j = opts.yearRange[1] + 1;
        } else {
            i = year - opts.yearRange;
            j = 1 + year + opts.yearRange;
        }

        for (arr = []; i < j && i <= opts.maxYear; i++) {
            if (i >= opts.minYear) {
                arr.push('<option value="' + i + '"' + (i === year ? ' selected="selected"': '') + '>' + (i) + '</option>');
            }
        }
        yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join('') + '</select></div>';

        if (opts.showMonthAfterYear) {
            html += yearHtml + monthHtml;
        } else {
            html += monthHtml + yearHtml;
        }

        if (isMinYear && (month === 0 || opts.minMonth >= month)) {
            prev = false;
        }

        if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
            next = false;
        }

        if (c === 0) {
            html += '<button class="pika-prev' + (prev ? '' : ' is-disabled') + '" type="button">' + opts.i18n.previousMonth + '</button>';
        }
        if (c === (instance._o.numberOfMonths - 1) ) {
            html += '<button class="pika-next' + (next ? '' : ' is-disabled') + '" type="button">' + opts.i18n.nextMonth + '</button>';
        }

        return html += '</div>';
    },

    renderTable = function(opts, data, randId)
    {
        return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data) + '</table>';
    },


    /**
     * Pikaday constructor
     */
    Pikaday = function(options)
    {
        var self = this,
            opts = self.config(options);

        self._onMouseDown = function(e)
        {
            if (!self._v) {
                return;
            }
            e = e || window.event;
            var target = e.target || e.srcElement;
            if (!target) {
                return;
            }

            if (!hasClass(target, 'is-disabled')) {
                if (hasClass(target, 'pika-button') && !hasClass(target, 'is-empty') && !hasClass(target.parentNode, 'is-disabled')) {
                    self.setDate(new Date(target.getAttribute('data-pika-year'), target.getAttribute('data-pika-month'), target.getAttribute('data-pika-day')));
                    if (opts.bound) {
                        sto(function() {
                            self.hide();
                            if (opts.blurFieldOnSelect && opts.field) {
                                opts.field.blur();
                            }
                        }, 100);
                    }
                }
                else if (hasClass(target, 'pika-prev')) {
                    self.prevMonth();
                }
                else if (hasClass(target, 'pika-next')) {
                    self.nextMonth();
                }
            }
            if (!hasClass(target, 'pika-select')) {
                // if this is touch event prevent mouse events emulation
                if (e.preventDefault) {
                    e.preventDefault();
                } else {
                    e.returnValue = false;
                    return false;
                }
            } else {
                self._c = true;
            }
        };

        self._onChange = function(e)
        {
            e = e || window.event;
            var target = e.target || e.srcElement;
            if (!target) {
                return;
            }
            if (hasClass(target, 'pika-select-month')) {
                self.gotoMonth(target.value);
            }
            else if (hasClass(target, 'pika-select-year')) {
                self.gotoYear(target.value);
            }
        };

        self._onKeyChange = function(e)
        {
            e = e || window.event;

            if (self.isVisible()) {

                switch(e.keyCode){
                    case 13:
                    case 27:
                        if (opts.field) {
                            opts.field.blur();
                        }
                        break;
                    case 37:
                        e.preventDefault();
                        self.adjustDate('subtract', 1);
                        break;
                    case 38:
                        self.adjustDate('subtract', 7);
                        break;
                    case 39:
                        self.adjustDate('add', 1);
                        break;
                    case 40:
                        self.adjustDate('add', 7);
                        break;
                }
            }
        };

        self._onInputChange = function(e)
        {
            var date;

            if (e.firedBy === self) {
                return;
            }
            if (opts.parse) {
                date = opts.parse(opts.field.value, opts.format);
            } else if (hasMoment) {
                date = moment(opts.field.value, opts.format, opts.formatStrict);
                date = (date && date.isValid()) ? date.toDate() : null;
            }
            else {
                date = new Date(Date.parse(opts.field.value));
            }
            if (isDate(date)) {
              self.setDate(date);
            }
            if (!self._v) {
                self.show();
            }
        };

        self._onInputFocus = function()
        {
            self.show();
        };

        self._onInputClick = function()
        {
            self.show();
        };

        self._onInputBlur = function()
        {
            // IE allows pika div to gain focus; catch blur the input field
            var pEl = document.activeElement;
            do {
                if (hasClass(pEl, 'pika-single')) {
                    return;
                }
            }
            while ((pEl = pEl.parentNode));

            if (!self._c) {
                self._b = sto(function() {
                    self.hide();
                }, 50);
            }
            self._c = false;
        };

        self._onClick = function(e)
        {
            e = e || window.event;
            var target = e.target || e.srcElement,
                pEl = target;
            if (!target) {
                return;
            }
            if (!hasEventListeners && hasClass(target, 'pika-select')) {
                if (!target.onchange) {
                    target.setAttribute('onchange', 'return;');
                    addEvent(target, 'change', self._onChange);
                }
            }
            do {
                if (hasClass(pEl, 'pika-single') || pEl === opts.trigger) {
                    return;
                }
            }
            while ((pEl = pEl.parentNode));
            if (self._v && target !== opts.trigger && pEl !== opts.trigger) {
                self.hide();
            }
        };

        self.el = document.createElement('div');
        self.el.className = 'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');

        addEvent(self.el, 'mousedown', self._onMouseDown, true);
        addEvent(self.el, 'touchend', self._onMouseDown, true);
        addEvent(self.el, 'change', self._onChange);
        addEvent(document, 'keydown', self._onKeyChange);

        if (opts.field) {
            if (opts.container) {
                opts.container.appendChild(self.el);
            } else if (opts.bound) {
                document.body.appendChild(self.el);
            } else {
                opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);
            }
            addEvent(opts.field, 'change', self._onInputChange);

            if (!opts.defaultDate) {
                if (hasMoment && opts.field.value) {
                    opts.defaultDate = moment(opts.field.value, opts.format).toDate();
                } else {
                    opts.defaultDate = new Date(Date.parse(opts.field.value));
                }
                opts.setDefaultDate = true;
            }
        }

        var defDate = opts.defaultDate;

        if (isDate(defDate)) {
            if (opts.setDefaultDate) {
                self.setDate(defDate, true);
            } else {
                self.gotoDate(defDate);
            }
        } else {
            self.gotoDate(new Date());
        }

        if (opts.bound) {
            this.hide();
            self.el.className += ' is-bound';
            addEvent(opts.trigger, 'click', self._onInputClick);
            addEvent(opts.trigger, 'focus', self._onInputFocus);
            addEvent(opts.trigger, 'blur', self._onInputBlur);
        } else {
            this.show();
        }
    };


    /**
     * public Pikaday API
     */
    Pikaday.prototype = {


        /**
         * configure functionality
         */
        config: function(options)
        {
            if (!this._o) {
                this._o = extend({}, defaults, true);
            }

            var opts = extend(this._o, options, true);

            opts.isRTL = !!opts.isRTL;

            opts.field = (opts.field && opts.field.nodeName) ? opts.field : null;

            opts.theme = (typeof opts.theme) === 'string' && opts.theme ? opts.theme : null;

            opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);

            opts.trigger = (opts.trigger && opts.trigger.nodeName) ? opts.trigger : opts.field;

            opts.disableWeekends = !!opts.disableWeekends;

            opts.disableDayFn = (typeof opts.disableDayFn) === 'function' ? opts.disableDayFn : null;

            var nom = parseInt(opts.numberOfMonths, 10) || 1;
            opts.numberOfMonths = nom > 4 ? 4 : nom;

            if (!isDate(opts.minDate)) {
                opts.minDate = false;
            }
            if (!isDate(opts.maxDate)) {
                opts.maxDate = false;
            }
            if ((opts.minDate && opts.maxDate) && opts.maxDate < opts.minDate) {
                opts.maxDate = opts.minDate = false;
            }
            if (opts.minDate) {
                this.setMinDate(opts.minDate);
            }
            if (opts.maxDate) {
                this.setMaxDate(opts.maxDate);
            }

            if (isArray(opts.yearRange)) {
                var fallback = new Date().getFullYear() - 10;
                opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
                opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
            } else {
                opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
                if (opts.yearRange > 100) {
                    opts.yearRange = 100;
                }
            }

            return opts;
        },

        /**
         * return a formatted string of the current selection (using Moment.js if available)
         */
        toString: function(format)
        {
            format = format || this._o.format;
            if (!isDate(this._d)) {
                return '';
            }
            if (this._o.toString) {
              return this._o.toString(this._d, format);
            }
            if (hasMoment) {
              return moment(this._d).format(format);
            }
            return this._d.toDateString();
        },

        /**
         * return a Moment.js object of the current selection (if available)
         */
        getMoment: function()
        {
            return hasMoment ? moment(this._d) : null;
        },

        /**
         * set the current selection from a Moment.js object (if available)
         */
        setMoment: function(date, preventOnSelect)
        {
            if (hasMoment && moment.isMoment(date)) {
                this.setDate(date.toDate(), preventOnSelect);
            }
        },

        /**
         * return a Date object of the current selection
         */
        getDate: function()
        {
            return isDate(this._d) ? new Date(this._d.getTime()) : null;
        },

        /**
         * set the current selection
         */
        setDate: function(date, preventOnSelect)
        {
            if (!date) {
                this._d = null;

                if (this._o.field) {
                    this._o.field.value = '';
                    fireEvent(this._o.field, 'change', { firedBy: this });
                }

                return this.draw();
            }
            if (typeof date === 'string') {
                date = new Date(Date.parse(date));
            }
            if (!isDate(date)) {
                return;
            }

            var min = this._o.minDate,
                max = this._o.maxDate;

            if (isDate(min) && date < min) {
                date = min;
            } else if (isDate(max) && date > max) {
                date = max;
            }

            this._d = new Date(date.getTime());
            setToStartOfDay(this._d);
            this.gotoDate(this._d);

            if (this._o.field) {
                this._o.field.value = this.toString();
                fireEvent(this._o.field, 'change', { firedBy: this });
            }
            if (!preventOnSelect && typeof this._o.onSelect === 'function') {
                this._o.onSelect.call(this, this.getDate());
            }
        },

        /**
         * change view to a specific date
         */
        gotoDate: function(date)
        {
            var newCalendar = true;

            if (!isDate(date)) {
                return;
            }

            if (this.calendars) {
                var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
                    lastVisibleDate = new Date(this.calendars[this.calendars.length-1].year, this.calendars[this.calendars.length-1].month, 1),
                    visibleDate = date.getTime();
                // get the end of the month
                lastVisibleDate.setMonth(lastVisibleDate.getMonth()+1);
                lastVisibleDate.setDate(lastVisibleDate.getDate()-1);
                newCalendar = (visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate);
            }

            if (newCalendar) {
                this.calendars = [{
                    month: date.getMonth(),
                    year: date.getFullYear()
                }];
                if (this._o.mainCalendar === 'right') {
                    this.calendars[0].month += 1 - this._o.numberOfMonths;
                }
            }

            this.adjustCalendars();
        },

        adjustDate: function(sign, days) {

            var day = this.getDate() || new Date();
            var difference = parseInt(days)*24*60*60*1000;

            var newDay;

            if (sign === 'add') {
                newDay = new Date(day.valueOf() + difference);
            } else if (sign === 'subtract') {
                newDay = new Date(day.valueOf() - difference);
            }

            this.setDate(newDay);
        },

        adjustCalendars: function() {
            this.calendars[0] = adjustCalendar(this.calendars[0]);
            for (var c = 1; c < this._o.numberOfMonths; c++) {
                this.calendars[c] = adjustCalendar({
                    month: this.calendars[0].month + c,
                    year: this.calendars[0].year
                });
            }
            this.draw();
        },

        gotoToday: function()
        {
            this.gotoDate(new Date());
        },

        /**
         * change view to a specific month (zero-index, e.g. 0: January)
         */
        gotoMonth: function(month)
        {
            if (!isNaN(month)) {
                this.calendars[0].month = parseInt(month, 10);
                this.adjustCalendars();
            }
        },

        nextMonth: function()
        {
            this.calendars[0].month++;
            this.adjustCalendars();
        },

        prevMonth: function()
        {
            this.calendars[0].month--;
            this.adjustCalendars();
        },

        /**
         * change view to a specific full year (e.g. "2012")
         */
        gotoYear: function(year)
        {
            if (!isNaN(year)) {
                this.calendars[0].year = parseInt(year, 10);
                this.adjustCalendars();
            }
        },

        /**
         * change the minDate
         */
        setMinDate: function(value)
        {
            if(value instanceof Date) {
                setToStartOfDay(value);
                this._o.minDate = value;
                this._o.minYear  = value.getFullYear();
                this._o.minMonth = value.getMonth();
            } else {
                this._o.minDate = defaults.minDate;
                this._o.minYear  = defaults.minYear;
                this._o.minMonth = defaults.minMonth;
                this._o.startRange = defaults.startRange;
            }

            this.draw();
        },

        /**
         * change the maxDate
         */
        setMaxDate: function(value)
        {
            if(value instanceof Date) {
                setToStartOfDay(value);
                this._o.maxDate = value;
                this._o.maxYear = value.getFullYear();
                this._o.maxMonth = value.getMonth();
            } else {
                this._o.maxDate = defaults.maxDate;
                this._o.maxYear = defaults.maxYear;
                this._o.maxMonth = defaults.maxMonth;
                this._o.endRange = defaults.endRange;
            }

            this.draw();
        },

        setStartRange: function(value)
        {
            this._o.startRange = value;
        },

        setEndRange: function(value)
        {
            this._o.endRange = value;
        },

        /**
         * refresh the HTML
         */
        draw: function(force)
        {
            if (!this._v && !force) {
                return;
            }
            var opts = this._o,
                minYear = opts.minYear,
                maxYear = opts.maxYear,
                minMonth = opts.minMonth,
                maxMonth = opts.maxMonth,
                html = '',
                randId;

            if (this._y <= minYear) {
                this._y = minYear;
                if (!isNaN(minMonth) && this._m < minMonth) {
                    this._m = minMonth;
                }
            }
            if (this._y >= maxYear) {
                this._y = maxYear;
                if (!isNaN(maxMonth) && this._m > maxMonth) {
                    this._m = maxMonth;
                }
            }

            randId = 'pika-title-' + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 2);

            for (var c = 0; c < opts.numberOfMonths; c++) {
                html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId) + '</div>';
            }

            this.el.innerHTML = html;

            if (opts.bound) {
                if(opts.field.type !== 'hidden') {
                    sto(function() {
                        opts.trigger.focus();
                    }, 1);
                }
            }

            if (typeof this._o.onDraw === 'function') {
                this._o.onDraw(this);
            }

            if (opts.bound) {
                // let the screen reader user know to use arrow keys
                opts.field.setAttribute('aria-label', 'Use the arrow keys to pick a date');
            }
        },

        adjustPosition: function()
        {
            var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect;

            if (this._o.container) return;

            this.el.style.position = 'absolute';

            field = this._o.trigger;
            pEl = field;
            width = this.el.offsetWidth;
            height = this.el.offsetHeight;
            viewportWidth = window.innerWidth || document.documentElement.clientWidth;
            viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;

            if (typeof field.getBoundingClientRect === 'function') {
                clientRect = field.getBoundingClientRect();
                left = clientRect.left + window.pageXOffset;
                top = clientRect.bottom + window.pageYOffset;
            } else {
                left = pEl.offsetLeft;
                top  = pEl.offsetTop + pEl.offsetHeight;
                while((pEl = pEl.offsetParent)) {
                    left += pEl.offsetLeft;
                    top  += pEl.offsetTop;
                }
            }

            // default position is bottom & left
            if ((this._o.reposition && left + width > viewportWidth) ||
                (
                    this._o.position.indexOf('right') > -1 &&
                    left - width + field.offsetWidth > 0
                )
            ) {
                left = left - width + field.offsetWidth;
            }
            if ((this._o.reposition && top + height > viewportHeight + scrollTop) ||
                (
                    this._o.position.indexOf('top') > -1 &&
                    top - height - field.offsetHeight > 0
                )
            ) {
                top = top - height - field.offsetHeight;
            }

            this.el.style.left = left + 'px';
            this.el.style.top = top + 'px';
        },

        /**
         * render HTML for a particular month
         */
        render: function(year, month, randId)
        {
            var opts   = this._o,
                now    = new Date(),
                days   = getDaysInMonth(year, month),
                before = new Date(year, month, 1).getDay(),
                data   = [],
                row    = [];
            setToStartOfDay(now);
            if (opts.firstDay > 0) {
                before -= opts.firstDay;
                if (before < 0) {
                    before += 7;
                }
            }
            var previousMonth = month === 0 ? 11 : month - 1,
                nextMonth = month === 11 ? 0 : month + 1,
                yearOfPreviousMonth = month === 0 ? year - 1 : year,
                yearOfNextMonth = month === 11 ? year + 1 : year,
                daysInPreviousMonth = getDaysInMonth(yearOfPreviousMonth, previousMonth);
            var cells = days + before,
                after = cells;
            while(after > 7) {
                after -= 7;
            }
            cells += 7 - after;
            var isWeekSelected = false;
            for (var i = 0, r = 0; i < cells; i++)
            {
                var day = new Date(year, month, 1 + (i - before)),
                    isSelected = isDate(this._d) ? compareDates(day, this._d) : false,
                    isToday = compareDates(day, now),
                    hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false,
                    isEmpty = i < before || i >= (days + before),
                    dayNumber = 1 + (i - before),
                    monthNumber = month,
                    yearNumber = year,
                    isStartRange = opts.startRange && compareDates(opts.startRange, day),
                    isEndRange = opts.endRange && compareDates(opts.endRange, day),
                    isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,
                    isDisabled = (opts.minDate && day < opts.minDate) ||
                                 (opts.maxDate && day > opts.maxDate) ||
                                 (opts.disableWeekends && isWeekend(day)) ||
                                 (opts.disableDayFn && opts.disableDayFn(day));

                if (isEmpty) {
                    if (i < before) {
                        dayNumber = daysInPreviousMonth + dayNumber;
                        monthNumber = previousMonth;
                        yearNumber = yearOfPreviousMonth;
                    } else {
                        dayNumber = dayNumber - days;
                        monthNumber = nextMonth;
                        yearNumber = yearOfNextMonth;
                    }
                }

                var dayConfig = {
                        day: dayNumber,
                        month: monthNumber,
                        year: yearNumber,
                        hasEvent: hasEvent,
                        isSelected: isSelected,
                        isToday: isToday,
                        isDisabled: isDisabled,
                        isEmpty: isEmpty,
                        isStartRange: isStartRange,
                        isEndRange: isEndRange,
                        isInRange: isInRange,
                        showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
                        enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths
                    };

                if (opts.pickWholeWeek && isSelected) {
                    isWeekSelected = true;
                }

                row.push(renderDay(dayConfig));

                if (++r === 7) {
                    if (opts.showWeekNumber) {
                        row.unshift(renderWeek(i - before, month, year));
                    }
                    data.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
                    row = [];
                    r = 0;
                    isWeekSelected = false;
                }
            }
            return renderTable(opts, data, randId);
        },

        isVisible: function()
        {
            return this._v;
        },

        show: function()
        {
            if (!this.isVisible()) {
                this._v = true;
                this.draw();
                removeClass(this.el, 'is-hidden');
                if (this._o.bound) {
                    addEvent(document, 'click', this._onClick);
                    this.adjustPosition();
                }
                if (typeof this._o.onOpen === 'function') {
                    this._o.onOpen.call(this);
                }
            }
        },

        hide: function()
        {
            var v = this._v;
            if (v !== false) {
                if (this._o.bound) {
                    removeEvent(document, 'click', this._onClick);
                }
                this.el.style.position = 'static'; // reset
                this.el.style.left = 'auto';
                this.el.style.top = 'auto';
                addClass(this.el, 'is-hidden');
                this._v = false;
                if (v !== undefined && typeof this._o.onClose === 'function') {
                    this._o.onClose.call(this);
                }
            }
        },

        /**
         * GAME OVER
         */
        destroy: function()
        {
            this.hide();
            removeEvent(this.el, 'mousedown', this._onMouseDown, true);
            removeEvent(this.el, 'touchend', this._onMouseDown, true);
            removeEvent(this.el, 'change', this._onChange);
            removeEvent(document, 'keydown', this._onKeyChange);
            if (this._o.field) {
                removeEvent(this._o.field, 'change', this._onInputChange);
                if (this._o.bound) {
                    removeEvent(this._o.trigger, 'click', this._onInputClick);
                    removeEvent(this._o.trigger, 'focus', this._onInputFocus);
                    removeEvent(this._o.trigger, 'blur', this._onInputBlur);
                }
            }
            if (this.el.parentNode) {
                this.el.parentNode.removeChild(this.el);
            }
        }

    };

    return Pikaday;

}));

},{"moment":20}],22:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define("index", [], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["index"] = factory();else root["index"] = root["index"] || {}, root["index"]["index"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports) {

			'use strict';

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var VeamsDOM = {
				options: {
					DOM: false
				},
				pluginName: '$',
				initialize: function initialize(Veams, _ref) {
					var DOM = _ref.DOM;

					if (!DOM) {
						console.error('VeamsDOM :: You need to pass an options object with a DOM handler: options.DOM!');
						return;
					}
					if (Veams.$) {
						console.log('VeamsDOM :: It seems that you have already defined a DOM handler. I am overwriting it now for you ;)');
					}

					Veams.$ = this.options.DOM = DOM;
				}
			};

			exports.default = VeamsDOM;
			module.exports = exports['default'];

			/***/
		}
		/******/])
	);
});
;


},{}],23:[function(require,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof2(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define("index", [], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object') exports["index"] = factory();else root["index"] = root["index"] || {}, root["index"]["index"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports) {

			'use strict';

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
				return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
			} : function (obj) {
				return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
			};

			var VeamsLogger = {
				options: {
					devmodeParam: 'devmode',
					loggerParam: 'logger'
				},
				pluginName: 'Logger',
				initialize: function initialize(Veams, opts) {

					if (opts) {
						this.options = Veams.helpers.extend(this.options, opts || {});
					}

					/**
      * Devmode and logger
      */
					Veams.devmode = false;
					Veams.logger = false;

					if (document.location.search.indexOf(this.options.devmodeParam) > -1 || window.sessionStorage && sessionStorage.getItem('devmodeEnabled')) {
						Veams.devmode = true;

						if (window.sessionStorage && !sessionStorage.getItem('devmodeEnabled')) {
							sessionStorage.setItem('devmodeEnabled', true);
						}

						document.documentElement.classList.add(this.options.devmodeParam);
					}

					if (document.location.search.indexOf(this.options.loggerParam) > -1) {
						Veams.logger = true;
					}

					// hide all warnings and logs if not in devmode
					if (!Veams.devmode) {
						console.log = console.warn = function () {};
					}

					// add console output element (triggered by parameter 'devmode' and 'logger' in url)
					if (Veams.devmode && Veams.logger) {
						var logger = document.createElement('pre');

						logger.setAttribute('id', 'logger');
						document.body.appendChild(logger);

						console.write = function () {
							for (var i = 0; i < arguments.length; i++) {
								if (_typeof(arguments[i]) === 'object') {
									logger.innerHTML += (JSON && JSON.stringify ? JSON.stringify(arguments[i], undefined, 2) : arguments[i]) + '<br />';
								} else {
									logger.innerHTML += arguments[i] + '<br />';
								}
							}

							logger.innerHTML += '<br />';
							logger.scrollTop = logger.scrollHeight;
						};

						console.error = function () {
							logger.innerHTML += '[Error]<br />';
							console.write.apply(this, arguments);
						};

						console.warn = function () {
							logger.innerHTML += '[Warn]<br />';
							console.write.apply(this, arguments);
						};

						console.log = function () {
							logger.innerHTML += '[Log]<br />';
							console.write.apply(this, arguments);
						};
					}
				}
			};

			exports.default = VeamsLogger;
			module.exports = exports['default'];

			/***/
		}
		/******/])
	);
});
;


},{}],24:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define("index", [], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["index"] = factory();else root["index"] = root["index"] || {}, root["index"]["index"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Imports
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var VeamsMediaQueryHandler = {
				options: {
					mediaQueryProp: 'font-family',
					delay: 300
				},
				pluginName: 'MediaQueryHandler',
				initialize: function initialize(Veams, opts) {
					var _this = this;

					// Media Query
					var head = document.querySelectorAll('head');

					if (opts) {
						this.options = Veams.helpers.extend(this.options, opts || {});
					}

					/**
      * Add current media query to Veams
      */
					Veams.currentMedia = window.getComputedStyle(head[0], null).getPropertyValue(this.options.mediaQueryProp);

					if (!Veams.Vent) {
						console.info('VeamsMediaQueryHandler :: In order to work properly with the VeamsMediaQueryHandler plugin you should add the VeamsVent plugin!');
					}

					// Trigger global resize event
					window.onresize = Veams.helpers.throttle(function (e) {
						var currentMedia = window.getComputedStyle(head[0], null).getPropertyValue(_this.options.mediaQueryProp);
						var width = window.innerWidth;

						if (currentMedia !== Veams.currentMedia) {
							var oldMedia = Veams.currentMedia;

							Veams.currentMedia = currentMedia;

							console.info('VeamsMediaQueryHandler :: Current media is ' + Veams.currentMedia);

							if (Veams.Vent) {
								Veams.Vent.trigger(Veams.EVENTS.mediachange, {
									type: Veams.EVENTS.mediachange,
									currentMedia: currentMedia,
									oldMedia: oldMedia
								});
							}
						}

						Veams.detections.width = width;
						Veams.Vent.trigger(Veams.EVENTS.resize, e);
					}, this.options.delay);
				}
			};

			exports.default = VeamsMediaQueryHandler;
			module.exports = exports['default'];

			/***/
		}
		/******/])
	);
});
;


},{}],25:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define("index", [], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["index"] = factory();else root["index"] = root["index"] || {}, root["index"]["index"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports) {

			'use strict';

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var _createClass = function () {
				function defineProperties(target, props) {
					for (var i = 0; i < props.length; i++) {
						var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
					}
				}return function (Constructor, protoProps, staticProps) {
					if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
				};
			}();

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}

			var Veams = {};
			var __cache = [];
			var __register = {
				modulesInRegister: [],
				modulesOnConditions: [],
				modulesOnInit: [],
				modulesInContext: []
			};

			/**
    * TODO: Clean up mutation observer
    */

			/**
    * - Get modules in DOM
    * - Get classes and options from init process
    * - Split up conditional modules from initial modules
    * - Init other modules
    * - Bind events when available from conditional modules
    * -
    */

			var Modules = function () {
				function Modules() {
					var VEAMS = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.Veams;
					var opts = arguments[1];

					_classCallCheck(this, Modules);

					Veams = VEAMS;

					this.options = opts;

					if (!this.options.internalCacheOnly) {
						this._cache = __cache; // Module list
					}

					if (!this.options.internalRegisterOnly) {
						this._register = __register;
					}

					this.initialize();
				}

				_createClass(Modules, [{
					key: 'initialize',
					value: function initialize() {
						this.queryString = '[' + this.options.attrPrefix + '-' + this.options.attrName + ']';
						__register.modulesInContext = Veams.helpers.querySelectorArray(this.queryString);

						if (this.options.useMutationObserver) {
							this.observe(document.body);
						}

						this.bindEvents();
					}
				}, {
					key: 'bindEvents',
					value: function bindEvents() {
						var _this = this;

						if (!Veams.Vent && this.options.useMutationObserver === false) {
							console.info('VeamsModules :: In order to work with the the ajax handling in VeamsModulesHandler ' + 'you need to define "useMutationObserver" or use the VeamsVent plugin!');

							return;
						}

						if (Veams.Vent && this.options.useMutationObserver === false) {
							Veams.Vent.on(Veams.EVENTS.DOMchanged, function (e, context) {
								__register.modulesInContext = _this.getModulesInContext(context);

								if (_this.options.logs) {
									console.info('VeamsModules :: Recording new context. When available new modules will be initialised in: ', context);
								}

								_this.registerAll();
							});
						}
					}

					// ------------------------
					// STATIC CACHE HANDLER
					// ------------------------

					/**
      * Save the module in __cache.
      *
      * @param {Object} module - module metadata object (@see VeamsComponent.metaData())
      * @param {Object} element - module element (this.el)
      * @param {Object} instance - module instance
      * @param {String} namespace - module namespace
      */

				}, {
					key: 'bindConditions',
					value: function bindConditions() {
						var _this2 = this;

						__register.modulesOnConditions.forEach(function (module) {
							if (module.conditionsListenOn && module.conditionsListenOn.length) {
								_this2.bindCondition(module);
							}
						});
					}
				}, {
					key: 'bindCondition',
					value: function bindCondition(module) {
						var _this3 = this;

						var globalEvts = module.conditionsListenOn.join(' ');

						if (Veams.Vent) {
							Veams.Vent.subscribe(globalEvts, function () {
								_this3.registerConditionalModule(module);
							});
						}
					}

					// ------------------------
					// UN/REGISTER HANDLER
					// ------------------------

					/**
      * Split up modules depending on condition check
      */

				}, {
					key: 'splitUpModules',
					value: function splitUpModules() {
						var _this4 = this;

						__register.modulesInRegister.forEach(function (obj) {
							if (_this4.constructor.isCondition(obj)) {
								__register.modulesOnConditions.push(obj);
							} else {
								__register.modulesOnInit.push(obj);
							}
						});
					}

					/**
      * Register multiple modules.
      *
      * @param {Array} arr - Array which contains the modules as object.
      *
      * @public
      */

				}, {
					key: 'register',
					value: function register(arr) {
						if (!Array.isArray(arr)) {
							throw new Error('VeamsModules :: You need to pass an array to register()!');
						}

						__register.modulesInRegister = __register.modulesInRegister.concat(arr);

						this.splitUpModules();
						this.bindConditions();
						this.registerAll();
					}
				}, {
					key: 'add',
					value: function add(namespace, module) {
						var optionsObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

						var currentModule = Object.assign({}, {
							namespace: namespace,
							module: module
						}, optionsObj);

						if (this.constructor.isCondition(currentModule)) {
							if (currentModule.conditionsListenOn && currentModule.conditionsListenOn.length) {
								this.bindCondition(currentModule);
							}
							this.registerConditionalModule(currentModule);
						} else {
							this.registerOne(currentModule);
						}
					}

					/**
      * Register all modules
      */

				}, {
					key: 'registerAll',
					value: function registerAll() {
						if (!__register.modulesInRegister) return;

						this.registerInitialModules();
						this.registerConditionalModules();
					}

					/**
      * Register all initial modules
      */

				}, {
					key: 'registerInitialModules',
					value: function registerInitialModules() {
						var _this5 = this;

						__register.modulesOnInit.forEach(function (obj) {
							_this5.registerOne(obj);
						});
					}

					/**
      * Register conditional modules
      *
      * Therefore we check the condition and
      * when true register the specific module
      * when false unregister the specific module
      */

				}, {
					key: 'registerConditionalModules',
					value: function registerConditionalModules() {
						var _this6 = this;

						__register.modulesOnConditions.forEach(function (obj) {
							_this6.registerConditionalModule(obj);
						});
					}
				}, {
					key: 'registerConditionalModule',
					value: function registerConditionalModule(obj) {
						if (this.constructor.makeConditionCheck(obj)) {
							this.registerOne(obj);
						} else {
							this.unregisterOne(obj);
						}
					}

					/**
      * Register one module and init the elements in the specific context
      *
      * @param {String} namespace - Required: element name in DOM
      * @param {String} domName - Required: element name in DOM
      * @param {Object} module - Required: class which will be used to render your module
      * @param {boolean} [render=true] - Optional: render the class, if false the class will only be initialized
      * @param {function} [cb] - Optional: provide a function which will be executed after initialisation
      * @param {Object} [options] - Optional: You can pass options to the module via JS (Useful for DOMChanged)
      *
      */

				}, {
					key: 'registerOne',
					value: function registerOne(_ref) {
						var namespace = _ref.namespace,
						    domName = _ref.domName,
						    module = _ref.module,
						    render = _ref.render,
						    cb = _ref.cb,
						    options = _ref.options;

						var nameSpace = namespace ? namespace : domName;

						if (!module) throw new Error('VeamsModules :: In order to work with register() or add() you need to define a module!');
						if (!nameSpace) throw new Error('VeamsModules :: In order to work with register() or add() you need to define a module!');

						this.initModules({
							namespace: nameSpace,
							module: module,
							render: render,
							cb: cb,
							options: options
						});
					}
				}, {
					key: 'unregisterOne',
					value: function unregisterOne(_ref2) {
						var namespace = _ref2.namespace;

						if (this.constructor.checkModuleInCache(namespace, 'namespace') === true) {
							this.constructor.removeFromCacheByKey(namespace, 'namespace');
						}
					}

					// ------------------------
					// INIT HANDLER
					// ------------------------

					/**
      * Initialize a module and render it and/or provide a callback function
      *
      * @param {string} namespace - Required: dom name of the element
      * @param {Object} module - Required: class which will be used to render your module
      * @param {boolean} [render=true] - Optional: render the class, if false the class will only be initialized
      * @param {Object} [options] - Optional: You can pass options to the module via JS (Useful for DOMChanged)
      * @param {function} [cb] - Optional: provide a function which will be executed after initialisation
      *
      */

				}, {
					key: 'initModules',
					value: function initModules(_ref3) {
						var _this7 = this;

						var namespace = _ref3.namespace,
						    module = _ref3.module,
						    render = _ref3.render,
						    options = _ref3.options,
						    cb = _ref3.cb;

						Veams.helpers.forEach(__register.modulesInContext, function (i, el) {
							_this7.initModule({
								el: el,
								namespace: namespace,
								options: options,
								module: module,
								render: render,
								cb: cb
							});
						});
					}
				}, {
					key: 'initModule',
					value: function initModule(_ref4) {
						var el = _ref4.el,
						    namespace = _ref4.namespace,
						    options = _ref4.options,
						    module = _ref4.module,
						    render = _ref4.render,
						    cb = _ref4.cb;

						var noRender = el.getAttribute(this.options.attrPrefix + '-no-render') || render === false || false;
						var dataModules = el.getAttribute(this.options.attrPrefix + '-' + this.options.attrName).split(' ');

						if (dataModules.indexOf(namespace) !== -1) {
							// Check init state
							if (this.constructor.checkModuleInCache(el, 'element', namespace) === true) {
								console.info('VeamsModules :: Element is already in cache and initialized: ');
								console.log(el);
								return;
							}

							// Go ahead when condition is true
							var attrs = el.getAttribute(this.options.attrPrefix + '-' + this.options.attrOptions);
							var mergedOptions = Veams.helpers.extend(JSON.parse(attrs), options || {});
							var Module = module;
							var instance = new Module({
								el: el,
								namespace: namespace,
								options: mergedOptions,
								appInstance: Veams
							});

							this.constructor.addToCache({
								element: el,
								module: module,
								instance: instance,
								namespace: namespace
							});

							// Mount process
							if (instance.willMount) instance.willMount();

							// Render after initial module loading
							if (!noRender) instance.render();

							// Provide callback function in which you can use module and options
							if (cb && typeof cb === 'function') cb(module, mergedOptions);

							// Mount process
							if (instance.didMount) instance.didMount();
						}
					}

					/**
      * Add mutation observer to observe new modules.
      *
      * @param {Object} context - Context for the mutation observer
      *
      * TODO: Improve for loops
      */

				}, {
					key: 'observe',
					value: function observe(context) {
						var _this8 = this;

						var observer = new MutationObserver(function (mutations) {
							// look through all mutations that just occured
							for (var i = 0; i < mutations.length; ++i) {
								// look through all added nodes of this mutation

								for (var j = 0; j < mutations[i].addedNodes.length; ++j) {
									var addedNode = mutations[i].addedNodes[j];

									if (addedNode instanceof HTMLElement) {
										if (addedNode.getAttribute(_this8.options.attrPrefix + '-' + _this8.options.attrName)) {
											var namespace = addedNode.getAttribute(_this8.options.attrPrefix + '-' + _this8.options.attrName);

											if (_this8.options.logs) {
												console.info('VeamsModules :: Recording a new module with the namespace ' + namespace + ' at: ', addedNode);
											}

											var _iteratorNormalCompletion = true;
											var _didIteratorError = false;
											var _iteratorError = undefined;

											try {
												for (var _iterator = __register.modulesInRegister[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
													var module = _step.value;

													if (module.namespace === namespace) {
														_this8.initModule({
															el: addedNode,
															module: module.module,
															namespace: module.namespace
														});

														break;
													}
												}
											} catch (err) {
												_didIteratorError = true;
												_iteratorError = err;
											} finally {
												try {
													if (!_iteratorNormalCompletion && _iterator.return) {
														_iterator.return();
													}
												} finally {
													if (_didIteratorError) {
														throw _iteratorError;
													}
												}
											}
										}

										if (_this8.getModulesInContext(addedNode).length) {
											__register.modulesInContext = _this8.getModulesInContext(addedNode);

											if (_this8.options.logs) {
												console.info('VeamsModules :: Recording new context. When available new modules will be initialised in: ', addedNode);
											}

											_this8.registerAll();

											__register.modulesInContext = _this8.getModulesInContext(document);
										}
									}
								}

								for (var _j = 0; _j < mutations[i].removedNodes.length; ++_j) {
									var removedNode = mutations[i].removedNodes[_j];

									if (removedNode instanceof HTMLElement) {
										if (removedNode.getAttribute(_this8.options.attrPrefix + '-' + _this8.options.attrName)) {

											if (_this8.options.logs) {
												console.info('VeamsModules :: Recording deletion of module: ', removedNode);
											}

											_this8.constructor.removeFromCacheByKey(removedNode);

											__register.modulesInContext = _this8.getModulesInContext(document);
										}

										if (_this8.getModulesInContext(removedNode).length) {
											__register.modulesInContext = _this8.getModulesInContext(removedNode);

											if (_this8.options.logs) {
												console.info('VeamsModules :: Recording deletion of DOM element. When available modules will be unbound in ', removedNode);
											}

											__register.modulesInContext.forEach(function (node) {
												_this8.constructor.removeFromCacheByKey(node);
											});

											__register.modulesInContext = _this8.getModulesInContext(document);
										}
									}
								}
							}
						});

						observer.observe(context, {
							childList: true,
							subtree: true
						});
					}

					/**
      * Get Modules in a specific context.
      *
      * @param {Object} context - Context for query specific string
      */

				}, {
					key: 'getModulesInContext',
					value: function getModulesInContext(context) {
						return Veams.helpers.querySelectorArray(this.queryString, context);
					}
				}], [{
					key: 'addToCache',
					value: function addToCache(_ref5) {
						var module = _ref5.module,
						    element = _ref5.element,
						    instance = _ref5.instance,
						    namespace = _ref5.namespace;

						__cache.push({
							module: module,
							element: element,
							instance: instance,
							namespace: namespace
						});

						if (Veams.Vent && Veams.EVENTS.moduleCached) {
							Veams.Vent.trigger(Veams.EVENTS.moduleCached, {
								module: module,
								element: element
							});
						}
					}
				}, {
					key: 'removeFromCacheByKey',
					value: function removeFromCacheByKey(obj) {
						var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'element';

						var deleteIndex = void 0;

						for (var i = 0; i < __cache.length; i++) {
							var cacheItem = __cache[i];

							if (cacheItem[key] === obj) {
								if (cacheItem.instance.willUnmount) cacheItem.instance.willUnmount();
								if (cacheItem.instance.unregisterEvents) cacheItem.instance.unregisterEvents();
								if (cacheItem.instance.didUnmount) cacheItem.instance.didUnmount();

								deleteIndex = i;
							}
						}

						if (deleteIndex) __cache.splice(deleteIndex, 1);
					}
				}, {
					key: 'checkModuleInCache',
					value: function checkModuleInCache(obj) {
						var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'element';
						var namespace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

						var state = false;

						for (var i = 0; i < __cache.length; i++) {
							var cacheItem = __cache[i];

							state = namespace !== undefined ? cacheItem[key] === obj && cacheItem.namespace === namespace : cacheItem[key] === obj;

							if (state) break;
						}

						return state;
					}

					// ------------------------
					// CONDITIONS HANDLER
					// ------------------------

				}, {
					key: 'isCondition',
					value: function isCondition(_ref6) {
						var conditions = _ref6.conditions;

						return conditions && typeof conditions === 'function';
					}
				}, {
					key: 'makeConditionCheck',
					value: function makeConditionCheck(_ref7) {
						var conditions = _ref7.conditions;

						if (conditions && typeof conditions === 'function') {
							return conditions();
						}
					}
				}]);

				return Modules;
			}();

			/**
    * Plugin object
    */

			var VeamsModules = {
				options: {
					DEBUG: false,
					attrPrefix: 'data-js',
					attrName: 'module',
					attrOptions: 'options',
					logs: false,
					internalCacheOnly: true,
					internalRegisterOnly: false,
					useMutationObserver: false
				},
				pluginName: 'ModulesHandler',
				initialize: function initialize(Veams, opts) {
					this.options = Veams.helpers.extend(this.options, opts || {});
					Veams.modules = Veams.modules || new Modules(Veams, this.options);
				}
			};

			exports.default = VeamsModules;
			exports.Modules = Modules;

			/***/
		}
		/******/])
	);
});
;


},{}],26:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define("index", [], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["index"] = factory();else root["index"] = root["index"] || {}, root["index"]["index"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports) {

			'use strict';
			/**
    * Represents the Templater class which will be used in VeamsTemplater plugin.
    * @module Templater
    *
    * @author Sebastian Fitzner
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var _createClass = function () {
				function defineProperties(target, props) {
					for (var i = 0; i < props.length; i++) {
						var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
					}
				}return function (Constructor, protoProps, staticProps) {
					if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
				};
			}();

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}

			var Veams = {};

			var Templater = function () {
				function Templater() {
					var VEAMS = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.Veams;
					var _ref = arguments[1];
					var engine = _ref.engine,
					    templates = _ref.templates,
					    partials = _ref.partials,
					    helpers = _ref.helpers;

					_classCallCheck(this, Templater);

					Veams = VEAMS;

					if (!templates) {
						console.error('VeamsTemplater :: You need to pass an object which contains your templates (obj.templates)!');
						return;
					}

					if (!engine) {
						console.error('VeamsTemplater :: You need to pass a handlebars instance by providing obj.engine!');
						return;
					}

					this.options = {
						namespace: Veams.options.namespace,
						engine: engine,
						templates: templates,
						partials: partials,
						helpers: helpers
					};

					this.initialize();
				}

				_createClass(Templater, [{
					key: 'initialize',
					value: function initialize() {
						if (this.options.helpers) {
							this.registerHelpers();
						}

						this.addTemplater();
					}
				}, {
					key: 'registerHelpers',
					value: function registerHelpers() {
						if (!Array.isArray(this.options.helpers)) {
							console.error('VeamsTemplater :: You need to pass the helpers as an array!');
							return;
						}

						for (var i = 0; i < this.options.helpers.length; i++) {
							var helper = this.options.helpers[i];

							if (helper.register) {
								this.options.engine.registerHelper(helper.register(this.options.engine));
							} else {
								console.error('VeamsTemplater :: Your helper does not have a register function, see: ' + helper);
							}
						}
					}
				}, {
					key: 'addTemplater',
					value: function addTemplater() {
						if (Veams.templater) {
							console.warn('It seems that you are already using Veams.templater! Veams is overriding it now!');
						}

						Veams.templater = {
							engine: this.options.engine,
							templates: this.options.templates(this.options.engine),
							partials: this.options.partials ? this.options.partials(this.options.engine) : {},
							helpers: this.options.helpers,
							render: function render(tplName, data) {
								if (!data && Veams.templater.templates[tplName]) {
									console.error('VeamsTemplater :: You need to provide some data for ' + tplName + '.');
									return;
								}

								if (!Veams.templater.templates[tplName]) {
									console.error('VeamsTemplater :: Template ' + tplName + ' not found.');
									return;
								}

								return Veams.templater.templates[tplName](data);
							}
						};
					}
				}]);

				return Templater;
			}();

			/**
    * Represents a templater plugin which you can use to render your precompiled handlebars templates.
    * You can also register custom helpers by providing them in an array!
    *
    * @module VeamsTemplater
    *
    * @author Sebastian Fitzner
    */

			var VeamsTemplater = {
				options: {
					engine: function engine() {},
					templates: function templates() {},
					partials: function partials() {},
					helpers: []
				},
				pluginName: 'Templater',
				initialize: function initialize(Veams, _ref2) {
					var engine = _ref2.engine,
					    templates = _ref2.templates,
					    partials = _ref2.partials,
					    helpers = _ref2.helpers;

					new Templater(Veams, {
						engine: engine,
						templates: templates,
						partials: partials,
						helpers: helpers
					});
				}
			};

			exports.default = VeamsTemplater;
			exports.Templater = Templater;

			/***/
		}
		/******/])
	);
});
;


},{}],27:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define("index", [], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["index"] = factory();else root["index"] = root["index"] || {}, root["index"]["index"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Represents a Vent plugin which creates an empty object.
    * The object will be used as publish/subscribe plugin.
    *
    * The module extends the default EVENTS object of Veams
    * when you pass the option called 'furtherEvents'.
    *
    * @module VeamsVent
    *
    * @author Sebastian Fitzner
    */

			/**
    * @module EventsHandler
    *
    * Pub/Sub system for Loosely Coupled logic.
    * Based on Peter Higgins' port from Dojo to jQuery
    * https://github.com/phiggins42/bloody-jquery-plugins/blob/master/pubsub.js
    * adopted https://github.com/phiggins42/bloody-jquery-plugins/blob/55e41df9bf08f42378bb08b93efcb28555b61aeb/pubsub.js
    *
    * modified by Sebastian Fitzner
    *
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var EventsHandler = function () {
				var cache = {},


				/**
     *    Events.publish
     *    e.g.: Events.publish("/Article/added", {article: article}, this);
     *
     *    @class Events
     *    @method publish
     *    @param topic {String}
     *    @param args    {Object}
     *    @param scope {Object} Optional
     */
				publish = function publish(topic, args, scope) {
					if (cache[topic]) {
						var thisTopic = cache[topic];
						var i = thisTopic.length - 1;

						for (i; i >= 0; i -= 1) {
							thisTopic[i].call(scope || this, args || {});
						}
					}
				},


				/**
     *    Events.subscribe
     *    e.g.: Events.subscribe("/Article/added", Articles.validate)
     *
     *    @class Events
     *    @method subscribe
     *    @param topic {String}
     *    @param callback {Function}
     *    @return Event handler {Array}
     */
				subscribe = function subscribe(topic, callback) {
					var topics = topic.split(' ');

					for (var i = 0; i < topics.length; i++) {
						var _topic = topics[i];

						if (!cache[_topic]) {
							cache[_topic] = [];
						}

						cache[_topic].push(callback);
					}
				},


				/**
     *    Events.unsubscribe
     *    e.g.: var handle = Events.subscribe("/Article/added", Articles.validate);
     *        Events.unsubscribe("/Article/added", Articles.validate);
     *
     *    @class Events
     *    @method unsubscribe
     *    @param topic {String}
     *    @param handle {Function}
     *    @param completly {Boolean}
     */
				unsubscribe = function unsubscribe(topic, handle) {
					var completly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

					var i = cache[topic].length - 1;

					if (cache[topic]) {
						for (i; i >= 0; i--) {
							if (cache[topic][i] === handle) {
								cache[topic].splice(i, 1);
								if (completly) {
									delete cache[topic];
								}
							}
						}
					}
				};

				return {
					publish: publish,
					subscribe: subscribe,
					unsubscribe: unsubscribe,
					trigger: publish,
					on: subscribe,
					off: unsubscribe
				};
			}();

			var VeamsVent = {
				options: {
					furtherEvents: {}
				},
				pluginName: 'Vent',
				initialize: function initialize(Veams, opts) {
					if (opts) {
						this.options = Veams.helpers.extend(this.options, opts || {});
					}

					Veams.Vent = EventsHandler;
					Veams.EVENTS = Veams.helpers.extend(Veams.EVENTS, this.options.furtherEvents);
				}
			};

			exports.default = VeamsVent;
			module.exports = exports['default'];

			/***/
		}
		/******/])
	);
});
;


},{}],28:[function(require,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof2(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define("veams", [], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object') exports["veams"] = factory();else root["veams"] = root["veams"] || {}, root["veams"]["veams"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			/**
    * Imports
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var _starter = __webpack_require__(11);

			var _starter2 = _interopRequireDefault(_starter);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			/**
    * Variables
    */

			exports.default = _starter2.default;
			module.exports = exports['default'];

			/***/
		},,,
		/* 1 */
		/* 2 */
		/* 3 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = mixin;

			var _defaults = __webpack_require__(4);

			var _defaults2 = _interopRequireDefault(_defaults);

			var _methodExtend = __webpack_require__(5);

			var _methodExtend2 = _interopRequireDefault(_methodExtend);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			/**
    * Merge method functions.
    *
    * @param {Object} from - Mixin object which will be merged via Helpers.defaults with the methods of our class
    * @param {Array} methods - Array of method names which will be extended.
    */
			function mixin(from) {
				var methods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['initialize', 'render'];

				if (from === undefined) {
					console.error('VeamsHelpers : Mixin :: Mixin not found!');

					return;
				}

				var to = this.prototype;

				/** Add those methods which exists on `from` but not on `to` to the latter */
				(0, _defaults2.default)(to, from);

				/** we do the same for events */
				if (to.events) {
					(0, _defaults2.default)(to.events, from.events);
				}

				// Extend to's methods
				methods.forEach(function (method) {
					(0, _methodExtend2.default)(to, from, method);
				});
			};
			module.exports = exports['default'];

			/***/
		},
		/* 4 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Simple extend method, which extends an object.
    *
    * @param {Object} obj - object which will be extended
    *
    * @return {Object} obj - extended object
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = defaultsHelper;
			function defaultsHelper(obj) {
				[].slice.call(arguments, 1).forEach(function (item) {
					for (var key in item) {
						if (obj[key] === undefined) obj[key] = item[key];
					}
				});
				return obj;
			};
			module.exports = exports['default'];

			/***/
		},
		/* 5 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Helper method to extend an already existing method.
    *
    * @param {Object} to - view which will be extended
    * @param {Object} from - methods which comes from mixin
    * @param {string} methodName - function name
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = methodExtend;
			function methodExtend(to, from, methodName) {
				function isUndefined(value) {
					return typeof value === 'undefined';
				}

				if (from === undefined) return;

				// if the method is defined on from ...
				if (!isUndefined(from[methodName])) {
					var old = to[methodName];

					// ... we create a new function on to
					to[methodName] = function () {

						// wherein we first call the method which exists on `to`
						var oldReturn = old.apply(this, arguments);

						// and then call the method on `from`
						from[methodName].apply(this, arguments);

						// and then return the expected result,
						// i.e. what the method on `to` returns
						return oldReturn;
					};
				}
			};
			module.exports = exports['default'];

			/***/
		},
		/* 6 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Simple extend method to extend the properties of an object.
    *
    * @param {Object} obj - object which will be extended
    *
    * @return {Object} obj - extended object
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = extend;
			function extend(obj) {
				[].slice.call(arguments, 1).forEach(function (item) {
					for (var key in item) {
						obj[key] = item[key];
					}
				});
				return obj;
			};
			module.exports = exports['default'];

			/***/
		},
		/* 7 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Generates numeric id.
    *
    * @param {Number} [segments=1] - number of segments of generated id (segments consist of 10 digits, separated by '-').
    *
    * @return {String} - generated id
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = makeId;
			function makeId() {
				var segments = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

				var crypto = window.crypto || window.msCrypto;
				var array = crypto.getRandomValues(new Uint32Array(segments));
				var id = '';
				var i = 0;

				for (; i < array.length; i++) {
					id += array[i] + '-';
				}

				return id.slice(0, -1);
			};
			module.exports = exports['default'];

			/***/
		},,,,
		/* 8 */
		/* 9 */
		/* 10 */
		/* 11 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			/**
    * Polyfills
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			__webpack_require__(12);

			var _core = __webpack_require__(13);

			var _core2 = _interopRequireDefault(_core);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			var Veams = {};

			/**
    * Imports
    */

			(function (window, document, undefined) {
				'use strict';

				Veams = new _core2.default({
					namespace: 'Veams',
					addToGlobal: true
				});

				Veams.initialize();
			})(window, document);

			exports.default = Veams;
			module.exports = exports['default'];

			/***/
		},
		/* 12 */
		/***/function (module, exports) {

			'use strict';

			// Polyfill for custom events

			(function () {
				if (typeof window.CustomEvent === 'function') return false;

				function CustomEvent(event, params) {
					var evt = document.createEvent('CustomEvent');

					params = params || { bubbles: false, cancelable: false, detail: undefined };

					evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
					return evt;
				}

				CustomEvent.prototype = window.Event.prototype;

				window.CustomEvent = CustomEvent;
			})();

			/***/
		},
		/* 13 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var _createClass = function () {
				function defineProperties(target, props) {
					for (var i = 0; i < props.length; i++) {
						var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
					}
				}return function (Constructor, protoProps, staticProps) {
					if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
				};
			}(); /**
         * Represents VeamsCore.
         * @module VeamsCore
         *
         * @author Sebastian Fitzner
         */

			__webpack_require__(12);

			var _use = __webpack_require__(14);

			var _use2 = _interopRequireDefault(_use);

			var _events = __webpack_require__(15);

			var _events2 = _interopRequireDefault(_events);

			var _helpers = __webpack_require__(16);

			var _helpers2 = _interopRequireDefault(_helpers);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}

			var initState = false;

			var VeamsCore = function () {
				function VeamsCore(opts) {
					_classCallCheck(this, VeamsCore);

					this._options = {
						namespace: 'Veams',
						addToGlobal: false
					};

					this.base = {
						name: 'Veams',
						version: '5.0.1'
					};

					this.use = _use2.default.bind(this);
					this.Plugins = {};
					this.EVENTS = _events2.default;
					this.helpers = {};
					this.detections = {
						width: window.innerWidth,
						height: window.innerHeight
					};

					initState = false;

					this.setup(opts);
				}

				_createClass(VeamsCore, [{
					key: 'setup',
					value: function setup(opts) {
						this.use(_helpers2.default);

						this.detections = this.helpers.extend({
							touch: this.helpers.isTouch()
						}, this.detections);

						this.options = opts;
					}
				}, {
					key: 'initialize',
					value: function initialize(opts) {
						if (initState === true) {
							return console.info('Veams :: You already initialized Veams!');
						}

						/**
       * Set global options on initialize
       */
						this.options = opts;

						if (this.options.addToGlobal) {
							if (window && !window[this.options.namespace]) {
								window[this.options.namespace] = this || {};
							}
						}

						initState = true;
					}
				}, {
					key: 'onInitialize',
					value: function onInitialize(cb) {
						if (!cb || typeof cb !== 'function') {
							console.log('Veams :: Callback is not a function!');
							return;
						}

						if (initState === false) {
							this.initialize();
						}

						cb();
					}
				}, {
					key: 'onDOMReady',
					value: function onDOMReady(cb) {
						if (typeof cb !== 'function') {
							console.log('Veams :: Callback is not a function!');
							return;
						}
						document.addEventListener('DOMContentLoaded', cb);
					}
				}, {
					key: 'version',
					set: function set(version) {
						this._version = version;
					},
					get: function get() {
						return this._version;
					}
				}, {
					key: 'initialized',
					set: function set(bool) {
						this._initialized = bool;
					},
					get: function get() {
						return this._initialized;
					}
				}, {
					key: 'options',
					set: function set(options) {
						this._options = this.helpers.extend(this.options, options || {});
					},
					get: function get() {
						return this._options;
					}
				}]);

				return VeamsCore;
			}();

			exports.default = VeamsCore;
			module.exports = exports['default'];

			/***/
		},
		/* 14 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Represents a simple plugin system in which `this` is Veams.
    * @module plugin
    *
    * @author Sebastian Fitzner
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			exports.default = function (plugin) {
				if (plugin.pluginName) {
					this.Plugins[plugin.pluginName] = plugin;
				}

				for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
					args[_key - 1] = arguments[_key];
				}

				plugin.initialize.apply(plugin, [this].concat(args));
			};

			module.exports = exports['default'];

			/***/
		},
		/* 15 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Const for events (pub/sub)
    *
    * @author: Sebastian Fitzner
    */

			/**
    * Events Global
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var EVENTS = {
				blur: 'blur',
				change: 'change',
				click: 'click',
				dblclick: 'dblclick',
				DOMchanged: 'dom:changed',
				DOMredirect: 'dom:redirect',
				hashchange: 'hashchange',
				input: 'input',
				keydown: 'keydown',
				keypress: 'keypress',
				keyup: 'keyup',
				mediachange: 'mediachange',
				moduleCached: 'module:cached',
				mousedown: 'mousedown',
				mouseenter: 'mouseenter',
				mouseleave: 'mouseleave',
				mouseout: 'mouseout',
				mouseover: 'mouseover',
				mouseup: 'mouseup',
				reset: 'reset',
				resize: 'resize',
				scroll: 'scroll',
				submit: 'submit',
				swipe: 'swipe'
			};

			exports.default = EVENTS;
			module.exports = exports['default'];

			/***/
		},
		/* 16 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
				return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
			} : function (obj) {
				return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
			};

			var _extend = __webpack_require__(6);

			var _extend2 = _interopRequireDefault(_extend);

			var _mixin = __webpack_require__(3);

			var _mixin2 = _interopRequireDefault(_mixin);

			var _methodExtend = __webpack_require__(5);

			var _methodExtend2 = _interopRequireDefault(_methodExtend);

			var _isTouch = __webpack_require__(17);

			var _isTouch2 = _interopRequireDefault(_isTouch);

			var _throttle = __webpack_require__(18);

			var _throttle2 = _interopRequireDefault(_throttle);

			var _querySelectorArray = __webpack_require__(19);

			var _querySelectorArray2 = _interopRequireDefault(_querySelectorArray);

			var _forEach = __webpack_require__(20);

			var _forEach2 = _interopRequireDefault(_forEach);

			var _makeId = __webpack_require__(7);

			var _makeId2 = _interopRequireDefault(_makeId);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			var VeamsHelpers = {
				pluginName: 'Helpers',
				initialize: function initialize(Veams) {
					Veams.addHelper = function addHelper() {
						for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
							args[_key] = arguments[_key];
						}

						var params = [].concat(args);

						if (params.length === 1) {
							if (_typeof(params[0]) !== 'object') {
								console.error('VeamsHelpers :: You need to pass an object!');
								return;
							}

							for (var key in params[0]) {
								if (params[0].hasOwnProperty(key)) {
									if (!Veams.helpers[key]) {
										Veams.helpers[key] = params[0][key];
									} else {
										console.info('VeamsHelpers :: The helper ' + key + ' is already defined! Please define a new name for: ', params[0][key]);
									}
								}
							}
						} else if (params.length === 2) {

							if (!Veams.helpers[params[0]]) {
								if (typeof params[0] !== 'string' || typeof params[1] !== 'function') {
									console.error('VeamsHelpers :: You need to pass a string as first argument and the helper function as second one.');
									return;
								}
								Veams.helpers[params[0]] = params[1];
							} else {
								console.info('VeamsHelpers :: The helper ' + params[0] + ' is already defined! Please define a new name for: ', params[1]);
							}
						}
					};

					this.addDefaultHelpers(Veams);
				},

				addDefaultHelpers: function addDefaultHelpers(Veams) {
					Veams.addHelper('querySelectorArray', _querySelectorArray2.default);
					Veams.addHelper('extend', _extend2.default);
					Veams.addHelper('isTouch', _isTouch2.default);
					Veams.addHelper('mixin', _mixin2.default);
					Veams.addHelper('methodExtend', _methodExtend2.default);
					Veams.addHelper('throttle', _throttle2.default);
					Veams.addHelper('forEach', _forEach2.default);
					Veams.addHelper('makeId', _makeId2.default);
				}
			};

			exports.default = VeamsHelpers;
			module.exports = exports['default'];

			/***/
		},
		/* 17 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Touch Detection
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = isTouch;
			function isTouch() {
				return 'ontouchstart' in window;
			};
			module.exports = exports['default'];

			/***/
		},
		/* 18 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Throttle method for resize events and more
    *
    * @param {function} func - Function which will be executed.
    * @param {number} wait - number to wait in milliseconds.
    * @param {boolean} immediate - execute function immediately.
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = throttle;
			function throttle(func, wait, immediate) {
				var timeout = void 0;

				return function () {
					var context = this;
					var args = arguments;
					var callNow = immediate && !timeout;
					var later = function later() {
						timeout = null;
						if (!immediate) func.apply(context, args);
					};

					clearTimeout(timeout);

					timeout = setTimeout(later, wait);

					if (callNow) func.apply(context, args);
				};
			};
			module.exports = exports['default'];

			/***/
		},
		/* 19 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Get dom elements in an array
    *
    * @param {String} elem - Required: selector
    * @param {Object} [context] - Optional: context
    *
    * @return {Array}
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = querySelectorArray;
			function querySelectorArray(elem, context) {
				if (!elem) throw new Error('In order to work with querySelectorArray you need to define an element as string!');
				var el = elem;
				var customContext = context || document;

				return Array.prototype.slice.call(customContext.querySelectorAll(el));
			};
			module.exports = exports['default'];

			/***/
		},
		/* 20 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Simple forEach method
    *
    * @param {Array} array - array of objects
    * @param {function} callback - callback function
    * @param {string} scope - scope of function
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = forEach;
			function forEach(array, callback, scope) {
				for (var i = 0; i < array.length; i++) {
					callback.call(scope, i, array[i]);
				}
			};
			module.exports = exports['default'];

			/***/
		}
		/******/])
	);
});
;


},{}],29:[function(require,module,exports){
'use strict';
/**
 * Represents a base constructor which supports
 * options merging and
 * saving of standard stuff.
 *
 * @module VeamsBase
 * @author Sebastian Fitzner
 */

/**
 * Imports
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _string = require('../utils/internal-helpers/string');

var _string2 = _interopRequireDefault(_string);

var _mixin = require('../utils/helpers/mixin');

var _mixin2 = _interopRequireDefault(_mixin);

var _extend = require('../utils/helpers/extend');

var _extend2 = _interopRequireDefault(_extend);

var _makeId = require('../utils/helpers/make-id');

var _makeId2 = _interopRequireDefault(_makeId);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VeamsBase = function () {
	/**
  * Constructor
  *
  * to save standard elements like el and options and
  * execute initialize as default method.
  *
  * @param {String} namespace - Add custom namespace to your class.
  * @param {Object} el - Save element in class.
  * @param {Object} options - Options passed by init process.
  * @param {Object} opts [{}] - Object which contains options of the extended class.
  */
	function VeamsBase(_ref) {
		var namespace = _ref.namespace,
		    el = _ref.el,
		    options = _ref.options;
		var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		_classCallCheck(this, VeamsBase);

		this.namespace = namespace || 'base';
		this.instanceId = this.namespace;
		this.options = opts;
		this._options = options;

		if (el) {
			this.el = el;
		}
	}

	// ----------------------------------------------------------
	// GETTER & SETTERS
	// ----------------------------------------------------------

	_createClass(VeamsBase, [{
		key: 'namespace',
		set: function set(namespace) {
			this._namespace = namespace;
		},
		get: function get() {
			return this._namespace;
		}
	}, {
		key: 'instanceId',
		get: function get() {
			return this._instanceId;
		},
		set: function set(id) {
			this._instanceId = id + '_' + Date.now() + '_' + (0, _makeId2.default)();
		}
	}, {
		key: '_options',
		get: function get() {
			return this.options;
		},
		set: function set(options) {
			this.options = (0, _extend2.default)(this.options, options || {});
		}
	}, {
		key: 'el',
		set: function set(element) {
			this._el = element;
		},
		get: function get() {
			return this._el;
		}

		/**
   * Get module information
   */

	}, {
		key: 'metaData',
		get: function get() {
			return {
				name: typeof this.namespace === 'string' ? _string2.default.capitalizeFirstLetter(_string2.default.toCamelCase(this.namespace)) : ''
			};
		}
	}]);

	return VeamsBase;
}();

/**
 * Add mixin functionality to extend module class by using simple objects
 */


VeamsBase.mixin = _mixin2.default;

exports.default = VeamsBase;
module.exports = exports['default'];

},{"../utils/helpers/extend":32,"../utils/helpers/make-id":34,"../utils/helpers/mixin":36,"../utils/internal-helpers/string":39}],30:[function(require,module,exports){
'use strict';

/**
 * Represents a component constructor which supports
 * options merging,
 * binding and unbinding of events and subscriptions with template strings,
 * rendering of templates
 * and a destroy behaviour.
 *
 * Keep in mind, that this class is a dependent of Veams.
 *
 * TODO: Make a native one which does not need any Veams specific stuff.
 *
 * @module VeamsComponent
 * @author Sebastian Fitzner
 */

/**
 * Imports
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _base = require('./base');

var _base2 = _interopRequireDefault(_base);

var _getStringValue = require('../utils/internal-helpers/get-string-value');

var _getStringValue2 = _interopRequireDefault(_getStringValue);

var _templateEngine = require('../utils/internal-helpers/template-engine');

var _templateEngine2 = _interopRequireDefault(_templateEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Custom Functions
 */
function buildEvtId(evtKeyArr, fnName) {
	return evtKeyArr.join('_') + '_' + fnName;
}

var VeamsComponent = function (_VeamsBase) {
	_inherits(VeamsComponent, _VeamsBase);

	/**
  * Constructor
  *
  * to save standard elements like el and options and
  * execute initialize as default method.
  *
  * @param {Object} obj [{}] - Object which contains el, options from the DOM and namespace.
  * @param {Object} options [{}] - Object which contains options of the extended class.
  */
	function VeamsComponent() {
		var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		_classCallCheck(this, VeamsComponent);

		var _this = _possibleConstructorReturn(this, (VeamsComponent.__proto__ || Object.getPrototypeOf(VeamsComponent)).call(this, obj, options));

		_this.appInstance = obj.appInstance || window.Veams;

		if (!_this.appInstance) {
			throw new Error('VeamsComponent :: Please provide your app instance!');
		}

		if (!_this.appInstance.$) {
			console.info('VeamsComponent :: Please add a DOM handler like jQuery to the app instance!');
		}

		if (_this.appInstance.$) {
			_this.$el = _this.appInstance.$(obj.el);
		}

		_this.initialize(obj, options);
		_this._create();
		return _this;
	}

	// ----------------------------------------------------------
	// GETTER & SETTERS
	// ----------------------------------------------------------

	/**
  * Get and set events object
  */


	_createClass(VeamsComponent, [{
		key: 'initialize',


		// ----------------------------------------------------------
		// STANDARD METHODS
		// ----------------------------------------------------------
		value: function initialize() {
			return this;
		}

		/**
   * Private method to create all necessary elements and bindings.
   *
   * @private
   */

	}, {
		key: '_create',
		value: function _create() {
			this.preRender();
			this.registerEvents(this.events, false);
			this.registerEvents(this.subscribe, true);
			this.bindEvents();
		}

		/**
   * Bind local and global events
   *
   * @public
   */

	}, {
		key: 'bindEvents',
		value: function bindEvents() {}

		/**
   * Unbind events
   *
   * @public
   */

	}, {
		key: 'unbindEvents',
		value: function unbindEvents() {}

		/**
   * Pre-Render templates
   * which can be used to render content into it
   *
   * @public
   */

	}, {
		key: 'preRender',
		value: function preRender() {
			return this;
		}

		/**
   * Render your module
   *
   * @public
   */

	}, {
		key: 'render',
		value: function render() {
			return this;
		}

		/**
   * Destroy component by unbinding events and
   * removing element from DOM
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			this.unregisterEvents();
			this.unbindEvents();
			this.$el.remove();
		}

		/**
   * Render template with data
   *
   * @param {String} tplName - Template name which gets returned as rendered element.
   * @param {Object} data - Data which gets handled by the template.
   */

	}, {
		key: 'renderTemplate',
		value: function renderTemplate(tplName, data) {
			if (!this.appInstance.templater) {
				console.error('\n\t\t\t\tVeamsComponent :: It seems that you haven\'t added the VeamsTemplater plugin. In order to work with \'renderTemplate()\' you need to add it!\n\t\t\t');
			} else {
				return this.appInstance.templater.render(tplName, data);
			}
		}

		// ----------------------------------------------------------
		// MOUNT PROCESS METHODS
		// Mount process methods will be handled by the VeamsModules plugin
		// ----------------------------------------------------------

		/**
   * This method will be executed after initialise
   */

	}, {
		key: 'willMount',
		value: function willMount() {}

		/**
   * This method will be executed before unregistering events
   */

	}, {
		key: 'willUnmount',
		value: function willUnmount() {}

		/**
   * This method will be executed after render
   */

	}, {
		key: 'didMount',
		value: function didMount() {}

		/**
   * This method will be executed after unregistering events
   */

	}, {
		key: 'didUnmount',
		value: function didUnmount() {}

		// ----------------------------------------------------------
		// EVENTS METHODS
		// ----------------------------------------------------------

		/**
   * Register multiple events which are saved in an object.
   *
   * @param {Object} evts - Events object which contains an object with events as key and functions as value.
   * @param {Boolean} global - Flag to switch between global and local events.
   *
   * @private
   */

	}, {
		key: 'registerEvents',
		value: function registerEvents(evts) {
			var _this2 = this;

			var global = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

			if (evts) {
				Object.keys(evts).forEach(function (key) {
					_this2.registerEvent(key, evts[key], global);
				});
			}
		}

		/**
   * Register an event by using a simple template engine and
   * a key/value pair.
   *
   * @param {String} evtKey - Event key which contains event and additionally a delegated element.
   * @param {String} fn - Function defined as string which will be bound to this.
   * @param {Boolean} global - Flag if global or local event .
   *
   * @public
   *
   * @example
   * this.registerEvent('click .btn', 'render');
   * this.registerEvent('click {{this.options.btn}}', 'render');
   * this.registerEvent('{{App.EVENTS.custom.event', 'render');
   * this.registerEvent('{{App.EVENTS.resize', 'render', true);
   */

	}, {
		key: 'registerEvent',
		value: function registerEvent(evtKey, fn) {
			var global = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

			if (typeof evtKey !== 'string') {
				console.error('VeamsComponent :: Your event is not a string!');
				return;
			}

			if (typeof fn !== 'string') {
				console.error('VeamsComponent :: Your event handler function is not a string!');
				return;
			}

			var evtKeyArr = evtKey.split(' ');
			var arrlen = evtKeyArr.length;
			var evtType = _getStringValue2.default.apply(this, [(0, _templateEngine2.default)(evtKeyArr[0]), this.appInstance]);
			var bindFn = this[fn].bind(this);
			var id = buildEvtId(evtKeyArr, fn);

			if (arrlen > 2) {
				throw new Error('It seems like you have more than two strings in your events object!');
			}

			// Bind on this.$el
			if (arrlen === 1 && !global) {
				this.$el.on(evtType, bindFn);

				this._subscribers = {
					type: 'event',
					id: id,
					event: evtType,
					handler: bindFn
				};
			} else if (arrlen === 1 && global) {
				this.appInstance.Vent.subscribe(evtType, bindFn);

				this._subscribers = {
					type: 'globalEvent',
					id: id,
					event: evtType,
					handler: bindFn
				};
			} else {
				var delegate = _getStringValue2.default.apply(this, [(0, _templateEngine2.default)(evtKeyArr[1])]);

				this.$el.on(evtType, delegate, bindFn);

				this._subscribers = {
					type: 'delegatedEvent',
					delegate: delegate,
					id: id,
					event: evtType,
					handler: bindFn
				};
			}
		}

		/**
   * Delete all registered events.
   */

	}, {
		key: 'unregisterEvents',
		value: function unregisterEvents() {
			for (var key in this._subscribers) {
				if (this._subscribers.hasOwnProperty(key)) {
					var obj = this._subscribers[key];

					if (obj.type === 'globalEvent') {
						this.appInstance.Vent.unsubscribe(obj.event, obj.handler);
					} else if (obj.type === 'delegatedEvent') {
						this.$el.off(obj.event, obj.delegate, obj.handler);
					} else {
						this.$el.off(obj.event, obj.handler);
					}
				}
			}
		}

		/**
   * Unregister an event by using the saved subscribers and
   * a key/value pair.
   *
   *
   * @param {String} evtKey - Event key which contains event and additionally a delegated element.
   * @param {String} fn - Function defined as string which will be unbound to this.
   *
   * @public
   *
   * @example
   * this.unregisterEvent('click .btn', 'render');
   * this.unregisterEvent('click {{this.options.btn}}', 'render');
   * this.unregisterEvent('{{App.EVENTS.custom.event', 'render');
   * this.unregisterEvent('{{App.EVENTS.resize', 'render');
   */

	}, {
		key: 'unregisterEvent',
		value: function unregisterEvent(evtKey, fn) {
			var evtKeyArr = evtKey.split(' ');
			var id = buildEvtId(evtKeyArr, fn);

			if (this._subscribers[id]) {
				var obj = this._subscribers[id];

				if (obj.type === 'globalEvent') {
					this.appInstance.Vent.unsubscribe(obj.event, obj.handler);
				} else if (obj.type === 'delegatedEvent') {
					this.$el.off(obj.event, obj.delegate, obj.handler);
				} else {
					this.$el.off(obj.event, obj.handler);
				}
			}
		}
	}, {
		key: 'events',
		set: function set(obj) {
			this._events = obj;
		},
		get: function get() {
			return this._events;
		}

		/**
   * Get and set subscribe object
   */

	}, {
		key: 'subscribe',
		set: function set(obj) {
			this._subscribe = obj;
		},
		get: function get() {
			return this._subscribe;
		}
	}, {
		key: '_subscribers',
		set: function set(obj) {
			if (!this.__subscribers) {
				this.__subscribers = {};
			}

			this.__subscribers[obj.id] = {
				delegate: obj.delegate,
				type: obj.type,
				event: obj.event,
				handler: obj.handler
			};
		},
		get: function get() {
			return this.__subscribers;
		}
	}]);

	return VeamsComponent;
}(_base2.default);

exports.default = VeamsComponent;
module.exports = exports['default'];

},{"../utils/internal-helpers/get-string-value":38,"../utils/internal-helpers/template-engine":40,"./base":29}],31:[function(require,module,exports){
'use strict';

/**
 * Simple extend method, which extends an object.
 *
 * @param {Object} obj - object which will be extended
 *
 * @return {Object} obj - extended object
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = defaultsHelper;
function defaultsHelper(obj) {
  [].slice.call(arguments, 1).forEach(function (item) {
    for (var key in item) {
      if (obj[key] === undefined) obj[key] = item[key];
    }
  });
  return obj;
};
module.exports = exports['default'];

},{}],32:[function(require,module,exports){
'use strict';

/**
 * Simple extend method to extend the properties of an object.
 *
 * @param {Object} obj - object which will be extended
 *
 * @return {Object} obj - extended object
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extend;
function extend(obj) {
  [].slice.call(arguments, 1).forEach(function (item) {
    for (var key in item) {
      obj[key] = item[key];
    }
  });
  return obj;
};
module.exports = exports['default'];

},{}],33:[function(require,module,exports){
'use strict';

/**
 * Check if element is in viewport
 *
 * @param {Object} elem - Object, which we want to check
 * @param {boolean} useBounds - if true, whole element must be visible
 *
 * @return {boolean}
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = isInViewport;
function isInViewport(elem, useBounds) {
	var el = elem;
	var top = el.offsetTop;
	var left = el.offsetLeft;
	var width = el.offsetWidth;
	var height = el.offsetHeight;
	var cond = false;

	while (el.offsetParent) {
		el = el.offsetParent;
		top += el.offsetTop;
		left += el.offsetLeft;
	}

	if (useBounds) {
		cond = top >= window.pageYOffset && left >= window.pageXOffset && top + height <= window.pageYOffset + window.innerHeight && left + width <= window.pageXOffset + window.innerWidth;
	} else {
		cond = top < window.pageYOffset + window.innerHeight && left < window.pageXOffset + window.innerWidth && top + height > window.pageYOffset && left + width > window.pageXOffset;
	}

	return cond;
};
module.exports = exports['default'];

},{}],34:[function(require,module,exports){
'use strict';

/**
 * Generates numeric id.
 *
 * @param {Number} [segments=1] - number of segments of generated id (segments consist of 10 digits, separated by '-').
 *
 * @return {String} - generated id
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = makeId;
function makeId() {
	var segments = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

	var crypto = window.crypto || window.msCrypto;
	var array = crypto.getRandomValues(new Uint32Array(segments));
	var id = '';
	var i = 0;

	for (; i < array.length; i++) {
		id += array[i] + '-';
	}

	return id.slice(0, -1);
};
module.exports = exports['default'];

},{}],35:[function(require,module,exports){
'use strict';

/**
 * Helper method to extend an already existing method.
 *
 * @param {Object} to - view which will be extended
 * @param {Object} from - methods which comes from mixin
 * @param {string} methodName - function name
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = methodExtend;
function methodExtend(to, from, methodName) {
	function isUndefined(value) {
		return typeof value === 'undefined';
	}

	if (from === undefined) return;

	// if the method is defined on from ...
	if (!isUndefined(from[methodName])) {
		var old = to[methodName];

		// ... we create a new function on to
		to[methodName] = function () {

			// wherein we first call the method which exists on `to`
			var oldReturn = old.apply(this, arguments);

			// and then call the method on `from`
			from[methodName].apply(this, arguments);

			// and then return the expected result,
			// i.e. what the method on `to` returns
			return oldReturn;
		};
	}
};
module.exports = exports['default'];

},{}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = mixin;

var _defaults = require('./defaults');

var _defaults2 = _interopRequireDefault(_defaults);

var _methodExtend = require('./method-extend');

var _methodExtend2 = _interopRequireDefault(_methodExtend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Merge method functions.
 *
 * @param {Object} from - Mixin object which will be merged via Helpers.defaults with the methods of our class
 * @param {Array} methods - Array of method names which will be extended.
 */
function mixin(from) {
	var methods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['initialize', 'render'];

	if (from === undefined) {
		console.error('VeamsHelpers : Mixin :: Mixin not found!');

		return;
	}

	var to = this.prototype;

	/** Add those methods which exists on `from` but not on `to` to the latter */
	(0, _defaults2.default)(to, from);

	/** we do the same for events */
	if (to.events) {
		(0, _defaults2.default)(to.events, from.events);
	}

	// Extend to's methods
	methods.forEach(function (method) {
		(0, _methodExtend2.default)(to, from, method);
	});
};
module.exports = exports['default'];

},{"./defaults":31,"./method-extend":35}],37:[function(require,module,exports){
'use strict';

/**
 * Detect transitionend event.
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = transitionEndEvent;
function transitionEndEvent() {
	var t = void 0;
	var el = document.createElement('fakeelement');
	var transitions = {
		'transition': 'transitionend',
		'OTransition': 'oTransitionEnd',
		'MozTransition': 'transitionend',
		'WebkitTransition': 'webkitTransitionEnd'
	};

	for (t in transitions) {
		if (el.style[t] !== undefined) {
			return transitions[t];
		}
	}
};
module.exports = exports['default'];

},{}],38:[function(require,module,exports){
'use strict';

/**
 * Get value out of variable string.
 *
 * @param {String} str - String which is a reference to a var.
 *
 * @return String
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
var getStringValue = function getStringValue(str, instanceObject) {
	if (str.indexOf('.') === -1) return str;
	var arr = str.split('.');
	var context = arr[0];
	var finalStr = context === 'this' ? this : instanceObject ? instanceObject : window[context];

	var strReplacer = function strReplacer(el, prev) {
		return prev[el];
	};

	arr.shift();
	arr.forEach(function (item) {
		finalStr = strReplacer(item, finalStr);
		return finalStr;
	});

	if (typeof finalStr !== 'string') {
		throw new Error('The resulting variable out of your events object must be a string!');
	} else {
		return finalStr;
	}
};

exports.default = getStringValue;
module.exports = exports['default'];

},{}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
var stringHelpers = {};

/**
 * CamelCase strings by replacing hyphens, white space and points.
 *
 * @param {String} str - String which will be camelcased
 */
stringHelpers.toCamelCase = function (str) {
	// Lower cases the string
	return str.toLowerCase()
	// Replaces any - or _ characters with a space
	.replace(/[-_]+/g, ' ')
	// Removes any non alphanumeric characters
	.replace(/[^\w\s]/g, '')
	// Uppercases the first character in each group immediately following a space
	// (delimited by spaces)
	.replace(/ (.)/g, function ($1) {
		return $1.toUpperCase();
	})
	// Removes spaces
	.replace(/ /g, '');
};

/**
 * String which will be hyphenated by replacing white space and lower case the characters.
 * @param {String} str - String
 */
stringHelpers.hyphenate = function (str) {
	return str.replace(/\s/g, '-').toLowerCase();
};

/**
 * String.
 * @param {String} str - String where first char is upper cased
 */
stringHelpers.capitalizeFirstLetter = function (str) {
	return str.charAt(0).toUpperCase() + str.slice(1);
};

exports.default = stringHelpers;
module.exports = exports['default'];

},{}],40:[function(require,module,exports){
'use strict';

/**
 * Simple template engine for event system.
 *
 * @param {String} tplStr - Template string.
 *
 * @return String
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
var templateEngine = function templateEngine(tplStr) {
	var reg = new RegExp('(\{\{\s?)(.+)(\s?\}\})');
	var match = reg.exec(tplStr);
	var returnVal = '';

	if (match) {
		returnVal = match[2];
	} else {
		returnVal = tplStr;
	}

	return returnVal;
};

exports.default = templateEngine;
module.exports = exports['default'];

},{}],41:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});/**
 * Const for events (pub/sub)
 *
 * @author: Sebastian Fitzner
 *//**
 * Events Global
 */var EVENTS={};/**
 * Events for Slider
 */EVENTS.slider={slideStart:'slide:start'};/**
 * Events Accordion
 */EVENTS.accordion={openAll:'accordion:openAll',closeAll:'accordion:closeAll'};/**
 * Events for Toggler
 */EVENTS.toggler={eventName:'toggler:eventName'};/**
 * Events Form
 */EVENTS.form={complete:'form:complete',reset:'form:reset'};/**
 * Events Overlay
 */EVENTS.overlay={open:'overlay:open'};// @INSERTPOINT :: @ref: js-events
exports.default=EVENTS;

},{}],42:[function(require,module,exports){
'use strict';var _app=require('./app');var _slider=require('../templating/partials/components/slider/js/slider');var _slider2=_interopRequireDefault(_slider);var _accordion=require('../templating/partials/components/accordion/js/accordion');var _accordion2=_interopRequireDefault(_accordion);var _toggler=require('../templating/partials/components/toggler/js/toggler');var _toggler2=_interopRequireDefault(_toggler);var _cta=require('../templating/partials/components/cta/js/cta');var _cta2=_interopRequireDefault(_cta);var _formAjax=require('../templating/partials/components/form/js/form-ajax');var _formAjax2=_interopRequireDefault(_formAjax);var _formDatepicker=require('../templating/partials/components/form/js/form-datepicker');var _formDatepicker2=_interopRequireDefault(_formDatepicker);var _comparer=require('../templating/partials/components/comparer/js/comparer');var _comparer2=_interopRequireDefault(_comparer);var _overlay=require('../templating/partials/components/overlay/js/overlay');var _overlay2=_interopRequireDefault(_overlay);var _slideFox=require('../templating/partials/components/slide-fox/js/slide-fox');var _slideFox2=_interopRequireDefault(_slideFox);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}console.log('JS initialized in version:',_app.App.version);// Global dependencies
console.log('Veams initialized in version:',_app.Veams.base.version);// Imports
// @INSERTPOINT :: @ref: js-self-contained-import, @keep: true //
// Initialize modules with Veams
_app.Veams.modules.register([/**
     * Init Slider
     */{namespace:'slider',module:_slider2.default},// Init Accordion
{namespace:'accordion',module:_accordion2.default},// Init Toggler //
{domName:'toggler',module:_toggler2.default},// Init Call-To-Action
{namespace:'cta',module:_cta2.default},/**
     * Init AJAX Form
     */{namespace:'form-ajax',module:_formAjax2.default},/**
     * Init Form Datepicker
     */{namespace:'form-datepicker',module:_formDatepicker2.default},// Init Comparer
{namespace:'comparer',module:_comparer2.default},/**
     * Init SlideFox
     */{namespace:'slide-fox',module:_slideFox2.default// @INSERTPOINT :: @ref: js-init-v5, @keep: true //
}]);/**
 * Init Overlay
 */new _overlay2.default({appInstance:_app.Veams});// @INSERTPOINT :: @ref: js-init-once-v5, @keep: true //

},{"../templating/partials/components/accordion/js/accordion":44,"../templating/partials/components/comparer/js/comparer":45,"../templating/partials/components/cta/js/cta":46,"../templating/partials/components/form/js/form-ajax":47,"../templating/partials/components/form/js/form-datepicker":48,"../templating/partials/components/overlay/js/overlay":49,"../templating/partials/components/slide-fox/js/slide-fox":50,"../templating/partials/components/slider/js/slider":51,"../templating/partials/components/toggler/js/toggler":52,"./app":"app"}],43:[function(require,module,exports){
"use strict";module.exports=function(Handlebars){window["App"]=window["App"]||{};window["App"]["Templates"]=window["App"]["Templates"]||{};window["App"]["Templates"]["OVERLAY"]=Handlebars.template({"compiler":[7,">= 4.0.0"],"main":function main(container,depth0,helpers,partials,data){return"<div class=\"c-overlay--default\" data-css=\"c-overlay\" data-js-item=\"overlay\">\n	<div class=\"overlay__wrapper\">\n		<button class=\"overlay__close\" data-js-item=\"overlay-close\"></button>\n		<div class=\"overlay__content\">\n			<div class=\"overlay__inner\" data-js-item=\"overlay-content\">\n\n			</div>\n		</div>\n	</div>\n	<div class=\"overlay__mask\" data-js-item=\"overlay-mask\"></div>\n</div>";},"useData":true});return window["App"]["Templates"];};

},{}],44:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * Represents a simple accordion with transitions and max-height.
 *
 * @module Accordion
 * @version v3.0.2
 *
 * @author Sebastian Fitzner
 * @author Andy Gutsche
 *//**
 * Requirements
 */var $=_app.Veams.$;var Helpers=_app.Veams.helpers;/**
 * Class Accordion
 */var Accordion=function(_VeamsComponent){_inherits(Accordion,_VeamsComponent);function Accordion(obj){_classCallCheck(this,Accordion);var options={activeClass:'is-active',accordionBtn:'[data-js-item="accordion-btn"]',accordionContent:'[data-js-item="accordion-content"]',calculatingClass:'is-calculating',clickHandler:'click',closeClass:'is-closed',dataMaxAttr:'data-js-height',openAllOnInit:false,openByHash:false,openClass:'is-open',openIndex:null,openOnViewports:['tablet-small','tablet-large','desktop'],// array: viewport names - eg.: ['mobile', 'tablet', 'desktop-small', 'desktop']
removeStyles:false,// TODO
singleOpen:false,tabMode:false,unresolvedClass:'is-unresolved'};return _possibleConstructorReturn(this,(Accordion.__proto__||Object.getPrototypeOf(Accordion)).call(this,obj,options));}/** =================================================
	 * GETTER & SETTER
	 * ================================================ *//**
	 * Get module information
	 */_createClass(Accordion,[{key:'initialize',/** =================================================
	 * STANDARD METHODS
	 * ================================================= *//**
	 * Init method to save all necessary references.
	 */value:function initialize(){this.$accordionContents=$(this.options.accordionContent,this.$el);this.$accordionBtns=$(this.options.accordionBtn,this.$el);this.$target=null;this.$btn=null;this.openIndex=this.options.openIndex;if(this.options.openByHash){var idx=this.getIndexByHash();this.openIndex=typeof idx==='number'?idx:this.options.openIndex;}else if(this.options.tabMode&&!this.options.openIndex){this.openIndex=0;}}/**
	 * Bind all events
	 */},{key:'bindEvents',value:function bindEvents(){var fnOnHashChange=this.onHashChange.bind(this);// Global events
if(this.options.openByHash){$(window).on(_app.Veams.EVENTS.hashchange,fnOnHashChange);}}},{key:'render',value:function render(){if(!_app.Veams.currentMedia){console.warn('Accordion: Veams.currentMedia is necessary to support the slider module!');return;}this.removeStyles();this.saveHeights(this.$accordionContents);this.closeAll();if(this.options.openAllOnInit){this.openAll();}// Open on index if set in options
if(typeof this.openIndex==='number'){if(this.options.tabMode||this.options.openOnViewports.indexOf(_app.Veams.currentMedia)!==-1){this.activateBtn(this.$accordionBtns.eq(this.openIndex));this.slideDown(this.$accordionContents.eq(this.openIndex));}}if(this.$el.hasClass(this.options.unresolvedClass)){this.$el.removeClass(this.options.unresolvedClass);}}/** =================================================
	 * CUSTOM ACCORDION METHODS
	 * ================================================= *//**
	 * Get index of accordion content referenced by hash
	 *
	 * @return {number|boolean} - index of element or false if no match
	 */},{key:'getIndexByHash',value:function getIndexByHash(){var hash=document.location.hash.split('#');var retVal=false;var i=0;if(hash<2){return false;}for(i;i<this.$accordionContents.length;i++){if(this.$accordionContents[i].id===hash[1]){retVal=i;break;}}return retVal;}/**
	 * Open accordion content referenced by hash
	 *
	 * @param {object} e - event object
	 */},{key:'onHashChange',value:function onHashChange(e){var idx=this.getIndexByHash();if(typeof idx==='number'){if(this.options.singleOpen){this.closeAll();}this.activateBtn(this.$accordionBtns.eq(idx));this.slideDown(this.$accordionContents.eq(idx));}}/**
	 * Save heights of all accordion contents.
	 *
	 * @param {Array} items - array of items
	 */},{key:'saveHeights',value:function saveHeights(items){var _this2=this;Helpers.forEach(items,function(idx,item){_this2.saveHeight(item);});}/**
	 * Save the height of the node item.
	 *
	 * @param {Object} item - item to calculate the height
	 */},{key:'saveHeight',value:function saveHeight(item){var $el=$(item);// the el is hidden so:
// making the el block so we can measure its height but still be hidden
$el.addClass(this.options.calculatingClass);var wantedHeight=$el.outerHeight();// reverting to the original values
$el.removeClass(this.options.calculatingClass);// save height in data attribute
$el.attr(this.options.dataMaxAttr,wantedHeight);}/**
	 * Handle the click,
	 * get the id of the clicked button and
	 * execute the toggleContent method.
	 *
	 * @param {Object} e - event object
	 * @param {object} currentTarget - Target to which listener was attached.
	 */},{key:'handleClick',value:function handleClick(e,currentTarget){this.$btn=currentTarget?$(currentTarget):$(e.currentTarget);var targetId=this.$btn.attr('href');e.preventDefault();if(this.options.tabMode&&this.$btn.hasClass(this.options.activeClass)){return;}this.toggleContent(targetId);}/**
	 * Toggle the accordion content by using the id of the accordion button.
	 *
	 * @param {String} id - id of the target
	 *
	 * @public
	 */},{key:'toggleContent',value:function toggleContent(id){this.$target=this.$el.find(id);if(this.$target.hasClass(this.options.openClass)){this.slideUp(this.$target);this.deactivateBtn(this.$btn);}else{if(this.options.singleOpen||this.options.tabMode){this.closeAll();}this.activateBtn(this.$btn);this.slideDown(this.$target);}}/**
	 * Mimics the slideUp functionality of jQuery by using height and transition.
	 *
	 * @param {Object} $item - jQuery object of item
	 */},{key:'slideUp',value:function slideUp($item){$item.css('height',0).removeAttr('style').attr('aria-expanded','false').removeClass(this.options.openClass).addClass(this.options.closeClass);}/**
	 * Mimics the slideDown functionality of jQuery by using height and transition.
	 *
	 * @param {Object} $item - jQuery object of item
	 */},{key:'slideDown',value:function slideDown($item){$item.css('height',$item.attr('data-js-height')+'px').attr('aria-expanded','true').removeClass(this.options.closeClass).addClass(this.options.openClass);}/**
	 * Adds active class to the clicked button.
	 *
	 * @param {Object} $item - jQuery object of button
	 */},{key:'activateBtn',value:function activateBtn($item){$item.addClass(this.options.activeClass);}/**
	 * Removes active class from the button.
	 *
	 * @param {Object} $item - jQuery object of button
	 */},{key:'deactivateBtn',value:function deactivateBtn($item){$item.removeClass(this.options.activeClass);}/**
	 * Remove all styles of the accordion content elements
	 */},{key:'removeStyles',value:function removeStyles(){this.$accordionContents.removeAttr('style');}/**
	 * Close all accordion contents and active buttons
	 *
	 * @public
	 */},{key:'closeAll',value:function closeAll(){var _this3=this;Helpers.forEach(this.$accordionContents,function(idx,item){_this3.slideUp($(item));});Helpers.forEach(this.$accordionBtns,function(idx,item){_this3.deactivateBtn($(item));});}/**
	 * Close all accordion contents and active buttons
	 *
	 * @public
	 */},{key:'openAll',value:function openAll(){var _this4=this;Helpers.forEach(this.$accordionContents,function(idx,item){_this4.slideDown($(item));});Helpers.forEach(this.$accordionBtns,function(idx,item){_this4.activateBtn($(item));});}},{key:'$accordionContents',set:function set(items){this._$accordionContents=items;},get:function get(){return this._$accordionContents;}},{key:'$accordionBtns',set:function set(items){this._$accordionBtns=items;},get:function get(){return this._$accordionBtns;}},{key:'$target',set:function set(item){this._$target=item;},get:function get(){return this._$target;}},{key:'$btn',set:function set(item){this._$btn=item;},get:function get(){return this._$btn;}/** =================================================
	 * EVENTS
	 * ================================================ */},{key:'events',get:function get(){return{'{{this.options.clickHandler}} {{this.options.accordionBtn}}':'handleClick'};}},{key:'subscribe',get:function get(){return{'{{Veams.EVENTS.resize}}':'render','{{Veams.EVENTS.accordion.closeAll}}':'closeAll','{{Veams.EVENTS.accordion.openAll}}':'openAll'};}}],[{key:'info',get:function get(){return{name:'Accordion',version:'3.0.2',vc:true,mod:false// set to true if source was modified in project
};}}]);return Accordion;}(_component2.default);// Returns constructor
exports.default=Accordion;

},{"app":"app","veams/src/js/common/component":30}],45:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * Description of ContentComparer.
 *
 * @module ContentComparer
 * @version v3.0.0
 *
 * @author koen.zigterman
 */var $=_app.Veams.$;var Comparer=function(_VeamsComponent){_inherits(Comparer,_VeamsComponent);/**
	 * Constructor for our class
	 *
	 * @see module.js
	 *
	 * @param {Object} obj - Object which is passed to our class
	 * @param {Object} obj.el - element which will be saved in this.el
	 * @param {Object} obj.options - options which will be passed in as JSON object
	 */function Comparer(obj){_classCallCheck(this,Comparer);var options={handle:'[data-js-item="comparer-handle"]',topContainer:'[data-js-item="comparer-top-container"]',topContent:'[data-js-item="comparer-top-content"]',draggClass:'is-dragging',dragMode:true,topContentRight:false,disabled:{'desktop':false,'tablet-large':false,'tablet-small':false,'mobile-large':false,'mobile-medium':false,'mobile-small':false}};return _possibleConstructorReturn(this,(Comparer.__proto__||Object.getPrototypeOf(Comparer)).call(this,obj,options));}/** =================================================
	 * GETTER & SETTER
	 * ================================================ *//**
	 * Get module information
	 */_createClass(Comparer,[{key:'initialize',/** =================================================
	 * STANDARD METHODS
	 * ================================================= *//**
	 * Initialize the view and merge options
	 *
	 */value:function initialize(){this.$topContainer=$(this.options.topContainer,this.$el);this.$topContent=$(this.options.topContent,this.$el);this.$handle=$(this.options.handle,this.$el);}/**
	 * Pre-Render method
	 */},{key:'preRender',value:function preRender(){// Return if module is disabled
if(this.disabled)return;this.elWidth=this.el.clientWidth;this.$topContent.css('width',this.elWidth);}/**
	 * Render method
	 */},{key:'render',value:function render(){if(this.options.disabled[_app.Veams.currentMedia]&&!this.disabled){this.disabled=true;this.resetStyles();}else{this.disabled=this.options.disabled[_app.Veams.currentMedia];}}/** =================================================
	 * CUSTOM COMPARER METHODS
	 * ================================================= */},{key:'mouseDown',value:function mouseDown(e){e.preventDefault();this.dragging=true;this.$handle.addClass(this.options.draggClass);}},{key:'mouseUp',value:function mouseUp(){this.dragging=false;this.$handle.addClass(this.options.draggClass);}/**
	 * Resize top container
	 */},{key:'resizeContainer',value:function resizeContainer(e){// Return if module is disabled or if it is not dragging when dragging mode is enabled
if(this.disabled||!this.dragging&&this.options.dragMode)return;var mousePos=this.getMousePos(e);var contentWidth=this.options.topContentRight?this.elWidth-mousePos:0+mousePos;this.$topContainer.css('width',contentWidth);}/**
	 * Reset styles
	 */},{key:'resetStyles',value:function resetStyles(){this.$topContent.removeAttr('style');this.$topContainer.removeAttr('style');}/**
	 * Get mouse position
	 */},{key:'getMousePos',value:function getMousePos(e){return e.pageX-this.$el.offset().left;}},{key:'subscribe',/** =================================================
	 * EVENTS
	 * ================================================ *//**
	 * Subscribe to global events of Veams or App namespace.
	 */get:function get(){return{'{{Veams.EVENTS.resize}}':'preRender','{{Veams.EVENTS.mediachange}}':'render'};}/**
	 * Bind local events to this.$el.
	 */},{key:'events',get:function get(){return{'mousedown {{this.options.handle}}':'mouseDown','mouseup':'mouseUp','touchstart {{this.options.handle}}':'mouseDown','touchend':'mouseUp','mousemove':'resizeContainer'};}}],[{key:'info',get:function get(){return{version:'3.0.0'};}}]);return Comparer;}(_component2.default);exports.default=Comparer;

},{"app":"app","veams/src/js/common/component":30}],46:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * Represents a button with custom click handlers.
 *
 * @module CTA
 * @version v3.0.2
 *
 * @author Sebastian Fitzner
 * @author Andy Gutsche
 *//**
 * Requirements
 */var $=_app.Veams.$;var CTA=function(_VeamsComponent){_inherits(CTA,_VeamsComponent);/**
	 * Constructor for our class
	 *
	 * @see module.js
	 *
	 * @param {Object} obj - Object which is passed to our class
	 * @param {Object} obj.el - element which will be saved in this.el
	 * @param {Object} obj.options - options which will be passed in as JSON object
	 */function CTA(obj){_classCallCheck(this,CTA);var options={activeClass:'is-active',clickHandler:'click',closedLabel:null,ctaContent:'[data-js-item="cta-content"]',globalEvent:'cta:click',openedLabel:null};return _possibleConstructorReturn(this,(CTA.__proto__||Object.getPrototypeOf(CTA)).call(this,obj,options));}/** =================================================
	 * GETTER & SETTER
	 * ================================================ *//**
	 * Get module information
	 */_createClass(CTA,[{key:'initialize',/** =================================================
	 * STANDARD METHODS
	 * ================================================= *//**
	 * Initialize the view and merge options
	 *
	 */value:function initialize(){this.$ctaContent=$(this.options.ctaContent,this.$el);if(this.options.closedLabel&&!this.options.openedLabel||!this.options.closedLabel&&this.options.openedLabel){console.warn('CTA: You have to set closedLabel and openedLabel or none.');}else{if(this.options.closedLabel&&this.options.openedLabel&&!this.$ctaContent.length){console.warn('CTA: Labels set, but '+this.options.ctaContent+' not found, please make sure settings.ctaContentJsItem is set to true for c-cta__content.');}}if(this.$el.is('.'+this.options.activeClass)){this.active=true;}}},{key:'render',value:function render(){return this;}/** =================================================
	 * CUSTOM CTA METHODS
	 * ================================================= *//**
	 * Close method
	 *
	 * Remove the active class, set label and trigger global event
	 *
	 * @public
	 */},{key:'close',value:function close(){if(this.options.closedLabel){this.$ctaContent.text(this.options.closedLabel);this.$el.attr('title',this.options.closedLabel);}this.$el.removeClass(this.options.activeClass);this.active=false;}/**
	 * Open method
	 *
	 * Add the active class, set label and trigger global event
	 *
	 * @public
	 */},{key:'open',value:function open(){if(this.options.openedLabel){this.$ctaContent.text(this.options.openedLabel);this.$el.attr('title',this.options.openedLabel);}this.$el.addClass(this.options.activeClass);this.active=true;}/**
	 * Click event method
	 *
	 * This method should be overriden when you want to use the button view
	 * @see button-init.js
	 *
	 * @param {event} e - event object
	 */},{key:'onClick',value:function onClick(e){console.log('ready');e.preventDefault();if(typeof this.clickHandler==='function'){if(this.active){this.close();}else{this.open();}this.clickHandler.apply(this,arguments);}else{console.warn('CTA: You need to inherit from '+this+' and override the onClick method or pass a function to '+this+'.clickHandler !');}}/**
	 * Click handler
	 *
	 * This method is public and can be overridden by
	 * other instances to support a generic button module
	 *
	 * @public
	 */},{key:'clickHandler',value:function clickHandler(){_app.Veams.Vent.trigger(this.options.globalEvent,{el:this.el,isActive:this.active,options:this.options});}},{key:'active',/**
	 * Get and set the active state.
	 *
	 * @param {boolean} state - active state
	 */get:function get(){return this._active;},set:function set(state){this._active=state;}/** =================================================
	 * EVENTS
	 * ================================================ */},{key:'events',get:function get(){return{'{{this.options.clickHandler}}':'onClick'};}}],[{key:'info',get:function get(){return{version:'3.0.2',vc:true,mod:false// set to true if source was modified in project
};}}]);return CTA;}(_component2.default);exports.default=CTA;

},{"app":"app","veams/src/js/common/component":30}],47:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * Represents a ajax form class.
 *
 * @module FormAjax
 * @version v3.0.1
 *
 * @author Sebastian Fitzner
 */var $=_app.Veams.$;var FormAjax=function(_VeamsComponent){_inherits(FormAjax,_VeamsComponent);/**
	 * Constructor for our class
	 *
	 * @see module.js
	 *
	 * @param {Object} obj - Object which is passed to our class
	 * @param {Object} obj.el - element which will be saved in this.el
	 * @param {Object} obj.options - options which will be passed in as JSON object
	 */function FormAjax(obj){_classCallCheck(this,FormAjax);var options={submitOnLoad:false,submitOnChange:true,loadingClass:null,successClass:'is-success',errorClass:'is-error',eventName:_app.Veams.EVENTS.form.complete};return _possibleConstructorReturn(this,(FormAjax.__proto__||Object.getPrototypeOf(FormAjax)).call(this,obj,options));}/**
	 * Get module information
	 */_createClass(FormAjax,[{key:'initialize',value:function initialize(){// save some references
this.fields=$('input',this.$el);this.selects=$('select',this.$el);// Fetch data if option is true
if(this.options.submitOnLoad){this.fetchData(this.$el);}// call super
_get(FormAjax.prototype.__proto__||Object.getPrototypeOf(FormAjax.prototype),'initialize',this).call(this);}/**
	 * Bind all evente
	 */},{key:'bindEvents',value:function bindEvents(){var fnFetchData=this.fetchData.bind(this);var fnReset=this.resetFilters.bind(this);/**
		 * On submit event fetch data
		 */this.$el.on(_app.Veams.EVENTS.submit+' '+_app.Veams.EVENTS.reset,fnFetchData);/**
		 * Reset filters on reset event
		 */_app.Veams.Vent.on(_app.Veams.EVENTS.form.reset,fnReset);/**
		 * If submitOnChange is true
		 *
		 * fetch data
		 * show reset button
		 *
		 */if(this.options.submitOnChange){this.$el.on(_app.Veams.EVENTS.blur+' '+_app.Veams.EVENTS.change,this.fields,fnFetchData);}}/**
	 * Ajax call to get data object with results or error message.
	 *
	 * @param {Object} e - object or event.
	 * @param {object} currentTarget - Target to which listener was attached.
	 */},{key:'fetchData',value:function fetchData(e,currentTarget){var _this2=this;var el=void 0;if(e&&typeof e.preventDefault==='function'){e.preventDefault();el=currentTarget||e.currentTarget;}else{el=e;}if(this.options.loadingClass){this.$el.addClass(this.options.loadingClass);}var action=this.$el.attr('action');var method=this.$el.attr('method');var serialize=this.$el.serialize();var url=action+'?'+serialize;$.ajax({url:url,dataType:'json',success:function success(data){_this2.onSuccess(data,el);},error:function error(status,statusText){_this2.onError(status,statusText);}});}},{key:'onSuccess',value:function onSuccess(data,el){this.fields=$('input',this.$el);this.selects=$('select',this.$el);_app.Veams.Vent.trigger(this.options.eventName,{data:data,el:el});if(this.options.loadingClass){this.$el.removeClass(this.options.loadingClass);}this.$el.addClass(this.options.successClass);}},{key:'onError',value:function onError(status,statusText){if(this.options.loadingClass){this.$el.removeClass(this.options.loadingClass);}this.$el.addClass(this.options.errorClass);console.warn('FormAjax:',statusText,'('+status+')');}/**
	 * Reset filters, currently supported
	 *
	 * checkboxes
	 * selects
	 */},{key:'resetFilters',value:function resetFilters(){this.resetChecks();this.resetSelects();}/**
	 * Reset checkboxes
	 */},{key:'resetChecks',value:function resetChecks(){this.fields.each(function(){$(this).prop('checked',false);});}/**
	 * Resest selects
	 */},{key:'resetSelects',value:function resetSelects(){this.selects.each(function(){$(this).prop('selectedIndex',0);});}}],[{key:'info',get:function get(){return{version:'3.0.1',vc:true,mod:false// set to true if source was modified in project
};}}]);return FormAjax;}(_component2.default);// Returns constructor
exports.default=FormAjax;

},{"app":"app","veams/src/js/common/component":30}],48:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * form component datepicker
 *
 * @module FormDatepicker
 * @version v1.0.0
 *
 * @author Sang-In Haetzel
 * @author Sebastian Fitzner
 */require('moment');var $=_app.Veams.$;var Pikaday=require('pikaday');var FormDatepicker=function(_VeamsComponent){_inherits(FormDatepicker,_VeamsComponent);/**
	 * Constructor for our class
	 *
	 * @see module.js
	 *
	 * @param {Object} obj - Object which is passed to our class
	 * @param {Object} obj.el - element which will be saved in this.el
	 * @param {Object} obj.options - options which will be passed in as JSON object
	 */function FormDatepicker(obj){_classCallCheck(this,FormDatepicker);var options={};return _possibleConstructorReturn(this,(FormDatepicker.__proto__||Object.getPrototypeOf(FormDatepicker)).call(this,obj,options));}/**
	 * Get module information
	 */_createClass(FormDatepicker,[{key:'initialize',/**
	 * Initialize class
	 */value:function initialize(){var i18n=_app.Veams.i18n&&_app.Veams.i18n.datepicker?_app.Veams.i18n.datepicker:this.i18nFallback;var _this=this;this.$input=$('input',this.$el);this.dateFormat=i18n.calendarFormat;this.datetimepicker=new Pikaday({field:this.$input[0],i18n:i18n,container:this.el,onSelect:function onSelect(){_this.date=this.getMoment().format(_this.dateFormat);_this.$input.val(_this.date);}});}},{key:'date',/**
	 * GETTERS AND SETTERS
	 *//**
	 * Get and set date
	 *//**
	 * Date
	 */set:function set(date){this._date=date;this.datetimepicker.setDate(this._date,true);},get:function get(){return this._date;}/**
	 * i18n
	 */},{key:'i18nFallback',get:function get(){return{previousMonth:'Previous Month',nextMonth:'Next Month',months:['January','February','March','April','May','June','July','August','September','October','November','December'],weekdays:['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],weekdaysShort:['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],calendarFormat:'DD.MM.YYYY'};}}],[{key:'info',get:function get(){return{name:'FormDatepicker',version:'1.0.0'};}}]);return FormDatepicker;}(_component2.default);// Returns constructor
exports.default=FormDatepicker;

},{"app":"app","moment":20,"pikaday":21,"veams/src/js/common/component":30}],49:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * Represents an overlay module.
 *
 * This module is responsible to create an overlay
 * without predefining any inner overlay template.
 *
 * It should be used by other modules
 * to display their content in an overlay.
 *
 * @module Overlay
 * @version v3.0.0
 *
 * @author Sebastian Fitzner
 */var $=_app.Veams.$;var Template=_app.Veams.templater.templates;var Overlay=function(_VeamsComponent){_inherits(Overlay,_VeamsComponent);/**
	 * Constructor for our class
	 *
	 * @see module.js
	 *
	 * @param {Object} obj - Object which is passed to our class
	 * @param {Object} obj.el - element which will be saved in this.el
	 * @param {Object} obj.options - options which will be passed in as JSON object
	 */function Overlay(obj){_classCallCheck(this,Overlay);var options={openClass:'is-open',closeBtn:'[data-js-item="overlay-close"]',overlay:'[data-js-item="overlay"]',regionContent:'[data-js-item="overlay-content"]',template:Template['OVERLAY']};return _possibleConstructorReturn(this,(Overlay.__proto__||Object.getPrototypeOf(Overlay)).call(this,obj,options));}/** =================================================
	 * GETTER & SETTER
	 * ================================================ *//**
	 * Get module information
	 */_createClass(Overlay,[{key:'bindEvents',/**
	 * Bind global events
	 *
	 * Listen to open and close events
	 */value:function bindEvents(){var _this2=this;// Close overlay with ESC
$(window).on(_app.Veams.EVENTS.keyup,function(e){if(e.keyCode==27&&_this2.isOpen){_this2.close();}});}/**
	 * Bind local events
	 */},{key:'bindLocalEvents',value:function bindLocalEvents(){var fnClose=this.close.bind(this);// Local events
this.$closeBtn.on(_app.Veams.EVENTS.click,fnClose);}/** =================================================
	 * STANDARD METHODS
	 * ================================================= *//**
	 * Initialize the view and merge options
	 *
	 */},{key:'initialize',value:function initialize(){this.$body=$('body');this.template=this.options.template;}/**
	 * Pre-Render the overlay and save references
	 */},{key:'preRender',value:function preRender(){// Append FE template
this.$body.append(this.template());// Set some references
this.$overlay=$(this.options.overlay);this.$closeBtn=$(this.options.closeBtn,this.$overlay);this.$regionContent=$(this.options.regionContent,this.$overlay);this.overlayCreated=true;this.bindLocalEvents();}/**
	 * Render the overlay
	 */},{key:'render',value:function render(obj){var data=obj.data||obj.options&&obj.options.data;// Check if data object is provided
if(!data){console.warn('Overlay: You have to provide an object with data (obj.data || obj.options.data)!');return;}// Append data to overlay region
this.$regionContent.html(data);// Open overlay
this.open();}/** =================================================
	 * CUSTOM OVERLAY METHODS
	 * ================================================= *//**
	 * Open Overlay
	 */},{key:'open',value:function open(){this.$overlay.addClass(this.options.openClass);this.isOpen=true;}/**
	 * Close overlay
	 */},{key:'close',value:function close(){this.$overlay.removeClass(this.options.openClass);this.isOpen=false;}},{key:'template',// set and get overlay template
get:function get(){return this._template;},set:function set(tpl){this._template=tpl;}// set and get infos if overlay is created
},{key:'overlayCreated',get:function get(){return this._overlayCreated;},set:function set(bol){this._overlayCreated=bol;}// set and get infos if overlay is open
},{key:'isOpen',get:function get(){return this._isOpen;},set:function set(bol){this._isOpen=bol;}// set and get overlay element after creation
},{key:'$overlay',get:function get(){return this._$overlay;},set:function set(el){this._$overlay=el;}// set and get close button after creation
},{key:'$closeBtn',get:function get(){return this._$closeBtn;},set:function set(el){this._$closeBtn=el;}// set and get content region
},{key:'$regionContent',get:function get(){return this._$regionContent;},set:function set(el){this._$regionContent=el;}/** =================================================
	 * EVENTS
	 * ================================================ */},{key:'subscribe',get:function get(){return{'{{Veams.EVENTS.overlay.open}}':'render'};}}],[{key:'info',get:function get(){return{version:'3.0.0',vc:true,mod:false// set to true if source was modified in project
};}}]);return Overlay;}(_component2.default);exports.default=Overlay;

},{"app":"app","veams/src/js/common/component":30}],50:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);var _isInViewport=require('veams/src/js/utils/helpers/is-in-viewport');var _isInViewport2=_interopRequireDefault(_isInViewport);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * Represents an element that slides into view when it's scrolled into viewport.
 *
 * @module SlideFox
 * @version v3.0.1
 *
 * @author Andy Gutsche
 * @refactoring Sebastian Fitzner
 */var $=_app.Veams.$;var Helpers=_app.Veams.helpers;var SlideFox=function(_VeamsComponent){_inherits(SlideFox,_VeamsComponent);/**
	 * Constructor for our class
	 *
	 * @see module.js
	 *
	 * @param {Object} obj - Object which is passed to our class
	 * @param {Object} obj.el - element which will be saved in this.el
	 * @param {Object} obj.options - options which will be passed in as JSON object
	 */function SlideFox(obj){_classCallCheck(this,SlideFox);var options={visibleClass:'is-visible'};return _possibleConstructorReturn(this,(SlideFox.__proto__||Object.getPrototypeOf(SlideFox)).call(this,obj,options));}/** =================================================
	 * GETTER & SETTER
	 * ================================================ *//**
	 * Get module information
	 */_createClass(SlideFox,[{key:'render',// bindEvents() {
// 	let fnRender = this.render.bind(this);
//
// 	$(window).on('scroll', fnRender);
// }
/** =================================================
	 * STANDARD METHODS
	 * ================================================= */value:function render(){console.log('initalized');(0,_isInViewport2.default)(this.el)?this.showSlideFox():this.hideSlideFox();}/** =================================================
	 * CUSTOM SLIDEFOX METHODS
	 * ================================================= */},{key:'showSlideFox',value:function showSlideFox(){this.$el.addClass(this.options.visibleClass);}},{key:'hideSlideFox',value:function hideSlideFox(){this.$el.removeClass(this.options.visibleClass);}},{key:'subscribe',/** =================================================
	 * EVENTS
	 * ================================================ */get:function get(){return{'{{Veams.EVENTS.scroll}}':'render'};}}],[{key:'info',get:function get(){return{version:'3.0.1',vc:true,mod:false// set to true if source was modified in project
};}}]);return SlideFox;}(_component2.default);// Returns the constructor
exports.default=SlideFox;

},{"app":"app","veams/src/js/common/component":30,"veams/src/js/utils/helpers/is-in-viewport":33}],51:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);var _transitionEndEvent=require('veams/src/js/utils/helpers/transition-end-event');var _transitionEndEvent2=_interopRequireDefault(_transitionEndEvent);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * Represents a responsive slider which can be used as ribbon.
 *
 * @module Slider
 * @version v3.0.3
 *
 * @author Sebastian Fitzner
 * @author Andy Gutsche
 */var $=_app.Veams.$;var Helpers=_app.Veams.helpers;var Slider=function(_VeamsComponent){_inherits(Slider,_VeamsComponent);/**
	 * Constructor for our class
	 *
	 * @see module.js
	 *
	 * @param {Object} obj - Object which is passed to our class
	 * @param {Object} obj.el - element which will be saved in this.el
	 * @param {Object} obj.options - options which will be passed in as JSON object
	 */function Slider(obj){_classCallCheck(this,Slider);var options={activeClass:'is-active',// Active class for slides and pagination items
actions:'[data-js-item="slider-actions"]',// Previous Button
autoPlay:false,// Enable autoplay
autoPlayInterval:4800,// Autoplay intervall in milliseconds
cloneClass:'is-cloned',// Clone class for cloned items (only used with infinite)
disablePagination:false,// Disable pagination display
enableTouchSwipe:true,// Enable/Disable swipe support
groupPaginationItems:false,// Group the pagination elements (useful for multiple visible items)
hiddenClass:'is-hidden',// hidden class for pagination
infinite:false,// Infinite looping (only possible without multiple visible items)
items:'[data-js-item="slider-item"]',// Slide Items
next:'[data-js-item="slider-next"]',// Next Button
prev:'[data-js-item="slider-prev"]',// Previous Button
pagination:'[data-js-item="slider-pagination"]',// Pagination
paginationItemClass:'slider__pagination-list-item',// Define your class which we use in our mini tmpl
paginationItemJsItem:'slider-pagination-item',// data-js-item for pagination list item
paginationList:'[data-js-item="slider-pagination-list"]',// Pagination List
ribbon:'[data-js-item="slider-ribbon"]',// Ribbon element
pauseOnHover:true,// Used when options.autoPlay is true
slideByItemNumber:false,// Use the option to override the initial slide step
startAtIndex:0,// Start at a different index
unresolvedClass:'is-unresolved',// Unresolved class which gets removed when initialized
visibleItems:{// Visible items per viewport
'desktop':1,'tablet-large':1,'tablet-small':1,'mobile-large':1,'mobile-medium':1,'mobile-small':1},wrapper:'[data-js-item="slider-wrapper"]'// Wrapper element
};return _possibleConstructorReturn(this,(Slider.__proto__||Object.getPrototypeOf(Slider)).call(this,obj,options));}/**
	 * Custom getters and setter
	 *//**
	 * Get module information
	 */_createClass(Slider,[{key:'bindEvents',/**
	 * Bind all events
	 */value:function bindEvents(){if(this.autoPlay&&this.options.pauseOnHover){this.registerEvent('{{Veams.EVENTS.mouseenter}}','pause');this.registerEvent('{{Veams.EVENTS.mouseleave}}','play');}}/**
	 * Unbind all events
	 */},{key:'unbindEvents',value:function unbindEvents(){// Global Events
_app.Veams.Vent.off(_app.Veams.EVENTS.resize);// Local Events
this.$el.off(_app.Veams.clickHandler);}/** =================================================
	 * STANDARD METHODS
	 * ================================================= *//**
	 * Initialize the view
	 */},{key:'initialize',value:function initialize(){this.index=0;this.$prev=this.$el.find(this.options.prev);this.$next=this.$el.find(this.options.next);this.$items=this.$el.find(this.options.items);this.$initialItems=this.$items;this.$wrapper=this.$el.find(this.options.wrapper);this.$ribbon=this.$el.find(this.options.ribbon);this.startAtIndex=~~this.options.startAtIndex;this.$lastItem=this.$items.eq(this.$items.length-1);this.$firstItem=this.$items.eq(0);this.transition=this.$ribbon.css('transition');this.paginationDisabled=this.options.disablePagination||this.$items.length<2;this.infinite=this.options.infinite&&this.$items.length>1;this.touchSwipeEnabled=false;this.clickHandler=true;this.autoPlay=this.options.autoPlay&&this.infinite;this.paginationItemSel='[data-js-item="'+this.options.paginationItemJsItem+'"]';if(!this.paginationDisabled){this.$paginationList=this.$el.find(this.options.paginationList);}if(this.options.autoPlay&&!this.infinite){console.warn('Slider: Sorry - option "autoPlay" has no effect while option "infinite" is set to false!');}if(this.infinite){for(var item in this.options.visibleItems){if(this.options.visibleItems.hasOwnProperty(item)){if(this.options.visibleItems[item]>1){console.warn('Slider: Sorry - option "visibleItems" has no effect while option "infinite" is set to true!');break;}}}}}/**
	 * Renders the view's template to the UI
	 */},{key:'render',value:function render(){if(!_app.Veams.currentMedia){console.warn('Slider: Veams.currentMedia is necessary to support the slider module!');return;}if(this.$clonedLast&&this.$clonedFirst){this.$clonedLast.remove();this.$clonedFirst.remove();this.$items=this.$initialItems;}this.visibles=this.infinite?1:this.options.visibleItems[_app.Veams.currentMedia];this.itemsLength=this.$items.length;this.handleVisibility();if(!this.paginationDisabled){this.removePagination();this.addPagination();}if(this.infinite){this.infiniteLoop();}this.bindTransitions();this.getAndSetDimensions();if(_app.Veams.detections.touch&&this.options.enableTouchSwipe&&!this.touchSwipeEnabled){this.bindSwipes();}if(this.infinite){this.goToItem(this.startAtIndex+this.visibles);}else{this.goToItem(this.startAtIndex);}if(this.autoPlay&&this.paused){this.play();}}/** =================================================
	 * CUSTOM SLIDER METHODS
	 * ================================================= *//**
	 * Bind transition events
	 *
	 */},{key:'bindTransitions',value:function bindTransitions(){var onRibbonTransitionEnd=this.onRibbonTransitionEnd.bind(this);var onItemsTransitionEnd=this.onItemsTransitionEnd.bind(this);this.$ribbon.on((0,_transitionEndEvent2.default)(),onRibbonTransitionEnd);this.$items.on((0,_transitionEndEvent2.default)(),onItemsTransitionEnd);}/**
	 * React to transitionend on ribbon
	 *
	 * @param {Object} e - Event object.
	 */},{key:'onRibbonTransitionEnd',value:function onRibbonTransitionEnd(e){e.stopPropagation();if(this.autoPlay&&this.paused){if(this.options.pauseOnHover){if(!this.$el.is(':hover')){this.play();}}else{this.play();}}if(this.$clonedFirst&&this.$clonedFirst.hasClass(this.options.activeClass)){this.$clonedFirst.removeClass(this.options.activeClass);this.index=1;this.animateSlide({idx:this.index,animate:false});}if(this.$clonedLast&&this.$clonedLast.hasClass(this.options.activeClass)){this.$clonedLast.removeClass(this.options.activeClass);this.index=this.$items.length-this.visibles-1;this.animateSlide({idx:this.index,animate:false});}this.clickHandler=true;}/**
	 * React to transitionend on items
	 *
	 * @param {Object} e - Event object.
	 */},{key:'onItemsTransitionEnd',value:function onItemsTransitionEnd(e){e.stopPropagation();}/**
	 * Clone first and last element
	 *
	 */},{key:'infiniteLoop',value:function infiniteLoop(){this.$clonedFirst=this.$firstItem.clone(true).addClass(this.options.cloneClass);this.$clonedLast=this.$lastItem.clone(true).addClass(this.options.cloneClass);if(this.options.infinite){this.$clonedFirst.find(this.paginationItemSel).attr('data-index',this.itemsLength);this.$clonedLast.find(this.paginationItemSel).attr('data-index',-1);}this.$firstItem.before(this.$clonedLast);this.$lastItem.after(this.$clonedFirst);this.$items=$(this.options.items,this.$el);}/**
	 * Animate slide
	 *
	 * @param {Object} obj - animation property object.
	 */},{key:'animateSlide',value:function animateSlide(obj){if(!obj.animate){this.$ribbon.css('transition','none');}else{this.$ribbon.css('transition',this.transition);}this.$ribbon.css('left',-obj.idx*this.thumbWidth+'px');}/**
	 * Check first/last slide classes
	 *
	 */},{key:'checkSlides',value:function checkSlides(){if(this.$clonedFirst.hasClass(this.options.activeClass)){this.$firstItem.addClass(this.options.activeClass);}if(this.$clonedLast.hasClass(this.options.activeClass)){this.$lastItem.addClass(this.options.activeClass);}}/**
	 * When items length is 0 we hide this view.
	 */},{key:'handleVisibility',value:function handleVisibility(){if(this.itemsLength===0){this.$el.addClass(this.options.hiddenClass);console.warn('Slider: There is no item we can use in our slider :(');}this.$el.css('max-width','none');}/**
	 * Empty pagination.
	 */},{key:'removePagination',value:function removePagination(){this.$paginationList.empty();}/**
	 * Add pagination elements with a simple string template and
	 * save a pagination item reference.
	 */},{key:'addPagination',value:function addPagination(){var tmpl='';var i=0;var item=this.options.paginationItemJsItem;var itemClass=this.options.paginationItemClass;for(i;i<this.$items.length;i++){var idx=i+1;var hiddenClass='';if(this.options.groupPaginationItems){hiddenClass=i%this.visibles===0?'':this.options.hiddenClass;}tmpl+='\n\t\t\t\t\t<li class="'+itemClass+' '+hiddenClass+'" data-js-item="'+item+'" data-index="'+i+'">\n\t\t\t\t\t\t<strong>'+idx+'</strong>\n\t\t\t\t\t</li>\n\t\t\t\t\t';}this.$paginationList.append(tmpl);this.$paginationItems=$('[data-js-item="'+this.options.paginationItemJsItem+'"]',this.$el);}/**
	 * Navigate to a specific slide.
	 *
	 * @param {object} e - Event object.
	 * @param {object} currentTarget - Target to which listener was attached.
	 */},{key:'navigateToElement',value:function navigateToElement(e,currentTarget){var $currentTarget=currentTarget?$(currentTarget):$(e.currentTarget);if($currentTarget.hasClass(this.options.activeClass)){return;}var idx=parseInt($currentTarget.attr('data-index'),10)||$currentTarget.index();if(this.infinite){idx=idx+this.slideBy;}this.goToItem(idx);}/**
	 * Go to the next slide.
	 *
	 * @param {object} e - Event object.
	 * @param {object} currentTarget - Target to which listener was attached.
	 */},{key:'showNextElement',value:function showNextElement(e,currentTarget){var $currentTarget=currentTarget?$(currentTarget):$(e.currentTarget);if(e&&typeof e.preventDefault==='function'){e.preventDefault();}if($currentTarget.prop('disabled')){return;}if(this.clickHandler){this.goToItem(this.index+this.slideBy);this.clickHandler=false;}}/**
	 * Go to the previous slide.
	 *
	 * @param {object} e - Event object.
	 * @param {object} currentTarget - Target to which listener was attached.
	 */},{key:'showPrevElement',value:function showPrevElement(e,currentTarget){var $currentTarget=currentTarget?$(currentTarget):$(e.currentTarget);if(e&&typeof e.preventDefault==='function'){e.preventDefault();}if($currentTarget.prop('disabled')){return;}if(this.clickHandler){this.goToItem(this.index-this.slideBy);this.clickHandler=false;}}/**
	 * Return the direction `next` or `prev`.
	 *
	 * @param {number} index - Index of the pagination element.
	 */},{key:'getDirection',value:function getDirection(index){return index>this.index?"next":"prev";}/**
	 * Bind all swipe gestures.
	 */},{key:'bindSwipes',value:function bindSwipes(){var _this2=this;if(this.$items.length>this.visibles){Helpers.detectSwipe(this.el,75);this.$el.on(_app.Veams.EVENTS.swipe,function(e){var direction=e.detail.direction;if(direction==='left'){_this2.goToItem(_this2.index+_this2.visibles);}if(direction==='right'){_this2.goToItem(_this2.index-_this2.visibles);}});this.touchSwipeEnabled=true;}}/**
	 * Enables button
	 *
	 * @param {Object} $btn - button element.
	 */},{key:'enableBtn',value:function enableBtn($btn){$btn.removeClass(this.options.hiddenClass);$btn.prop('disabled',false);$btn.removeAttr('aria-disabled');}/**
	 * Disables button
	 *
	 * @param {Object} $btn - button element.
	 */},{key:'disableBtn',value:function disableBtn($btn){$btn.addClass(this.options.hiddenClass);$btn.prop('disabled',true);$btn.attr('aria-disabled',true);}/**
	 * Handles the method to go to a specific item.
	 * Further we handle the class
	 *
	 * @param {number} i - Index number.
	 */},{key:'goToItem',value:function goToItem(i){var maxIndex=this.$items.length-this.visibles;if(maxIndex<0){maxIndex=0;}if(!this.paused){this.pause();}if(this.infinite){if(i<0){i=maxIndex;}else if(i>maxIndex){i=0;}}else{this.enableBtn(this.$prev);this.enableBtn(this.$next);if(i<1){this.disableBtn(this.$prev);if(i<0){i=0;}}if(i>maxIndex-1){this.disableBtn(this.$next);if(i>maxIndex){i=maxIndex;}}}this.animateSlide({idx:i,animate:!this.$el.hasClass(this.options.unresolvedClass)});if(this.$el.hasClass(this.options.unresolvedClass)){this.$el.removeClass(this.options.unresolvedClass);}this.index=i;this.handleActivity();if(this.infinite){this.checkSlides();}}},{key:'handleActivity',value:function handleActivity(){this.$items.removeClass(this.options.activeClass);if(!this.paginationDisabled&&this.$paginationItems&&this.$paginationItems.length){this.$paginationItems.removeClass(this.options.activeClass);}// If this slider instance isn't infinite
if(!this.infinite){for(var idx=this.index;idx<this.index+this.visibles;idx++){// First set active slide element(s)
this.$items.eq(idx).addClass(this.options.activeClass);// Do that also for pagination element(s)
if(!this.paginationDisabled){this.$paginationItems.eq(idx).addClass(this.options.activeClass);}}}else{for(var _idx=this.index-1;_idx<this.index-1+this.visibles;_idx++){var slideIdx=_idx;this.$items.eq(slideIdx+1).addClass(this.options.activeClass);if(!this.paginationDisabled){if(_idx>=this.$paginationItems.length){slideIdx=0;}if(_idx<0){slideIdx=this.$paginationItems.length-1;}this.$paginationItems.eq(slideIdx).addClass(this.options.activeClass);}}}}/**
	 * Start autoplay.
	 */},{key:'play',value:function play(){var _this3=this;clearInterval(this.autoPlayInterval);this.autoPlayInterval=setInterval(function(){_this3.goToItem(_this3.index+_this3.visibles);},this.options.autoPlayInterval);this.paused=false;}/**
	 * Pause autoplay.
	 */},{key:'pause',value:function pause(){clearInterval(this.autoPlayInterval);this.paused=true;}/**
	 * Get and set dimensions for our project progress.
	 */},{key:'getAndSetDimensions',value:function getAndSetDimensions(){this.resetStyles();this.width=this.$wrapper.outerWidth();this.thumbWidth=this.width/this.visibles;this.$wrapper.css('width',this.width+'px');this.$items.css('width',this.thumbWidth+'px');this.$ribbon.css({width:this.ribbonWidth+'px'});}/**
	 * Reset width styles
	 */},{key:'resetStyles',value:function resetStyles(){this.$wrapper[0].removeAttribute('style');this.$items.removeAttr('style');this.$ribbon.removeAttr('style');}},{key:'visibles',/**
	 * Get and set visible items.
	 *
	 * @param {number} visible - Number of visible items
	 */get:function get(){return this._numVisible;},set:function set(visible){this._numVisible=visible;}/**
	 * Get and set items length for slider.
	 *
	 * @param {number} len - Number of item length
	 */},{key:'itemsLength',get:function get(){return this._itemLength;},set:function set(len){this._itemLength=len;}/**
	 * Get and set the index of slider.
	 *
	 * @param {number} idx - index number of slide
	 */},{key:'index',get:function get(){return this._index;},set:function set(idx){this._index=idx;}/**
	 * Get paused property.
	 *
	 * @param {Boolean} bool - pause state
	 */},{key:'paused',get:function get(){return this._paused;},set:function set(bool){this._paused=bool;}/**
	 * Get autoPlay property.
	 *
	 * @param {Boolean} bool - autoplay state
	 */},{key:'autoPlay',get:function get(){return this._autoPlay;},set:function set(bool){this._autoPlay=bool;}/**
	 * Get controls height.
	 */},{key:'controlHeight',get:function get(){return Helpers.getOuterHeight(this.$prev);}/**
	 * Return the defined option or current visible items
	 * which will be used for the next and previous slide animation.
	 */},{key:'slideBy',get:function get(){return this.options.slideByItemNumber||this.visibles;}/**
	 * Get ribbon width.
	 */},{key:'ribbonWidth',get:function get(){return this.$items.length*this.thumbWidth;}/** =================================================
	 * EVENTS
	 * ================================================ *//**
	 * Bind local events to this.$el.
	 */},{key:'events',get:function get(){return{'click {{this.options.prev}}':'showPrevElement','touchstart {{this.options.prev}}':'showPrevElement','click {{this.options.next}}':'showNextElement','touchstart {{this.options.next}}':'showNextElement','click {{this.paginationItemSel}}':'navigateToElement','touchstart {{this.paginationItemSel}}':'navigateToElement'};}/**
	 * Subscribe to global events of Veams or App namespace.
	 */},{key:'subscribe',get:function get(){return{'{{Veams.EVENTS.resize}}':'render'};}}],[{key:'info',get:function get(){return{version:'3.0.3',vc:true,mod:false};}}]);return Slider;}(_component2.default);exports.default=Slider;

},{"app":"app","veams/src/js/common/component":30,"veams/src/js/utils/helpers/transition-end-event":37}],52:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * Represents a simple toggler with global event binding.
 *
 * @module Toggler
 * @version v3.0.3
 *
 * @author Andy Gutsche
 */// Global dependencies
var $=_app.Veams.$;var Helpers=_app.Veams.helpers;var Toggler=function(_VeamsComponent){_inherits(Toggler,_VeamsComponent);/**
	 * Constructor for our class
	 *
	 * @see module.js
	 *
	 * @param {Object} obj - Object which is passed to our class
	 * @param {Object} obj.el - element which will be saved in this.el
	 * @param {Object} obj.options - options which will be passed in as JSON object
	 */function Toggler(obj){_classCallCheck(this,Toggler);var options={a11yFocusKeyClass:'a11y-focus-key',calculatingClass:'is-calculating',closeClass:'is-closed',context:false,dataMaxAttr:'data-js-height',globalEvent:'',globalEventId:'',openClass:'is-open',setOverflow:false,toggleTabindexElems:''};return _possibleConstructorReturn(this,(Toggler.__proto__||Object.getPrototypeOf(Toggler)).call(this,obj,options));}/**
	 * Get module information
	 */_createClass(Toggler,[{key:'initialize',/**
	 * Initialize the view and merge options
	 *
	 */value:function initialize(){var _this2=this;var selfInit=this.$el.attr('data-js-module')&&this.$el.attr('data-js-module').indexOf('toggler')>-1;if(selfInit&&!this.options.globalEvent){console.info('Toggler: this.options.globalEvent not set.');}this.isOpen=this.$el.hasClass(this.options.openClass);this.calculateHeight().then(function(){if(!_this2.isOpen){_this2.setHeight(0);}});}/**
	 * Bind events
	 *
	 * Listen to open and close events
	 */},{key:'bindEvents',value:function bindEvents(){// Global events
if(this.options.globalEvent){this.registerEvent('{{this.options.globalEvent}}','toggle',true);}}/**
	 * handle on resize event
	 *
	 * close the toggler
	 *
	 */},{key:'onResize',value:function onResize(){var _this3=this;// give browser some tie to recalculate
setTimeout(function(){_this3.calculateHeight().then(function(){_this3.setHeight();});},200);}/**
	 * Enable calc mode.
	 *
	 * @private
	 */},{key:'enableCalcMode',value:function enableCalcMode(){if(!this.isOpen){this.$el.addClass(this.options.openClass);this.$el.removeClass(this.options.closeClass);}this.$el.addClass(this.options.calculatingClass);}/**
	 * Disable calc mode.
	 *
	 * @private
	 */},{key:'disableCalcMode',value:function disableCalcMode(){this.$el.removeClass(this.options.calculatingClass);if(!this.isOpen){this.$el.addClass(this.options.closeClass);this.$el.removeClass(this.options.openClass);}else{this.setHeight();}}/**
	 * Set height of current view element to given value or latest calculated value.
	 *
	 * @private
	 * @param {Number} [height] - height
	 */},{key:'setHeight',value:function setHeight(height){this.$el.css('height',typeof height==='number'?height+'px':this.$el.attr(this.options.dataMaxAttr)+'px');}/**
	 * Calc the height of current view element.
	 *
	 * @private
	 */},{key:'calcHeight',value:function calcHeight(){var _this4=this;return new Promise(function(resolve,reject){setTimeout(function(){var wantedHeight=_this4.$el.outerHeight();_this4.$el.attr(_this4.options.dataMaxAttr,wantedHeight);_this4.height=wantedHeight!==_this4.height?wantedHeight:_this4.height;resolve();},10);});}/**
	 * Save all styles from current view element
	 *
	 * @private
	 */},{key:'saveStyles',value:function saveStyles(){this.savedStyles=this.$el.attr('style');}/**
	 * Restore all styles from current view element
	 *
	 * @private
	 */},{key:'restoreStyles',value:function restoreStyles(){this.$el.attr('style',this.savedStyles);delete this.savedStyles;}/**
	 * Toggles content
	 *
	 * @public
	 *
	 * @param {Object} obj - the event data
	 * @param {Boolean} obj.isActive - indicates if panel should open or close itself
	 * @param {String} obj.options.setFocus - element to set focus on open
	 */},{key:'toggle',value:function toggle(obj){//console.log('obj', obj);
// if globalEventId is set on both (cta and toggler)
if(this.options.globalEventId&&obj.options&&obj.options.globalEventId){// stop here if global event id don't match
if(this.options.globalEventId!==obj.options.globalEventId){return;}}if(obj.isActive){this.open(obj);}else{this.close();}}/**
	 * Open current view element
	 *
	 * @public
	 *
	 * @param {Object} [obj] - the event object
	 * @param {Boolean} [obj.isActive] - indicates if panel should open or close itself
	 * @param {String} [obj.options.setFocus] - element to set focus on open
	 */},{key:'open',value:function open(obj){var _this5=this;this.$el.css('height',this.$el.attr(this.options.dataMaxAttr)+'px').attr('aria-hidden',false).removeClass(this.options.closeClass).addClass(this.options.openClass);if(obj&&obj.focusEl){this.$el.on(Helpers.transitionEndEvent(),function(){obj.focusEl.focus();_this5.$el.off(Helpers.transitionEndEvent());});}_app.Veams.Vent.trigger(_app.Veams.EVENTS.toggler.open,{context:this.options.context});if(this.options.setOverflow){this.$el.on(Helpers.transitionEndEvent(),function(){_this5.$el.css('overflow','visible');_this5.$el.off(Helpers.transitionEndEvent());});}if(this.options.toggleTabindexElems){$(this.options.toggleTabindexElems,this.el).attr('tabindex',0);}this.isOpen=true;}/**
	 * Close current view element
	 *
	 * @public
	 */},{key:'close',value:function close(){this.$el.css('height',0).removeAttr('style').attr('aria-hidden','true').removeClass(this.options.openClass).addClass(this.options.closeClass);if(this.options.setOverflow){this.$el.css('overflow','hidden');}if(this.options.toggleTabindexElems){$(this.options.toggleTabindexElems,this.el).attr('tabindex',-1);}this.isOpen=false;}/**
	 * calculateHeight class
	 */},{key:'calculateHeight',value:function calculateHeight(){var _this6=this;return new Promise(function(resolve,reject){if(_this6.el&&_this6.el.hasAttribute('style')){_this6.saveStyles();}_this6.enableCalcMode(true);_this6.calcHeight().then(function(){if(_this6.savedStyles){_this6.restoreStyles();}_this6.disableCalcMode();resolve();});});}},{key:'height',get:function get(){return this._height;},set:function set(height){this._height=height;}},{key:'isOpen',get:function get(){return this._isOpen;},set:function set(bool){this._isOpen=bool;}/**
	 * Get global events
	 *
	 */},{key:'subscribe',get:function get(){return{'{{Veams.EVENTS.resize}}':'onResize'};}}],[{key:'info',get:function get(){return{version:'3.0.3',vc:true,mod:false// set to true if source was modified in project
};}}]);return Toggler;}(_component2.default);exports.default=Toggler;

},{"app":"app","veams/src/js/common/component":30}],"app":[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});exports.Veams=exports.App=undefined;var _jquery=require('jquery');var _jquery2=_interopRequireDefault(_jquery);var _veams=require('veams');var _veams2=_interopRequireDefault(_veams);var _veamsPluginLogger=require('veams-plugin-logger');var _veamsPluginLogger2=_interopRequireDefault(_veamsPluginLogger);var _veamsPluginDom=require('veams-plugin-dom');var _veamsPluginDom2=_interopRequireDefault(_veamsPluginDom);var _veamsPluginVent=require('veams-plugin-vent');var _veamsPluginVent2=_interopRequireDefault(_veamsPluginVent);var _veamsPluginModules=require('veams-plugin-modules');var _veamsPluginModules2=_interopRequireDefault(_veamsPluginModules);var _veamsPluginMediaQueryHandler=require('veams-plugin-media-query-handler');var _veamsPluginMediaQueryHandler2=_interopRequireDefault(_veamsPluginMediaQueryHandler);var _veamsPluginTemplater=require('veams-plugin-templater');var _veamsPluginTemplater2=_interopRequireDefault(_veamsPluginTemplater);var _events=require('./events');var _events2=_interopRequireDefault(_events);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// Global dependencies 
var Handlebars=require('handlebars/runtime');var Templates=require('./templates/templates');// import VeamsStore from 'veams-plugin-store';
// Trigger global resize event
window.onscroll=_veams2.default.helpers.throttle(function(e){_veams2.default.Vent.trigger(_veams2.default.EVENTS.scroll,e);},200);var App={};App.$=_jquery2.default;// Versioning
App.version="0.0.1";// Veams
_veams2.default.onInitialize(function(){/**
	* Veams Plugins
	*/// Dom Plugin
_veams2.default.use(_veamsPluginDom2.default,{DOM:_jquery2.default});// Vent Plugin
_veams2.default.use(_veamsPluginVent2.default,{furtherEvents:_events2.default});_veams2.default.use(_veamsPluginTemplater2.default,{templates:Templates,engine:Handlebars});// Logger Plugin for devmode and logger
_veams2.default.use(_veamsPluginLogger2.default);// Module System Plugin
_veams2.default.use(_veamsPluginModules2.default,{useMutationObserver:true,internalCacheOnly:false});// Store Plugin
// Veams.use(VeamsStore, {
// 	reducer: rootReducer,
// 	state: INITIAL_STATE,
// 	subjects: subjects
// });
// Media Query Handler Plugin
_veams2.default.use(_veamsPluginMediaQueryHandler2.default);});exports.App=App;exports.Veams=_veams2.default;

},{"./events":41,"./templates/templates":43,"handlebars/runtime":19,"jquery":"jquery","veams":28,"veams-plugin-dom":22,"veams-plugin-logger":23,"veams-plugin-media-query-handler":24,"veams-plugin-modules":25,"veams-plugin-templater":26,"veams-plugin-vent":27}]},{},[42])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy5ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2RlY29yYXRvcnMuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9kZWNvcmF0b3JzL2lubGluZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2V4Y2VwdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2Jsb2NrLWhlbHBlci1taXNzaW5nLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9lYWNoLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9oZWxwZXItbWlzc2luZy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvaWYuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2xvZy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvbG9va3VwLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy93aXRoLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvbG9nZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9uby1jb25mbGljdC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9zYWZlLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3Bpa2FkYXkvcGlrYWRheS5qcyIsIm5vZGVfbW9kdWxlcy92ZWFtcy1wbHVnaW4tZG9tL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWFtcy1wbHVnaW4tbG9nZ2VyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWFtcy1wbHVnaW4tbWVkaWEtcXVlcnktaGFuZGxlci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmVhbXMtcGx1Z2luLW1vZHVsZXMvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlYW1zLXBsdWdpbi10ZW1wbGF0ZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlYW1zLXBsdWdpbi12ZW50L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWFtcy9saWIvdmVhbXMuanMiLCJub2RlX21vZHVsZXMvdmVhbXMvc3JjL2pzL2NvbW1vbi9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3ZlYW1zL3NyYy9qcy9jb21tb24vY29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3ZlYW1zL3NyYy9qcy91dGlscy9oZWxwZXJzL2RlZmF1bHRzLmpzIiwibm9kZV9tb2R1bGVzL3ZlYW1zL3NyYy9qcy91dGlscy9oZWxwZXJzL2V4dGVuZC5qcyIsIm5vZGVfbW9kdWxlcy92ZWFtcy9zcmMvanMvdXRpbHMvaGVscGVycy9pcy1pbi12aWV3cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy92ZWFtcy9zcmMvanMvdXRpbHMvaGVscGVycy9tYWtlLWlkLmpzIiwibm9kZV9tb2R1bGVzL3ZlYW1zL3NyYy9qcy91dGlscy9oZWxwZXJzL21ldGhvZC1leHRlbmQuanMiLCJub2RlX21vZHVsZXMvdmVhbXMvc3JjL2pzL3V0aWxzL2hlbHBlcnMvbWl4aW4uanMiLCJub2RlX21vZHVsZXMvdmVhbXMvc3JjL2pzL3V0aWxzL2hlbHBlcnMvdHJhbnNpdGlvbi1lbmQtZXZlbnQuanMiLCJub2RlX21vZHVsZXMvdmVhbXMvc3JjL2pzL3V0aWxzL2ludGVybmFsLWhlbHBlcnMvZ2V0LXN0cmluZy12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWFtcy9zcmMvanMvdXRpbHMvaW50ZXJuYWwtaGVscGVycy9zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvdmVhbXMvc3JjL2pzL3V0aWxzL2ludGVybmFsLWhlbHBlcnMvdGVtcGxhdGUtZW5naW5lLmpzIiwicmVzb3VyY2VzL2pzL2V2ZW50cy5qcyIsInJlc291cmNlcy9qcy9tYWluLmpzIiwicmVzb3VyY2VzL2pzL3RlbXBsYXRlcy90ZW1wbGF0ZXMuanMiLCJyZXNvdXJjZXMvdGVtcGxhdGluZy9wYXJ0aWFscy9jb21wb25lbnRzL2FjY29yZGlvbi9qcy9hY2NvcmRpb24uanMiLCJyZXNvdXJjZXMvdGVtcGxhdGluZy9wYXJ0aWFscy9jb21wb25lbnRzL2NvbXBhcmVyL2pzL2NvbXBhcmVyLmpzIiwicmVzb3VyY2VzL3RlbXBsYXRpbmcvcGFydGlhbHMvY29tcG9uZW50cy9jdGEvanMvY3RhLmpzIiwicmVzb3VyY2VzL3RlbXBsYXRpbmcvcGFydGlhbHMvY29tcG9uZW50cy9mb3JtL2pzL2Zvcm0tYWpheC5qcyIsInJlc291cmNlcy90ZW1wbGF0aW5nL3BhcnRpYWxzL2NvbXBvbmVudHMvZm9ybS9qcy9mb3JtLWRhdGVwaWNrZXIuanMiLCJyZXNvdXJjZXMvdGVtcGxhdGluZy9wYXJ0aWFscy9jb21wb25lbnRzL292ZXJsYXkvanMvb3ZlcmxheS5qcyIsInJlc291cmNlcy90ZW1wbGF0aW5nL3BhcnRpYWxzL2NvbXBvbmVudHMvc2xpZGUtZm94L2pzL3NsaWRlLWZveC5qcyIsInJlc291cmNlcy90ZW1wbGF0aW5nL3BhcnRpYWxzL2NvbXBvbmVudHMvc2xpZGVyL2pzL3NsaWRlci5qcyIsInJlc291cmNlcy90ZW1wbGF0aW5nL3BhcnRpYWxzL2NvbXBvbmVudHMvdG9nZ2xlci9qcy90b2dnbGVyLmpzIiwicmVzb3VyY2VzL2pzL2FwcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7OzhCQ0FzQixtQkFBbUI7O0lBQTdCLElBQUk7Ozs7O29DQUlPLDBCQUEwQjs7OzttQ0FDM0Isd0JBQXdCOzs7OytCQUN2QixvQkFBb0I7O0lBQS9CLEtBQUs7O2lDQUNRLHNCQUFzQjs7SUFBbkMsT0FBTzs7b0NBRUksMEJBQTBCOzs7OztBQUdqRCxTQUFTLE1BQU0sR0FBRztBQUNoQixNQUFJLEVBQUUsR0FBRyxJQUFJLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDOztBQUUxQyxPQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUN2QixJQUFFLENBQUMsVUFBVSxvQ0FBYSxDQUFDO0FBQzNCLElBQUUsQ0FBQyxTQUFTLG1DQUFZLENBQUM7QUFDekIsSUFBRSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDakIsSUFBRSxDQUFDLGdCQUFnQixHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQzs7QUFFN0MsSUFBRSxDQUFDLEVBQUUsR0FBRyxPQUFPLENBQUM7QUFDaEIsSUFBRSxDQUFDLFFBQVEsR0FBRyxVQUFTLElBQUksRUFBRTtBQUMzQixXQUFPLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0dBQ25DLENBQUM7O0FBRUYsU0FBTyxFQUFFLENBQUM7Q0FDWDs7QUFFRCxJQUFJLElBQUksR0FBRyxNQUFNLEVBQUUsQ0FBQztB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O0NBQ2Y7O0FBRU0sU0FBUyxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsRUFBRSxFQUFFO0FBQ2pELFNBQU8sQ0FBQyxXQUFXLEdBQUcsV0FBVyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUEsR0FBSSxFQUFFLENBQUM7Q0FDcEQ7Ozs7QUMzR0Q7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy8ySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3B0Q0EsQ0FBQyxTQUFTLGdDQUFULENBQTBDLElBQTFDLEVBQWdELE9BQWhELEVBQXlEO0FBQ3pELEtBQUcsUUFBTyxPQUFQLHlDQUFPLE9BQVAsT0FBbUIsUUFBbkIsSUFBK0IsUUFBTyxNQUFQLHlDQUFPLE1BQVAsT0FBa0IsUUFBcEQs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UUFBUCxDQUFrQixnQkFBTSxPQUFOLENBQWMsUUFBZCxDQUF1QixTQUFDLENBQUQsQ0FBTyxDQUM1QyxnQkFBTSxJQUFOLENBQVcsT0FBWCxDQUFtQixnQkFBTSxNQUFOLENBQWEsTUFBaEMsQ0FBd0MsQ0FBeEMsRUFDSCxDQUZpQixDQUVmLEdBRmUsQ0FBbEIsQ0FLQSxHQUFJLEtBQU0sRUFBVixDQUNBLElBQUksQ0FBSixrQkFFQTtBQUNBLElBQUksT0FBSixDQUFjLE9BQWQsQ0FFQTtBQUNBLGdCQUFNLFlBQU4sQ0FBbUIsVUFBTSxDQUN4Qjs7R0FJQTtBQUNBLGdCQUFNLEdBQU4sMEJBQW9CLENBQ25CLG9CQURtQixDQUFwQixFQUlBO0FBQ0EsZ0JBQU0sR0FBTiwyQkFBcUIsQ0FDcEIsOEJBRG9CLENBQXJCLEVBS0csZ0JBQU0sR0FBTixnQ0FBMEIsQ0FDdEIsVUFBVyxTQURXLENBRXRCLE9BQVEsVUFGYyxDQUExQixFQU1BO0FBQ0gsZ0JBQU0sR0FBTiw4QkFFQTtBQUNBLGdCQUFNLEdBQU4sOEJBQXdCLENBQ3ZCLG9CQUFxQixJQURFLENBRXZCLGtCQUFtQixLQUZJLENBQXhCLEVBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQSxnQkFBTSxHQUFOLHlDQUNBLENBeENELEUsUUEwQ1EsRyxDQUFBLEcsU0FBSyxLIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsImltcG9ydCAqIGFzIGJhc2UgZnJvbSAnLi9oYW5kbGViYXJzL2Jhc2UnO1xuXG4vLyBFYWNoIG9mIHRoZXNlIGF1Z21lbnQgdGhlIEhhbmRsZWJhcnMgb2JqZWN0LiBObyBuZWVkIHRvIHNldHVwIGhlcmUuXG4vLyAoVGhpcyBpcyBkb25lIHRvIGVhc2lseSBzaGFyZSBjb2RlIGJldHdlZW4gY29tbW9uanMgYW5kIGJyb3dzZSBlbnZzKVxuaW1wb3J0IFNhZmVTdHJpbmcgZnJvbSAnLi9oYW5kbGViYXJzL3NhZmUtc3RyaW5nJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi9oYW5kbGViYXJzL2V4Y2VwdGlvbic7XG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tICcuL2hhbmRsZWJhcnMvdXRpbHMnO1xuaW1wb3J0ICogYXMgcnVudGltZSBmcm9tICcuL2hhbmRsZWJhcnMvcnVudGltZSc7XG5cbmltcG9ydCBub0NvbmZsaWN0IGZyb20gJy4vaGFuZGxlYmFycy9uby1jb25mbGljdCc7XG5cbi8vIEZvciBjb21wYXRpYmlsaXR5IGFuZCB1c2FnZSBvdXRzaWRlIG9mIG1vZHVsZSBzeXN0ZW1zLCBtYWtlIHRoZSBIYW5kbGViYXJzIG9iamVjdCBhIG5hbWVzcGFjZVxuZnVuY3Rpb24gY3JlYXRlKCkge1xuICBsZXQgaGIgPSBuZXcgYmFzZS5IYW5kbGViYXJzRW52aXJvbm1lbnQoKTtcblxuICBVdGlscy5leHRlbmQoaGIsIGJhc2UpO1xuICBoYi5TYWZlU3RyaW5nID0gU2FmZVN0cmluZztcbiAgaGIuRXhjZXB0aW9uID0gRXhjZXB0aW9uO1xuICBoYi5VdGlscyA9IFV0aWxzO1xuICBoYi5lc2NhcGVFeHByZXNzaW9uID0gVXRpbHMuZXNjYXBlRXhwcmVzc2lvbjtcblxuICBoYi5WTSA9IHJ1bnRpbWU7XG4gIGhiLnRlbXBsYXRlID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHJldHVybiBydW50aW1lLnRlbXBsYXRlKHNwZWMsIGhiKTtcbiAgfTtcblxuICByZXR1cm4gaGI7XG59XG5cbmxldCBpbnN0ID0gY3JlYXRlKCk7XG5pbnN0LmNyZWF0ZSA9IGNyZWF0ZTtcblxubm9Db25mbGljdChpbnN0KTtcblxuaW5zdFsnZGVmYXVsdCddID0gaW5zdDtcblxuZXhwb3J0IGRlZmF1bHQgaW5zdDtcbiIsImltcG9ydCB7Y3JlYXRlRnJhbWUsIGV4dGVuZCwgdG9TdHJpbmd9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuL2V4Y2VwdGlvbic7XG5pbXBvcnQge3JlZ2lzdGVyRGVmYXVsdEhlbHBlcnN9IGZyb20gJy4vaGVscGVycyc7XG5pbXBvcnQge3JlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnN9IGZyb20gJy4vZGVjb3JhdG9ycyc7XG5pbXBvcnQgbG9nZ2VyIGZyb20gJy4vbG9nZ2VyJztcblxuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSAnNC4wLjExJztcbmV4cG9ydCBjb25zdCBDT01QSUxFUl9SRVZJU0lPTiA9IDc7XG5cbmV4cG9ydCBjb25zdCBSRVZJU0lPTl9DSEFOR0VTID0ge1xuICAxOiAnPD0gMS4wLnJjLjInLCAvLyAxLjAucmMuMiBpcyBhY3R1YWxseSByZXYyIGJ1dCBkb2Vzbid0IHJlcG9ydCBpdFxuICAyOiAnPT0gMS4wLjAtcmMuMycsXG4gIDM6ICc9PSAxLjAuMC1yYy40JyxcbiAgNDogJz09IDEueC54JyxcbiAgNTogJz09IDIuMC4wLWFscGhhLngnLFxuICA2OiAnPj0gMi4wLjAtYmV0YS4xJyxcbiAgNzogJz49IDQuMC4wJ1xufTtcblxuY29uc3Qgb2JqZWN0VHlwZSA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG5leHBvcnQgZnVuY3Rpb24gSGFuZGxlYmFyc0Vudmlyb25tZW50KGhlbHBlcnMsIHBhcnRpYWxzLCBkZWNvcmF0b3JzKSB7XG4gIHRoaXMuaGVscGVycyA9IGhlbHBlcnMgfHwge307XG4gIHRoaXMucGFydGlhbHMgPSBwYXJ0aWFscyB8fCB7fTtcbiAgdGhpcy5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycyB8fCB7fTtcblxuICByZWdpc3RlckRlZmF1bHRIZWxwZXJzKHRoaXMpO1xuICByZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzKHRoaXMpO1xufVxuXG5IYW5kbGViYXJzRW52aXJvbm1lbnQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogSGFuZGxlYmFyc0Vudmlyb25tZW50LFxuXG4gIGxvZ2dlcjogbG9nZ2VyLFxuICBsb2c6IGxvZ2dlci5sb2csXG5cbiAgcmVnaXN0ZXJIZWxwZXI6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobmFtZSkgPT09IG9iamVjdFR5cGUpIHtcbiAgICAgIGlmIChmbikgeyB0aHJvdyBuZXcgRXhjZXB0aW9uKCdBcmcgbm90IHN1cHBvcnRlZCB3aXRoIG11bHRpcGxlIGhlbHBlcnMnKTsgfVxuICAgICAgZXh0ZW5kKHRoaXMuaGVscGVycywgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVscGVyc1tuYW1lXSA9IGZuO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3RlckhlbHBlcjogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmhlbHBlcnNbbmFtZV07XG4gIH0sXG5cbiAgcmVnaXN0ZXJQYXJ0aWFsOiBmdW5jdGlvbihuYW1lLCBwYXJ0aWFsKSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobmFtZSkgPT09IG9iamVjdFR5cGUpIHtcbiAgICAgIGV4dGVuZCh0aGlzLnBhcnRpYWxzLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBwYXJ0aWFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKGBBdHRlbXB0aW5nIHRvIHJlZ2lzdGVyIGEgcGFydGlhbCBjYWxsZWQgXCIke25hbWV9XCIgYXMgdW5kZWZpbmVkYCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcnRpYWxzW25hbWVdID0gcGFydGlhbDtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJQYXJ0aWFsOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMucGFydGlhbHNbbmFtZV07XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uKG5hbWUsIGZuKSB7XG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobmFtZSkgPT09IG9iamVjdFR5cGUpIHtcbiAgICAgIGlmIChmbikgeyB0aHJvdyBuZXcgRXhjZXB0aW9uKCdBcmcgbm90IHN1cHBvcnRlZCB3aXRoIG11bHRpcGxlIGRlY29yYXRvcnMnKTsgfVxuICAgICAgZXh0ZW5kKHRoaXMuZGVjb3JhdG9ycywgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVjb3JhdG9yc1tuYW1lXSA9IGZuO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3RlckRlY29yYXRvcjogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLmRlY29yYXRvcnNbbmFtZV07XG4gIH1cbn07XG5cbmV4cG9ydCBsZXQgbG9nID0gbG9nZ2VyLmxvZztcblxuZXhwb3J0IHtjcmVhdGVGcmFtZSwgbG9nZ2VyfTtcbiIsImltcG9ydCByZWdpc3RlcklubGluZSBmcm9tICcuL2RlY29yYXRvcnMvaW5saW5lJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdERlY29yYXRvcnMoaW5zdGFuY2UpIHtcbiAgcmVnaXN0ZXJJbmxpbmUoaW5zdGFuY2UpO1xufVxuXG4iLCJpbXBvcnQge2V4dGVuZH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckRlY29yYXRvcignaW5saW5lJywgZnVuY3Rpb24oZm4sIHByb3BzLCBjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgICBsZXQgcmV0ID0gZm47XG4gICAgaWYgKCFwcm9wcy5wYXJ0aWFscykge1xuICAgICAgcHJvcHMucGFydGlhbHMgPSB7fTtcbiAgICAgIHJldCA9IGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBhcnRpYWxzIHN0YWNrIGZyYW1lIHByaW9yIHRvIGV4ZWMuXG4gICAgICAgIGxldCBvcmlnaW5hbCA9IGNvbnRhaW5lci5wYXJ0aWFscztcbiAgICAgICAgY29udGFpbmVyLnBhcnRpYWxzID0gZXh0ZW5kKHt9LCBvcmlnaW5hbCwgcHJvcHMucGFydGlhbHMpO1xuICAgICAgICBsZXQgcmV0ID0gZm4oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IG9yaWdpbmFsO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBwcm9wcy5wYXJ0aWFsc1tvcHRpb25zLmFyZ3NbMF1dID0gb3B0aW9ucy5mbjtcblxuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuIiwiXG5jb25zdCBlcnJvclByb3BzID0gWydkZXNjcmlwdGlvbicsICdmaWxlTmFtZScsICdsaW5lTnVtYmVyJywgJ21lc3NhZ2UnLCAnbmFtZScsICdudW1iZXInLCAnc3RhY2snXTtcblxuZnVuY3Rpb24gRXhjZXB0aW9uKG1lc3NhZ2UsIG5vZGUpIHtcbiAgbGV0IGxvYyA9IG5vZGUgJiYgbm9kZS5sb2MsXG4gICAgICBsaW5lLFxuICAgICAgY29sdW1uO1xuICBpZiAobG9jKSB7XG4gICAgbGluZSA9IGxvYy5zdGFydC5saW5lO1xuICAgIGNvbHVtbiA9IGxvYy5zdGFydC5jb2x1bW47XG5cbiAgICBtZXNzYWdlICs9ICcgLSAnICsgbGluZSArICc6JyArIGNvbHVtbjtcbiAgfVxuXG4gIGxldCB0bXAgPSBFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcblxuICAvLyBVbmZvcnR1bmF0ZWx5IGVycm9ycyBhcmUgbm90IGVudW1lcmFibGUgaW4gQ2hyb21lIChhdCBsZWFzdCksIHNvIGBmb3IgcHJvcCBpbiB0bXBgIGRvZXNuJ3Qgd29yay5cbiAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgZXJyb3JQcm9wcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgdGhpc1tlcnJvclByb3BzW2lkeF1dID0gdG1wW2Vycm9yUHJvcHNbaWR4XV07XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBFeGNlcHRpb24pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAobG9jKSB7XG4gICAgICB0aGlzLmxpbmVOdW1iZXIgPSBsaW5lO1xuXG4gICAgICAvLyBXb3JrIGFyb3VuZCBpc3N1ZSB1bmRlciBzYWZhcmkgd2hlcmUgd2UgY2FuJ3QgZGlyZWN0bHkgc2V0IHRoZSBjb2x1bW4gdmFsdWVcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29sdW1uJywge1xuICAgICAgICAgIHZhbHVlOiBjb2x1bW4sXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAobm9wKSB7XG4gICAgLyogSWdub3JlIGlmIHRoZSBicm93c2VyIGlzIHZlcnkgcGFydGljdWxhciAqL1xuICB9XG59XG5cbkV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuZXhwb3J0IGRlZmF1bHQgRXhjZXB0aW9uO1xuIiwiaW1wb3J0IHJlZ2lzdGVyQmxvY2tIZWxwZXJNaXNzaW5nIGZyb20gJy4vaGVscGVycy9ibG9jay1oZWxwZXItbWlzc2luZyc7XG5pbXBvcnQgcmVnaXN0ZXJFYWNoIGZyb20gJy4vaGVscGVycy9lYWNoJztcbmltcG9ydCByZWdpc3RlckhlbHBlck1pc3NpbmcgZnJvbSAnLi9oZWxwZXJzL2hlbHBlci1taXNzaW5nJztcbmltcG9ydCByZWdpc3RlcklmIGZyb20gJy4vaGVscGVycy9pZic7XG5pbXBvcnQgcmVnaXN0ZXJMb2cgZnJvbSAnLi9oZWxwZXJzL2xvZyc7XG5pbXBvcnQgcmVnaXN0ZXJMb29rdXAgZnJvbSAnLi9oZWxwZXJzL2xvb2t1cCc7XG5pbXBvcnQgcmVnaXN0ZXJXaXRoIGZyb20gJy4vaGVscGVycy93aXRoJztcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdEhlbHBlcnMoaW5zdGFuY2UpIHtcbiAgcmVnaXN0ZXJCbG9ja0hlbHBlck1pc3NpbmcoaW5zdGFuY2UpO1xuICByZWdpc3RlckVhY2goaW5zdGFuY2UpO1xuICByZWdpc3RlckhlbHBlck1pc3NpbmcoaW5zdGFuY2UpO1xuICByZWdpc3RlcklmKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJMb2coaW5zdGFuY2UpO1xuICByZWdpc3Rlckxvb2t1cChpbnN0YW5jZSk7XG4gIHJlZ2lzdGVyV2l0aChpbnN0YW5jZSk7XG59XG4iLCJpbXBvcnQge2FwcGVuZENvbnRleHRQYXRoLCBjcmVhdGVGcmFtZSwgaXNBcnJheX0gZnJvbSAnLi4vdXRpbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignYmxvY2tIZWxwZXJNaXNzaW5nJywgZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgIGxldCBpbnZlcnNlID0gb3B0aW9ucy5pbnZlcnNlLFxuICAgICAgICBmbiA9IG9wdGlvbnMuZm47XG5cbiAgICBpZiAoY29udGV4dCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGZuKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoY29udGV4dCA9PT0gZmFsc2UgfHwgY29udGV4dCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gaW52ZXJzZSh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoY29udGV4dCkpIHtcbiAgICAgIGlmIChjb250ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaWRzKSB7XG4gICAgICAgICAgb3B0aW9ucy5pZHMgPSBbb3B0aW9ucy5uYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzLmVhY2goY29udGV4dCwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW52ZXJzZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xuICAgICAgICBsZXQgZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgICAgIGRhdGEuY29udGV4dFBhdGggPSBhcHBlbmRDb250ZXh0UGF0aChvcHRpb25zLmRhdGEuY29udGV4dFBhdGgsIG9wdGlvbnMubmFtZSk7XG4gICAgICAgIG9wdGlvbnMgPSB7ZGF0YTogZGF0YX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbihjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiaW1wb3J0IHthcHBlbmRDb250ZXh0UGF0aCwgYmxvY2tQYXJhbXMsIGNyZWF0ZUZyYW1lLCBpc0FycmF5LCBpc0Z1bmN0aW9ufSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4uL2V4Y2VwdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdlYWNoJywgZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignTXVzdCBwYXNzIGl0ZXJhdG9yIHRvICNlYWNoJyk7XG4gICAgfVxuXG4gICAgbGV0IGZuID0gb3B0aW9ucy5mbixcbiAgICAgICAgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIHJldCA9ICcnLFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0UGF0aDtcblxuICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgIGNvbnRleHRQYXRoID0gYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLmlkc1swXSkgKyAnLic7XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24oY29udGV4dCkpIHsgY29udGV4dCA9IGNvbnRleHQuY2FsbCh0aGlzKTsgfVxuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhlY0l0ZXJhdGlvbihmaWVsZCwgaW5kZXgsIGxhc3QpIHtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGRhdGEua2V5ID0gZmllbGQ7XG4gICAgICAgIGRhdGEuaW5kZXggPSBpbmRleDtcbiAgICAgICAgZGF0YS5maXJzdCA9IGluZGV4ID09PSAwO1xuICAgICAgICBkYXRhLmxhc3QgPSAhIWxhc3Q7XG5cbiAgICAgICAgaWYgKGNvbnRleHRQYXRoKSB7XG4gICAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGNvbnRleHRQYXRoICsgZmllbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0ID0gcmV0ICsgZm4oY29udGV4dFtmaWVsZF0sIHtcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgYmxvY2tQYXJhbXM6IGJsb2NrUGFyYW1zKFtjb250ZXh0W2ZpZWxkXSwgZmllbGRdLCBbY29udGV4dFBhdGggKyBmaWVsZCwgbnVsbF0pXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dCAmJiB0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChpc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICAgIGZvciAobGV0IGogPSBjb250ZXh0Lmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgIGlmIChpIGluIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGV4ZWNJdGVyYXRpb24oaSwgaSwgaSA9PT0gY29udGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwcmlvcktleTtcblxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gY29udGV4dCkge1xuICAgICAgICAgIGlmIChjb250ZXh0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIC8vIFdlJ3JlIHJ1bm5pbmcgdGhlIGl0ZXJhdGlvbnMgb25lIHN0ZXAgb3V0IG9mIHN5bmMgc28gd2UgY2FuIGRldGVjdFxuICAgICAgICAgICAgLy8gdGhlIGxhc3QgaXRlcmF0aW9uIHdpdGhvdXQgaGF2ZSB0byBzY2FuIHRoZSBvYmplY3QgdHdpY2UgYW5kIGNyZWF0ZVxuICAgICAgICAgICAgLy8gYW4gaXRlcm1lZGlhdGUga2V5cyBhcnJheS5cbiAgICAgICAgICAgIGlmIChwcmlvcktleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGV4ZWNJdGVyYXRpb24ocHJpb3JLZXksIGkgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByaW9yS2V5ID0ga2V5O1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpb3JLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGV4ZWNJdGVyYXRpb24ocHJpb3JLZXksIGkgLSAxLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICByZXQgPSBpbnZlcnNlKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuIiwiaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9leGNlcHRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignaGVscGVyTWlzc2luZycsIGZ1bmN0aW9uKC8qIFthcmdzLCBdb3B0aW9ucyAqLykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBBIG1pc3NpbmcgZmllbGQgaW4gYSB7e2Zvb319IGNvbnN0cnVjdC5cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNvbWVvbmUgaXMgYWN0dWFsbHkgdHJ5aW5nIHRvIGNhbGwgc29tZXRoaW5nLCBibG93IHVwLlxuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignTWlzc2luZyBoZWxwZXI6IFwiJyArIGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0ubmFtZSArICdcIicpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJpbXBvcnQge2lzRW1wdHksIGlzRnVuY3Rpb259IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2lmJywgZnVuY3Rpb24oY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihjb25kaXRpb25hbCkpIHsgY29uZGl0aW9uYWwgPSBjb25kaXRpb25hbC5jYWxsKHRoaXMpOyB9XG5cbiAgICAvLyBEZWZhdWx0IGJlaGF2aW9yIGlzIHRvIHJlbmRlciB0aGUgcG9zaXRpdmUgcGF0aCBpZiB0aGUgdmFsdWUgaXMgdHJ1dGh5IGFuZCBub3QgZW1wdHkuXG4gICAgLy8gVGhlIGBpbmNsdWRlWmVyb2Agb3B0aW9uIG1heSBiZSBzZXQgdG8gdHJlYXQgdGhlIGNvbmR0aW9uYWwgYXMgcHVyZWx5IG5vdCBlbXB0eSBiYXNlZCBvbiB0aGVcbiAgICAvLyBiZWhhdmlvciBvZiBpc0VtcHR5LiBFZmZlY3RpdmVseSB0aGlzIGRldGVybWluZXMgaWYgMCBpcyBoYW5kbGVkIGJ5IHRoZSBwb3NpdGl2ZSBwYXRoIG9yIG5lZ2F0aXZlLlxuICAgIGlmICgoIW9wdGlvbnMuaGFzaC5pbmNsdWRlWmVybyAmJiAhY29uZGl0aW9uYWwpIHx8IGlzRW1wdHkoY29uZGl0aW9uYWwpKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5mbih0aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCd1bmxlc3MnLCBmdW5jdGlvbihjb25kaXRpb25hbCwgb3B0aW9ucykge1xuICAgIHJldHVybiBpbnN0YW5jZS5oZWxwZXJzWydpZiddLmNhbGwodGhpcywgY29uZGl0aW9uYWwsIHtmbjogb3B0aW9ucy5pbnZlcnNlLCBpbnZlcnNlOiBvcHRpb25zLmZuLCBoYXNoOiBvcHRpb25zLmhhc2h9KTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignbG9nJywgZnVuY3Rpb24oLyogbWVzc2FnZSwgb3B0aW9ucyAqLykge1xuICAgIGxldCBhcmdzID0gW3VuZGVmaW5lZF0sXG4gICAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxuXG4gICAgbGV0IGxldmVsID0gMTtcbiAgICBpZiAob3B0aW9ucy5oYXNoLmxldmVsICE9IG51bGwpIHtcbiAgICAgIGxldmVsID0gb3B0aW9ucy5oYXNoLmxldmVsO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuZGF0YS5sZXZlbCAhPSBudWxsKSB7XG4gICAgICBsZXZlbCA9IG9wdGlvbnMuZGF0YS5sZXZlbDtcbiAgICB9XG4gICAgYXJnc1swXSA9IGxldmVsO1xuXG4gICAgaW5zdGFuY2UubG9nKC4uLiBhcmdzKTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignbG9va3VwJywgZnVuY3Rpb24ob2JqLCBmaWVsZCkge1xuICAgIHJldHVybiBvYmogJiYgb2JqW2ZpZWxkXTtcbiAgfSk7XG59XG4iLCJpbXBvcnQge2FwcGVuZENvbnRleHRQYXRoLCBibG9ja1BhcmFtcywgY3JlYXRlRnJhbWUsIGlzRW1wdHksIGlzRnVuY3Rpb259IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ3dpdGgnLCBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oY29udGV4dCkpIHsgY29udGV4dCA9IGNvbnRleHQuY2FsbCh0aGlzKTsgfVxuXG4gICAgbGV0IGZuID0gb3B0aW9ucy5mbjtcblxuICAgIGlmICghaXNFbXB0eShjb250ZXh0KSkge1xuICAgICAgbGV0IGRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLmlkc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbihjb250ZXh0LCB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyhbY29udGV4dF0sIFtkYXRhICYmIGRhdGEuY29udGV4dFBhdGhdKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmludmVyc2UodGhpcyk7XG4gICAgfVxuICB9KTtcbn1cbiIsImltcG9ydCB7aW5kZXhPZn0gZnJvbSAnLi91dGlscyc7XG5cbmxldCBsb2dnZXIgPSB7XG4gIG1ldGhvZE1hcDogWydkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InXSxcbiAgbGV2ZWw6ICdpbmZvJyxcblxuICAvLyBNYXBzIGEgZ2l2ZW4gbGV2ZWwgdmFsdWUgdG8gdGhlIGBtZXRob2RNYXBgIGluZGV4ZXMgYWJvdmUuXG4gIGxvb2t1cExldmVsOiBmdW5jdGlvbihsZXZlbCkge1xuICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgbGV2ZWxNYXAgPSBpbmRleE9mKGxvZ2dlci5tZXRob2RNYXAsIGxldmVsLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgaWYgKGxldmVsTWFwID49IDApIHtcbiAgICAgICAgbGV2ZWwgPSBsZXZlbE1hcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsID0gcGFyc2VJbnQobGV2ZWwsIDEwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGV2ZWw7XG4gIH0sXG5cbiAgLy8gQ2FuIGJlIG92ZXJyaWRkZW4gaW4gdGhlIGhvc3QgZW52aXJvbm1lbnRcbiAgbG9nOiBmdW5jdGlvbihsZXZlbCwgLi4ubWVzc2FnZSkge1xuICAgIGxldmVsID0gbG9nZ2VyLmxvb2t1cExldmVsKGxldmVsKTtcblxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbG9nZ2VyLmxvb2t1cExldmVsKGxvZ2dlci5sZXZlbCkgPD0gbGV2ZWwpIHtcbiAgICAgIGxldCBtZXRob2QgPSBsb2dnZXIubWV0aG9kTWFwW2xldmVsXTtcbiAgICAgIGlmICghY29uc29sZVttZXRob2RdKSB7ICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgIG1ldGhvZCA9ICdsb2cnO1xuICAgICAgfVxuICAgICAgY29uc29sZVttZXRob2RdKC4uLm1lc3NhZ2UpOyAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGxvZ2dlcjtcbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKEhhbmRsZWJhcnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgbGV0IHJvb3QgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdyxcbiAgICAgICRIYW5kbGViYXJzID0gcm9vdC5IYW5kbGViYXJzO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBIYW5kbGViYXJzLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAocm9vdC5IYW5kbGViYXJzID09PSBIYW5kbGViYXJzKSB7XG4gICAgICByb290LkhhbmRsZWJhcnMgPSAkSGFuZGxlYmFycztcbiAgICB9XG4gICAgcmV0dXJuIEhhbmRsZWJhcnM7XG4gIH07XG59XG4iLCJpbXBvcnQgKiBhcyBVdGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi9leGNlcHRpb24nO1xuaW1wb3J0IHsgQ09NUElMRVJfUkVWSVNJT04sIFJFVklTSU9OX0NIQU5HRVMsIGNyZWF0ZUZyYW1lIH0gZnJvbSAnLi9iYXNlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmV2aXNpb24oY29tcGlsZXJJbmZvKSB7XG4gIGNvbnN0IGNvbXBpbGVyUmV2aXNpb24gPSBjb21waWxlckluZm8gJiYgY29tcGlsZXJJbmZvWzBdIHx8IDEsXG4gICAgICAgIGN1cnJlbnRSZXZpc2lvbiA9IENPTVBJTEVSX1JFVklTSU9OO1xuXG4gIGlmIChjb21waWxlclJldmlzaW9uICE9PSBjdXJyZW50UmV2aXNpb24pIHtcbiAgICBpZiAoY29tcGlsZXJSZXZpc2lvbiA8IGN1cnJlbnRSZXZpc2lvbikge1xuICAgICAgY29uc3QgcnVudGltZVZlcnNpb25zID0gUkVWSVNJT05fQ0hBTkdFU1tjdXJyZW50UmV2aXNpb25dLFxuICAgICAgICAgICAgY29tcGlsZXJWZXJzaW9ucyA9IFJFVklTSU9OX0NIQU5HRVNbY29tcGlsZXJSZXZpc2lvbl07XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhbiBvbGRlciB2ZXJzaW9uIG9mIEhhbmRsZWJhcnMgdGhhbiB0aGUgY3VycmVudCBydW50aW1lLiAnICtcbiAgICAgICAgICAgICdQbGVhc2UgdXBkYXRlIHlvdXIgcHJlY29tcGlsZXIgdG8gYSBuZXdlciB2ZXJzaW9uICgnICsgcnVudGltZVZlcnNpb25zICsgJykgb3IgZG93bmdyYWRlIHlvdXIgcnVudGltZSB0byBhbiBvbGRlciB2ZXJzaW9uICgnICsgY29tcGlsZXJWZXJzaW9ucyArICcpLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVc2UgdGhlIGVtYmVkZGVkIHZlcnNpb24gaW5mbyBzaW5jZSB0aGUgcnVudGltZSBkb2Vzbid0IGtub3cgYWJvdXQgdGhpcyByZXZpc2lvbiB5ZXRcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1RlbXBsYXRlIHdhcyBwcmVjb21waWxlZCB3aXRoIGEgbmV3ZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIHVwZGF0ZSB5b3VyIHJ1bnRpbWUgdG8gYSBuZXdlciB2ZXJzaW9uICgnICsgY29tcGlsZXJJbmZvWzFdICsgJykuJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZSh0ZW1wbGF0ZVNwZWMsIGVudikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoIWVudikge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ05vIGVudmlyb25tZW50IHBhc3NlZCB0byB0ZW1wbGF0ZScpO1xuICB9XG4gIGlmICghdGVtcGxhdGVTcGVjIHx8ICF0ZW1wbGF0ZVNwZWMubWFpbikge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1Vua25vd24gdGVtcGxhdGUgb2JqZWN0OiAnICsgdHlwZW9mIHRlbXBsYXRlU3BlYyk7XG4gIH1cblxuICB0ZW1wbGF0ZVNwZWMubWFpbi5kZWNvcmF0b3IgPSB0ZW1wbGF0ZVNwZWMubWFpbl9kO1xuXG4gIC8vIE5vdGU6IFVzaW5nIGVudi5WTSByZWZlcmVuY2VzIHJhdGhlciB0aGFuIGxvY2FsIHZhciByZWZlcmVuY2VzIHRocm91Z2hvdXQgdGhpcyBzZWN0aW9uIHRvIGFsbG93XG4gIC8vIGZvciBleHRlcm5hbCB1c2VycyB0byBvdmVycmlkZSB0aGVzZSBhcyBwc3VlZG8tc3VwcG9ydGVkIEFQSXMuXG4gIGVudi5WTS5jaGVja1JldmlzaW9uKHRlbXBsYXRlU3BlYy5jb21waWxlcik7XG5cbiAgZnVuY3Rpb24gaW52b2tlUGFydGlhbFdyYXBwZXIocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmhhc2gpIHtcbiAgICAgIGNvbnRleHQgPSBVdGlscy5leHRlbmQoe30sIGNvbnRleHQsIG9wdGlvbnMuaGFzaCk7XG4gICAgICBpZiAob3B0aW9ucy5pZHMpIHtcbiAgICAgICAgb3B0aW9ucy5pZHNbMF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcnRpYWwgPSBlbnYuVk0ucmVzb2x2ZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcbiAgICBsZXQgcmVzdWx0ID0gZW52LlZNLmludm9rZVBhcnRpYWwuY2FsbCh0aGlzLCBwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKTtcblxuICAgIGlmIChyZXN1bHQgPT0gbnVsbCAmJiBlbnYuY29tcGlsZSkge1xuICAgICAgb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdID0gZW52LmNvbXBpbGUocGFydGlhbCwgdGVtcGxhdGVTcGVjLmNvbXBpbGVyT3B0aW9ucywgZW52KTtcbiAgICAgIHJlc3VsdCA9IG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXShjb250ZXh0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9ucy5pbmRlbnQpIHtcbiAgICAgICAgbGV0IGxpbmVzID0gcmVzdWx0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWxpbmVzW2ldICYmIGkgKyAxID09PSBsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaW5lc1tpXSA9IG9wdGlvbnMuaW5kZW50ICsgbGluZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gbGluZXMuam9pbignXFxuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUaGUgcGFydGlhbCAnICsgb3B0aW9ucy5uYW1lICsgJyBjb3VsZCBub3QgYmUgY29tcGlsZWQgd2hlbiBydW5uaW5nIGluIHJ1bnRpbWUtb25seSBtb2RlJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gSnVzdCBhZGQgd2F0ZXJcbiAgbGV0IGNvbnRhaW5lciA9IHtcbiAgICBzdHJpY3Q6IGZ1bmN0aW9uKG9iaiwgbmFtZSkge1xuICAgICAgaWYgKCEobmFtZSBpbiBvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1wiJyArIG5hbWUgKyAnXCIgbm90IGRlZmluZWQgaW4gJyArIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqW25hbWVdO1xuICAgIH0sXG4gICAgbG9va3VwOiBmdW5jdGlvbihkZXB0aHMsIG5hbWUpIHtcbiAgICAgIGNvbnN0IGxlbiA9IGRlcHRocy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChkZXB0aHNbaV0gJiYgZGVwdGhzW2ldW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gZGVwdGhzW2ldW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsYW1iZGE6IGZ1bmN0aW9uKGN1cnJlbnQsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgY3VycmVudCA9PT0gJ2Z1bmN0aW9uJyA/IGN1cnJlbnQuY2FsbChjb250ZXh0KSA6IGN1cnJlbnQ7XG4gICAgfSxcblxuICAgIGVzY2FwZUV4cHJlc3Npb246IFV0aWxzLmVzY2FwZUV4cHJlc3Npb24sXG4gICAgaW52b2tlUGFydGlhbDogaW52b2tlUGFydGlhbFdyYXBwZXIsXG5cbiAgICBmbjogZnVuY3Rpb24oaSkge1xuICAgICAgbGV0IHJldCA9IHRlbXBsYXRlU3BlY1tpXTtcbiAgICAgIHJldC5kZWNvcmF0b3IgPSB0ZW1wbGF0ZVNwZWNbaSArICdfZCddO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuXG4gICAgcHJvZ3JhbXM6IFtdLFxuICAgIHByb2dyYW06IGZ1bmN0aW9uKGksIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcbiAgICAgIGxldCBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0sXG4gICAgICAgICAgZm4gPSB0aGlzLmZuKGkpO1xuICAgICAgaWYgKGRhdGEgfHwgZGVwdGhzIHx8IGJsb2NrUGFyYW1zIHx8IGRlY2xhcmVkQmxvY2tQYXJhbXMpIHtcbiAgICAgICAgcHJvZ3JhbVdyYXBwZXIgPSB3cmFwUHJvZ3JhbSh0aGlzLCBpLCBmbiwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gICAgICB9IGVsc2UgaWYgKCFwcm9ncmFtV3JhcHBlcikge1xuICAgICAgICBwcm9ncmFtV3JhcHBlciA9IHRoaXMucHJvZ3JhbXNbaV0gPSB3cmFwUHJvZ3JhbSh0aGlzLCBpLCBmbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvZ3JhbVdyYXBwZXI7XG4gICAgfSxcblxuICAgIGRhdGE6IGZ1bmN0aW9uKHZhbHVlLCBkZXB0aCkge1xuICAgICAgd2hpbGUgKHZhbHVlICYmIGRlcHRoLS0pIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5fcGFyZW50O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgbWVyZ2U6IGZ1bmN0aW9uKHBhcmFtLCBjb21tb24pIHtcbiAgICAgIGxldCBvYmogPSBwYXJhbSB8fCBjb21tb247XG5cbiAgICAgIGlmIChwYXJhbSAmJiBjb21tb24gJiYgKHBhcmFtICE9PSBjb21tb24pKSB7XG4gICAgICAgIG9iaiA9IFV0aWxzLmV4dGVuZCh7fSwgY29tbW9uLCBwYXJhbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICAvLyBBbiBlbXB0eSBvYmplY3QgdG8gdXNlIGFzIHJlcGxhY2VtZW50IGZvciBudWxsLWNvbnRleHRzXG4gICAgbnVsbENvbnRleHQ6IE9iamVjdC5zZWFsKHt9KSxcblxuICAgIG5vb3A6IGVudi5WTS5ub29wLFxuICAgIGNvbXBpbGVySW5mbzogdGVtcGxhdGVTcGVjLmNvbXBpbGVyXG4gIH07XG5cbiAgZnVuY3Rpb24gcmV0KGNvbnRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBkYXRhID0gb3B0aW9ucy5kYXRhO1xuXG4gICAgcmV0Ll9zZXR1cChvcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMucGFydGlhbCAmJiB0ZW1wbGF0ZVNwZWMudXNlRGF0YSkge1xuICAgICAgZGF0YSA9IGluaXREYXRhKGNvbnRleHQsIGRhdGEpO1xuICAgIH1cbiAgICBsZXQgZGVwdGhzLFxuICAgICAgICBibG9ja1BhcmFtcyA9IHRlbXBsYXRlU3BlYy51c2VCbG9ja1BhcmFtcyA/IFtdIDogdW5kZWZpbmVkO1xuICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlRGVwdGhzKSB7XG4gICAgICBpZiAob3B0aW9ucy5kZXB0aHMpIHtcbiAgICAgICAgZGVwdGhzID0gY29udGV4dCAhPSBvcHRpb25zLmRlcHRoc1swXSA/IFtjb250ZXh0XS5jb25jYXQob3B0aW9ucy5kZXB0aHMpIDogb3B0aW9ucy5kZXB0aHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXB0aHMgPSBbY29udGV4dF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFpbihjb250ZXh0LyosIG9wdGlvbnMqLykge1xuICAgICAgcmV0dXJuICcnICsgdGVtcGxhdGVTcGVjLm1haW4oY29udGFpbmVyLCBjb250ZXh0LCBjb250YWluZXIuaGVscGVycywgY29udGFpbmVyLnBhcnRpYWxzLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgICB9XG4gICAgbWFpbiA9IGV4ZWN1dGVEZWNvcmF0b3JzKHRlbXBsYXRlU3BlYy5tYWluLCBtYWluLCBjb250YWluZXIsIG9wdGlvbnMuZGVwdGhzIHx8IFtdLCBkYXRhLCBibG9ja1BhcmFtcyk7XG4gICAgcmV0dXJuIG1haW4oY29udGV4dCwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0LmlzVG9wID0gdHJ1ZTtcblxuICByZXQuX3NldHVwID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5wYXJ0aWFsKSB7XG4gICAgICBjb250YWluZXIuaGVscGVycyA9IGNvbnRhaW5lci5tZXJnZShvcHRpb25zLmhlbHBlcnMsIGVudi5oZWxwZXJzKTtcblxuICAgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VQYXJ0aWFsKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IGNvbnRhaW5lci5tZXJnZShvcHRpb25zLnBhcnRpYWxzLCBlbnYucGFydGlhbHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRlbXBsYXRlU3BlYy51c2VQYXJ0aWFsIHx8IHRlbXBsYXRlU3BlYy51c2VEZWNvcmF0b3JzKSB7XG4gICAgICAgIGNvbnRhaW5lci5kZWNvcmF0b3JzID0gY29udGFpbmVyLm1lcmdlKG9wdGlvbnMuZGVjb3JhdG9ycywgZW52LmRlY29yYXRvcnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250YWluZXIuaGVscGVycyA9IG9wdGlvbnMuaGVscGVycztcbiAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IG9wdGlvbnMucGFydGlhbHM7XG4gICAgICBjb250YWluZXIuZGVjb3JhdG9ycyA9IG9wdGlvbnMuZGVjb3JhdG9ycztcbiAgICB9XG4gIH07XG5cbiAgcmV0Ll9jaGlsZCA9IGZ1bmN0aW9uKGksIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpIHtcbiAgICBpZiAodGVtcGxhdGVTcGVjLnVzZUJsb2NrUGFyYW1zICYmICFibG9ja1BhcmFtcykge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignbXVzdCBwYXNzIGJsb2NrIHBhcmFtcycpO1xuICAgIH1cbiAgICBpZiAodGVtcGxhdGVTcGVjLnVzZURlcHRocyAmJiAhZGVwdGhzKSB7XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdtdXN0IHBhc3MgcGFyZW50IGRlcHRocycpO1xuICAgIH1cblxuICAgIHJldHVybiB3cmFwUHJvZ3JhbShjb250YWluZXIsIGksIHRlbXBsYXRlU3BlY1tpXSwgZGF0YSwgMCwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gIH07XG4gIHJldHVybiByZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwUHJvZ3JhbShjb250YWluZXIsIGksIGZuLCBkYXRhLCBkZWNsYXJlZEJsb2NrUGFyYW1zLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG4gIGZ1bmN0aW9uIHByb2coY29udGV4dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IGN1cnJlbnREZXB0aHMgPSBkZXB0aHM7XG4gICAgaWYgKGRlcHRocyAmJiBjb250ZXh0ICE9IGRlcHRoc1swXSAmJiAhKGNvbnRleHQgPT09IGNvbnRhaW5lci5udWxsQ29udGV4dCAmJiBkZXB0aHNbMF0gPT09IG51bGwpKSB7XG4gICAgICBjdXJyZW50RGVwdGhzID0gW2NvbnRleHRdLmNvbmNhdChkZXB0aHMpO1xuICAgIH1cblxuICAgIHJldHVybiBmbihjb250YWluZXIsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGNvbnRhaW5lci5oZWxwZXJzLCBjb250YWluZXIucGFydGlhbHMsXG4gICAgICAgIG9wdGlvbnMuZGF0YSB8fCBkYXRhLFxuICAgICAgICBibG9ja1BhcmFtcyAmJiBbb3B0aW9ucy5ibG9ja1BhcmFtc10uY29uY2F0KGJsb2NrUGFyYW1zKSxcbiAgICAgICAgY3VycmVudERlcHRocyk7XG4gIH1cblxuICBwcm9nID0gZXhlY3V0ZURlY29yYXRvcnMoZm4sIHByb2csIGNvbnRhaW5lciwgZGVwdGhzLCBkYXRhLCBibG9ja1BhcmFtcyk7XG5cbiAgcHJvZy5wcm9ncmFtID0gaTtcbiAgcHJvZy5kZXB0aCA9IGRlcHRocyA/IGRlcHRocy5sZW5ndGggOiAwO1xuICBwcm9nLmJsb2NrUGFyYW1zID0gZGVjbGFyZWRCbG9ja1BhcmFtcyB8fCAwO1xuICByZXR1cm4gcHJvZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQYXJ0aWFsKHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgaWYgKCFwYXJ0aWFsKSB7XG4gICAgaWYgKG9wdGlvbnMubmFtZSA9PT0gJ0BwYXJ0aWFsLWJsb2NrJykge1xuICAgICAgcGFydGlhbCA9IG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0aWFsID0gb3B0aW9ucy5wYXJ0aWFsc1tvcHRpb25zLm5hbWVdO1xuICAgIH1cbiAgfSBlbHNlIGlmICghcGFydGlhbC5jYWxsICYmICFvcHRpb25zLm5hbWUpIHtcbiAgICAvLyBUaGlzIGlzIGEgZHluYW1pYyBwYXJ0aWFsIHRoYXQgcmV0dXJuZWQgYSBzdHJpbmdcbiAgICBvcHRpb25zLm5hbWUgPSBwYXJ0aWFsO1xuICAgIHBhcnRpYWwgPSBvcHRpb25zLnBhcnRpYWxzW3BhcnRpYWxdO1xuICB9XG4gIHJldHVybiBwYXJ0aWFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlUGFydGlhbChwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIC8vIFVzZSB0aGUgY3VycmVudCBjbG9zdXJlIGNvbnRleHQgdG8gc2F2ZSB0aGUgcGFydGlhbC1ibG9jayBpZiB0aGlzIHBhcnRpYWxcbiAgY29uc3QgY3VycmVudFBhcnRpYWxCbG9jayA9IG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXTtcbiAgb3B0aW9ucy5wYXJ0aWFsID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMuaWRzKSB7XG4gICAgb3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoID0gb3B0aW9ucy5pZHNbMF0gfHwgb3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoO1xuICB9XG5cbiAgbGV0IHBhcnRpYWxCbG9jaztcbiAgaWYgKG9wdGlvbnMuZm4gJiYgb3B0aW9ucy5mbiAhPT0gbm9vcCkge1xuICAgIG9wdGlvbnMuZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgLy8gV3JhcHBlciBmdW5jdGlvbiB0byBnZXQgYWNjZXNzIHRvIGN1cnJlbnRQYXJ0aWFsQmxvY2sgZnJvbSB0aGUgY2xvc3VyZVxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm47XG4gICAgcGFydGlhbEJsb2NrID0gb3B0aW9ucy5kYXRhWydwYXJ0aWFsLWJsb2NrJ10gPSBmdW5jdGlvbiBwYXJ0aWFsQmxvY2tXcmFwcGVyKGNvbnRleHQsIG9wdGlvbnMgPSB7fSkge1xuXG4gICAgICAvLyBSZXN0b3JlIHRoZSBwYXJ0aWFsLWJsb2NrIGZyb20gdGhlIGNsb3N1cmUgZm9yIHRoZSBleGVjdXRpb24gb2YgdGhlIGJsb2NrXG4gICAgICAvLyBpLmUuIHRoZSBwYXJ0IGluc2lkZSB0aGUgYmxvY2sgb2YgdGhlIHBhcnRpYWwgY2FsbC5cbiAgICAgIG9wdGlvbnMuZGF0YSA9IGNyZWF0ZUZyYW1lKG9wdGlvbnMuZGF0YSk7XG4gICAgICBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXSA9IGN1cnJlbnRQYXJ0aWFsQmxvY2s7XG4gICAgICByZXR1cm4gZm4oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBpZiAoZm4ucGFydGlhbHMpIHtcbiAgICAgIG9wdGlvbnMucGFydGlhbHMgPSBVdGlscy5leHRlbmQoe30sIG9wdGlvbnMucGFydGlhbHMsIGZuLnBhcnRpYWxzKTtcbiAgICB9XG4gIH1cblxuICBpZiAocGFydGlhbCA9PT0gdW5kZWZpbmVkICYmIHBhcnRpYWxCbG9jaykge1xuICAgIHBhcnRpYWwgPSBwYXJ0aWFsQmxvY2s7XG4gIH1cblxuICBpZiAocGFydGlhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVGhlIHBhcnRpYWwgJyArIG9wdGlvbnMubmFtZSArICcgY291bGQgbm90IGJlIGZvdW5kJyk7XG4gIH0gZWxzZSBpZiAocGFydGlhbCBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIHBhcnRpYWwoY29udGV4dCwgb3B0aW9ucyk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKSB7IHJldHVybiAnJzsgfVxuXG5mdW5jdGlvbiBpbml0RGF0YShjb250ZXh0LCBkYXRhKSB7XG4gIGlmICghZGF0YSB8fCAhKCdyb290JyBpbiBkYXRhKSkge1xuICAgIGRhdGEgPSBkYXRhID8gY3JlYXRlRnJhbWUoZGF0YSkgOiB7fTtcbiAgICBkYXRhLnJvb3QgPSBjb250ZXh0O1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBleGVjdXRlRGVjb3JhdG9ycyhmbiwgcHJvZywgY29udGFpbmVyLCBkZXB0aHMsIGRhdGEsIGJsb2NrUGFyYW1zKSB7XG4gIGlmIChmbi5kZWNvcmF0b3IpIHtcbiAgICBsZXQgcHJvcHMgPSB7fTtcbiAgICBwcm9nID0gZm4uZGVjb3JhdG9yKHByb2csIHByb3BzLCBjb250YWluZXIsIGRlcHRocyAmJiBkZXB0aHNbMF0sIGRhdGEsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICAgIFV0aWxzLmV4dGVuZChwcm9nLCBwcm9wcyk7XG4gIH1cbiAgcmV0dXJuIHByb2c7XG59XG4iLCIvLyBCdWlsZCBvdXQgb3VyIGJhc2ljIFNhZmVTdHJpbmcgdHlwZVxuZnVuY3Rpb24gU2FmZVN0cmluZyhzdHJpbmcpIHtcbiAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG59XG5cblNhZmVTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nID0gU2FmZVN0cmluZy5wcm90b3R5cGUudG9IVE1MID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAnJyArIHRoaXMuc3RyaW5nO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgU2FmZVN0cmluZztcbiIsImNvbnN0IGVzY2FwZSA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPCc6ICcmbHQ7JyxcbiAgJz4nOiAnJmd0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICBcIidcIjogJyYjeDI3OycsXG4gICdgJzogJyYjeDYwOycsXG4gICc9JzogJyYjeDNEOydcbn07XG5cbmNvbnN0IGJhZENoYXJzID0gL1smPD5cIidgPV0vZyxcbiAgICAgIHBvc3NpYmxlID0gL1smPD5cIidgPV0vO1xuXG5mdW5jdGlvbiBlc2NhcGVDaGFyKGNocikge1xuICByZXR1cm4gZXNjYXBlW2Nocl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQob2JqLyogLCAuLi5zb3VyY2UgKi8pIHtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gYXJndW1lbnRzW2ldKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFyZ3VtZW50c1tpXSwga2V5KSkge1xuICAgICAgICBvYmpba2V5XSA9IGFyZ3VtZW50c1tpXVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmV4cG9ydCBsZXQgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vLyBTb3VyY2VkIGZyb20gbG9kYXNoXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvbG9kYXNoL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4vKiBlc2xpbnQtZGlzYWJsZSBmdW5jLXN0eWxlICovXG5sZXQgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59O1xuLy8gZmFsbGJhY2sgZm9yIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKGlzRnVuY3Rpb24oL3gvKSkge1xuICBpc0Z1bmN0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICB9O1xufVxuZXhwb3J0IHtpc0Z1bmN0aW9ufTtcbi8qIGVzbGludC1lbmFibGUgZnVuYy1zdHlsZSAqL1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JykgPyB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJyA6IGZhbHNlO1xufTtcblxuLy8gT2xkZXIgSUUgdmVyc2lvbnMgZG8gbm90IGRpcmVjdGx5IHN1cHBvcnQgaW5kZXhPZiBzbyB3ZSBtdXN0IGltcGxlbWVudCBvdXIgb3duLCBzYWRseS5cbmV4cG9ydCBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVFeHByZXNzaW9uKHN0cmluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBkb24ndCBlc2NhcGUgU2FmZVN0cmluZ3MsIHNpbmNlIHRoZXkncmUgYWxyZWFkeSBzYWZlXG4gICAgaWYgKHN0cmluZyAmJiBzdHJpbmcudG9IVE1MKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnRvSFRNTCgpO1xuICAgIH0gZWxzZSBpZiAoc3RyaW5nID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2UgaWYgKCFzdHJpbmcpIHtcbiAgICAgIHJldHVybiBzdHJpbmcgKyAnJztcbiAgICB9XG5cbiAgICAvLyBGb3JjZSBhIHN0cmluZyBjb252ZXJzaW9uIGFzIHRoaXMgd2lsbCBiZSBkb25lIGJ5IHRoZSBhcHBlbmQgcmVnYXJkbGVzcyBhbmRcbiAgICAvLyB0aGUgcmVnZXggdGVzdCB3aWxsIGRvIHRoaXMgdHJhbnNwYXJlbnRseSBiZWhpbmQgdGhlIHNjZW5lcywgY2F1c2luZyBpc3N1ZXMgaWZcbiAgICAvLyBhbiBvYmplY3QncyB0byBzdHJpbmcgaGFzIGVzY2FwZWQgY2hhcmFjdGVycyBpbiBpdC5cbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZztcbiAgfVxuXG4gIGlmICghcG9zc2libGUudGVzdChzdHJpbmcpKSB7IHJldHVybiBzdHJpbmc7IH1cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGJhZENoYXJzLCBlc2NhcGVDaGFyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRnJhbWUob2JqZWN0KSB7XG4gIGxldCBmcmFtZSA9IGV4dGVuZCh7fSwgb2JqZWN0KTtcbiAgZnJhbWUuX3BhcmVudCA9IG9iamVjdDtcbiAgcmV0dXJuIGZyYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmxvY2tQYXJhbXMocGFyYW1zLCBpZHMpIHtcbiAgcGFyYW1zLnBhdGggPSBpZHM7XG4gIHJldHVybiBwYXJhbXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBlbmRDb250ZXh0UGF0aChjb250ZXh0UGF0aCwgaWQpIHtcbiAgcmV0dXJuIChjb250ZXh0UGF0aCA/IGNvbnRleHRQYXRoICsgJy4nIDogJycpICsgaWQ7XG59XG4iLCIvLyBDcmVhdGUgYSBzaW1wbGUgcGF0aCBhbGlhcyB0byBhbGxvdyBicm93c2VyaWZ5IHRvIHJlc29sdmVcbi8vIHRoZSBydW50aW1lIG9uIGEgc3VwcG9ydGVkIHBhdGguXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9janMvaGFuZGxlYmFycy5ydW50aW1lJylbJ2RlZmF1bHQnXTtcbiIsIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4xOC4xXG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBob29rQ2FsbGJhY2s7XG5cbmZ1bmN0aW9uIGhvb2tzICgpIHtcbiAgICByZXR1cm4gaG9va0NhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbi8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4vLyB3aXRob3V0IGNyZWF0aW5nIGNpcmN1bGFyIGRlcGVuZGVuY2llcy5cbmZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayAoY2FsbGJhY2spIHtcbiAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGlucHV0KSB7XG4gICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgIHJldHVybiBpbnB1dCAhPSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgIHZhciBrO1xuICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgLy8gZXZlbiBpZiBpdHMgbm90IG93biBwcm9wZXJ0eSBJJ2Qgc3RpbGwgY2FsbCBpdCBub24tZW1wdHlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgPT09IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJztcbn1cblxuZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0IGluc3RhbmNlb2YgRGF0ZSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbmZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgIC8vIFdlIG5lZWQgdG8gZGVlcCBjbG9uZSB0aGlzIG9iamVjdC5cbiAgICByZXR1cm4ge1xuICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgdW51c2VkVG9rZW5zICAgIDogW10sXG4gICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgY2hhcnNMZWZ0T3ZlciAgIDogMCxcbiAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgIGludmFsaWRGb3JtYXQgICA6IGZhbHNlLFxuICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHBhcnNlZERhdGVQYXJ0cyA6IFtdLFxuICAgICAgICBtZXJpZGllbSAgICAgICAgOiBudWxsLFxuICAgICAgICByZmMyODIyICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgd2Vla2RheU1pc21hdGNoIDogZmFsc2VcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgIGlmIChtLl9wZiA9PSBudWxsKSB7XG4gICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgIH1cbiAgICByZXR1cm4gbS5fcGY7XG59XG5cbnZhciBzb21lO1xuaWYgKEFycmF5LnByb3RvdHlwZS5zb21lKSB7XG4gICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xufSBlbHNlIHtcbiAgICBzb21lID0gZnVuY3Rpb24gKGZ1bikge1xuICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgdmFyIGxlbiA9IHQubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG52YXIgc29tZSQxID0gc29tZTtcblxuZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSk7XG4gICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUkMS5jYWxsKGZsYWdzLnBhcnNlZERhdGVQYXJ0cywgZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaXNOb3dWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgIGlmIChtLl9zdHJpY3QpIHtcbiAgICAgICAgICAgIGlzTm93VmFsaWQgPSBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLnVudXNlZFRva2Vucy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoT2JqZWN0LmlzRnJvemVuID09IG51bGwgfHwgIU9iamVjdC5pc0Zyb3plbihtKSkge1xuICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbS5faXNWYWxpZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW52YWxpZCAoZmxhZ3MpIHtcbiAgICB2YXIgbSA9IGNyZWF0ZVVUQyhOYU4pO1xuICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4vLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxudmFyIG1vbWVudFByb3BlcnRpZXMgPSBob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbmZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgIH1cblxuICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRvO1xufVxuXG52YXIgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4vLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgIGNvcHlDb25maWcodGhpcywgY29uZmlnKTtcbiAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgIH1cbiAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XG4gICAgLy8gb2JqZWN0cy5cbiAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNNb21lbnQgKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xufVxuXG5mdW5jdGlvbiBhYnNGbG9vciAobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcikgfHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgIHZhciBjb2VyY2VkTnVtYmVyID0gK2FyZ3VtZW50Rm9yQ29lcmNpb24sXG4gICAgICAgIHZhbHVlID0gMDtcblxuICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgIHZhbHVlID0gYWJzRmxvb3IoY29lcmNlZE51bWJlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG5mdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnJheTEubGVuZ3RoLCBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgKCFkb250Q29udmVydCAmJiB0b0ludChhcnJheTFbaV0pICE9PSB0b0ludChhcnJheTJbaV0pKSkge1xuICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xufVxuXG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICAgIGlmIChob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAodHlwZW9mIGNvbnNvbGUgIT09ICAndW5kZWZpbmVkJykgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBhcmc7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBhcmcgKz0gJ1xcblsnICsgaSArICddICc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwgZm4pO1xufVxuXG52YXIgZGVwcmVjYXRpb25zID0ge307XG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcbiAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgfVxuICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgZGVwcmVjYXRpb25zW25hbWVdID0gdHJ1ZTtcbiAgICB9XG59XG5cbmhvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbmZ1bmN0aW9uIHNldCAoY29uZmlnKSB7XG4gICAgdmFyIHByb3AsIGk7XG4gICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgdGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKFxuICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgJ3wnICsgKC9cXGR7MSwyfS8pLnNvdXJjZSk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XG4gICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSwgcHJvcDtcbiAgICBmb3IgKHByb3AgaW4gY2hpbGRDb25maWcpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hpbGRDb25maWdbcHJvcF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgIHJlc1twcm9wXSA9IGV4dGVuZCh7fSwgcmVzW3Byb3BdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgfVxufVxuXG52YXIga2V5cztcblxuaWYgKE9iamVjdC5rZXlzKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzO1xufSBlbHNlIHtcbiAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgaSwgcmVzID0gW107XG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICByZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59XG5cbnZhciBrZXlzJDEgPSBrZXlzO1xuXG52YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICBuZXh0V2VlayA6ICdkZGRkIFthdF0gTFQnLFxuICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgIHNhbWVFbHNlIDogJ0wnXG59O1xuXG5mdW5jdGlvbiBjYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG59XG5cbnZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgTFRTICA6ICdoOm1tOnNzIEEnLFxuICAgIExUICAgOiAnaDptbSBBJyxcbiAgICBMICAgIDogJ01NL0REL1lZWVknLFxuICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcbiAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgIExMTEwgOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQSdcbn07XG5cbmZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgZm9ybWF0VXBwZXIgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV07XG5cbiAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG59XG5cbnZhciBkZWZhdWx0SW52YWxpZERhdGUgPSAnSW52YWxpZCBkYXRlJztcblxuZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbn1cblxudmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbnZhciBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbmZ1bmN0aW9uIG9yZGluYWwgKG51bWJlcikge1xuICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbn1cblxudmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICBwYXN0ICAgOiAnJXMgYWdvJyxcbiAgICBzICA6ICdhIGZldyBzZWNvbmRzJyxcbiAgICBzcyA6ICclZCBzZWNvbmRzJyxcbiAgICBtICA6ICdhIG1pbnV0ZScsXG4gICAgbW0gOiAnJWQgbWludXRlcycsXG4gICAgaCAgOiAnYW4gaG91cicsXG4gICAgaGggOiAnJWQgaG91cnMnLFxuICAgIGQgIDogJ2EgZGF5JyxcbiAgICBkZCA6ICclZCBkYXlzJyxcbiAgICBNICA6ICdhIG1vbnRoJyxcbiAgICBNTSA6ICclZCBtb250aHMnLFxuICAgIHkgIDogJ2EgeWVhcicsXG4gICAgeXkgOiAnJWQgeWVhcnMnXG59O1xuXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICByZXR1cm4gKGlzRnVuY3Rpb24ob3V0cHV0KSkgP1xuICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xufVxuXG5mdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGZvcm1hdCkgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xufVxuXG52YXIgYWxpYXNlcyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRVbml0QWxpYXMgKHVuaXQsIHNob3J0aGFuZCkge1xuICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgYWxpYXNlc1tsb3dlckNhc2VdID0gYWxpYXNlc1tsb3dlckNhc2UgKyAncyddID0gYWxpYXNlc1tzaG9ydGhhbmRdID0gdW5pdDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHVuaXRzID09PSAnc3RyaW5nJyA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV0gOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICBub3JtYWxpemVkUHJvcCxcbiAgICAgICAgcHJvcDtcblxuICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xufVxuXG52YXIgcHJpb3JpdGllcyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG59XG5cbmZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICB2YXIgdW5pdHMgPSBbXTtcbiAgICBmb3IgKHZhciB1IGluIHVuaXRzT2JqKSB7XG4gICAgICAgIHVuaXRzLnB1c2goe3VuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdfSk7XG4gICAgfVxuICAgIHVuaXRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgIH0pO1xuICAgIHJldHVybiB1bml0cztcbn1cblxuZnVuY3Rpb24gbWFrZUdldFNldCAodW5pdCwga2VlcFRpbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0KHRoaXMsIHVuaXQpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0IChtb20sIHVuaXQpIHtcbiAgICByZXR1cm4gbW9tLmlzVmFsaWQoKSA/XG4gICAgICAgIG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpIDogTmFOO1xufVxuXG5mdW5jdGlvbiBzZXQkMSAobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgIGlmIChtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgfVxufVxuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5cbmZ1bmN0aW9uIHN0cmluZ1NldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB1bml0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByaW9yaXRpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih0aGlzW3VuaXRzXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICB6ZXJvc1RvRmlsbCA9IHRhcmdldExlbmd0aCAtIGFic051bWJlci5sZW5ndGgsXG4gICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgIE1hdGgucG93KDEwLCBNYXRoLm1heCgwLCB6ZXJvc1RvRmlsbCkpLnRvU3RyaW5nKCkuc3Vic3RyKDEpICsgYWJzTnVtYmVyO1xufVxuXG52YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98WVlZWVlZfFlZWVlZfFlZWVl8WVl8Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbnZhciBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nO1xuXG52YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XG5cbnZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4vLyB0b2tlbjogICAgJ00nXG4vLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4vLyBvcmRpbmFsOiAgJ01vJ1xuLy8gY2FsbGJhY2s6IGZ1bmN0aW9uICgpIHsgdGhpcy5tb250aCgpICsgMSB9XG5mdW5jdGlvbiBhZGRGb3JtYXRUb2tlbiAodG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSA9IGZ1bmM7XG4gICAgfVxuICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbcGFkZGVkWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRva2VuKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL15cXFt8XFxdJC9nLCAnJyk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbn1cblxuZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgdmFyIG91dHB1dCA9ICcnLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dCArPSBpc0Z1bmN0aW9uKGFycmF5W2ldKSA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufVxuXG4vLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbmZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cblxuICAgIGZvcm1hdCA9IGV4cGFuZEZvcm1hdChmb3JtYXQsIG0ubG9jYWxlRGF0YSgpKTtcbiAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9IGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xufVxuXG5mdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICB2YXIgaSA9IDU7XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgfVxuXG4gICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGkgLT0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9ybWF0O1xufVxuXG52YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxudmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxudmFyIG1hdGNoMyAgICAgICAgID0gL1xcZHszfS87ICAgICAgICAgLy8gICAgIDAwMCAtIDk5OVxudmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbnZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbnZhciBtYXRjaDF0bzIgICAgICA9IC9cXGRcXGQ/LzsgICAgICAgICAvLyAgICAgICAwIC0gOTlcbnZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG52YXIgbWF0Y2g1dG82ICAgICAgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy87IC8vICAgOTk5OTkgLSA5OTk5OTlcbnZhciBtYXRjaDF0bzMgICAgICA9IC9cXGR7MSwzfS87ICAgICAgIC8vICAgICAgIDAgLSA5OTlcbnZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG52YXIgbWF0Y2gxdG82ICAgICAgPSAvWystXT9cXGR7MSw2fS87ICAvLyAtOTk5OTk5IC0gOTk5OTk5XG5cbnZhciBtYXRjaFVuc2lnbmVkICA9IC9cXGQrLzsgICAgICAgICAgIC8vICAgICAgIDAgLSBpbmZcbnZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxudmFyIG1hdGNoT2Zmc2V0ICAgID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpOyAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbnZhciBtYXRjaFNob3J0T2Zmc2V0ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vZ2k7IC8vICswMCAtMDAgKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG5cbnZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbi8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xudmFyIG1hdGNoV29yZCA9IC9bMC05XSpbJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkZcXC9dKyhcXHMqP1tcXHUwNjAwLVxcdTA2RkZdKyl7MSwyfS9pO1xuXG5cbnZhciByZWdleGVzID0ge307XG5cbmZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpID8gcmVnZXggOiBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIChpc1N0cmljdCAmJiBzdHJpY3RSZWdleCkgPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbiAodG9rZW4sIGNvbmZpZykge1xuICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodW5lc2NhcGVGb3JtYXQodG9rZW4pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbn1cblxuLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgIHJldHVybiByZWdleEVzY2FwZShzLnJlcGxhY2UoJ1xcXFwnLCAnJykucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAobWF0Y2hlZCwgcDEsIHAyLCBwMywgcDQpIHtcbiAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gcmVnZXhFc2NhcGUocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xufVxuXG52YXIgdG9rZW5zID0ge307XG5cbmZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgIHZhciBpLCBmdW5jID0gY2FsbGJhY2s7XG4gICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgIH1cbiAgICBpZiAoaXNOdW1iZXIoY2FsbGJhY2spKSB7XG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgIH1cbn1cblxudmFyIFlFQVIgPSAwO1xudmFyIE1PTlRIID0gMTtcbnZhciBEQVRFID0gMjtcbnZhciBIT1VSID0gMztcbnZhciBNSU5VVEUgPSA0O1xudmFyIFNFQ09ORCA9IDU7XG52YXIgTUlMTElTRUNPTkQgPSA2O1xudmFyIFdFRUsgPSA3O1xudmFyIFdFRUtEQVkgPSA4O1xuXG52YXIgaW5kZXhPZjtcblxuaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xufSBlbHNlIHtcbiAgICBpbmRleE9mID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgLy8gSSBrbm93XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbn1cblxudmFyIGluZGV4T2YkMSA9IGluZGV4T2Y7XG5cbmZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoICsgMSwgMCkpLmdldFVUQ0RhdGUoKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xufSk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdNJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdNTU0nLCAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuXG5hZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbn0pO1xuXG5hZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgIH1cbn0pO1xuXG4vLyBMT0NBTEVTXG5cbnZhciBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vO1xudmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZU1vbnRocyAobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHMgOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgIHRoaXMuX21vbnRoc1sodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLm1vbnRoKCldO1xufVxuXG52YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0sIGZvcm1hdCkge1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydCA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldIDpcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSBtb250aE5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyArK2kpIHtcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgIH1cblxuICAgIC8vIFRPRE86IGFkZCBzb3J0aW5nXG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ01NTU0nICYmIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAvLyBObyBvcFxuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgcmV0dXJuIG1vbTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0TW9udGggKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2V0TW9udGgodGhpcywgdmFsdWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXQodGhpcywgJ01vbnRoJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXREYXlzSW5Nb250aCAoKSB7XG4gICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xufVxuXG52YXIgZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiBtb250aHNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgIH1cbn1cblxudmFyIGRlZmF1bHRNb250aHNSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIG1vbnRoc1JlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UgKCkge1xuICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgIGksIG1vbTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgIHNob3J0UGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgIH1cbiAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgbWl4ZWRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShtaXhlZFBpZWNlc1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgIHJldHVybiB5IDw9IDk5OTkgPyAnJyArIHkgOiAnKycgKyB5O1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCAgIDRdLCAgICAgICAwLCAneWVhcicpO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVlZJywgNiwgdHJ1ZV0sIDAsICd5ZWFyJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuLy8gUFJJT1JJVElFU1xuXG5hZGRVbml0UHJpb3JpdHkoJ3llYXInLCAxKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdZJywgICAgICBtYXRjaFNpZ25lZCk7XG5hZGRSZWdleFRva2VuKCdZWScsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG5hZGRSZWdleFRva2VuKCdZWVlZWScsICBtYXRjaDF0bzYsIG1hdGNoNik7XG5hZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbmFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG5hZGRQYXJzZVRva2VuKCdZWVlZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W1lFQVJdID0gaW5wdXQubGVuZ3RoID09PSAyID8gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xufSk7XG5hZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtZRUFSXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbn0pO1xuYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG5mdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbn1cblxuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xufVxuXG4vLyBIT09LU1xuXG5ob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG59O1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuZnVuY3Rpb24gZ2V0SXNMZWFwWWVhciAoKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8xODEzNDhcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCAmJiBpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVVENEYXRlICh5KSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcblxuICAgIC8vIHRoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbmZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgIHZhciAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICBmd2RsdyA9ICg3ICsgY3JlYXRlVVRDRGF0ZSh5ZWFyLCAwLCBmd2QpLmdldFVUQ0RheSgpIC0gZG93KSAlIDc7XG5cbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPX3dlZWtfZGF0ZSNDYWxjdWxhdGluZ19hX2RhdGVfZ2l2ZW5fdGhlX3llYXIuMkNfd2Vla19udW1iZXJfYW5kX3dlZWtkYXlcbmZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQobW9tLnllYXIoKSwgZG93LCBkb3kpLFxuICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICByZXNXZWVrLCByZXNZZWFyO1xuXG4gICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgcmVzV2VlayA9IHdlZWsgKyB3ZWVrc0luWWVhcihyZXNZZWFyLCBkb3csIGRveSk7XG4gICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHdlZWs6IHJlc1dlZWssXG4gICAgICAgIHllYXI6IHJlc1llYXJcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbmFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4vLyBQUklPUklUSUVTXG5cbmFkZFVuaXRQcmlvcml0eSgnd2VlaycsIDUpO1xuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigndycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdXJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdXVycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMSldID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuLy8gTE9DQUxFU1xuXG5mdW5jdGlvbiBsb2NhbGVXZWVrIChtb20pIHtcbiAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2Vlaztcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbn07XG5cbmZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG59XG5cbmZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRJU09XZWVrIChpbnB1dCkge1xuICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG5hZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbmFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbi8vIFBSSU9SSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbmFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla2RheScsIDExKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2UnLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdkZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xufSk7XG5hZGRSZWdleFRva2VuKCdkZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XG59KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgfVxufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG5mdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG5cbiAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KSAlIDcgfHwgNztcbiAgICB9XG4gICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbn1cblxuLy8gTE9DQUxFU1xuXG52YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0sIGZvcm1hdCkge1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5cyA6XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1snc3RhbmRhbG9uZSddO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl93ZWVrZGF5cykgPyB0aGlzLl93ZWVrZGF5c1ttLmRheSgpXSA6XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzW3RoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXVttLmRheSgpXTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0ID0gJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgIHJldHVybiAobSkgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzTWluO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBpaSwgbW9tLCBsbGMgPSB3ZWVrZGF5TmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2UgKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgaWYgKHN0cmljdCAmJiAhdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICdcXC4/JykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZGQnICYmIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkJyAmJiB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXREYXlPZldlZWsgKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF5O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cblxuICAgIC8vIGJlaGF2ZXMgdGhlIHNhbWUgYXMgbW9tZW50I2RheSBleGNlcHRcbiAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICB9XG59XG5cbnZhciBkZWZhdWx0V2Vla2RheXNSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbmZ1bmN0aW9uIHdlZWtkYXlzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzTWluUmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBjb21wdXRlV2Vla2RheXNQYXJzZSAoKSB7XG4gICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgIGksIG1vbSwgbWlucCwgc2hvcnRwLCBsb25ncDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgIG1pbnAgPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xuICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgIGxvbmdwID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKTtcbiAgICAgICAgbWluUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICB9XG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgIG1pblBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcblxuICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuZnVuY3Rpb24gaEZvcm1hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG59XG5cbmZ1bmN0aW9uIGtGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbn1cblxuYWRkRm9ybWF0VG9rZW4oJ0gnLCBbJ0hIJywgMl0sIDAsICdob3VyJyk7XG5hZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG5hZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbmFkZEZvcm1hdFRva2VuKCdobW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignaG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpO1xufSk7XG5cbmZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgfSk7XG59XG5cbm1lcmlkaWVtKCdhJywgdHJ1ZSk7XG5tZXJpZGllbSgnQScsIGZhbHNlKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4vLyBQQVJTSU5HXG5cbmZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xufVxuXG5hZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbmFkZFJlZ2V4VG9rZW4oJ0gnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ2snLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcbmFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbmFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG5hZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XG5cbmFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIGtJbnB1dCA9IHRvSW50KGlucHV0KTtcbiAgICBhcnJheVtIT1VSXSA9IGtJbnB1dCA9PT0gMjQgPyAwIDoga0lucHV0O1xufSk7XG5hZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbn0pO1xuYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG59KTtcblxuLy8gTE9DQUxFU1xuXG5mdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG5mdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgfVxufVxuXG5cbi8vIE1PTUVOVFNcblxuLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4vLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4vLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbi8vIHRoaXMgcnVsZS5cbnZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuLy8gbW9udGhzXG4vLyB3ZWVrXG4vLyB3ZWVrZGF5c1xuLy8gbWVyaWRpZW1cbnZhciBiYXNlQ29uZmlnID0ge1xuICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICBpbnZhbGlkRGF0ZTogZGVmYXVsdEludmFsaWREYXRlLFxuICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgIHJlbGF0aXZlVGltZTogZGVmYXVsdFJlbGF0aXZlVGltZSxcblxuICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgd2VlazogZGVmYXVsdExvY2FsZVdlZWssXG5cbiAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgd2Vla2RheXNTaG9ydDogZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQsXG5cbiAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxufTtcblxuLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xudmFyIGxvY2FsZXMgPSB7fTtcbnZhciBsb2NhbGVGYW1pbGllcyA9IHt9O1xudmFyIGdsb2JhbExvY2FsZTtcblxuZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbn1cblxuLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4vLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuLy8gc3Vic3RyaW5nIGZyb20gbW9zdCBzcGVjaWZpYyB0byBsZWFzdCwgYnV0IG1vdmUgdG8gdGhlIG5leHQgYXJyYXkgaXRlbSBpZiBpdCdzIGEgbW9yZSBzcGVjaWZpYyB2YXJpYW50IHRoYW4gdGhlIGN1cnJlbnQgcm9vdFxuZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICB2YXIgb2xkTG9jYWxlID0gbnVsbDtcbiAgICAvLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byByZWdpc3RlciBhbmQgbG9hZCBhbGwgdGhlIGxvY2FsZXMgaW4gTm9kZVxuICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICBtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgIHJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgZGVmaW5lTG9jYWxlIGN1cnJlbnRseSBhbHNvIHNldHMgdGhlIGdsb2JhbCBsb2NhbGUsIHdlXG4gICAgICAgICAgICAvLyB3YW50IHRvIHVuZG8gdGhhdCBmb3IgbGF6eSBsb2FkZWQgbG9jYWxlc1xuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxuICAgIH1cbiAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4vLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuLy8gbG9jYWxlIGtleS5cbmZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICB2YXIgZGF0YTtcbiAgICBpZiAoa2V5KSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZXMpKSB7XG4gICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2xvYmFsTG9jYWxlLl9hYmJyO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVMb2NhbGUgKG5hbWUsIGNvbmZpZykge1xuICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKCdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICd1c2UgbW9tZW50LnVwZGF0ZUxvY2FsZShsb2NhbGVOYW1lLCBjb25maWcpIHRvIGNoYW5nZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZGVmaW5lLWxvY2FsZS8gZm9yIG1vcmUgaW5mby4nKTtcbiAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgaWYgKGxvY2FsZUZhbWlsaWVzW25hbWVdKSB7XG4gICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIHNldCB0aGUgbG9jYWxlIEFGVEVSIGFsbCBjaGlsZCBsb2NhbGVzIGhhdmUgYmVlblxuICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXG4gICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGxvY2FsZSwgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZyA9IG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZyk7XG4gICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgbG9jYWxlLnBhcmVudExvY2FsZSA9IGxvY2FsZXNbbmFtZV07XG4gICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGU7XG5cbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG59XG5cbi8vIHJldHVybnMgbG9jYWxlIGRhdGFcbmZ1bmN0aW9uIGdldExvY2FsZSAoa2V5KSB7XG4gICAgdmFyIGxvY2FsZTtcblxuICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgaWYgKCFrZXkpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSBba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG59XG5cbmZ1bmN0aW9uIGxpc3RMb2NhbGVzKCkge1xuICAgIHJldHVybiBrZXlzJDEobG9jYWxlcyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrT3ZlcmZsb3cgKG0pIHtcbiAgICB2YXIgb3ZlcmZsb3c7XG4gICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICBvdmVyZmxvdyA9XG4gICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgIGFbSE9VUl0gICAgICAgIDwgMCB8fCBhW0hPVVJdICAgICAgICA+IDI0IHx8IChhW0hPVVJdID09PSAyNCAmJiAoYVtNSU5VVEVdICE9PSAwIHx8IGFbU0VDT05EXSAhPT0gMCB8fCBhW01JTExJU0VDT05EXSAhPT0gMCkpID8gSE9VUiA6XG4gICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcbiAgICAgICAgICAgIC0xO1xuXG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla3MgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrZGF5ICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIGlzbyA4NjAxIHJlZ2V4XG4vLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbnZhciBleHRlbmRlZElzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzpcXGRcXGQtXFxkXFxkfFdcXGRcXGQtXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86OlxcZFxcZCg/OjpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xudmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuXG52YXIgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LztcblxudmFyIGlzb0RhdGVzID0gW1xuICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxuICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcbiAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgIC8vIFlZWVlNTSBpcyBOT1QgYWxsb3dlZCBieSB0aGUgc3RhbmRhcmRcbiAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgWydZWVlZREREJywgL1xcZHs3fS9dXG5dO1xuXG4vLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG52YXIgaXNvVGltZXMgPSBbXG4gICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcbiAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgWydISCcsIC9cXGRcXGQvXVxuXTtcblxudmFyIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2k7XG5cbi8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XG5mdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgIHZhciBpLCBsLFxuICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgIGFsbG93VGltZSwgZGF0ZUZvcm1hdCwgdGltZUZvcm1hdCwgdHpGb3JtYXQ7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgYWxsb3dUaW1lID0gaXNvRGF0ZXNbaV1bMl0gIT09IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIHRpbWVGb3JtYXQgPSAobWF0Y2hbMl0gfHwgJyAnKSArIGlzb1RpbWVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYWxsb3dUaW1lICYmIHRpbWVGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgIHR6Rm9ybWF0ID0gJ1onO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLl9mID0gZGF0ZUZvcm1hdCArICh0aW1lRm9ybWF0IHx8ICcnKSArICh0ekZvcm1hdCB8fCAnJyk7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIFJGQyAyODIyIHJlZ2V4OiBGb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjc2VjdGlvbi0zLjNcbnZhciBiYXNpY1JmY1JlZ2V4ID0gL14oKD86TW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkP1xcZFxccyg/OkphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyg/OlxcZFxcZCk/XFxkXFxkXFxzKShcXGRcXGQ6XFxkXFxkKShcXDpcXGRcXGQpPyhcXHMoPzpVVHxHTVR8W0VDTVBdW1NEXVR8W0EtSUstWmEtaWstel18WystXVxcZHs0fSkpJC87XG5cbi8vIGRhdGUgYW5kIHRpbWUgZnJvbSByZWYgMjgyMiBmb3JtYXRcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZykge1xuICAgIHZhciBzdHJpbmcsIG1hdGNoLCBkYXlGb3JtYXQsXG4gICAgICAgIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuICAgIHZhciB0aW1lem9uZXMgPSB7XG4gICAgICAgICcgR01UJzogJyArMDAwMCcsXG4gICAgICAgICcgRURUJzogJyAtMDQwMCcsXG4gICAgICAgICcgRVNUJzogJyAtMDUwMCcsXG4gICAgICAgICcgQ0RUJzogJyAtMDUwMCcsXG4gICAgICAgICcgQ1NUJzogJyAtMDYwMCcsXG4gICAgICAgICcgTURUJzogJyAtMDYwMCcsXG4gICAgICAgICcgTVNUJzogJyAtMDcwMCcsXG4gICAgICAgICcgUERUJzogJyAtMDcwMCcsXG4gICAgICAgICcgUFNUJzogJyAtMDgwMCdcbiAgICB9O1xuICAgIHZhciBtaWxpdGFyeSA9ICdZWFdWVVRTUlFQT05aQUJDREVGR0hJS0xNJztcbiAgICB2YXIgdGltZXpvbmUsIHRpbWV6b25lSW5kZXg7XG5cbiAgICBzdHJpbmcgPSBjb25maWcuX2lcbiAgICAgICAgLnJlcGxhY2UoL1xcKFteXFwpXSpcXCl8W1xcblxcdF0vZywgJyAnKSAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZVxuICAgICAgICAucmVwbGFjZSgvKFxcc1xccyspL2csICcgJykgLy8gUmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAucmVwbGFjZSgvXlxcc3xcXHMkL2csICcnKTsgLy8gUmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlc1xuICAgIG1hdGNoID0gYmFzaWNSZmNSZWdleC5leGVjKHN0cmluZyk7XG5cbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZGF5Rm9ybWF0ID0gbWF0Y2hbMV0gPyAnZGRkJyArICgobWF0Y2hbMV0ubGVuZ3RoID09PSA1KSA/ICcsICcgOiAnICcpIDogJyc7XG4gICAgICAgIGRhdGVGb3JtYXQgPSAnRCBNTU0gJyArICgobWF0Y2hbMl0ubGVuZ3RoID4gMTApID8gJ1lZWVkgJyA6ICdZWSAnKTtcbiAgICAgICAgdGltZUZvcm1hdCA9ICdISDptbScgKyAobWF0Y2hbNF0gPyAnOnNzJyA6ICcnKTtcblxuICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoZSB2YW5pbGxhIEpTIERhdGUgb2JqZWN0IHdpdGggYW4gaW5kZXBlbnRlbnQgZGF5LW9mLXdlZWsgY2hlY2suXG4gICAgICAgIGlmIChtYXRjaFsxXSkgeyAvLyBkYXkgb2Ygd2VlayBnaXZlblxuICAgICAgICAgICAgdmFyIG1vbWVudERhdGUgPSBuZXcgRGF0ZShtYXRjaFsyXSk7XG4gICAgICAgICAgICB2YXIgbW9tZW50RGF5ID0gWydTdW4nLCdNb24nLCdUdWUnLCdXZWQnLCdUaHUnLCdGcmknLCdTYXQnXVttb21lbnREYXRlLmdldERheSgpXTtcblxuICAgICAgICAgICAgaWYgKG1hdGNoWzFdLnN1YnN0cigwLDMpICE9PSBtb21lbnREYXkpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAobWF0Y2hbNV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDI6IC8vIG1pbGl0YXJ5XG4gICAgICAgICAgICAgICAgaWYgKHRpbWV6b25lSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXpvbmUgPSAnICswMDAwJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aW1lem9uZUluZGV4ID0gbWlsaXRhcnkuaW5kZXhPZihtYXRjaFs1XVsxXS50b1VwcGVyQ2FzZSgpKSAtIDEyO1xuICAgICAgICAgICAgICAgICAgICB0aW1lem9uZSA9ICgodGltZXpvbmVJbmRleCA8IDApID8gJyAtJyA6ICcgKycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgoJycgKyB0aW1lem9uZUluZGV4KS5yZXBsYWNlKC9eLT8vLCAnMCcpKS5tYXRjaCgvLi4kLylbMF0gKyAnMDAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDogLy8gWm9uZVxuICAgICAgICAgICAgICAgIHRpbWV6b25lID0gdGltZXpvbmVzW21hdGNoWzVdXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IC8vIFVUIG9yICsvLTk5OTlcbiAgICAgICAgICAgICAgICB0aW1lem9uZSA9IHRpbWV6b25lc1snIEdNVCddO1xuICAgICAgICB9XG4gICAgICAgIG1hdGNoWzVdID0gdGltZXpvbmU7XG4gICAgICAgIGNvbmZpZy5faSA9IG1hdGNoLnNwbGljZSgxKS5qb2luKCcnKTtcbiAgICAgICAgdHpGb3JtYXQgPSAnIFpaJztcbiAgICAgICAgY29uZmlnLl9mID0gZGF5Rm9ybWF0ICsgZGF0ZUZvcm1hdCArIHRpbWVGb3JtYXQgKyB0ekZvcm1hdDtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5yZmMyODIyID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG59XG5cbi8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcblxuICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG59XG5cbmhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICd2YWx1ZSBwcm92aWRlZCBpcyBub3QgaW4gYSByZWNvZ25pemVkIFJGQzI4MjIgb3IgSVNPIGZvcm1hdC4gbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUoKSwgJyArXG4gICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYW4gdXBjb21pbmcgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHJlZmVyIHRvICcgK1xuICAgICdodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvIGZvciBtb3JlIGluZm8uJyxcbiAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgfVxuKTtcblxuLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgIGlmIChhICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIGlmIChiICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgIC8vIGhvb2tzIGlzIGFjdHVhbGx5IHRoZSBleHBvcnRlZCBtb21lbnQgb2JqZWN0XG4gICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCksIG5vd1ZhbHVlLmdldFVUQ01vbnRoKCksIG5vd1ZhbHVlLmdldFVUQ0RhdGUoKV07XG4gICAgfVxuICAgIHJldHVybiBbbm93VmFsdWUuZ2V0RnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0TW9udGgoKSwgbm93VmFsdWUuZ2V0RGF0ZSgpXTtcbn1cblxuLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4vLyB0aGUgYXJyYXkgc2hvdWxkIG1pcnJvciB0aGUgcGFyYW1ldGVycyBiZWxvd1xuLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4vLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbmZ1bmN0aW9uIGNvbmZpZ0Zyb21BcnJheSAoY29uZmlnKSB7XG4gICAgdmFyIGksIGRhdGUsIGlucHV0ID0gW10sIGN1cnJlbnREYXRlLCB5ZWFyVG9Vc2U7XG5cbiAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICB9XG5cbiAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgIT0gbnVsbCkge1xuICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHwgY29uZmlnLl9kYXlPZlllYXIgPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd0RheU9mWWVhciA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgY29uZmlnLl9hW01PTlRIXSA9IGRhdGUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IGRhdGUuXG4gICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgLy8gKiBpZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBvbmx5IHllYXJcbiAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gY3VycmVudERhdGVbaV07XG4gICAgfVxuXG4gICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgZm9yICg7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIDI0OjAwOjAwLjAwMFxuICAgIGlmIChjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW1NFQ09ORF0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDApIHtcbiAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcbiAgICB9XG5cbiAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHV0Y09mZnNldCBjYW4gYmUgY2hhbmdlZFxuICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3c7XG5cbiAgICB3ID0gY29uZmlnLl93O1xuICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgZG93ID0gMTtcbiAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LkdHLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhcik7XG4gICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICB3ZWVrZGF5ID0gZGVmYXVsdHMody5FLCAxKTtcbiAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XG5cbiAgICAgICAgdmFyIGN1cldlZWsgPSB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIGRvdywgZG95KTtcblxuICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgY3VyV2Vlay55ZWFyKTtcblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgd2Vlay5cbiAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgY3VyV2Vlay53ZWVrKTtcblxuICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMCB8fCB3ZWVrZGF5ID4gNikge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAody5lICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh3ZWVrZGF5T3ZlcmZsb3cgIT0gbnVsbCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICB9XG59XG5cbi8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbmhvb2tzLklTT184NjAxID0gZnVuY3Rpb24gKCkge307XG5cbi8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBSRkMgMjgyMiBmb3JtXG5ob29rcy5SRkNfMjgyMiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuSVNPXzg2MDEpIHtcbiAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLlJGQ18yODIyKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uZmlnLl9hID0gW107XG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSB0cnVlO1xuXG4gICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3Rva2VuJywgdG9rZW4sICdwYXJzZWRJbnB1dCcsIHBhcnNlZElucHV0LFxuICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XG4gICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICB9XG5cbiAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgIGlmIChjb25maWcuX2FbSE9VUl0gPD0gMTIgJiZcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucGFyc2VkRGF0ZVBhcnRzID0gY29uZmlnLl9hLnNsaWNlKDApO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG59XG5cblxuZnVuY3Rpb24gbWVyaWRpZW1GaXhXcmFwIChsb2NhbGUsIGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgdmFyIGlzUG07XG5cbiAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgIHJldHVybiBob3VyO1xuICAgIH1cbiAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgLy8gRmFsbGJhY2tcbiAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgIHJldHVybiBob3VyO1xuICAgIH1cbn1cblxuLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbmZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgYmVzdE1vbWVudCxcblxuICAgICAgICBzY29yZVRvQmVhdCxcbiAgICAgICAgaSxcbiAgICAgICAgY3VycmVudFNjb3JlO1xuXG4gICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICBpZiAoIWlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgY3VycmVudFNjb3JlICs9IGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5jaGFyc0xlZnRPdmVyO1xuXG4gICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyh0ZW1wQ29uZmlnKS5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgIGNvbmZpZy5fYSA9IG1hcChbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgIH0pO1xuXG4gICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcgKGNvbmZpZykge1xuICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcbiAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUNvbmZpZyAoY29uZmlnKSB7XG4gICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGdldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgaWYgKGlucHV0ID09PSBudWxsIHx8IChmb3JtYXQgPT09IHVuZGVmaW5lZCAmJiBpbnB1dCA9PT0gJycpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICB9XG5cbiAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgIH0gIGVsc2Uge1xuICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzVmFsaWQoY29uZmlnKSkge1xuICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjb25maWc7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICB2YXIgaW5wdXQgPSBjb25maWcuX2k7XG4gICAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgdmFyIGMgPSB7fTtcblxuICAgIGlmIChsb2NhbGUgPT09IHRydWUgfHwgbG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoKGlzT2JqZWN0KGlucHV0KSAmJiBpc09iamVjdEVtcHR5KGlucHV0KSkgfHxcbiAgICAgICAgICAgIChpc0FycmF5KGlucHV0KSAmJiBpbnB1dC5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgIGMuX2lzQU1vbWVudE9iamVjdCA9IHRydWU7XG4gICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICBjLl9sID0gbG9jYWxlO1xuICAgIGMuX2kgPSBpbnB1dDtcbiAgICBjLl9mID0gZm9ybWF0O1xuICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xufVxuXG52YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICdtb21lbnQoKS5taW4gaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgfVxuICAgIH1cbik7XG5cbnZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICB9XG4gICAgfVxuKTtcblxuLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbi8vIG90aGVyLiBUaGlzIHJlbGllcyBvbiB0aGUgZnVuY3Rpb24gZm4gdG8gYmUgdHJhbnNpdGl2ZS5cbi8vXG4vLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4vLyBmaXJzdCBlbGVtZW50IGlzIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzLlxuZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgdmFyIHJlcywgaTtcbiAgICBpZiAobW9tZW50cy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShtb21lbnRzWzBdKSkge1xuICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICB9XG4gICAgaWYgKCFtb21lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICB9XG4gICAgcmVzID0gbW9tZW50c1swXTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vbWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbmZ1bmN0aW9uIG1pbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xufVxuXG5mdW5jdGlvbiBtYXggKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xufVxuXG52YXIgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArKG5ldyBEYXRlKCkpO1xufTtcblxudmFyIG9yZGVyaW5nID0gWyd5ZWFyJywgJ3F1YXJ0ZXInLCAnbW9udGgnLCAnd2VlaycsICdkYXknLCAnaG91cicsICdtaW51dGUnLCAnc2Vjb25kJywgJ21pbGxpc2Vjb25kJ107XG5cbmZ1bmN0aW9uIGlzRHVyYXRpb25WYWxpZChtKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG0pIHtcbiAgICAgICAgaWYgKCEob3JkZXJpbmcuaW5kZXhPZihrZXkpICE9PSAtMSAmJiAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuaXRIYXNEZWNpbWFsID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAobVtvcmRlcmluZ1tpXV0pIHtcbiAgICAgICAgICAgIGlmICh1bml0SGFzRGVjaW1hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KG1bb3JkZXJpbmdbaV1dKSAhPT0gdG9JbnQobVtvcmRlcmluZ1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihOYU4pO1xufVxuXG5mdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgMCxcbiAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgIHRoaXMuX2lzVmFsaWQgPSBpc0R1cmF0aW9uVmFsaWQobm9ybWFsaXplZElucHV0KTtcblxuICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgIHNlY29uZHMgKiAxZTMgKyAvLyAxMDAwXG4gICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgLy8gQmVjYXVzZSBvZiBkYXRlQWRkUmVtb3ZlIHRyZWF0cyAyNCBob3VycyBhcyBkaWZmZXJlbnQgZnJvbSBhXG4gICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgIHRoaXMuX2RheXMgPSArZGF5cyArXG4gICAgICAgIHdlZWtzICogNztcbiAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgcXVhcnRlcnMgKiAzICtcbiAgICAgICAgeWVhcnMgKiAxMjtcblxuICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgIHRoaXMuX2xvY2FsZSA9IGdldExvY2FsZSgpO1xuXG4gICAgdGhpcy5fYnViYmxlKCk7XG59XG5cbmZ1bmN0aW9uIGlzRHVyYXRpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbn1cblxuZnVuY3Rpb24gYWJzUm91bmQgKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgfVxufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduICsgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArIHNlcGFyYXRvciArIHplcm9GaWxsKH5+KG9mZnNldCkgJSA2MCwgMik7XG4gICAgfSk7XG59XG5cbm9mZnNldCgnWicsICc6Jyk7XG5vZmZzZXQoJ1paJywgJycpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1onLCAgbWF0Y2hTaG9ydE9mZnNldCk7XG5hZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG4vLyB0aW1lem9uZSBjaHVua2VyXG4vLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbi8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxudmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG5mdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgIHZhciBtYXRjaGVzID0gKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlcik7XG5cbiAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICB2YXIgcGFydHMgICA9IChjaHVuayArICcnKS5tYXRjaChjaHVua09mZnNldCkgfHwgWyctJywgMCwgMF07XG4gICAgdmFyIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgP1xuICAgICAgMCA6XG4gICAgICBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xufVxuXG4vLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuZnVuY3Rpb24gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCBtb2RlbCkge1xuICAgIHZhciByZXMsIGRpZmY7XG4gICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gaW5wdXQudmFsdWVPZigpIDogY3JlYXRlTG9jYWwoaW5wdXQpLnZhbHVlT2YoKSkgLSByZXMudmFsdWVPZigpO1xuICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXG4gICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcbiAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L3B1bGwvMTg3MVxuICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcbn1cblxuLy8gSE9PS1NcblxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG5ob29rcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gTU9NRU5UU1xuXG4vLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbi8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt1dGNPZmZzZXQoMiwgdHJ1ZSldLS0+XG4vLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4vLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4vL1xuLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4vLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbi8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cbi8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbmZ1bmN0aW9uIGdldFNldE9mZnNldCAoaW5wdXQsIGtlZXBMb2NhbFRpbWUsIGtlZXBNaW51dGVzKSB7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICBsb2NhbEFkanVzdDtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICB9XG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlucHV0ID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNiAmJiAha2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9mZnNldCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51dGNPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtdGhpcy51dGNPZmZzZXQoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldE9mZnNldFRvVVRDIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xufVxuXG5mdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICBpZiAodGhpcy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy51dGNPZmZzZXQodGhpcy5fdHptLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHRab25lID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSk7XG4gICAgICAgIGlmICh0Wm9uZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQgKGlucHV0KSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgcmV0dXJuICh0aGlzLnV0Y09mZnNldCgpIC0gaW5wdXQpICUgNjAgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDApLnV0Y09mZnNldCgpIHx8XG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICApO1xufVxuXG5mdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIHZhciBjID0ge307XG5cbiAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgaWYgKGMuX2EpIHtcbiAgICAgICAgdmFyIG90aGVyID0gYy5faXNVVEMgPyBjcmVhdGVVVEMoYy5fYSkgOiBjcmVhdGVMb2NhbChjLl9hKTtcbiAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbn1cblxuZnVuY3Rpb24gaXNMb2NhbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gIXRoaXMuX2lzVVRDIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzVXRjT2Zmc2V0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgJiYgdGhpcy5fb2Zmc2V0ID09PSAwIDogZmFsc2U7XG59XG5cbi8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxudmFyIGFzcE5ldFJlZ2V4ID0gL14oXFwtKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKykoXFwuXFxkKik/KT8kLztcblxuLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbi8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcbi8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbnZhciBpc29SZWdleCA9IC9eKC0pP1AoPzooLT9bMC05LC5dKilZKT8oPzooLT9bMC05LC5dKilNKT8oPzooLT9bMC05LC5dKilXKT8oPzooLT9bMC05LC5dKilEKT8oPzpUKD86KC0/WzAtOSwuXSopSCk/KD86KC0/WzAtOSwuXSopTSk/KD86KC0/WzAtOSwuXSopUyk/KT8kLztcblxuZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICBzaWduLFxuICAgICAgICByZXQsXG4gICAgICAgIGRpZmZSZXM7XG5cbiAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkICA6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgTSAgOiBpbnB1dC5fbW9udGhzXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkpIHtcbiAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9IGlucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgbSAgOiB0b0ludChtYXRjaFtNSU5VVEVdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgbXMgOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgc2lnbiA9IChtYXRjaFsxXSA9PT0gJy0nKSA/IC0xIDogMTtcbiAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICB5IDogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgTSA6IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgIHcgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICBkIDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgIG0gOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICBzIDogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJiAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pKSB7XG4gICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShjcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSwgY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pKTtcblxuICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgfVxuXG4gICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xufVxuXG5jcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcbmNyZWF0ZUR1cmF0aW9uLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkJDE7XG5cbmZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xufVxuXG5mdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgdmFyIHJlcyA9IHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG5cbiAgICByZXMubW9udGhzID0gb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArXG4gICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgIC0tcmVzLm1vbnRocztcbiAgICB9XG5cbiAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICB2YXIgcmVzO1xuICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG4gICAgfVxuXG4gICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2FkZC1pbnZlcnRlZC1wYXJhbS8gZm9yIG1vcmUgaW5mby4nKTtcbiAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgIH1cblxuICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICt2YWwgOiB2YWw7XG4gICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhZGRTdWJ0cmFjdCAobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcblxuICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAvLyBObyBvcFxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgIH1cbiAgICBpZiAoZGF5cykge1xuICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgfVxuICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgc2V0TW9udGgobW9tLCBnZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZU9mZnNldCkge1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgfVxufVxuXG52YXIgYWRkICAgICAgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyk7XG52YXIgc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbmZ1bmN0aW9uIGdldENhbGVuZGFyRm9ybWF0KG15TW9tZW50LCBub3cpIHtcbiAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xuICAgIHJldHVybiBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcbiAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxuICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbn1cblxuZnVuY3Rpb24gY2FsZW5kYXIkMSAodGltZSwgZm9ybWF0cykge1xuICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgdmFyIG5vdyA9IHRpbWUgfHwgY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJztcblxuICAgIHZhciBvdXRwdXQgPSBmb3JtYXRzICYmIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSkgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgIHJldHVybiB0aGlzLmZvcm1hdChvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKSk7XG59XG5cbmZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbn1cblxuZnVuY3Rpb24gaXNBZnRlciAoaW5wdXQsIHVuaXRzKSB7XG4gICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKCFpc1VuZGVmaW5lZCh1bml0cykgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbG9jYWxJbnB1dC52YWx1ZU9mKCkgPCB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNCZWZvcmUgKGlucHV0LCB1bml0cykge1xuICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0JldHdlZW4gKGZyb20sIHRvLCB1bml0cywgaW5jbHVzaXZpdHkpIHtcbiAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgcmV0dXJuIChpbmNsdXNpdml0eVswXSA9PT0gJygnID8gdGhpcy5pc0FmdGVyKGZyb20sIHVuaXRzKSA6ICF0aGlzLmlzQmVmb3JlKGZyb20sIHVuaXRzKSkgJiZcbiAgICAgICAgKGluY2x1c2l2aXR5WzFdID09PSAnKScgPyB0aGlzLmlzQmVmb3JlKHRvLCB1bml0cykgOiAhdGhpcy5pc0FmdGVyKHRvLCB1bml0cykpO1xufVxuXG5mdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCksXG4gICAgICAgIGlucHV0TXM7XG4gICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyB8fCAnbWlsbGlzZWNvbmQnKTtcbiAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbnB1dE1zID0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCx1bml0cyk7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LHVuaXRzKTtcbn1cblxuZnVuY3Rpb24gZGlmZiAoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XG4gICAgdmFyIHRoYXQsXG4gICAgICAgIHpvbmVEZWx0YSxcbiAgICAgICAgZGVsdGEsIG91dHB1dDtcblxuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgIGlmICghdGhhdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0O1xuXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICBpZiAodW5pdHMgPT09ICd5ZWFyJyB8fCB1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDM7XG4gICAgICAgIH0gZWxzZSBpZiAodW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0IC8gMTI7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBkZWx0YSA9IHRoaXMgLSB0aGF0O1xuICAgICAgICBvdXRwdXQgPSB1bml0cyA9PT0gJ3NlY29uZCcgPyBkZWx0YSAvIDFlMyA6IC8vIDEwMDBcbiAgICAgICAgICAgIHVuaXRzID09PSAnbWludXRlJyA/IGRlbHRhIC8gNmU0IDogLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICB1bml0cyA9PT0gJ2hvdXInID8gZGVsdGEgLyAzNmU1IDogLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgIHVuaXRzID09PSAnZGF5JyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA4NjRlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIHVuaXRzID09PSAnd2VlaycgPyAoZGVsdGEgLSB6b25lRGVsdGEpIC8gNjA0OGU1IDogLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGRlbHRhO1xuICAgIH1cbiAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG59XG5cbmZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgdmFyIHdob2xlTW9udGhEaWZmID0gKChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyKSArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgIGFuY2hvcjIsIGFkanVzdDtcblxuICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiAtIDEsICdtb250aHMnKTtcbiAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICBhZGp1c3QgPSAoYiAtIGFuY2hvcikgLyAoYW5jaG9yMiAtIGFuY2hvcik7XG4gICAgfVxuXG4gICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KSB8fCAwO1xufVxuXG5ob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcbmhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgPSAnWVlZWS1NTS1ERFRISDptbTpzc1taXSc7XG5cbmZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG59XG5cbmZ1bmN0aW9uIHRvSVNPU3RyaW5nKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBtID0gdGhpcy5jbG9uZSgpLnV0YygpO1xuICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbihEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZykpIHtcbiAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgcmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGh1bWFuIHJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9tZW50IHRoYXQgY2FuXG4gKiBhbHNvIGJlIGV2YWx1YXRlZCB0byBnZXQgYSBuZXcgbW9tZW50IHdoaWNoIGlzIHRoZSBzYW1lXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL3V0aWwuaHRtbCN1dGlsX2N1c3RvbV9pbnNwZWN0X2Z1bmN0aW9uX29uX29iamVjdHNcbiAqL1xuZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgIH1cbiAgICB2YXIgZnVuYyA9ICdtb21lbnQnO1xuICAgIHZhciB6b25lID0gJyc7XG4gICAgaWYgKCF0aGlzLmlzTG9jYWwoKSkge1xuICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgem9uZSA9ICdaJztcbiAgICB9XG4gICAgdmFyIHByZWZpeCA9ICdbJyArIGZ1bmMgKyAnKFwiXSc7XG4gICAgdmFyIHllYXIgPSAoMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5KSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgIHZhciBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgIHZhciBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKSA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGMgOiBob29rcy5kZWZhdWx0Rm9ybWF0O1xuICAgIH1cbiAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmcm9tTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbn1cblxuZnVuY3Rpb24gdG8gKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe2Zyb206IHRoaXMsIHRvOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRvTm93ICh3aXRob3V0U3VmZml4KSB7XG4gICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG59XG5cbi8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcbi8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbi8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbmZ1bmN0aW9uIGxvY2FsZSAoa2V5KSB7XG4gICAgdmFyIG5ld0xvY2FsZURhdGE7XG5cbiAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG52YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbik7XG5cbmZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xuICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgLy8gdGhlIGZvbGxvd2luZyBzd2l0Y2ggaW50ZW50aW9uYWxseSBvbWl0cyBicmVhayBrZXl3b3Jkc1xuICAgIC8vIHRvIHV0aWxpemUgZmFsbGluZyB0aHJvdWdoIHRoZSBjYXNlcy5cbiAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgdGhpcy5tb250aCgwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgIHRoaXMuZGF0ZSgxKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgIHRoaXMuaG91cnMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgdGhpcy5taW51dGVzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgdGhpcy5zZWNvbmRzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZHMoMCk7XG4gICAgfVxuXG4gICAgLy8gd2Vla3MgYXJlIGEgc3BlY2lhbCBjYXNlXG4gICAgaWYgKHVuaXRzID09PSAnd2VlaycpIHtcbiAgICAgICAgdGhpcy53ZWVrZGF5KDApO1xuICAgIH1cbiAgICBpZiAodW5pdHMgPT09ICdpc29XZWVrJykge1xuICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XG4gICAgfVxuXG4gICAgLy8gcXVhcnRlcnMgYXJlIGFsc28gc3BlY2lhbFxuICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgIHRoaXMubW9udGgoTWF0aC5mbG9vcih0aGlzLm1vbnRoKCkgLyAzKSAqIDMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBlbmRPZiAodW5pdHMpIHtcbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyAnZGF0ZScgaXMgYW4gYWxpYXMgZm9yICdkYXknLCBzbyBpdCBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyBzdWNoLlxuICAgIGlmICh1bml0cyA9PT0gJ2RhdGUnKSB7XG4gICAgICAgIHVuaXRzID0gJ2RheSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RhcnRPZih1bml0cykuYWRkKDEsICh1bml0cyA9PT0gJ2lzb1dlZWsnID8gJ3dlZWsnIDogdW5pdHMpKS5zdWJ0cmFjdCgxLCAnbXMnKTtcbn1cblxuZnVuY3Rpb24gdmFsdWVPZiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2QudmFsdWVPZigpIC0gKCh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMCk7XG59XG5cbmZ1bmN0aW9uIHVuaXggKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMudmFsdWVPZigpIC8gMTAwMCk7XG59XG5cbmZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgdmFyIG0gPSB0aGlzO1xuICAgIHJldHVybiBbbS55ZWFyKCksIG0ubW9udGgoKSwgbS5kYXRlKCksIG0uaG91cigpLCBtLm1pbnV0ZSgpLCBtLnNlY29uZCgpLCBtLm1pbGxpc2Vjb25kKCldO1xufVxuXG5mdW5jdGlvbiB0b09iamVjdCAoKSB7XG4gICAgdmFyIG0gPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMudG9JU09TdHJpbmcoKSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWQkMiAoKSB7XG4gICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNpbmdGbGFncyAoKSB7XG4gICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZEF0ICgpIHtcbiAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xufVxuXG5mdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3RcbiAgICB9O1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbn0pO1xuXG5mdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xufVxuXG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZ2cnLCAgICAnd2Vla1llYXInKTtcbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAgJ2lzb1dlZWtZZWFyJyk7XG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbmFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCd3ZWVrWWVhcicsIDEpO1xuYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignRycsICAgICAgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignR0cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignZ2cnLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignZ2dnZycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignR0dHR0cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG59KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICB3ZWVrW3Rva2VuXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbn0pO1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhciAoaW5wdXQpIHtcbiAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG59XG5cbmZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyICgpIHtcbiAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xufVxuXG5mdW5jdGlvbiBnZXRXZWVrc0luWWVhciAoKSB7XG4gICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG59XG5cbmZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xufSk7XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0UXVhcnRlciAoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuLy8gUFJJT1JPSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdEJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgcmV0dXJuIGlzU3RyaWN0ID9cbiAgICAgIChsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2UpIDpcbiAgICAgIGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQ7XG59KTtcblxuYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG5hZGRQYXJzZVRva2VuKCdEbycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0sIDEwKTtcbn0pO1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXREYXlPZk1vbnRoID0gbWFrZUdldFNldCgnRGF0ZScsIHRydWUpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbi8vIFBSSU9SSVRZXG5hZGRVbml0UHJpb3JpdHkoJ2RheU9mWWVhcicsIDQpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ0RERCcsICBtYXRjaDF0bzMpO1xuYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG5hZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG59KTtcblxuLy8gSEVMUEVSU1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldERheU9mWWVhciAoaW5wdXQpIHtcbiAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdtaW51dGUnLCAxNCk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignbScsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdzJywgWydzcycsIDJdLCAwLCAnc2Vjb25kJyk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdzJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbi8vIE1PTUVOVFNcblxudmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTUycsIDRdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTJywgNV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTUycsIDZdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG59KTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTUycsIDddLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTJywgOF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1NTUycsIDldLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG59KTtcblxuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdTJywgICAgbWF0Y2gxdG8zLCBtYXRjaDEpO1xuYWRkUmVnZXhUb2tlbignU1MnLCAgIG1hdGNoMXRvMywgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbnZhciB0b2tlbjtcbmZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xufVxuXG5mb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG59XG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcbmFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFpvbmVBYmJyICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xufVxuXG5mdW5jdGlvbiBnZXRab25lTmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xufVxuXG52YXIgcHJvdG8gPSBNb21lbnQucHJvdG90eXBlO1xuXG5wcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZDtcbnByb3RvLmNhbGVuZGFyICAgICAgICAgID0gY2FsZW5kYXIkMTtcbnByb3RvLmNsb25lICAgICAgICAgICAgID0gY2xvbmU7XG5wcm90by5kaWZmICAgICAgICAgICAgICA9IGRpZmY7XG5wcm90by5lbmRPZiAgICAgICAgICAgICA9IGVuZE9mO1xucHJvdG8uZm9ybWF0ICAgICAgICAgICAgPSBmb3JtYXQ7XG5wcm90by5mcm9tICAgICAgICAgICAgICA9IGZyb207XG5wcm90by5mcm9tTm93ICAgICAgICAgICA9IGZyb21Ob3c7XG5wcm90by50byAgICAgICAgICAgICAgICA9IHRvO1xucHJvdG8udG9Ob3cgICAgICAgICAgICAgPSB0b05vdztcbnByb3RvLmdldCAgICAgICAgICAgICAgID0gc3RyaW5nR2V0O1xucHJvdG8uaW52YWxpZEF0ICAgICAgICAgPSBpbnZhbGlkQXQ7XG5wcm90by5pc0FmdGVyICAgICAgICAgICA9IGlzQWZ0ZXI7XG5wcm90by5pc0JlZm9yZSAgICAgICAgICA9IGlzQmVmb3JlO1xucHJvdG8uaXNCZXR3ZWVuICAgICAgICAgPSBpc0JldHdlZW47XG5wcm90by5pc1NhbWUgICAgICAgICAgICA9IGlzU2FtZTtcbnByb3RvLmlzU2FtZU9yQWZ0ZXIgICAgID0gaXNTYW1lT3JBZnRlcjtcbnByb3RvLmlzU2FtZU9yQmVmb3JlICAgID0gaXNTYW1lT3JCZWZvcmU7XG5wcm90by5pc1ZhbGlkICAgICAgICAgICA9IGlzVmFsaWQkMjtcbnByb3RvLmxhbmcgICAgICAgICAgICAgID0gbGFuZztcbnByb3RvLmxvY2FsZSAgICAgICAgICAgID0gbG9jYWxlO1xucHJvdG8ubG9jYWxlRGF0YSAgICAgICAgPSBsb2NhbGVEYXRhO1xucHJvdG8ubWF4ICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNYXg7XG5wcm90by5taW4gICAgICAgICAgICAgICA9IHByb3RvdHlwZU1pbjtcbnByb3RvLnBhcnNpbmdGbGFncyAgICAgID0gcGFyc2luZ0ZsYWdzO1xucHJvdG8uc2V0ICAgICAgICAgICAgICAgPSBzdHJpbmdTZXQ7XG5wcm90by5zdGFydE9mICAgICAgICAgICA9IHN0YXJ0T2Y7XG5wcm90by5zdWJ0cmFjdCAgICAgICAgICA9IHN1YnRyYWN0O1xucHJvdG8udG9BcnJheSAgICAgICAgICAgPSB0b0FycmF5O1xucHJvdG8udG9PYmplY3QgICAgICAgICAgPSB0b09iamVjdDtcbnByb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xucHJvdG8udG9JU09TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZztcbnByb3RvLmluc3BlY3QgICAgICAgICAgID0gaW5zcGVjdDtcbnByb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xucHJvdG8udG9TdHJpbmcgICAgICAgICAgPSB0b1N0cmluZztcbnByb3RvLnVuaXggICAgICAgICAgICAgID0gdW5peDtcbnByb3RvLnZhbHVlT2YgICAgICAgICAgID0gdmFsdWVPZjtcbnByb3RvLmNyZWF0aW9uRGF0YSAgICAgID0gY3JlYXRpb25EYXRhO1xuXG4vLyBZZWFyXG5wcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbnByb3RvLmlzTGVhcFllYXIgPSBnZXRJc0xlYXBZZWFyO1xuXG4vLyBXZWVrIFllYXJcbnByb3RvLndlZWtZZWFyICAgID0gZ2V0U2V0V2Vla1llYXI7XG5wcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuXG4vLyBRdWFydGVyXG5wcm90by5xdWFydGVyID0gcHJvdG8ucXVhcnRlcnMgPSBnZXRTZXRRdWFydGVyO1xuXG4vLyBNb250aFxucHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcbnByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG5cbi8vIFdlZWtcbnByb3RvLndlZWsgICAgICAgICAgID0gcHJvdG8ud2Vla3MgICAgICAgID0gZ2V0U2V0V2VlaztcbnByb3RvLmlzb1dlZWsgICAgICAgID0gcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbnByb3RvLndlZWtzSW5ZZWFyICAgID0gZ2V0V2Vla3NJblllYXI7XG5wcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuXG4vLyBEYXlcbnByb3RvLmRhdGUgICAgICAgPSBnZXRTZXREYXlPZk1vbnRoO1xucHJvdG8uZGF5ICAgICAgICA9IHByb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG5wcm90by53ZWVrZGF5ICAgID0gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrO1xucHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbnByb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG5cbi8vIEhvdXJcbnByb3RvLmhvdXIgPSBwcm90by5ob3VycyA9IGdldFNldEhvdXI7XG5cbi8vIE1pbnV0ZVxucHJvdG8ubWludXRlID0gcHJvdG8ubWludXRlcyA9IGdldFNldE1pbnV0ZTtcblxuLy8gU2Vjb25kXG5wcm90by5zZWNvbmQgPSBwcm90by5zZWNvbmRzID0gZ2V0U2V0U2Vjb25kO1xuXG4vLyBNaWxsaXNlY29uZFxucHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcblxuLy8gT2Zmc2V0XG5wcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbnByb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG5wcm90by5sb2NhbCAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvTG9jYWw7XG5wcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xucHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbnByb3RvLmlzRFNUICAgICAgICAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG5wcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG5wcm90by5pc1V0Y09mZnNldCAgICAgICAgICA9IGlzVXRjT2Zmc2V0O1xucHJvdG8uaXNVdGMgICAgICAgICAgICAgICAgPSBpc1V0YztcbnByb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG5cbi8vIFRpbWV6b25lXG5wcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xucHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcblxuLy8gRGVwcmVjYXRpb25zXG5wcm90by5kYXRlcyAgPSBkZXByZWNhdGUoJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJywgZ2V0U2V0RGF5T2ZNb250aCk7XG5wcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbnByb3RvLnllYXJzICA9IGRlcHJlY2F0ZSgneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsIGdldFNldFllYXIpO1xucHJvdG8uem9uZSAgID0gZGVwcmVjYXRlKCdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsIGdldFNldFpvbmUpO1xucHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKCdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJywgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKTtcblxuZnVuY3Rpb24gY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW5ab25lICgpIHtcbiAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbn1cblxuZnVuY3Rpb24gcHJlUGFyc2VQb3N0Rm9ybWF0IChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nO1xufVxuXG52YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbnByb3RvJDEuY2FsZW5kYXIgICAgICAgID0gY2FsZW5kYXI7XG5wcm90byQxLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xucHJvdG8kMS5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbnByb3RvJDEub3JkaW5hbCAgICAgICAgID0gb3JkaW5hbDtcbnByb3RvJDEucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xucHJvdG8kMS5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG5wcm90byQxLnJlbGF0aXZlVGltZSAgICA9IHJlbGF0aXZlVGltZTtcbnByb3RvJDEucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbnByb3RvJDEuc2V0ICAgICAgICAgICAgID0gc2V0O1xuXG4vLyBNb250aFxucHJvdG8kMS5tb250aHMgICAgICAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHM7XG5wcm90byQxLm1vbnRoc1Nob3J0ICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRoc1Nob3J0O1xucHJvdG8kMS5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbnByb3RvJDEubW9udGhzUmVnZXggICAgICAgPSBtb250aHNSZWdleDtcbnByb3RvJDEubW9udGhzU2hvcnRSZWdleCAgPSBtb250aHNTaG9ydFJlZ2V4O1xuXG4vLyBXZWVrXG5wcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xucHJvdG8kMS5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xucHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4vLyBEYXkgb2YgV2Vla1xucHJvdG8kMS53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbnByb3RvJDEud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG5wcm90byQxLndlZWtkYXlzU2hvcnQgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG5wcm90byQxLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbnByb3RvJDEud2Vla2RheXNSZWdleCAgICAgICA9ICAgICAgICB3ZWVrZGF5c1JlZ2V4O1xucHJvdG8kMS53ZWVrZGF5c1Nob3J0UmVnZXggID0gICAgICAgIHdlZWtkYXlzU2hvcnRSZWdleDtcbnByb3RvJDEud2Vla2RheXNNaW5SZWdleCAgICA9ICAgICAgICB3ZWVrZGF5c01pblJlZ2V4O1xuXG4vLyBIb3Vyc1xucHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbnByb3RvJDEubWVyaWRpZW0gPSBsb2NhbGVNZXJpZGllbTtcblxuZnVuY3Rpb24gZ2V0JDEgKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCBzZXR0ZXIpIHtcbiAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG4gICAgdmFyIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG59XG5cbmZ1bmN0aW9uIGxpc3RNb250aHNJbXBsIChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5cbi8vICgpXG4vLyAoNSlcbi8vIChmbXQsIDUpXG4vLyAoZm10KVxuLy8gKHRydWUpXG4vLyAodHJ1ZSwgNSlcbi8vICh0cnVlLCBmbXQsIDUpXG4vLyAodHJ1ZSwgZm10KVxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgIHNoaWZ0ID0gbG9jYWxlU29ydGVkID8gbG9jYWxlLl93ZWVrLmRvdyA6IDA7XG5cbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBsaXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbn1cblxuZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xufVxuXG5mdW5jdGlvbiBsaXN0V2Vla2RheXMgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzJyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0IChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbiAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbn1cblxuZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiAvXFxkezEsMn0odGh8c3R8bmR8cmQpLyxcbiAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xuICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgb3V0cHV0ID0gKHRvSW50KG51bWJlciAlIDEwMCAvIDEwKSA9PT0gMSkgPyAndGgnIDpcbiAgICAgICAgICAgIChiID09PSAxKSA/ICdzdCcgOlxuICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAoYiA9PT0gMykgPyAncmQnIDogJ3RoJztcbiAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICB9XG59KTtcblxuLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuaG9va3MubGFuZyA9IGRlcHJlY2F0ZSgnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLCBnZXRTZXRHbG9iYWxMb2NhbGUpO1xuaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBnZXRMb2NhbGUpO1xuXG52YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG5mdW5jdGlvbiBhYnMgKCkge1xuICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XG5cbiAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgdGhpcy5fZGF5cyAgICAgICAgID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICBkYXRhLm1pbGxpc2Vjb25kcyAgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICBkYXRhLnNlY29uZHMgICAgICAgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgIGRhdGEuaG91cnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS5ob3Vycyk7XG4gICAgZGF0YS5tb250aHMgICAgICAgID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBhZGRTdWJ0cmFjdCQxIChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgZHVyYXRpb24uX21pbGxpc2Vjb25kcyArPSBkaXJlY3Rpb24gKiBvdGhlci5fbWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgZHVyYXRpb24uX21vbnRocyAgICAgICArPSBkaXJlY3Rpb24gKiBvdGhlci5fbW9udGhzO1xuXG4gICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbn1cblxuLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKGR1cmF0aW9uKVxuZnVuY3Rpb24gYWRkJDEgKGlucHV0LCB2YWx1ZSkge1xuICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG59XG5cbi8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIHN1YnRyYWN0KDEsICdzJykgb3Igc3VidHJhY3QoZHVyYXRpb24pXG5mdW5jdGlvbiBzdWJ0cmFjdCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbn1cblxuZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKG51bWJlcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBidWJibGUgKCkge1xuICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG4gICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IHRoaXMuX21vbnRocztcbiAgICB2YXIgZGF0YSAgICAgICAgID0gdGhpcy5fZGF0YTtcbiAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAvLyBjaGVjazogaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzIxNjZcbiAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMCkpKSB7XG4gICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgIG1vbnRocyA9IDA7XG4gICAgfVxuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgIGRhdGEuaG91cnMgICAgICAgID0gaG91cnMgJSAyNDtcblxuICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAvLyBjb252ZXJ0IGRheXMgdG8gbW9udGhzXG4gICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICBkYXlzIC09IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRoc0Zyb21EYXlzKSk7XG5cbiAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgbW9udGhzICU9IDEyO1xuXG4gICAgZGF0YS5kYXlzICAgPSBkYXlzO1xuICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZGF5c1RvTW9udGhzIChkYXlzKSB7XG4gICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgIHJldHVybiBkYXlzICogNDgwMCAvIDE0NjA5Nztcbn1cblxuZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAvLyB0aGUgcmV2ZXJzZSBvZiBkYXlzVG9Nb250aHNcbiAgICByZXR1cm4gbW9udGhzICogMTQ2MDk3IC8gNDgwMDtcbn1cblxuZnVuY3Rpb24gYXMgKHVuaXRzKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICB2YXIgZGF5cztcbiAgICB2YXIgbW9udGhzO1xuICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgIGRheXMgICA9IHRoaXMuX2RheXMgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgIHJldHVybiB1bml0cyA9PT0gJ21vbnRoJyA/IG1vbnRocyA6IG1vbnRocyAvIDEyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBNYXRoLnJvdW5kKG1vbnRoc1RvRGF5cyh0aGlzLl9tb250aHMpKTtcbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAnd2VlaycgICA6IHJldHVybiBkYXlzIC8gNyAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICBjYXNlICdkYXknICAgIDogcmV0dXJuIGRheXMgICAgICAgICArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJyA6IHJldHVybiBkYXlzICogMTQ0MCAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnIDogcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzogcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuZnVuY3Rpb24gdmFsdWVPZiQxICgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgKTtcbn1cblxuZnVuY3Rpb24gbWFrZUFzIChhbGlhcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzKGFsaWFzKTtcbiAgICB9O1xufVxuXG52YXIgYXNNaWxsaXNlY29uZHMgPSBtYWtlQXMoJ21zJyk7XG52YXIgYXNTZWNvbmRzICAgICAgPSBtYWtlQXMoJ3MnKTtcbnZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xudmFyIGFzSG91cnMgICAgICAgID0gbWFrZUFzKCdoJyk7XG52YXIgYXNEYXlzICAgICAgICAgPSBtYWtlQXMoJ2QnKTtcbnZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xudmFyIGFzTW9udGhzICAgICAgID0gbWFrZUFzKCdNJyk7XG52YXIgYXNZZWFycyAgICAgICAgPSBtYWtlQXMoJ3knKTtcblxuZnVuY3Rpb24gZ2V0JDIgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpc1t1bml0cyArICdzJ10oKSA6IE5hTjtcbn1cblxuZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5fZGF0YVtuYW1lXSA6IE5hTjtcbiAgICB9O1xufVxuXG52YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XG52YXIgc2Vjb25kcyAgICAgID0gbWFrZUdldHRlcignc2Vjb25kcycpO1xudmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbnZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xudmFyIGRheXMgICAgICAgICA9IG1ha2VHZXR0ZXIoJ2RheXMnKTtcbnZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbnZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG5mdW5jdGlvbiB3ZWVrcyAoKSB7XG4gICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG59XG5cbnZhciByb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgdGhyZXNob2xkcyA9IHtcbiAgICBzczogNDQsICAgICAgICAgLy8gYSBmZXcgc2Vjb25kcyB0byBzZWNvbmRzXG4gICAgcyA6IDQ1LCAgICAgICAgIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgbSA6IDQ1LCAgICAgICAgIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgIGggOiAyMiwgICAgICAgICAvLyBob3VycyB0byBkYXlcbiAgICBkIDogMjYsICAgICAgICAgLy8gZGF5cyB0byBtb250aFxuICAgIE0gOiAxMSAgICAgICAgICAvLyBtb250aHMgdG8geWVhclxufTtcblxuLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbmZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG59XG5cbmZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxIChwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XG4gICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgIHZhciBtaW51dGVzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpO1xuICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgIHZhciBtb250aHMgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpO1xuICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgdmFyIGEgPSBzZWNvbmRzIDw9IHRocmVzaG9sZHMuc3MgJiYgWydzJywgc2Vjb25kc10gIHx8XG4gICAgICAgICAgICBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICAgJiYgWydzcycsIHNlY29uZHNdIHx8XG4gICAgICAgICAgICBtaW51dGVzIDw9IDEgICAgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBtaW51dGVzIDwgdGhyZXNob2xkcy5tICAgJiYgWydtbScsIG1pbnV0ZXNdIHx8XG4gICAgICAgICAgICBob3VycyAgIDw9IDEgICAgICAgICAgICAgJiYgWydoJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICAgJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICBkYXlzICAgIDw9IDEgICAgICAgICAgICAgJiYgWydkJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICAgJiYgWydkZCcsIGRheXNdICAgIHx8XG4gICAgICAgICAgICBtb250aHMgIDw9IDEgICAgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICBtb250aHMgIDwgdGhyZXNob2xkcy5NICAgJiYgWydNTScsIG1vbnRoc10gIHx8XG4gICAgICAgICAgICB5ZWFycyAgIDw9IDEgICAgICAgICAgICAgJiYgWyd5J10gICAgICAgICAgIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICBhWzRdID0gbG9jYWxlO1xuICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcgKHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICBpZiAocm91bmRpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByb3VuZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZihyb3VuZGluZ0Z1bmN0aW9uKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByb3VuZCA9IHJvdW5kaW5nRnVuY3Rpb247XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkICh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICB9XG4gICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgIHRocmVzaG9sZHMuc3MgPSBsaW1pdCAtIDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBodW1hbml6ZSAod2l0aFN1ZmZpeCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgIHZhciBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgbG9jYWxlKTtcblxuICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xufVxuXG52YXIgYWJzJDEgPSBNYXRoLmFicztcblxuZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAvLyBmb3IgSVNPIHN0cmluZ3Mgd2UgZG8gbm90IHVzZSB0aGUgbm9ybWFsIGJ1YmJsaW5nIHJ1bGVzOlxuICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgLy8gICogbW9udGhzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSB5ZWFyc1xuICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgLy8gYW5kIGFsc28gbm90IGJldHdlZW4gZGF5cyBhbmQgbW9udGhzICgyOC0zMSBkYXlzIHBlciBtb250aClcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBzZWNvbmRzID0gYWJzJDEodGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDA7XG4gICAgdmFyIGRheXMgICAgICAgICA9IGFicyQxKHRoaXMuX2RheXMpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBhYnMkMSh0aGlzLl9tb250aHMpO1xuICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAvLyAzNjAwIHNlY29uZHMgLT4gNjAgbWludXRlcyAtPiAxIGhvdXJcbiAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgIHNlY29uZHMgJT0gNjA7XG4gICAgbWludXRlcyAlPSA2MDtcblxuICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICB5ZWFycyAgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgbW9udGhzICU9IDEyO1xuXG5cbiAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgIHZhciBZID0geWVhcnM7XG4gICAgdmFyIE0gPSBtb250aHM7XG4gICAgdmFyIEQgPSBkYXlzO1xuICAgIHZhciBoID0gaG91cnM7XG4gICAgdmFyIG0gPSBtaW51dGVzO1xuICAgIHZhciBzID0gc2Vjb25kcztcbiAgICB2YXIgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpO1xuXG4gICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBzYW1lIGFzIEMjJ3MgKE5vZGEpIGFuZCBweXRob24gKGlzb2RhdGUpLi4uXG4gICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgIH1cblxuICAgIHJldHVybiAodG90YWwgPCAwID8gJy0nIDogJycpICtcbiAgICAgICAgJ1AnICtcbiAgICAgICAgKFkgPyBZICsgJ1knIDogJycpICtcbiAgICAgICAgKE0gPyBNICsgJ00nIDogJycpICtcbiAgICAgICAgKEQgPyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAoaCA/IGggKyAnSCcgOiAnJykgK1xuICAgICAgICAobSA/IG0gKyAnTScgOiAnJykgK1xuICAgICAgICAocyA/IHMgKyAnUycgOiAnJyk7XG59XG5cbnZhciBwcm90byQyID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG5wcm90byQyLmlzVmFsaWQgICAgICAgID0gaXNWYWxpZCQxO1xucHJvdG8kMi5hYnMgICAgICAgICAgICA9IGFicztcbnByb3RvJDIuYWRkICAgICAgICAgICAgPSBhZGQkMTtcbnByb3RvJDIuc3VidHJhY3QgICAgICAgPSBzdWJ0cmFjdCQxO1xucHJvdG8kMi5hcyAgICAgICAgICAgICA9IGFzO1xucHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xucHJvdG8kMi5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbnByb3RvJDIuYXNNaW51dGVzICAgICAgPSBhc01pbnV0ZXM7XG5wcm90byQyLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbnByb3RvJDIuYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG5wcm90byQyLmFzV2Vla3MgICAgICAgID0gYXNXZWVrcztcbnByb3RvJDIuYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbnByb3RvJDIuYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xucHJvdG8kMi52YWx1ZU9mICAgICAgICA9IHZhbHVlT2YkMTtcbnByb3RvJDIuX2J1YmJsZSAgICAgICAgPSBidWJibGU7XG5wcm90byQyLmdldCAgICAgICAgICAgID0gZ2V0JDI7XG5wcm90byQyLm1pbGxpc2Vjb25kcyAgID0gbWlsbGlzZWNvbmRzO1xucHJvdG8kMi5zZWNvbmRzICAgICAgICA9IHNlY29uZHM7XG5wcm90byQyLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbnByb3RvJDIuaG91cnMgICAgICAgICAgPSBob3VycztcbnByb3RvJDIuZGF5cyAgICAgICAgICAgPSBkYXlzO1xucHJvdG8kMi53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xucHJvdG8kMi5tb250aHMgICAgICAgICA9IG1vbnRocztcbnByb3RvJDIueWVhcnMgICAgICAgICAgPSB5ZWFycztcbnByb3RvJDIuaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbnByb3RvJDIudG9JU09TdHJpbmcgICAgPSB0b0lTT1N0cmluZyQxO1xucHJvdG8kMi50b1N0cmluZyAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG5wcm90byQyLnRvSlNPTiAgICAgICAgID0gdG9JU09TdHJpbmckMTtcbnByb3RvJDIubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG5wcm90byQyLmxvY2FsZURhdGEgICAgID0gbG9jYWxlRGF0YTtcblxuLy8gRGVwcmVjYXRpb25zXG5wcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIHRvSVNPU3RyaW5nJDEpO1xucHJvdG8kMi5sYW5nID0gbGFuZztcblxuLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdYJywgMCwgMCwgJ3VuaXgnKTtcbmFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCd4JywgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbmFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0LCAxMCkgKiAxMDAwKTtcbn0pO1xuYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG59KTtcblxuLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG5cbmhvb2tzLnZlcnNpb24gPSAnMi4xOC4xJztcblxuc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcblxuaG9va3MuZm4gICAgICAgICAgICAgICAgICAgID0gcHJvdG87XG5ob29rcy5taW4gICAgICAgICAgICAgICAgICAgPSBtaW47XG5ob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG5ob29rcy5ub3cgICAgICAgICAgICAgICAgICAgPSBub3c7XG5ob29rcy51dGMgICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVVEM7XG5ob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVbml4O1xuaG9va3MubW9udGhzICAgICAgICAgICAgICAgID0gbGlzdE1vbnRocztcbmhvb2tzLmlzRGF0ZSAgICAgICAgICAgICAgICA9IGlzRGF0ZTtcbmhvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGdldFNldEdsb2JhbExvY2FsZTtcbmhvb2tzLmludmFsaWQgICAgICAgICAgICAgICA9IGNyZWF0ZUludmFsaWQ7XG5ob29rcy5kdXJhdGlvbiAgICAgICAgICAgICAgPSBjcmVhdGVEdXJhdGlvbjtcbmhvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xuaG9va3Mud2Vla2RheXMgICAgICAgICAgICAgID0gbGlzdFdlZWtkYXlzO1xuaG9va3MucGFyc2Vab25lICAgICAgICAgICAgID0gY3JlYXRlSW5ab25lO1xuaG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gZ2V0TG9jYWxlO1xuaG9va3MuaXNEdXJhdGlvbiAgICAgICAgICAgID0gaXNEdXJhdGlvbjtcbmhvb2tzLm1vbnRoc1Nob3J0ICAgICAgICAgICA9IGxpc3RNb250aHNTaG9ydDtcbmhvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RXZWVrZGF5c01pbjtcbmhvb2tzLmRlZmluZUxvY2FsZSAgICAgICAgICA9IGRlZmluZUxvY2FsZTtcbmhvb2tzLnVwZGF0ZUxvY2FsZSAgICAgICAgICA9IHVwZGF0ZUxvY2FsZTtcbmhvb2tzLmxvY2FsZXMgICAgICAgICAgICAgICA9IGxpc3RMb2NhbGVzO1xuaG9va3Mud2Vla2RheXNTaG9ydCAgICAgICAgID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG5ob29rcy5ub3JtYWxpemVVbml0cyAgICAgICAgPSBub3JtYWxpemVVbml0cztcbmhvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nID0gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmc7XG5ob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG5ob29rcy5jYWxlbmRhckZvcm1hdCAgICAgICAgPSBnZXRDYWxlbmRhckZvcm1hdDtcbmhvb2tzLnByb3RvdHlwZSAgICAgICAgICAgICA9IHByb3RvO1xuXG5yZXR1cm4gaG9va3M7XG5cbn0pKSk7XG4iLCIvKiFcbiAqIFBpa2FkYXlcbiAqXG4gKiBDb3B5cmlnaHQgwqkgMjAxNCBEYXZpZCBCdXNoZWxsIHwgQlNEICYgTUlUIGxpY2Vuc2UgfCBodHRwczovL2dpdGh1Yi5jb20vZGJ1c2hlbGwvUGlrYWRheVxuICovXG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSlcbntcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgbW9tZW50O1xuICAgIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gQ29tbW9uSlMgbW9kdWxlXG4gICAgICAgIC8vIExvYWQgbW9tZW50LmpzIGFzIGFuIG9wdGlvbmFsIGRlcGVuZGVuY3lcbiAgICAgICAgdHJ5IHsgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7IH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShtb21lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uIChyZXEpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIExvYWQgbW9tZW50LmpzIGFzIGFuIG9wdGlvbmFsIGRlcGVuZGVuY3lcbiAgICAgICAgICAgIHZhciBpZCA9ICdtb21lbnQnO1xuICAgICAgICAgICAgdHJ5IHsgbW9tZW50ID0gcmVxKGlkKTsgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KG1vbWVudCk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuUGlrYWRheSA9IGZhY3Rvcnkocm9vdC5tb21lbnQpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKG1vbWVudClcbntcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKipcbiAgICAgKiBmZWF0dXJlIGRldGVjdGlvbiBhbmQgaGVscGVyIGZ1bmN0aW9uc1xuICAgICAqL1xuICAgIHZhciBoYXNNb21lbnQgPSB0eXBlb2YgbW9tZW50ID09PSAnZnVuY3Rpb24nLFxuXG4gICAgaGFzRXZlbnRMaXN0ZW5lcnMgPSAhIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyLFxuXG4gICAgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXG5cbiAgICBzdG8gPSB3aW5kb3cuc2V0VGltZW91dCxcblxuICAgIGFkZEV2ZW50ID0gZnVuY3Rpb24oZWwsIGUsIGNhbGxiYWNrLCBjYXB0dXJlKVxuICAgIHtcbiAgICAgICAgaWYgKGhhc0V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGUsIGNhbGxiYWNrLCAhIWNhcHR1cmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmVFdmVudCA9IGZ1bmN0aW9uKGVsLCBlLCBjYWxsYmFjaywgY2FwdHVyZSlcbiAgICB7XG4gICAgICAgIGlmIChoYXNFdmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBjYWxsYmFjaywgISFjYXB0dXJlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmRldGFjaEV2ZW50KCdvbicgKyBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdHJpbSA9IGZ1bmN0aW9uKHN0cilcbiAgICB7XG4gICAgICAgIHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywnJyk7XG4gICAgfSxcblxuICAgIGhhc0NsYXNzID0gZnVuY3Rpb24oZWwsIGNuKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICgnICcgKyBlbC5jbGFzc05hbWUgKyAnICcpLmluZGV4T2YoJyAnICsgY24gKyAnICcpICE9PSAtMTtcbiAgICB9LFxuXG4gICAgYWRkQ2xhc3MgPSBmdW5jdGlvbihlbCwgY24pXG4gICAge1xuICAgICAgICBpZiAoIWhhc0NsYXNzKGVsLCBjbikpIHtcbiAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IChlbC5jbGFzc05hbWUgPT09ICcnKSA/IGNuIDogZWwuY2xhc3NOYW1lICsgJyAnICsgY247XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbihlbCwgY24pXG4gICAge1xuICAgICAgICBlbC5jbGFzc05hbWUgPSB0cmltKCgnICcgKyBlbC5jbGFzc05hbWUgKyAnICcpLnJlcGxhY2UoJyAnICsgY24gKyAnICcsICcgJykpO1xuICAgIH0sXG5cbiAgICBpc0FycmF5ID0gZnVuY3Rpb24ob2JqKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICgvQXJyYXkvKS50ZXN0KE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKTtcbiAgICB9LFxuXG4gICAgaXNEYXRlID0gZnVuY3Rpb24ob2JqKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICgvRGF0ZS8pLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpICYmICFpc05hTihvYmouZ2V0VGltZSgpKTtcbiAgICB9LFxuXG4gICAgaXNXZWVrZW5kID0gZnVuY3Rpb24oZGF0ZSlcbiAgICB7XG4gICAgICAgIHZhciBkYXkgPSBkYXRlLmdldERheSgpO1xuICAgICAgICByZXR1cm4gZGF5ID09PSAwIHx8IGRheSA9PT0gNjtcbiAgICB9LFxuXG4gICAgaXNMZWFwWWVhciA9IGZ1bmN0aW9uKHllYXIpXG4gICAge1xuICAgICAgICAvLyBzb2x1dGlvbiBieSBNYXR0aSBWaXJra3VuZW46IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ4ODE5NTFcbiAgICAgICAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9LFxuXG4gICAgZ2V0RGF5c0luTW9udGggPSBmdW5jdGlvbih5ZWFyLCBtb250aClcbiAgICB7XG4gICAgICAgIHJldHVybiBbMzEsIGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1bbW9udGhdO1xuICAgIH0sXG5cbiAgICBzZXRUb1N0YXJ0T2ZEYXkgPSBmdW5jdGlvbihkYXRlKVxuICAgIHtcbiAgICAgICAgaWYgKGlzRGF0ZShkYXRlKSkgZGF0ZS5zZXRIb3VycygwLDAsMCwwKTtcbiAgICB9LFxuXG4gICAgY29tcGFyZURhdGVzID0gZnVuY3Rpb24oYSxiKVxuICAgIHtcbiAgICAgICAgLy8gd2VhayBkYXRlIGNvbXBhcmlzb24gKHVzZSBzZXRUb1N0YXJ0T2ZEYXkoZGF0ZSkgdG8gZW5zdXJlIGNvcnJlY3QgcmVzdWx0KVxuICAgICAgICByZXR1cm4gYS5nZXRUaW1lKCkgPT09IGIuZ2V0VGltZSgpO1xuICAgIH0sXG5cbiAgICBleHRlbmQgPSBmdW5jdGlvbih0bywgZnJvbSwgb3ZlcndyaXRlKVxuICAgIHtcbiAgICAgICAgdmFyIHByb3AsIGhhc1Byb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBmcm9tKSB7XG4gICAgICAgICAgICBoYXNQcm9wID0gdG9bcHJvcF0gIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChoYXNQcm9wICYmIHR5cGVvZiBmcm9tW3Byb3BdID09PSAnb2JqZWN0JyAmJiBmcm9tW3Byb3BdICE9PSBudWxsICYmIGZyb21bcHJvcF0ubm9kZU5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpc0RhdGUoZnJvbVtwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSBuZXcgRGF0ZShmcm9tW3Byb3BdLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheShmcm9tW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcndyaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IGZyb21bcHJvcF0uc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IGV4dGVuZCh7fSwgZnJvbVtwcm9wXSwgb3ZlcndyaXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJ3cml0ZSB8fCAhaGFzUHJvcCkge1xuICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG87XG4gICAgfSxcblxuICAgIGZpcmVFdmVudCA9IGZ1bmN0aW9uKGVsLCBldmVudE5hbWUsIGRhdGEpXG4gICAge1xuICAgICAgICB2YXIgZXY7XG5cbiAgICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICBldiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgICAgICAgICBldi5pbml0RXZlbnQoZXZlbnROYW1lLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICBldiA9IGV4dGVuZChldiwgZGF0YSk7XG4gICAgICAgICAgICBlbC5kaXNwYXRjaEV2ZW50KGV2KTtcbiAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCkge1xuICAgICAgICAgICAgZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpO1xuICAgICAgICAgICAgZXYgPSBleHRlbmQoZXYsIGRhdGEpO1xuICAgICAgICAgICAgZWwuZmlyZUV2ZW50KCdvbicgKyBldmVudE5hbWUsIGV2KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhZGp1c3RDYWxlbmRhciA9IGZ1bmN0aW9uKGNhbGVuZGFyKSB7XG4gICAgICAgIGlmIChjYWxlbmRhci5tb250aCA8IDApIHtcbiAgICAgICAgICAgIGNhbGVuZGFyLnllYXIgLT0gTWF0aC5jZWlsKE1hdGguYWJzKGNhbGVuZGFyLm1vbnRoKS8xMik7XG4gICAgICAgICAgICBjYWxlbmRhci5tb250aCArPSAxMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsZW5kYXIubW9udGggPiAxMSkge1xuICAgICAgICAgICAgY2FsZW5kYXIueWVhciArPSBNYXRoLmZsb29yKE1hdGguYWJzKGNhbGVuZGFyLm1vbnRoKS8xMik7XG4gICAgICAgICAgICBjYWxlbmRhci5tb250aCAtPSAxMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsZW5kYXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRlZmF1bHRzIGFuZCBsb2NhbGlzYXRpb25cbiAgICAgKi9cbiAgICBkZWZhdWx0cyA9IHtcblxuICAgICAgICAvLyBiaW5kIHRoZSBwaWNrZXIgdG8gYSBmb3JtIGZpZWxkXG4gICAgICAgIGZpZWxkOiBudWxsLFxuXG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgc2hvdy9oaWRlIHRoZSBwaWNrZXIgb24gYGZpZWxkYCBmb2N1cyAoZGVmYXVsdCBgdHJ1ZWAgaWYgYGZpZWxkYCBpcyBzZXQpXG4gICAgICAgIGJvdW5kOiB1bmRlZmluZWQsXG5cbiAgICAgICAgLy8gcG9zaXRpb24gb2YgdGhlIGRhdGVwaWNrZXIsIHJlbGF0aXZlIHRvIHRoZSBmaWVsZCAoZGVmYXVsdCB0byBib3R0b20gJiBsZWZ0KVxuICAgICAgICAvLyAoJ2JvdHRvbScgJiAnbGVmdCcga2V5d29yZHMgYXJlIG5vdCB1c2VkLCAndG9wJyAmICdyaWdodCcgYXJlIG1vZGlmaWVyIG9uIHRoZSBib3R0b20vbGVmdCBwb3NpdGlvbilcbiAgICAgICAgcG9zaXRpb246ICdib3R0b20gbGVmdCcsXG5cbiAgICAgICAgLy8gYXV0b21hdGljYWxseSBmaXQgaW4gdGhlIHZpZXdwb3J0IGV2ZW4gaWYgaXQgbWVhbnMgcmVwb3NpdGlvbmluZyBmcm9tIHRoZSBwb3NpdGlvbiBvcHRpb25cbiAgICAgICAgcmVwb3NpdGlvbjogdHJ1ZSxcblxuICAgICAgICAvLyB0aGUgZGVmYXVsdCBvdXRwdXQgZm9ybWF0IGZvciBgLnRvU3RyaW5nKClgIGFuZCBgZmllbGRgIHZhbHVlXG4gICAgICAgIGZvcm1hdDogJ1lZWVktTU0tREQnLFxuXG4gICAgICAgIC8vIHRoZSB0b1N0cmluZyBmdW5jdGlvbiB3aGljaCBnZXRzIHBhc3NlZCBhIGN1cnJlbnQgZGF0ZSBvYmplY3QgYW5kIGZvcm1hdFxuICAgICAgICAvLyBhbmQgcmV0dXJucyBhIHN0cmluZ1xuICAgICAgICB0b1N0cmluZzogbnVsbCxcblxuICAgICAgICAvLyB1c2VkIHRvIGNyZWF0ZSBkYXRlIG9iamVjdCBmcm9tIGN1cnJlbnQgaW5wdXQgc3RyaW5nXG4gICAgICAgIHBhcnNlOiBudWxsLFxuXG4gICAgICAgIC8vIHRoZSBpbml0aWFsIGRhdGUgdG8gdmlldyB3aGVuIGZpcnN0IG9wZW5lZFxuICAgICAgICBkZWZhdWx0RGF0ZTogbnVsbCxcblxuICAgICAgICAvLyBtYWtlIHRoZSBgZGVmYXVsdERhdGVgIHRoZSBpbml0aWFsIHNlbGVjdGVkIHZhbHVlXG4gICAgICAgIHNldERlZmF1bHREYXRlOiBmYWxzZSxcblxuICAgICAgICAvLyBmaXJzdCBkYXkgb2Ygd2VlayAoMDogU3VuZGF5LCAxOiBNb25kYXkgZXRjKVxuICAgICAgICBmaXJzdERheTogMCxcblxuICAgICAgICAvLyB0aGUgZGVmYXVsdCBmbGFnIGZvciBtb21lbnQncyBzdHJpY3QgZGF0ZSBwYXJzaW5nXG4gICAgICAgIGZvcm1hdFN0cmljdDogZmFsc2UsXG5cbiAgICAgICAgLy8gdGhlIG1pbmltdW0vZWFybGllc3QgZGF0ZSB0aGF0IGNhbiBiZSBzZWxlY3RlZFxuICAgICAgICBtaW5EYXRlOiBudWxsLFxuICAgICAgICAvLyB0aGUgbWF4aW11bS9sYXRlc3QgZGF0ZSB0aGF0IGNhbiBiZSBzZWxlY3RlZFxuICAgICAgICBtYXhEYXRlOiBudWxsLFxuXG4gICAgICAgIC8vIG51bWJlciBvZiB5ZWFycyBlaXRoZXIgc2lkZSwgb3IgYXJyYXkgb2YgdXBwZXIvbG93ZXIgcmFuZ2VcbiAgICAgICAgeWVhclJhbmdlOiAxMCxcblxuICAgICAgICAvLyBzaG93IHdlZWsgbnVtYmVycyBhdCBoZWFkIG9mIHJvd1xuICAgICAgICBzaG93V2Vla051bWJlcjogZmFsc2UsXG5cbiAgICAgICAgLy8gV2VlayBwaWNrZXIgbW9kZVxuICAgICAgICBwaWNrV2hvbGVXZWVrOiBmYWxzZSxcblxuICAgICAgICAvLyB1c2VkIGludGVybmFsbHkgKGRvbid0IGNvbmZpZyBvdXRzaWRlKVxuICAgICAgICBtaW5ZZWFyOiAwLFxuICAgICAgICBtYXhZZWFyOiA5OTk5LFxuICAgICAgICBtaW5Nb250aDogdW5kZWZpbmVkLFxuICAgICAgICBtYXhNb250aDogdW5kZWZpbmVkLFxuXG4gICAgICAgIHN0YXJ0UmFuZ2U6IG51bGwsXG4gICAgICAgIGVuZFJhbmdlOiBudWxsLFxuXG4gICAgICAgIGlzUlRMOiBmYWxzZSxcblxuICAgICAgICAvLyBBZGRpdGlvbmFsIHRleHQgdG8gYXBwZW5kIHRvIHRoZSB5ZWFyIGluIHRoZSBjYWxlbmRhciB0aXRsZVxuICAgICAgICB5ZWFyU3VmZml4OiAnJyxcblxuICAgICAgICAvLyBSZW5kZXIgdGhlIG1vbnRoIGFmdGVyIHllYXIgaW4gdGhlIGNhbGVuZGFyIHRpdGxlXG4gICAgICAgIHNob3dNb250aEFmdGVyWWVhcjogZmFsc2UsXG5cbiAgICAgICAgLy8gUmVuZGVyIGRheXMgb2YgdGhlIGNhbGVuZGFyIGdyaWQgdGhhdCBmYWxsIGluIHRoZSBuZXh0IG9yIHByZXZpb3VzIG1vbnRoXG4gICAgICAgIHNob3dEYXlzSW5OZXh0QW5kUHJldmlvdXNNb250aHM6IGZhbHNlLFxuXG4gICAgICAgIC8vIEFsbG93cyB1c2VyIHRvIHNlbGVjdCBkYXlzIHRoYXQgZmFsbCBpbiB0aGUgbmV4dCBvciBwcmV2aW91cyBtb250aFxuICAgICAgICBlbmFibGVTZWxlY3Rpb25EYXlzSW5OZXh0QW5kUHJldmlvdXNNb250aHM6IGZhbHNlLFxuXG4gICAgICAgIC8vIGhvdyBtYW55IG1vbnRocyBhcmUgdmlzaWJsZVxuICAgICAgICBudW1iZXJPZk1vbnRoczogMSxcblxuICAgICAgICAvLyB3aGVuIG51bWJlck9mTW9udGhzIGlzIHVzZWQsIHRoaXMgd2lsbCBoZWxwIHlvdSB0byBjaG9vc2Ugd2hlcmUgdGhlIG1haW4gY2FsZW5kYXIgd2lsbCBiZSAoZGVmYXVsdCBgbGVmdGAsIGNhbiBiZSBzZXQgdG8gYHJpZ2h0YClcbiAgICAgICAgLy8gb25seSB1c2VkIGZvciB0aGUgZmlyc3QgZGlzcGxheSBvciB3aGVuIGEgc2VsZWN0ZWQgZGF0ZSBpcyBub3QgdmlzaWJsZVxuICAgICAgICBtYWluQ2FsZW5kYXI6ICdsZWZ0JyxcblxuICAgICAgICAvLyBTcGVjaWZ5IGEgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIHRoZSBjYWxlbmRhciBpblxuICAgICAgICBjb250YWluZXI6IHVuZGVmaW5lZCxcblxuICAgICAgICAvLyBCbHVyIGZpZWxkIHdoZW4gZGF0ZSBpcyBzZWxlY3RlZFxuICAgICAgICBibHVyRmllbGRPblNlbGVjdCA6IHRydWUsXG5cbiAgICAgICAgLy8gaW50ZXJuYXRpb25hbGl6YXRpb25cbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgcHJldmlvdXNNb250aCA6ICdQcmV2aW91cyBNb250aCcsXG4gICAgICAgICAgICBuZXh0TW9udGggICAgIDogJ05leHQgTW9udGgnLFxuICAgICAgICAgICAgbW9udGhzICAgICAgICA6IFsnSmFudWFyeScsJ0ZlYnJ1YXJ5JywnTWFyY2gnLCdBcHJpbCcsJ01heScsJ0p1bmUnLCdKdWx5JywnQXVndXN0JywnU2VwdGVtYmVyJywnT2N0b2JlcicsJ05vdmVtYmVyJywnRGVjZW1iZXInXSxcbiAgICAgICAgICAgIHdlZWtkYXlzICAgICAgOiBbJ1N1bmRheScsJ01vbmRheScsJ1R1ZXNkYXknLCdXZWRuZXNkYXknLCdUaHVyc2RheScsJ0ZyaWRheScsJ1NhdHVyZGF5J10sXG4gICAgICAgICAgICB3ZWVrZGF5c1Nob3J0IDogWydTdW4nLCdNb24nLCdUdWUnLCdXZWQnLCdUaHUnLCdGcmknLCdTYXQnXVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRoZW1lIENsYXNzbmFtZVxuICAgICAgICB0aGVtZTogbnVsbCxcblxuICAgICAgICAvLyBldmVudHMgYXJyYXlcbiAgICAgICAgZXZlbnRzOiBbXSxcblxuICAgICAgICAvLyBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICBvblNlbGVjdDogbnVsbCxcbiAgICAgICAgb25PcGVuOiBudWxsLFxuICAgICAgICBvbkNsb3NlOiBudWxsLFxuICAgICAgICBvbkRyYXc6IG51bGxcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiB0ZW1wbGF0aW5nIGZ1bmN0aW9ucyB0byBhYnN0cmFjdCBIVE1MIHJlbmRlcmluZ1xuICAgICAqL1xuICAgIHJlbmRlckRheU5hbWUgPSBmdW5jdGlvbihvcHRzLCBkYXksIGFiYnIpXG4gICAge1xuICAgICAgICBkYXkgKz0gb3B0cy5maXJzdERheTtcbiAgICAgICAgd2hpbGUgKGRheSA+PSA3KSB7XG4gICAgICAgICAgICBkYXkgLT0gNztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWJiciA/IG9wdHMuaTE4bi53ZWVrZGF5c1Nob3J0W2RheV0gOiBvcHRzLmkxOG4ud2Vla2RheXNbZGF5XTtcbiAgICB9LFxuXG4gICAgcmVuZGVyRGF5ID0gZnVuY3Rpb24ob3B0cylcbiAgICB7XG4gICAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgICAgdmFyIGFyaWFTZWxlY3RlZCA9ICdmYWxzZSc7XG4gICAgICAgIGlmIChvcHRzLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLnNob3dEYXlzSW5OZXh0QW5kUHJldmlvdXNNb250aHMpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaCgnaXMtb3V0c2lkZS1jdXJyZW50LW1vbnRoJyk7XG5cbiAgICAgICAgICAgICAgICBpZighb3B0cy5lbmFibGVTZWxlY3Rpb25EYXlzSW5OZXh0QW5kUHJldmlvdXNNb250aHMpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goJ2lzLXNlbGVjdGlvbi1kaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzx0ZCBjbGFzcz1cImlzLWVtcHR5XCI+PC90ZD4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKCdpcy1kaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmlzVG9kYXkpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKCdpcy10b2RheScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKCdpcy1zZWxlY3RlZCcpO1xuICAgICAgICAgICAgYXJpYVNlbGVjdGVkID0gJ3RydWUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmhhc0V2ZW50KSB7XG4gICAgICAgICAgICBhcnIucHVzaCgnaGFzLWV2ZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaXNJblJhbmdlKSB7XG4gICAgICAgICAgICBhcnIucHVzaCgnaXMtaW5yYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmlzU3RhcnRSYW5nZSkge1xuICAgICAgICAgICAgYXJyLnB1c2goJ2lzLXN0YXJ0cmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5pc0VuZFJhbmdlKSB7XG4gICAgICAgICAgICBhcnIucHVzaCgnaXMtZW5kcmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzx0ZCBkYXRhLWRheT1cIicgKyBvcHRzLmRheSArICdcIiBjbGFzcz1cIicgKyBhcnIuam9pbignICcpICsgJ1wiIGFyaWEtc2VsZWN0ZWQ9XCInICsgYXJpYVNlbGVjdGVkICsgJ1wiPicgK1xuICAgICAgICAgICAgICAgICAnPGJ1dHRvbiBjbGFzcz1cInBpa2EtYnV0dG9uIHBpa2EtZGF5XCIgdHlwZT1cImJ1dHRvblwiICcgK1xuICAgICAgICAgICAgICAgICAgICAnZGF0YS1waWthLXllYXI9XCInICsgb3B0cy55ZWFyICsgJ1wiIGRhdGEtcGlrYS1tb250aD1cIicgKyBvcHRzLm1vbnRoICsgJ1wiIGRhdGEtcGlrYS1kYXk9XCInICsgb3B0cy5kYXkgKyAnXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmRheSArXG4gICAgICAgICAgICAgICAgICc8L2J1dHRvbj4nICtcbiAgICAgICAgICAgICAgICc8L3RkPic7XG4gICAgfSxcblxuICAgIHJlbmRlcldlZWsgPSBmdW5jdGlvbiAoZCwgbSwgeSkge1xuICAgICAgICAvLyBMaWZ0ZWQgZnJvbSBodHRwOi8vamF2YXNjcmlwdC5hYm91dC5jb20vbGlicmFyeS9ibHdlZWt5ZWFyLmh0bSwgbGlnaHRseSBtb2RpZmllZC5cbiAgICAgICAgdmFyIG9uZWphbiA9IG5ldyBEYXRlKHksIDAsIDEpLFxuICAgICAgICAgICAgd2Vla051bSA9IE1hdGguY2VpbCgoKChuZXcgRGF0ZSh5LCBtLCBkKSAtIG9uZWphbikgLyA4NjQwMDAwMCkgKyBvbmVqYW4uZ2V0RGF5KCkrMSkvNyk7XG4gICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwicGlrYS13ZWVrXCI+JyArIHdlZWtOdW0gKyAnPC90ZD4nO1xuICAgIH0sXG5cbiAgICByZW5kZXJSb3cgPSBmdW5jdGlvbihkYXlzLCBpc1JUTCwgcGlja1dob2xlV2VlaywgaXNSb3dTZWxlY3RlZClcbiAgICB7XG4gICAgICAgIHJldHVybiAnPHRyIGNsYXNzPVwicGlrYS1yb3cnICsgKHBpY2tXaG9sZVdlZWsgPyAnIHBpY2std2hvbGUtd2VlaycgOiAnJykgKyAoaXNSb3dTZWxlY3RlZCA/ICcgaXMtc2VsZWN0ZWQnIDogJycpICsgJ1wiPicgKyAoaXNSVEwgPyBkYXlzLnJldmVyc2UoKSA6IGRheXMpLmpvaW4oJycpICsgJzwvdHI+JztcbiAgICB9LFxuXG4gICAgcmVuZGVyQm9keSA9IGZ1bmN0aW9uKHJvd3MpXG4gICAge1xuICAgICAgICByZXR1cm4gJzx0Ym9keT4nICsgcm93cy5qb2luKCcnKSArICc8L3Rib2R5Pic7XG4gICAgfSxcblxuICAgIHJlbmRlckhlYWQgPSBmdW5jdGlvbihvcHRzKVxuICAgIHtcbiAgICAgICAgdmFyIGksIGFyciA9IFtdO1xuICAgICAgICBpZiAob3B0cy5zaG93V2Vla051bWJlcikge1xuICAgICAgICAgICAgYXJyLnB1c2goJzx0aD48L3RoPicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIGFyci5wdXNoKCc8dGggc2NvcGU9XCJjb2xcIj48YWJiciB0aXRsZT1cIicgKyByZW5kZXJEYXlOYW1lKG9wdHMsIGkpICsgJ1wiPicgKyByZW5kZXJEYXlOYW1lKG9wdHMsIGksIHRydWUpICsgJzwvYWJicj48L3RoPicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnPHRoZWFkPjx0cj4nICsgKG9wdHMuaXNSVEwgPyBhcnIucmV2ZXJzZSgpIDogYXJyKS5qb2luKCcnKSArICc8L3RyPjwvdGhlYWQ+JztcbiAgICB9LFxuXG4gICAgcmVuZGVyVGl0bGUgPSBmdW5jdGlvbihpbnN0YW5jZSwgYywgeWVhciwgbW9udGgsIHJlZlllYXIsIHJhbmRJZClcbiAgICB7XG4gICAgICAgIHZhciBpLCBqLCBhcnIsXG4gICAgICAgICAgICBvcHRzID0gaW5zdGFuY2UuX28sXG4gICAgICAgICAgICBpc01pblllYXIgPSB5ZWFyID09PSBvcHRzLm1pblllYXIsXG4gICAgICAgICAgICBpc01heFllYXIgPSB5ZWFyID09PSBvcHRzLm1heFllYXIsXG4gICAgICAgICAgICBodG1sID0gJzxkaXYgaWQ9XCInICsgcmFuZElkICsgJ1wiIGNsYXNzPVwicGlrYS10aXRsZVwiIHJvbGU9XCJoZWFkaW5nXCIgYXJpYS1saXZlPVwiYXNzZXJ0aXZlXCI+JyxcbiAgICAgICAgICAgIG1vbnRoSHRtbCxcbiAgICAgICAgICAgIHllYXJIdG1sLFxuICAgICAgICAgICAgcHJldiA9IHRydWUsXG4gICAgICAgICAgICBuZXh0ID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKGFyciA9IFtdLCBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIGFyci5wdXNoKCc8b3B0aW9uIHZhbHVlPVwiJyArICh5ZWFyID09PSByZWZZZWFyID8gaSAtIGMgOiAxMiArIGkgLSBjKSArICdcIicgK1xuICAgICAgICAgICAgICAgIChpID09PSBtb250aCA/ICcgc2VsZWN0ZWQ9XCJzZWxlY3RlZFwiJzogJycpICtcbiAgICAgICAgICAgICAgICAoKGlzTWluWWVhciAmJiBpIDwgb3B0cy5taW5Nb250aCkgfHwgKGlzTWF4WWVhciAmJiBpID4gb3B0cy5tYXhNb250aCkgPyAnZGlzYWJsZWQ9XCJkaXNhYmxlZFwiJyA6ICcnKSArICc+JyArXG4gICAgICAgICAgICAgICAgb3B0cy5pMThuLm1vbnRoc1tpXSArICc8L29wdGlvbj4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vbnRoSHRtbCA9ICc8ZGl2IGNsYXNzPVwicGlrYS1sYWJlbFwiPicgKyBvcHRzLmkxOG4ubW9udGhzW21vbnRoXSArICc8c2VsZWN0IGNsYXNzPVwicGlrYS1zZWxlY3QgcGlrYS1zZWxlY3QtbW9udGhcIiB0YWJpbmRleD1cIi0xXCI+JyArIGFyci5qb2luKCcnKSArICc8L3NlbGVjdD48L2Rpdj4nO1xuXG4gICAgICAgIGlmIChpc0FycmF5KG9wdHMueWVhclJhbmdlKSkge1xuICAgICAgICAgICAgaSA9IG9wdHMueWVhclJhbmdlWzBdO1xuICAgICAgICAgICAgaiA9IG9wdHMueWVhclJhbmdlWzFdICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkgPSB5ZWFyIC0gb3B0cy55ZWFyUmFuZ2U7XG4gICAgICAgICAgICBqID0gMSArIHllYXIgKyBvcHRzLnllYXJSYW5nZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoYXJyID0gW107IGkgPCBqICYmIGkgPD0gb3B0cy5tYXhZZWFyOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID49IG9wdHMubWluWWVhcikge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKCc8b3B0aW9uIHZhbHVlPVwiJyArIGkgKyAnXCInICsgKGkgPT09IHllYXIgPyAnIHNlbGVjdGVkPVwic2VsZWN0ZWRcIic6ICcnKSArICc+JyArIChpKSArICc8L29wdGlvbj4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5ZWFySHRtbCA9ICc8ZGl2IGNsYXNzPVwicGlrYS1sYWJlbFwiPicgKyB5ZWFyICsgb3B0cy55ZWFyU3VmZml4ICsgJzxzZWxlY3QgY2xhc3M9XCJwaWthLXNlbGVjdCBwaWthLXNlbGVjdC15ZWFyXCIgdGFiaW5kZXg9XCItMVwiPicgKyBhcnIuam9pbignJykgKyAnPC9zZWxlY3Q+PC9kaXY+JztcblxuICAgICAgICBpZiAob3B0cy5zaG93TW9udGhBZnRlclllYXIpIHtcbiAgICAgICAgICAgIGh0bWwgKz0geWVhckh0bWwgKyBtb250aEh0bWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBodG1sICs9IG1vbnRoSHRtbCArIHllYXJIdG1sO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTWluWWVhciAmJiAobW9udGggPT09IDAgfHwgb3B0cy5taW5Nb250aCA+PSBtb250aCkpIHtcbiAgICAgICAgICAgIHByZXYgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01heFllYXIgJiYgKG1vbnRoID09PSAxMSB8fCBvcHRzLm1heE1vbnRoIDw9IG1vbnRoKSkge1xuICAgICAgICAgICAgbmV4dCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGMgPT09IDApIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJzxidXR0b24gY2xhc3M9XCJwaWthLXByZXYnICsgKHByZXYgPyAnJyA6ICcgaXMtZGlzYWJsZWQnKSArICdcIiB0eXBlPVwiYnV0dG9uXCI+JyArIG9wdHMuaTE4bi5wcmV2aW91c01vbnRoICsgJzwvYnV0dG9uPic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09IChpbnN0YW5jZS5fby5udW1iZXJPZk1vbnRocyAtIDEpICkge1xuICAgICAgICAgICAgaHRtbCArPSAnPGJ1dHRvbiBjbGFzcz1cInBpa2EtbmV4dCcgKyAobmV4dCA/ICcnIDogJyBpcy1kaXNhYmxlZCcpICsgJ1wiIHR5cGU9XCJidXR0b25cIj4nICsgb3B0cy5pMThuLm5leHRNb250aCArICc8L2J1dHRvbj4nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGh0bWwgKz0gJzwvZGl2Pic7XG4gICAgfSxcblxuICAgIHJlbmRlclRhYmxlID0gZnVuY3Rpb24ob3B0cywgZGF0YSwgcmFuZElkKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICc8dGFibGUgY2VsbHBhZGRpbmc9XCIwXCIgY2VsbHNwYWNpbmc9XCIwXCIgY2xhc3M9XCJwaWthLXRhYmxlXCIgcm9sZT1cImdyaWRcIiBhcmlhLWxhYmVsbGVkYnk9XCInICsgcmFuZElkICsgJ1wiPicgKyByZW5kZXJIZWFkKG9wdHMpICsgcmVuZGVyQm9keShkYXRhKSArICc8L3RhYmxlPic7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogUGlrYWRheSBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIFBpa2FkYXkgPSBmdW5jdGlvbihvcHRpb25zKVxuICAgIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgICAgb3B0cyA9IHNlbGYuY29uZmlnKG9wdGlvbnMpO1xuXG4gICAgICAgIHNlbGYuX29uTW91c2VEb3duID0gZnVuY3Rpb24oZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFzZWxmLl92KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWhhc0NsYXNzKHRhcmdldCwgJ2lzLWRpc2FibGVkJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3ModGFyZ2V0LCAncGlrYS1idXR0b24nKSAmJiAhaGFzQ2xhc3ModGFyZ2V0LCAnaXMtZW1wdHknKSAmJiAhaGFzQ2xhc3ModGFyZ2V0LnBhcmVudE5vZGUsICdpcy1kaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V0RGF0ZShuZXcgRGF0ZSh0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXBpa2EteWVhcicpLCB0YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLXBpa2EtbW9udGgnKSwgdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1waWthLWRheScpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuYmx1ckZpZWxkT25TZWxlY3QgJiYgb3B0cy5maWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmZpZWxkLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc0NsYXNzKHRhcmdldCwgJ3Bpa2EtcHJldicpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucHJldk1vbnRoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc0NsYXNzKHRhcmdldCwgJ3Bpa2EtbmV4dCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYubmV4dE1vbnRoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNDbGFzcyh0YXJnZXQsICdwaWthLXNlbGVjdCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyB0b3VjaCBldmVudCBwcmV2ZW50IG1vdXNlIGV2ZW50cyBlbXVsYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9jID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLl9vbkNoYW5nZSA9IGZ1bmN0aW9uKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNDbGFzcyh0YXJnZXQsICdwaWthLXNlbGVjdC1tb250aCcpKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5nb3RvTW9udGgodGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGhhc0NsYXNzKHRhcmdldCwgJ3Bpa2Etc2VsZWN0LXllYXInKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZ290b1llYXIodGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLl9vbktleUNoYW5nZSA9IGZ1bmN0aW9uKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICAgICAgICAgICAgaWYgKHNlbGYuaXNWaXNpYmxlKCkpIHtcblxuICAgICAgICAgICAgICAgIHN3aXRjaChlLmtleUNvZGUpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmZpZWxkLmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGp1c3REYXRlKCdzdWJ0cmFjdCcsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkanVzdERhdGUoJ3N1YnRyYWN0JywgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRqdXN0RGF0ZSgnYWRkJywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRqdXN0RGF0ZSgnYWRkJywgNyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5fb25JbnB1dENoYW5nZSA9IGZ1bmN0aW9uKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBkYXRlO1xuXG4gICAgICAgICAgICBpZiAoZS5maXJlZEJ5ID09PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMucGFyc2UpIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gb3B0cy5wYXJzZShvcHRzLmZpZWxkLnZhbHVlLCBvcHRzLmZvcm1hdCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhc01vbWVudCkge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBtb21lbnQob3B0cy5maWVsZC52YWx1ZSwgb3B0cy5mb3JtYXQsIG9wdHMuZm9ybWF0U3RyaWN0KTtcbiAgICAgICAgICAgICAgICBkYXRlID0gKGRhdGUgJiYgZGF0ZS5pc1ZhbGlkKCkpID8gZGF0ZS50b0RhdGUoKSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5wYXJzZShvcHRzLmZpZWxkLnZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEYXRlKGRhdGUpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0RGF0ZShkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2VsZi5fdikge1xuICAgICAgICAgICAgICAgIHNlbGYuc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuX29uSW5wdXRGb2N1cyA9IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgc2VsZi5zaG93KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5fb25JbnB1dENsaWNrID0gZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICBzZWxmLnNob3coKTtcbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLl9vbklucHV0Qmx1ciA9IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gSUUgYWxsb3dzIHBpa2EgZGl2IHRvIGdhaW4gZm9jdXM7IGNhdGNoIGJsdXIgdGhlIGlucHV0IGZpZWxkXG4gICAgICAgICAgICB2YXIgcEVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzQ2xhc3MocEVsLCAncGlrYS1zaW5nbGUnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKChwRWwgPSBwRWwucGFyZW50Tm9kZSkpO1xuXG4gICAgICAgICAgICBpZiAoIXNlbGYuX2MpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9iID0gc3RvKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9LCA1MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9jID0gZmFsc2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5fb25DbGljayA9IGZ1bmN0aW9uKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQsXG4gICAgICAgICAgICAgICAgcEVsID0gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhc0V2ZW50TGlzdGVuZXJzICYmIGhhc0NsYXNzKHRhcmdldCwgJ3Bpa2Etc2VsZWN0JykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5vbmNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKCdvbmNoYW5nZScsICdyZXR1cm47Jyk7XG4gICAgICAgICAgICAgICAgICAgIGFkZEV2ZW50KHRhcmdldCwgJ2NoYW5nZScsIHNlbGYuX29uQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKHBFbCwgJ3Bpa2Etc2luZ2xlJykgfHwgcEVsID09PSBvcHRzLnRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICgocEVsID0gcEVsLnBhcmVudE5vZGUpKTtcbiAgICAgICAgICAgIGlmIChzZWxmLl92ICYmIHRhcmdldCAhPT0gb3B0cy50cmlnZ2VyICYmIHBFbCAhPT0gb3B0cy50cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzZWxmLmVsLmNsYXNzTmFtZSA9ICdwaWthLXNpbmdsZScgKyAob3B0cy5pc1JUTCA/ICcgaXMtcnRsJyA6ICcnKSArIChvcHRzLnRoZW1lID8gJyAnICsgb3B0cy50aGVtZSA6ICcnKTtcblxuICAgICAgICBhZGRFdmVudChzZWxmLmVsLCAnbW91c2Vkb3duJywgc2VsZi5fb25Nb3VzZURvd24sIHRydWUpO1xuICAgICAgICBhZGRFdmVudChzZWxmLmVsLCAndG91Y2hlbmQnLCBzZWxmLl9vbk1vdXNlRG93biwgdHJ1ZSk7XG4gICAgICAgIGFkZEV2ZW50KHNlbGYuZWwsICdjaGFuZ2UnLCBzZWxmLl9vbkNoYW5nZSk7XG4gICAgICAgIGFkZEV2ZW50KGRvY3VtZW50LCAna2V5ZG93bicsIHNlbGYuX29uS2V5Q2hhbmdlKTtcblxuICAgICAgICBpZiAob3B0cy5maWVsZCkge1xuICAgICAgICAgICAgaWYgKG9wdHMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5jb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZi5lbCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuYm91bmQpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNlbGYuZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRzLmZpZWxkLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNlbGYuZWwsIG9wdHMuZmllbGQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkRXZlbnQob3B0cy5maWVsZCwgJ2NoYW5nZScsIHNlbGYuX29uSW5wdXRDaGFuZ2UpO1xuXG4gICAgICAgICAgICBpZiAoIW9wdHMuZGVmYXVsdERhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzTW9tZW50ICYmIG9wdHMuZmllbGQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5kZWZhdWx0RGF0ZSA9IG1vbWVudChvcHRzLmZpZWxkLnZhbHVlLCBvcHRzLmZvcm1hdCkudG9EYXRlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5kZWZhdWx0RGF0ZSA9IG5ldyBEYXRlKERhdGUucGFyc2Uob3B0cy5maWVsZC52YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRzLnNldERlZmF1bHREYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZWZEYXRlID0gb3B0cy5kZWZhdWx0RGF0ZTtcblxuICAgICAgICBpZiAoaXNEYXRlKGRlZkRhdGUpKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5zZXREZWZhdWx0RGF0ZSkge1xuICAgICAgICAgICAgICAgIHNlbGYuc2V0RGF0ZShkZWZEYXRlLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5nb3RvRGF0ZShkZWZEYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuZ290b0RhdGUobmV3IERhdGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0cy5ib3VuZCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICBzZWxmLmVsLmNsYXNzTmFtZSArPSAnIGlzLWJvdW5kJztcbiAgICAgICAgICAgIGFkZEV2ZW50KG9wdHMudHJpZ2dlciwgJ2NsaWNrJywgc2VsZi5fb25JbnB1dENsaWNrKTtcbiAgICAgICAgICAgIGFkZEV2ZW50KG9wdHMudHJpZ2dlciwgJ2ZvY3VzJywgc2VsZi5fb25JbnB1dEZvY3VzKTtcbiAgICAgICAgICAgIGFkZEV2ZW50KG9wdHMudHJpZ2dlciwgJ2JsdXInLCBzZWxmLl9vbklucHV0Qmx1cik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIHB1YmxpYyBQaWthZGF5IEFQSVxuICAgICAqL1xuICAgIFBpa2FkYXkucHJvdG90eXBlID0ge1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbmZpZ3VyZSBmdW5jdGlvbmFsaXR5XG4gICAgICAgICAqL1xuICAgICAgICBjb25maWc6IGZ1bmN0aW9uKG9wdGlvbnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fbykge1xuICAgICAgICAgICAgICAgIHRoaXMuX28gPSBleHRlbmQoe30sIGRlZmF1bHRzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9wdHMgPSBleHRlbmQodGhpcy5fbywgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIG9wdHMuaXNSVEwgPSAhIW9wdHMuaXNSVEw7XG5cbiAgICAgICAgICAgIG9wdHMuZmllbGQgPSAob3B0cy5maWVsZCAmJiBvcHRzLmZpZWxkLm5vZGVOYW1lKSA/IG9wdHMuZmllbGQgOiBudWxsO1xuXG4gICAgICAgICAgICBvcHRzLnRoZW1lID0gKHR5cGVvZiBvcHRzLnRoZW1lKSA9PT0gJ3N0cmluZycgJiYgb3B0cy50aGVtZSA/IG9wdHMudGhlbWUgOiBudWxsO1xuXG4gICAgICAgICAgICBvcHRzLmJvdW5kID0gISEob3B0cy5ib3VuZCAhPT0gdW5kZWZpbmVkID8gb3B0cy5maWVsZCAmJiBvcHRzLmJvdW5kIDogb3B0cy5maWVsZCk7XG5cbiAgICAgICAgICAgIG9wdHMudHJpZ2dlciA9IChvcHRzLnRyaWdnZXIgJiYgb3B0cy50cmlnZ2VyLm5vZGVOYW1lKSA/IG9wdHMudHJpZ2dlciA6IG9wdHMuZmllbGQ7XG5cbiAgICAgICAgICAgIG9wdHMuZGlzYWJsZVdlZWtlbmRzID0gISFvcHRzLmRpc2FibGVXZWVrZW5kcztcblxuICAgICAgICAgICAgb3B0cy5kaXNhYmxlRGF5Rm4gPSAodHlwZW9mIG9wdHMuZGlzYWJsZURheUZuKSA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuZGlzYWJsZURheUZuIDogbnVsbDtcblxuICAgICAgICAgICAgdmFyIG5vbSA9IHBhcnNlSW50KG9wdHMubnVtYmVyT2ZNb250aHMsIDEwKSB8fCAxO1xuICAgICAgICAgICAgb3B0cy5udW1iZXJPZk1vbnRocyA9IG5vbSA+IDQgPyA0IDogbm9tO1xuXG4gICAgICAgICAgICBpZiAoIWlzRGF0ZShvcHRzLm1pbkRhdGUpKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5taW5EYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzRGF0ZShvcHRzLm1heERhdGUpKSB7XG4gICAgICAgICAgICAgICAgb3B0cy5tYXhEYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG9wdHMubWluRGF0ZSAmJiBvcHRzLm1heERhdGUpICYmIG9wdHMubWF4RGF0ZSA8IG9wdHMubWluRGF0ZSkge1xuICAgICAgICAgICAgICAgIG9wdHMubWF4RGF0ZSA9IG9wdHMubWluRGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMubWluRGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWluRGF0ZShvcHRzLm1pbkRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMubWF4RGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TWF4RGF0ZShvcHRzLm1heERhdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNBcnJheShvcHRzLnllYXJSYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmFsbGJhY2sgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgLSAxMDtcbiAgICAgICAgICAgICAgICBvcHRzLnllYXJSYW5nZVswXSA9IHBhcnNlSW50KG9wdHMueWVhclJhbmdlWzBdLCAxMCkgfHwgZmFsbGJhY2s7XG4gICAgICAgICAgICAgICAgb3B0cy55ZWFyUmFuZ2VbMV0gPSBwYXJzZUludChvcHRzLnllYXJSYW5nZVsxXSwgMTApIHx8IGZhbGxiYWNrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRzLnllYXJSYW5nZSA9IE1hdGguYWJzKHBhcnNlSW50KG9wdHMueWVhclJhbmdlLCAxMCkpIHx8IGRlZmF1bHRzLnllYXJSYW5nZTtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy55ZWFyUmFuZ2UgPiAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy55ZWFyUmFuZ2UgPSAxMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3B0cztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJuIGEgZm9ybWF0dGVkIHN0cmluZyBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gKHVzaW5nIE1vbWVudC5qcyBpZiBhdmFpbGFibGUpXG4gICAgICAgICAqL1xuICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24oZm9ybWF0KVxuICAgICAgICB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgdGhpcy5fby5mb3JtYXQ7XG4gICAgICAgICAgICBpZiAoIWlzRGF0ZSh0aGlzLl9kKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vLnRvU3RyaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vLnRvU3RyaW5nKHRoaXMuX2QsIGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzTW9tZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBtb21lbnQodGhpcy5fZCkuZm9ybWF0KGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZC50b0RhdGVTdHJpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJuIGEgTW9tZW50LmpzIG9iamVjdCBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24gKGlmIGF2YWlsYWJsZSlcbiAgICAgICAgICovXG4gICAgICAgIGdldE1vbWVudDogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gaGFzTW9tZW50ID8gbW9tZW50KHRoaXMuX2QpIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHRoZSBjdXJyZW50IHNlbGVjdGlvbiBmcm9tIGEgTW9tZW50LmpzIG9iamVjdCAoaWYgYXZhaWxhYmxlKVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0TW9tZW50OiBmdW5jdGlvbihkYXRlLCBwcmV2ZW50T25TZWxlY3QpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChoYXNNb21lbnQgJiYgbW9tZW50LmlzTW9tZW50KGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREYXRlKGRhdGUudG9EYXRlKCksIHByZXZlbnRPblNlbGVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybiBhIERhdGUgb2JqZWN0IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RGF0ZTogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gaXNEYXRlKHRoaXMuX2QpID8gbmV3IERhdGUodGhpcy5fZC5nZXRUaW1lKCkpIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgc2V0RGF0ZTogZnVuY3Rpb24oZGF0ZSwgcHJldmVudE9uU2VsZWN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX28uZmllbGQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZmlyZUV2ZW50KHRoaXMuX28uZmllbGQsICdjaGFuZ2UnLCB7IGZpcmVkQnk6IHRoaXMgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLnBhcnNlKGRhdGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNEYXRlKGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWluID0gdGhpcy5fby5taW5EYXRlLFxuICAgICAgICAgICAgICAgIG1heCA9IHRoaXMuX28ubWF4RGF0ZTtcblxuICAgICAgICAgICAgaWYgKGlzRGF0ZShtaW4pICYmIGRhdGUgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbWluO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUobWF4KSAmJiBkYXRlID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG1heDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIHNldFRvU3RhcnRPZkRheSh0aGlzLl9kKTtcbiAgICAgICAgICAgIHRoaXMuZ290b0RhdGUodGhpcy5fZCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5maWVsZC52YWx1ZSA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBmaXJlRXZlbnQodGhpcy5fby5maWVsZCwgJ2NoYW5nZScsIHsgZmlyZWRCeTogdGhpcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJldmVudE9uU2VsZWN0ICYmIHR5cGVvZiB0aGlzLl9vLm9uU2VsZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5vblNlbGVjdC5jYWxsKHRoaXMsIHRoaXMuZ2V0RGF0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hhbmdlIHZpZXcgdG8gYSBzcGVjaWZpYyBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBnb3RvRGF0ZTogZnVuY3Rpb24oZGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG5ld0NhbGVuZGFyID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCFpc0RhdGUoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGVuZGFycykge1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFZpc2libGVEYXRlID0gbmV3IERhdGUodGhpcy5jYWxlbmRhcnNbMF0ueWVhciwgdGhpcy5jYWxlbmRhcnNbMF0ubW9udGgsIDEpLFxuICAgICAgICAgICAgICAgICAgICBsYXN0VmlzaWJsZURhdGUgPSBuZXcgRGF0ZSh0aGlzLmNhbGVuZGFyc1t0aGlzLmNhbGVuZGFycy5sZW5ndGgtMV0ueWVhciwgdGhpcy5jYWxlbmRhcnNbdGhpcy5jYWxlbmRhcnMubGVuZ3RoLTFdLm1vbnRoLCAxKSxcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZURhdGUgPSBkYXRlLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGVuZCBvZiB0aGUgbW9udGhcbiAgICAgICAgICAgICAgICBsYXN0VmlzaWJsZURhdGUuc2V0TW9udGgobGFzdFZpc2libGVEYXRlLmdldE1vbnRoKCkrMSk7XG4gICAgICAgICAgICAgICAgbGFzdFZpc2libGVEYXRlLnNldERhdGUobGFzdFZpc2libGVEYXRlLmdldERhdGUoKS0xKTtcbiAgICAgICAgICAgICAgICBuZXdDYWxlbmRhciA9ICh2aXNpYmxlRGF0ZSA8IGZpcnN0VmlzaWJsZURhdGUuZ2V0VGltZSgpIHx8IGxhc3RWaXNpYmxlRGF0ZS5nZXRUaW1lKCkgPCB2aXNpYmxlRGF0ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXdDYWxlbmRhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJzID0gW3tcbiAgICAgICAgICAgICAgICAgICAgbW9udGg6IGRhdGUuZ2V0TW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgeWVhcjogZGF0ZS5nZXRGdWxsWWVhcigpXG4gICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX28ubWFpbkNhbGVuZGFyID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJzWzBdLm1vbnRoICs9IDEgLSB0aGlzLl9vLm51bWJlck9mTW9udGhzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5hZGp1c3RDYWxlbmRhcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGp1c3REYXRlOiBmdW5jdGlvbihzaWduLCBkYXlzKSB7XG5cbiAgICAgICAgICAgIHZhciBkYXkgPSB0aGlzLmdldERhdGUoKSB8fCBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSBwYXJzZUludChkYXlzKSoyNCo2MCo2MCoxMDAwO1xuXG4gICAgICAgICAgICB2YXIgbmV3RGF5O1xuXG4gICAgICAgICAgICBpZiAoc2lnbiA9PT0gJ2FkZCcpIHtcbiAgICAgICAgICAgICAgICBuZXdEYXkgPSBuZXcgRGF0ZShkYXkudmFsdWVPZigpICsgZGlmZmVyZW5jZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNpZ24gPT09ICdzdWJ0cmFjdCcpIHtcbiAgICAgICAgICAgICAgICBuZXdEYXkgPSBuZXcgRGF0ZShkYXkudmFsdWVPZigpIC0gZGlmZmVyZW5jZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2V0RGF0ZShuZXdEYXkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkanVzdENhbGVuZGFyczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyc1swXSA9IGFkanVzdENhbGVuZGFyKHRoaXMuY2FsZW5kYXJzWzBdKTtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAxOyBjIDwgdGhpcy5fby5udW1iZXJPZk1vbnRoczsgYysrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhcnNbY10gPSBhZGp1c3RDYWxlbmRhcih7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoOiB0aGlzLmNhbGVuZGFyc1swXS5tb250aCArIGMsXG4gICAgICAgICAgICAgICAgICAgIHllYXI6IHRoaXMuY2FsZW5kYXJzWzBdLnllYXJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdvdG9Ub2RheTogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmdvdG9EYXRlKG5ldyBEYXRlKCkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFuZ2UgdmlldyB0byBhIHNwZWNpZmljIG1vbnRoICh6ZXJvLWluZGV4LCBlLmcuIDA6IEphbnVhcnkpXG4gICAgICAgICAqL1xuICAgICAgICBnb3RvTW9udGg6IGZ1bmN0aW9uKG1vbnRoKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJzWzBdLm1vbnRoID0gcGFyc2VJbnQobW9udGgsIDEwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkanVzdENhbGVuZGFycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG5leHRNb250aDogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyc1swXS5tb250aCsrO1xuICAgICAgICAgICAgdGhpcy5hZGp1c3RDYWxlbmRhcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcmV2TW9udGg6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhcnNbMF0ubW9udGgtLTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0Q2FsZW5kYXJzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYW5nZSB2aWV3IHRvIGEgc3BlY2lmaWMgZnVsbCB5ZWFyIChlLmcuIFwiMjAxMlwiKVxuICAgICAgICAgKi9cbiAgICAgICAgZ290b1llYXI6IGZ1bmN0aW9uKHllYXIpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghaXNOYU4oeWVhcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGVuZGFyc1swXS55ZWFyID0gcGFyc2VJbnQoeWVhciwgMTApO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRqdXN0Q2FsZW5kYXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYW5nZSB0aGUgbWluRGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0TWluRGF0ZTogZnVuY3Rpb24odmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHNldFRvU3RhcnRPZkRheSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5taW5EYXRlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5taW5ZZWFyICA9IHZhbHVlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5taW5Nb250aCA9IHZhbHVlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX28ubWluRGF0ZSA9IGRlZmF1bHRzLm1pbkRhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5taW5ZZWFyICA9IGRlZmF1bHRzLm1pblllYXI7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5taW5Nb250aCA9IGRlZmF1bHRzLm1pbk1vbnRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX28uc3RhcnRSYW5nZSA9IGRlZmF1bHRzLnN0YXJ0UmFuZ2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFuZ2UgdGhlIG1heERhdGVcbiAgICAgICAgICovXG4gICAgICAgIHNldE1heERhdGU6IGZ1bmN0aW9uKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZih2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICBzZXRUb1N0YXJ0T2ZEYXkodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX28ubWF4RGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX28ubWF4WWVhciA9IHZhbHVlLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5tYXhNb250aCA9IHZhbHVlLmdldE1vbnRoKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX28ubWF4RGF0ZSA9IGRlZmF1bHRzLm1heERhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5tYXhZZWFyID0gZGVmYXVsdHMubWF4WWVhcjtcbiAgICAgICAgICAgICAgICB0aGlzLl9vLm1heE1vbnRoID0gZGVmYXVsdHMubWF4TW9udGg7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5lbmRSYW5nZSA9IGRlZmF1bHRzLmVuZFJhbmdlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRyYXcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRTdGFydFJhbmdlOiBmdW5jdGlvbih2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fby5zdGFydFJhbmdlID0gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0RW5kUmFuZ2U6IGZ1bmN0aW9uKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9vLmVuZFJhbmdlID0gdmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlZnJlc2ggdGhlIEhUTUxcbiAgICAgICAgICovXG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uKGZvcmNlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3YgJiYgIWZvcmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9wdHMgPSB0aGlzLl9vLFxuICAgICAgICAgICAgICAgIG1pblllYXIgPSBvcHRzLm1pblllYXIsXG4gICAgICAgICAgICAgICAgbWF4WWVhciA9IG9wdHMubWF4WWVhcixcbiAgICAgICAgICAgICAgICBtaW5Nb250aCA9IG9wdHMubWluTW9udGgsXG4gICAgICAgICAgICAgICAgbWF4TW9udGggPSBvcHRzLm1heE1vbnRoLFxuICAgICAgICAgICAgICAgIGh0bWwgPSAnJyxcbiAgICAgICAgICAgICAgICByYW5kSWQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl95IDw9IG1pblllYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gbWluWWVhcjtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKG1pbk1vbnRoKSAmJiB0aGlzLl9tIDwgbWluTW9udGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbSA9IG1pbk1vbnRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl95ID49IG1heFllYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl95ID0gbWF4WWVhcjtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKG1heE1vbnRoKSAmJiB0aGlzLl9tID4gbWF4TW9udGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbSA9IG1heE1vbnRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmFuZElkID0gJ3Bpa2EtdGl0bGUtJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnJlcGxhY2UoL1teYS16XSsvZywgJycpLnN1YnN0cigwLCAyKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBvcHRzLm51bWJlck9mTW9udGhzOyBjKyspIHtcbiAgICAgICAgICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwicGlrYS1sZW5kYXJcIj4nICsgcmVuZGVyVGl0bGUodGhpcywgYywgdGhpcy5jYWxlbmRhcnNbY10ueWVhciwgdGhpcy5jYWxlbmRhcnNbY10ubW9udGgsIHRoaXMuY2FsZW5kYXJzWzBdLnllYXIsIHJhbmRJZCkgKyB0aGlzLnJlbmRlcih0aGlzLmNhbGVuZGFyc1tjXS55ZWFyLCB0aGlzLmNhbGVuZGFyc1tjXS5tb250aCwgcmFuZElkKSArICc8L2Rpdj4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmVsLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAgICAgICAgIGlmIChvcHRzLmJvdW5kKSB7XG4gICAgICAgICAgICAgICAgaWYob3B0cy5maWVsZC50eXBlICE9PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgICAgICAgICBzdG8oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzLnRyaWdnZXIuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX28ub25EcmF3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5vbkRyYXcodGhpcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChvcHRzLmJvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gbGV0IHRoZSBzY3JlZW4gcmVhZGVyIHVzZXIga25vdyB0byB1c2UgYXJyb3cga2V5c1xuICAgICAgICAgICAgICAgIG9wdHMuZmllbGQuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgJ1VzZSB0aGUgYXJyb3cga2V5cyB0byBwaWNrIGEgZGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGFkanVzdFBvc2l0aW9uOiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCwgcEVsLCB3aWR0aCwgaGVpZ2h0LCB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCwgc2Nyb2xsVG9wLCBsZWZ0LCB0b3AsIGNsaWVudFJlY3Q7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vLmNvbnRhaW5lcikgcmV0dXJuO1xuXG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblxuICAgICAgICAgICAgZmllbGQgPSB0aGlzLl9vLnRyaWdnZXI7XG4gICAgICAgICAgICBwRWwgPSBmaWVsZDtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5lbC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuZWwub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgdmlld3BvcnRXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIHZpZXdwb3J0SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICBzY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjbGllbnRSZWN0ID0gZmllbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGNsaWVudFJlY3QubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICAgICAgICAgICAgICB0b3AgPSBjbGllbnRSZWN0LmJvdHRvbSArIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IHBFbC5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgIHRvcCAgPSBwRWwub2Zmc2V0VG9wICsgcEVsLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICB3aGlsZSgocEVsID0gcEVsLm9mZnNldFBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCArPSBwRWwub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdG9wICArPSBwRWwub2Zmc2V0VG9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGVmYXVsdCBwb3NpdGlvbiBpcyBib3R0b20gJiBsZWZ0XG4gICAgICAgICAgICBpZiAoKHRoaXMuX28ucmVwb3NpdGlvbiAmJiBsZWZ0ICsgd2lkdGggPiB2aWV3cG9ydFdpZHRoKSB8fFxuICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fby5wb3NpdGlvbi5pbmRleE9mKCdyaWdodCcpID4gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgbGVmdCAtIHdpZHRoICsgZmllbGQub2Zmc2V0V2lkdGggPiAwXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQgLSB3aWR0aCArIGZpZWxkLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLl9vLnJlcG9zaXRpb24gJiYgdG9wICsgaGVpZ2h0ID4gdmlld3BvcnRIZWlnaHQgKyBzY3JvbGxUb3ApIHx8XG4gICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vLnBvc2l0aW9uLmluZGV4T2YoJ3RvcCcpID4gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgdG9wIC0gaGVpZ2h0IC0gZmllbGQub2Zmc2V0SGVpZ2h0ID4gMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRvcCA9IHRvcCAtIGhlaWdodCAtIGZpZWxkLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlbmRlciBIVE1MIGZvciBhIHBhcnRpY3VsYXIgbW9udGhcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24oeWVhciwgbW9udGgsIHJhbmRJZClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIG9wdHMgICA9IHRoaXMuX28sXG4gICAgICAgICAgICAgICAgbm93ICAgID0gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICBkYXlzICAgPSBnZXREYXlzSW5Nb250aCh5ZWFyLCBtb250aCksXG4gICAgICAgICAgICAgICAgYmVmb3JlID0gbmV3IERhdGUoeWVhciwgbW9udGgsIDEpLmdldERheSgpLFxuICAgICAgICAgICAgICAgIGRhdGEgICA9IFtdLFxuICAgICAgICAgICAgICAgIHJvdyAgICA9IFtdO1xuICAgICAgICAgICAgc2V0VG9TdGFydE9mRGF5KG5vdyk7XG4gICAgICAgICAgICBpZiAob3B0cy5maXJzdERheSA+IDApIHtcbiAgICAgICAgICAgICAgICBiZWZvcmUgLT0gb3B0cy5maXJzdERheTtcbiAgICAgICAgICAgICAgICBpZiAoYmVmb3JlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBiZWZvcmUgKz0gNztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNNb250aCA9IG1vbnRoID09PSAwID8gMTEgOiBtb250aCAtIDEsXG4gICAgICAgICAgICAgICAgbmV4dE1vbnRoID0gbW9udGggPT09IDExID8gMCA6IG1vbnRoICsgMSxcbiAgICAgICAgICAgICAgICB5ZWFyT2ZQcmV2aW91c01vbnRoID0gbW9udGggPT09IDAgPyB5ZWFyIC0gMSA6IHllYXIsXG4gICAgICAgICAgICAgICAgeWVhck9mTmV4dE1vbnRoID0gbW9udGggPT09IDExID8geWVhciArIDEgOiB5ZWFyLFxuICAgICAgICAgICAgICAgIGRheXNJblByZXZpb3VzTW9udGggPSBnZXREYXlzSW5Nb250aCh5ZWFyT2ZQcmV2aW91c01vbnRoLCBwcmV2aW91c01vbnRoKTtcbiAgICAgICAgICAgIHZhciBjZWxscyA9IGRheXMgKyBiZWZvcmUsXG4gICAgICAgICAgICAgICAgYWZ0ZXIgPSBjZWxscztcbiAgICAgICAgICAgIHdoaWxlKGFmdGVyID4gNykge1xuICAgICAgICAgICAgICAgIGFmdGVyIC09IDc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxscyArPSA3IC0gYWZ0ZXI7XG4gICAgICAgICAgICB2YXIgaXNXZWVrU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCByID0gMDsgaSA8IGNlbGxzOyBpKyspXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIGRheSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxICsgKGkgLSBiZWZvcmUpKSxcbiAgICAgICAgICAgICAgICAgICAgaXNTZWxlY3RlZCA9IGlzRGF0ZSh0aGlzLl9kKSA/IGNvbXBhcmVEYXRlcyhkYXksIHRoaXMuX2QpIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGlzVG9kYXkgPSBjb21wYXJlRGF0ZXMoZGF5LCBub3cpLFxuICAgICAgICAgICAgICAgICAgICBoYXNFdmVudCA9IG9wdHMuZXZlbnRzLmluZGV4T2YoZGF5LnRvRGF0ZVN0cmluZygpKSAhPT0gLTEgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGlzRW1wdHkgPSBpIDwgYmVmb3JlIHx8IGkgPj0gKGRheXMgKyBiZWZvcmUpLFxuICAgICAgICAgICAgICAgICAgICBkYXlOdW1iZXIgPSAxICsgKGkgLSBiZWZvcmUpLFxuICAgICAgICAgICAgICAgICAgICBtb250aE51bWJlciA9IG1vbnRoLFxuICAgICAgICAgICAgICAgICAgICB5ZWFyTnVtYmVyID0geWVhcixcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydFJhbmdlID0gb3B0cy5zdGFydFJhbmdlICYmIGNvbXBhcmVEYXRlcyhvcHRzLnN0YXJ0UmFuZ2UsIGRheSksXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kUmFuZ2UgPSBvcHRzLmVuZFJhbmdlICYmIGNvbXBhcmVEYXRlcyhvcHRzLmVuZFJhbmdlLCBkYXkpLFxuICAgICAgICAgICAgICAgICAgICBpc0luUmFuZ2UgPSBvcHRzLnN0YXJ0UmFuZ2UgJiYgb3B0cy5lbmRSYW5nZSAmJiBvcHRzLnN0YXJ0UmFuZ2UgPCBkYXkgJiYgZGF5IDwgb3B0cy5lbmRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgaXNEaXNhYmxlZCA9IChvcHRzLm1pbkRhdGUgJiYgZGF5IDwgb3B0cy5taW5EYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wdHMubWF4RGF0ZSAmJiBkYXkgPiBvcHRzLm1heERhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3B0cy5kaXNhYmxlV2Vla2VuZHMgJiYgaXNXZWVrZW5kKGRheSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3B0cy5kaXNhYmxlRGF5Rm4gJiYgb3B0cy5kaXNhYmxlRGF5Rm4oZGF5KSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF5TnVtYmVyID0gZGF5c0luUHJldmlvdXNNb250aCArIGRheU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoTnVtYmVyID0gcHJldmlvdXNNb250aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHllYXJOdW1iZXIgPSB5ZWFyT2ZQcmV2aW91c01vbnRoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF5TnVtYmVyID0gZGF5TnVtYmVyIC0gZGF5cztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoTnVtYmVyID0gbmV4dE1vbnRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWVhck51bWJlciA9IHllYXJPZk5leHRNb250aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBkYXlDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXk6IGRheU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoOiBtb250aE51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHllYXI6IHllYXJOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFdmVudDogaGFzRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlbGVjdGVkOiBpc1NlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNUb2RheTogaXNUb2RheSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRGlzYWJsZWQ6IGlzRGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VtcHR5OiBpc0VtcHR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTdGFydFJhbmdlOiBpc1N0YXJ0UmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZFJhbmdlOiBpc0VuZFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNJblJhbmdlOiBpc0luUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93RGF5c0luTmV4dEFuZFByZXZpb3VzTW9udGhzOiBvcHRzLnNob3dEYXlzSW5OZXh0QW5kUHJldmlvdXNNb250aHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVTZWxlY3Rpb25EYXlzSW5OZXh0QW5kUHJldmlvdXNNb250aHM6IG9wdHMuZW5hYmxlU2VsZWN0aW9uRGF5c0luTmV4dEFuZFByZXZpb3VzTW9udGhzXG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0cy5waWNrV2hvbGVXZWVrICYmIGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNXZWVrU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJvdy5wdXNoKHJlbmRlckRheShkYXlDb25maWcpKTtcblxuICAgICAgICAgICAgICAgIGlmICgrK3IgPT09IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuc2hvd1dlZWtOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy51bnNoaWZ0KHJlbmRlcldlZWsoaSAtIGJlZm9yZSwgbW9udGgsIHllYXIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkYXRhLnB1c2gocmVuZGVyUm93KHJvdywgb3B0cy5pc1JUTCwgb3B0cy5waWNrV2hvbGVXZWVrLCBpc1dlZWtTZWxlY3RlZCkpO1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgciA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlzV2Vla1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlbmRlclRhYmxlKG9wdHMsIGRhdGEsIHJhbmRJZCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNWaXNpYmxlOiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92O1xuICAgICAgICB9LFxuXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3ModGhpcy5lbCwgJ2lzLWhpZGRlbicpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vLmJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEV2ZW50KGRvY3VtZW50LCAnY2xpY2snLCB0aGlzLl9vbkNsaWNrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGp1c3RQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX28ub25PcGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX28ub25PcGVuLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLl92O1xuICAgICAgICAgICAgaWYgKHYgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX28uYm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnQoZG9jdW1lbnQsICdjbGljaycsIHRoaXMuX29uQ2xpY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnBvc2l0aW9uID0gJ3N0YXRpYyc7IC8vIHJlc2V0XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5sZWZ0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUudG9wID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIGFkZENsYXNzKHRoaXMuZWwsICdpcy1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLl92ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdGhpcy5fby5vbkNsb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX28ub25DbG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogR0FNRSBPVkVSXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgcmVtb3ZlRXZlbnQodGhpcy5lbCwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0cnVlKTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50KHRoaXMuZWwsICd0b3VjaGVuZCcsIHRoaXMuX29uTW91c2VEb3duLCB0cnVlKTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50KHRoaXMuZWwsICdjaGFuZ2UnLCB0aGlzLl9vbkNoYW5nZSk7XG4gICAgICAgICAgICByZW1vdmVFdmVudChkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleUNoYW5nZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5fby5maWVsZCkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50KHRoaXMuX28uZmllbGQsICdjaGFuZ2UnLCB0aGlzLl9vbklucHV0Q2hhbmdlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fby5ib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudCh0aGlzLl9vLnRyaWdnZXIsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljayk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50KHRoaXMuX28udHJpZ2dlciwgJ2ZvY3VzJywgdGhpcy5fb25JbnB1dEZvY3VzKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnQodGhpcy5fby50cmlnZ2VyLCAnYmx1cicsIHRoaXMuX29uSW5wdXRCbHVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5lbC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgcmV0dXJuIFBpa2FkYXk7XG5cbn0pKTtcbiIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiaW5kZXhcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiaW5kZXhcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiaW5kZXhcIl0gPSByb290W1wiaW5kZXhcIl0gfHwge30sIHJvb3RbXCJpbmRleFwiXVtcImluZGV4XCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHR2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0dmFyIFZlYW1zRE9NID0ge1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdERPTTogZmFsc2Vcblx0XHR9LFxuXHRcdHBsdWdpbk5hbWU6ICckJyxcblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKFZlYW1zLCBfcmVmKSB7XG5cdFx0XHR2YXIgRE9NID0gX3JlZi5ET007XG5cdFxuXHRcdFx0aWYgKCFET00pIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVmVhbXNET00gOjogWW91IG5lZWQgdG8gcGFzcyBhbiBvcHRpb25zIG9iamVjdCB3aXRoIGEgRE9NIGhhbmRsZXI6IG9wdGlvbnMuRE9NIScpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoVmVhbXMuJCkge1xuXHRcdFx0XHRjb25zb2xlLmxvZygnVmVhbXNET00gOjogSXQgc2VlbXMgdGhhdCB5b3UgaGF2ZSBhbHJlYWR5IGRlZmluZWQgYSBET00gaGFuZGxlci4gSSBhbSBvdmVyd3JpdGluZyBpdCBub3cgZm9yIHlvdSA7KScpO1xuXHRcdFx0fVxuXHRcblx0XHRcdFZlYW1zLiQgPSB0aGlzLm9wdGlvbnMuRE9NID0gRE9NO1xuXHRcdH1cblx0fTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IFZlYW1zRE9NO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJpbmRleFwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJpbmRleFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJpbmRleFwiXSA9IHJvb3RbXCJpbmRleFwiXSB8fCB7fSwgcm9vdFtcImluZGV4XCJdW1wiaW5kZXhcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXHRcblx0dmFyIFZlYW1zTG9nZ2VyID0ge1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdGRldm1vZGVQYXJhbTogJ2Rldm1vZGUnLFxuXHRcdFx0bG9nZ2VyUGFyYW06ICdsb2dnZXInXG5cdFx0fSxcblx0XHRwbHVnaW5OYW1lOiAnTG9nZ2VyJyxcblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKFZlYW1zLCBvcHRzKSB7XG5cdFxuXHRcdFx0aWYgKG9wdHMpIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zID0gVmVhbXMuaGVscGVycy5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRzIHx8IHt9KTtcblx0XHRcdH1cblx0XG5cdFx0XHQvKipcblx0ICAgKiBEZXZtb2RlIGFuZCBsb2dnZXJcblx0ICAgKi9cblx0XHRcdFZlYW1zLmRldm1vZGUgPSBmYWxzZTtcblx0XHRcdFZlYW1zLmxvZ2dlciA9IGZhbHNlO1xuXHRcblx0XHRcdGlmIChkb2N1bWVudC5sb2NhdGlvbi5zZWFyY2guaW5kZXhPZih0aGlzLm9wdGlvbnMuZGV2bW9kZVBhcmFtKSA+IC0xIHx8IHdpbmRvdy5zZXNzaW9uU3RvcmFnZSAmJiBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdkZXZtb2RlRW5hYmxlZCcpKSB7XG5cdFx0XHRcdFZlYW1zLmRldm1vZGUgPSB0cnVlO1xuXHRcblx0XHRcdFx0aWYgKHdpbmRvdy5zZXNzaW9uU3RvcmFnZSAmJiAhc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSgnZGV2bW9kZUVuYWJsZWQnKSkge1xuXHRcdFx0XHRcdHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oJ2Rldm1vZGVFbmFibGVkJywgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMub3B0aW9ucy5kZXZtb2RlUGFyYW0pO1xuXHRcdFx0fVxuXHRcblx0XHRcdGlmIChkb2N1bWVudC5sb2NhdGlvbi5zZWFyY2guaW5kZXhPZih0aGlzLm9wdGlvbnMubG9nZ2VyUGFyYW0pID4gLTEpIHtcblx0XHRcdFx0VmVhbXMubG9nZ2VyID0gdHJ1ZTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBoaWRlIGFsbCB3YXJuaW5ncyBhbmQgbG9ncyBpZiBub3QgaW4gZGV2bW9kZVxuXHRcdFx0aWYgKCFWZWFtcy5kZXZtb2RlKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nID0gY29uc29sZS53YXJuID0gZnVuY3Rpb24gKCkge307XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gYWRkIGNvbnNvbGUgb3V0cHV0IGVsZW1lbnQgKHRyaWdnZXJlZCBieSBwYXJhbWV0ZXIgJ2Rldm1vZGUnIGFuZCAnbG9nZ2VyJyBpbiB1cmwpXG5cdFx0XHRpZiAoVmVhbXMuZGV2bW9kZSAmJiBWZWFtcy5sb2dnZXIpIHtcblx0XHRcdFx0dmFyIGxvZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ByZScpO1xuXHRcblx0XHRcdFx0bG9nZ2VyLnNldEF0dHJpYnV0ZSgnaWQnLCAnbG9nZ2VyJyk7XG5cdFx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobG9nZ2VyKTtcblx0XG5cdFx0XHRcdGNvbnNvbGUud3JpdGUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChfdHlwZW9mKGFyZ3VtZW50c1tpXSkgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0XHRcdGxvZ2dlci5pbm5lckhUTUwgKz0gKEpTT04gJiYgSlNPTi5zdHJpbmdpZnkgPyBKU09OLnN0cmluZ2lmeShhcmd1bWVudHNbaV0sIHVuZGVmaW5lZCwgMikgOiBhcmd1bWVudHNbaV0pICsgJzxiciAvPic7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsb2dnZXIuaW5uZXJIVE1MICs9IGFyZ3VtZW50c1tpXSArICc8YnIgLz4nO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0bG9nZ2VyLmlubmVySFRNTCArPSAnPGJyIC8+Jztcblx0XHRcdFx0XHRsb2dnZXIuc2Nyb2xsVG9wID0gbG9nZ2VyLnNjcm9sbEhlaWdodDtcblx0XHRcdFx0fTtcblx0XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bG9nZ2VyLmlubmVySFRNTCArPSAnW0Vycm9yXTxiciAvPic7XG5cdFx0XHRcdFx0Y29uc29sZS53cml0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9O1xuXHRcblx0XHRcdFx0Y29uc29sZS53YXJuID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGxvZ2dlci5pbm5lckhUTUwgKz0gJ1tXYXJuXTxiciAvPic7XG5cdFx0XHRcdFx0Y29uc29sZS53cml0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9O1xuXHRcblx0XHRcdFx0Y29uc29sZS5sb2cgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bG9nZ2VyLmlubmVySFRNTCArPSAnW0xvZ108YnIgLz4nO1xuXHRcdFx0XHRcdGNvbnNvbGUud3JpdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBWZWFtc0xvZ2dlcjtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiaW5kZXhcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiaW5kZXhcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiaW5kZXhcIl0gPSByb290W1wiaW5kZXhcIl0gfHwge30sIHJvb3RbXCJpbmRleFwiXVtcImluZGV4XCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogSW1wb3J0c1xuXHQgKi9cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHR2YXIgVmVhbXNNZWRpYVF1ZXJ5SGFuZGxlciA9IHtcblx0XHRvcHRpb25zOiB7XG5cdFx0XHRtZWRpYVF1ZXJ5UHJvcDogJ2ZvbnQtZmFtaWx5Jyxcblx0XHRcdGRlbGF5OiAzMDBcblx0XHR9LFxuXHRcdHBsdWdpbk5hbWU6ICdNZWRpYVF1ZXJ5SGFuZGxlcicsXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShWZWFtcywgb3B0cykge1xuXHRcdFx0dmFyIF90aGlzID0gdGhpcztcblx0XG5cdFx0XHQvLyBNZWRpYSBRdWVyeVxuXHRcdFx0dmFyIGhlYWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdoZWFkJyk7XG5cdFxuXHRcdFx0aWYgKG9wdHMpIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zID0gVmVhbXMuaGVscGVycy5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRzIHx8IHt9KTtcblx0XHRcdH1cblx0XG5cdFx0XHQvKipcblx0ICAgKiBBZGQgY3VycmVudCBtZWRpYSBxdWVyeSB0byBWZWFtc1xuXHQgICAqL1xuXHRcdFx0VmVhbXMuY3VycmVudE1lZGlhID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaGVhZFswXSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZSh0aGlzLm9wdGlvbnMubWVkaWFRdWVyeVByb3ApO1xuXHRcblx0XHRcdGlmICghVmVhbXMuVmVudCkge1xuXHRcdFx0XHRjb25zb2xlLmluZm8oJ1ZlYW1zTWVkaWFRdWVyeUhhbmRsZXIgOjogSW4gb3JkZXIgdG8gd29yayBwcm9wZXJseSB3aXRoIHRoZSBWZWFtc01lZGlhUXVlcnlIYW5kbGVyIHBsdWdpbiB5b3Ugc2hvdWxkIGFkZCB0aGUgVmVhbXNWZW50IHBsdWdpbiEnKTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBUcmlnZ2VyIGdsb2JhbCByZXNpemUgZXZlbnRcblx0XHRcdHdpbmRvdy5vbnJlc2l6ZSA9IFZlYW1zLmhlbHBlcnMudGhyb3R0bGUoZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0dmFyIGN1cnJlbnRNZWRpYSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGhlYWRbMF0sIG51bGwpLmdldFByb3BlcnR5VmFsdWUoX3RoaXMub3B0aW9ucy5tZWRpYVF1ZXJ5UHJvcCk7XG5cdFx0XHRcdHZhciB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXHRcblx0XHRcdFx0aWYgKGN1cnJlbnRNZWRpYSAhPT0gVmVhbXMuY3VycmVudE1lZGlhKSB7XG5cdFx0XHRcdFx0dmFyIG9sZE1lZGlhID0gVmVhbXMuY3VycmVudE1lZGlhO1xuXHRcblx0XHRcdFx0XHRWZWFtcy5jdXJyZW50TWVkaWEgPSBjdXJyZW50TWVkaWE7XG5cdFxuXHRcdFx0XHRcdGNvbnNvbGUuaW5mbygnVmVhbXNNZWRpYVF1ZXJ5SGFuZGxlciA6OiBDdXJyZW50IG1lZGlhIGlzICcgKyBWZWFtcy5jdXJyZW50TWVkaWEpO1xuXHRcblx0XHRcdFx0XHRpZiAoVmVhbXMuVmVudCkge1xuXHRcdFx0XHRcdFx0VmVhbXMuVmVudC50cmlnZ2VyKFZlYW1zLkVWRU5UUy5tZWRpYWNoYW5nZSwge1xuXHRcdFx0XHRcdFx0XHR0eXBlOiBWZWFtcy5FVkVOVFMubWVkaWFjaGFuZ2UsXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRNZWRpYTogY3VycmVudE1lZGlhLFxuXHRcdFx0XHRcdFx0XHRvbGRNZWRpYTogb2xkTWVkaWFcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0VmVhbXMuZGV0ZWN0aW9ucy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0XHRWZWFtcy5WZW50LnRyaWdnZXIoVmVhbXMuRVZFTlRTLnJlc2l6ZSwgZSk7XG5cdFx0XHR9LCB0aGlzLm9wdGlvbnMuZGVsYXkpO1xuXHRcdH1cblx0fTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IFZlYW1zTWVkaWFRdWVyeUhhbmRsZXI7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcImluZGV4XCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImluZGV4XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImluZGV4XCJdID0gcm9vdFtcImluZGV4XCJdIHx8IHt9LCByb290W1wiaW5kZXhcIl1bXCJpbmRleFwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0dmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdHZhciBWZWFtcyA9IHt9O1xuXHR2YXIgX19jYWNoZSA9IFtdO1xuXHR2YXIgX19yZWdpc3RlciA9IHtcblx0XHRtb2R1bGVzSW5SZWdpc3RlcjogW10sXG5cdFx0bW9kdWxlc09uQ29uZGl0aW9uczogW10sXG5cdFx0bW9kdWxlc09uSW5pdDogW10sXG5cdFx0bW9kdWxlc0luQ29udGV4dDogW11cblx0fTtcblx0XG5cdC8qKlxuXHQgKiBUT0RPOiBDbGVhbiB1cCBtdXRhdGlvbiBvYnNlcnZlclxuXHQgKi9cblx0XG5cdC8qKlxuXHQgKiAtIEdldCBtb2R1bGVzIGluIERPTVxuXHQgKiAtIEdldCBjbGFzc2VzIGFuZCBvcHRpb25zIGZyb20gaW5pdCBwcm9jZXNzXG5cdCAqIC0gU3BsaXQgdXAgY29uZGl0aW9uYWwgbW9kdWxlcyBmcm9tIGluaXRpYWwgbW9kdWxlc1xuXHQgKiAtIEluaXQgb3RoZXIgbW9kdWxlc1xuXHQgKiAtIEJpbmQgZXZlbnRzIHdoZW4gYXZhaWxhYmxlIGZyb20gY29uZGl0aW9uYWwgbW9kdWxlc1xuXHQgKiAtXG5cdCAqL1xuXHRcblx0dmFyIE1vZHVsZXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gTW9kdWxlcygpIHtcblx0XHRcdHZhciBWRUFNUyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogd2luZG93LlZlYW1zO1xuXHRcdFx0dmFyIG9wdHMgPSBhcmd1bWVudHNbMV07XG5cdFxuXHRcdFx0X2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vZHVsZXMpO1xuXHRcblx0XHRcdFZlYW1zID0gVkVBTVM7XG5cdFxuXHRcdFx0dGhpcy5vcHRpb25zID0gb3B0cztcblx0XG5cdFx0XHRpZiAoIXRoaXMub3B0aW9ucy5pbnRlcm5hbENhY2hlT25seSkge1xuXHRcdFx0XHR0aGlzLl9jYWNoZSA9IF9fY2FjaGU7IC8vIE1vZHVsZSBsaXN0XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCF0aGlzLm9wdGlvbnMuaW50ZXJuYWxSZWdpc3Rlck9ubHkpIHtcblx0XHRcdFx0dGhpcy5fcmVnaXN0ZXIgPSBfX3JlZ2lzdGVyO1xuXHRcdFx0fVxuXHRcblx0XHRcdHRoaXMuaW5pdGlhbGl6ZSgpO1xuXHRcdH1cblx0XG5cdFx0X2NyZWF0ZUNsYXNzKE1vZHVsZXMsIFt7XG5cdFx0XHRrZXk6ICdpbml0aWFsaXplJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuXHRcdFx0XHR0aGlzLnF1ZXJ5U3RyaW5nID0gJ1snICsgdGhpcy5vcHRpb25zLmF0dHJQcmVmaXggKyAnLScgKyB0aGlzLm9wdGlvbnMuYXR0ck5hbWUgKyAnXSc7XG5cdFx0XHRcdF9fcmVnaXN0ZXIubW9kdWxlc0luQ29udGV4dCA9IFZlYW1zLmhlbHBlcnMucXVlcnlTZWxlY3RvckFycmF5KHRoaXMucXVlcnlTdHJpbmcpO1xuXHRcblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy51c2VNdXRhdGlvbk9ic2VydmVyKSB7XG5cdFx0XHRcdFx0dGhpcy5vYnNlcnZlKGRvY3VtZW50LmJvZHkpO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHR0aGlzLmJpbmRFdmVudHMoKTtcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdiaW5kRXZlbnRzJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRzKCkge1xuXHRcdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcblx0XHRcdFx0aWYgKCFWZWFtcy5WZW50ICYmIHRoaXMub3B0aW9ucy51c2VNdXRhdGlvbk9ic2VydmVyID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdGNvbnNvbGUuaW5mbygnVmVhbXNNb2R1bGVzIDo6IEluIG9yZGVyIHRvIHdvcmsgd2l0aCB0aGUgdGhlIGFqYXggaGFuZGxpbmcgaW4gVmVhbXNNb2R1bGVzSGFuZGxlciAnICsgJ3lvdSBuZWVkIHRvIGRlZmluZSBcInVzZU11dGF0aW9uT2JzZXJ2ZXJcIiBvciB1c2UgdGhlIFZlYW1zVmVudCBwbHVnaW4hJyk7XG5cdFxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0aWYgKFZlYW1zLlZlbnQgJiYgdGhpcy5vcHRpb25zLnVzZU11dGF0aW9uT2JzZXJ2ZXIgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0VmVhbXMuVmVudC5vbihWZWFtcy5FVkVOVFMuRE9NY2hhbmdlZCwgZnVuY3Rpb24gKGUsIGNvbnRleHQpIHtcblx0XHRcdFx0XHRcdF9fcmVnaXN0ZXIubW9kdWxlc0luQ29udGV4dCA9IF90aGlzLmdldE1vZHVsZXNJbkNvbnRleHQoY29udGV4dCk7XG5cdFxuXHRcdFx0XHRcdFx0aWYgKF90aGlzLm9wdGlvbnMubG9ncykge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmluZm8oJ1ZlYW1zTW9kdWxlcyA6OiBSZWNvcmRpbmcgbmV3IGNvbnRleHQuIFdoZW4gYXZhaWxhYmxlIG5ldyBtb2R1bGVzIHdpbGwgYmUgaW5pdGlhbGlzZWQgaW46ICcsIGNvbnRleHQpO1xuXHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdF90aGlzLnJlZ2lzdGVyQWxsKCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHRcdC8vIFNUQVRJQyBDQUNIRSBIQU5ETEVSXG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XG5cdFx0XHQvKipcblx0ICAgKiBTYXZlIHRoZSBtb2R1bGUgaW4gX19jYWNoZS5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgLSBtb2R1bGUgbWV0YWRhdGEgb2JqZWN0IChAc2VlIFZlYW1zQ29tcG9uZW50Lm1ldGFEYXRhKCkpXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBtb2R1bGUgZWxlbWVudCAodGhpcy5lbClcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2UgLSBtb2R1bGUgaW5zdGFuY2Vcblx0ICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIC0gbW9kdWxlIG5hbWVzcGFjZVxuXHQgICAqL1xuXHRcblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdiaW5kQ29uZGl0aW9ucycsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gYmluZENvbmRpdGlvbnMoKSB7XG5cdFx0XHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXHRcblx0XHRcdFx0X19yZWdpc3Rlci5tb2R1bGVzT25Db25kaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xuXHRcdFx0XHRcdGlmIChtb2R1bGUuY29uZGl0aW9uc0xpc3Rlbk9uICYmIG1vZHVsZS5jb25kaXRpb25zTGlzdGVuT24ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRfdGhpczIuYmluZENvbmRpdGlvbihtb2R1bGUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAnYmluZENvbmRpdGlvbicsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gYmluZENvbmRpdGlvbihtb2R1bGUpIHtcblx0XHRcdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cdFxuXHRcdFx0XHR2YXIgZ2xvYmFsRXZ0cyA9IG1vZHVsZS5jb25kaXRpb25zTGlzdGVuT24uam9pbignICcpO1xuXHRcblx0XHRcdFx0aWYgKFZlYW1zLlZlbnQpIHtcblx0XHRcdFx0XHRWZWFtcy5WZW50LnN1YnNjcmliZShnbG9iYWxFdnRzLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRfdGhpczMucmVnaXN0ZXJDb25kaXRpb25hbE1vZHVsZShtb2R1bGUpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0XHQvLyBVTi9SRUdJU1RFUiBIQU5ETEVSXG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XG5cdFx0XHQvKipcblx0ICAgKiBTcGxpdCB1cCBtb2R1bGVzIGRlcGVuZGluZyBvbiBjb25kaXRpb24gY2hlY2tcblx0ICAgKi9cblx0XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAnc3BsaXRVcE1vZHVsZXMnLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIHNwbGl0VXBNb2R1bGVzKCkge1xuXHRcdFx0XHR2YXIgX3RoaXM0ID0gdGhpcztcblx0XG5cdFx0XHRcdF9fcmVnaXN0ZXIubW9kdWxlc0luUmVnaXN0ZXIuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG5cdFx0XHRcdFx0aWYgKF90aGlzNC5jb25zdHJ1Y3Rvci5pc0NvbmRpdGlvbihvYmopKSB7XG5cdFx0XHRcdFx0XHRfX3JlZ2lzdGVyLm1vZHVsZXNPbkNvbmRpdGlvbnMucHVzaChvYmopO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRfX3JlZ2lzdGVyLm1vZHVsZXNPbkluaXQucHVzaChvYmopO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyoqXG5cdCAgICogUmVnaXN0ZXIgbXVsdGlwbGUgbW9kdWxlcy5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7QXJyYXl9IGFyciAtIEFycmF5IHdoaWNoIGNvbnRhaW5zIHRoZSBtb2R1bGVzIGFzIG9iamVjdC5cblx0ICAgKlxuXHQgICAqIEBwdWJsaWNcblx0ICAgKi9cblx0XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAncmVnaXN0ZXInLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKGFycikge1xuXHRcdFx0XHRpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVmVhbXNNb2R1bGVzIDo6IFlvdSBuZWVkIHRvIHBhc3MgYW4gYXJyYXkgdG8gcmVnaXN0ZXIoKSEnKTtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0X19yZWdpc3Rlci5tb2R1bGVzSW5SZWdpc3RlciA9IF9fcmVnaXN0ZXIubW9kdWxlc0luUmVnaXN0ZXIuY29uY2F0KGFycik7XG5cdFxuXHRcdFx0XHR0aGlzLnNwbGl0VXBNb2R1bGVzKCk7XG5cdFx0XHRcdHRoaXMuYmluZENvbmRpdGlvbnMoKTtcblx0XHRcdFx0dGhpcy5yZWdpc3RlckFsbCgpO1xuXHRcdFx0fVxuXHRcdH0sIHtcblx0XHRcdGtleTogJ2FkZCcsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gYWRkKG5hbWVzcGFjZSwgbW9kdWxlKSB7XG5cdFx0XHRcdHZhciBvcHRpb25zT2JqID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblx0XG5cdFx0XHRcdHZhciBjdXJyZW50TW9kdWxlID0gT2JqZWN0LmFzc2lnbih7fSwge1xuXHRcdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuXHRcdFx0XHRcdG1vZHVsZTogbW9kdWxlXG5cdFx0XHRcdH0sIG9wdGlvbnNPYmopO1xuXHRcblx0XHRcdFx0aWYgKHRoaXMuY29uc3RydWN0b3IuaXNDb25kaXRpb24oY3VycmVudE1vZHVsZSkpIHtcblx0XHRcdFx0XHRpZiAoY3VycmVudE1vZHVsZS5jb25kaXRpb25zTGlzdGVuT24gJiYgY3VycmVudE1vZHVsZS5jb25kaXRpb25zTGlzdGVuT24ubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmJpbmRDb25kaXRpb24oY3VycmVudE1vZHVsZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMucmVnaXN0ZXJDb25kaXRpb25hbE1vZHVsZShjdXJyZW50TW9kdWxlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnJlZ2lzdGVyT25lKGN1cnJlbnRNb2R1bGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyoqXG5cdCAgICogUmVnaXN0ZXIgYWxsIG1vZHVsZXNcblx0ICAgKi9cblx0XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAncmVnaXN0ZXJBbGwnLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyQWxsKCkge1xuXHRcdFx0XHRpZiAoIV9fcmVnaXN0ZXIubW9kdWxlc0luUmVnaXN0ZXIpIHJldHVybjtcblx0XG5cdFx0XHRcdHRoaXMucmVnaXN0ZXJJbml0aWFsTW9kdWxlcygpO1xuXHRcdFx0XHR0aGlzLnJlZ2lzdGVyQ29uZGl0aW9uYWxNb2R1bGVzKCk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyoqXG5cdCAgICogUmVnaXN0ZXIgYWxsIGluaXRpYWwgbW9kdWxlc1xuXHQgICAqL1xuXHRcblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdyZWdpc3RlckluaXRpYWxNb2R1bGVzJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlckluaXRpYWxNb2R1bGVzKCkge1xuXHRcdFx0XHR2YXIgX3RoaXM1ID0gdGhpcztcblx0XG5cdFx0XHRcdF9fcmVnaXN0ZXIubW9kdWxlc09uSW5pdC5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0XHRfdGhpczUucmVnaXN0ZXJPbmUob2JqKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyoqXG5cdCAgICogUmVnaXN0ZXIgY29uZGl0aW9uYWwgbW9kdWxlc1xuXHQgICAqXG5cdCAgICogVGhlcmVmb3JlIHdlIGNoZWNrIHRoZSBjb25kaXRpb24gYW5kXG5cdCAgICogd2hlbiB0cnVlIHJlZ2lzdGVyIHRoZSBzcGVjaWZpYyBtb2R1bGVcblx0ICAgKiB3aGVuIGZhbHNlIHVucmVnaXN0ZXIgdGhlIHNwZWNpZmljIG1vZHVsZVxuXHQgICAqL1xuXHRcblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdyZWdpc3RlckNvbmRpdGlvbmFsTW9kdWxlcycsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJDb25kaXRpb25hbE1vZHVsZXMoKSB7XG5cdFx0XHRcdHZhciBfdGhpczYgPSB0aGlzO1xuXHRcblx0XHRcdFx0X19yZWdpc3Rlci5tb2R1bGVzT25Db25kaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRcdF90aGlzNi5yZWdpc3RlckNvbmRpdGlvbmFsTW9kdWxlKG9iaik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sIHtcblx0XHRcdGtleTogJ3JlZ2lzdGVyQ29uZGl0aW9uYWxNb2R1bGUnLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyQ29uZGl0aW9uYWxNb2R1bGUob2JqKSB7XG5cdFx0XHRcdGlmICh0aGlzLmNvbnN0cnVjdG9yLm1ha2VDb25kaXRpb25DaGVjayhvYmopKSB7XG5cdFx0XHRcdFx0dGhpcy5yZWdpc3Rlck9uZShvYmopO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudW5yZWdpc3Rlck9uZShvYmopO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyoqXG5cdCAgICogUmVnaXN0ZXIgb25lIG1vZHVsZSBhbmQgaW5pdCB0aGUgZWxlbWVudHMgaW4gdGhlIHNwZWNpZmljIGNvbnRleHRcblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgLSBSZXF1aXJlZDogZWxlbWVudCBuYW1lIGluIERPTVxuXHQgICAqIEBwYXJhbSB7U3RyaW5nfSBkb21OYW1lIC0gUmVxdWlyZWQ6IGVsZW1lbnQgbmFtZSBpbiBET01cblx0ICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIC0gUmVxdWlyZWQ6IGNsYXNzIHdoaWNoIHdpbGwgYmUgdXNlZCB0byByZW5kZXIgeW91ciBtb2R1bGVcblx0ICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW5kZXI9dHJ1ZV0gLSBPcHRpb25hbDogcmVuZGVyIHRoZSBjbGFzcywgaWYgZmFsc2UgdGhlIGNsYXNzIHdpbGwgb25seSBiZSBpbml0aWFsaXplZFxuXHQgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYl0gLSBPcHRpb25hbDogcHJvdmlkZSBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgaW5pdGlhbGlzYXRpb25cblx0ICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWw6IFlvdSBjYW4gcGFzcyBvcHRpb25zIHRvIHRoZSBtb2R1bGUgdmlhIEpTIChVc2VmdWwgZm9yIERPTUNoYW5nZWQpXG5cdCAgICpcblx0ICAgKi9cblx0XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAncmVnaXN0ZXJPbmUnLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyT25lKF9yZWYpIHtcblx0XHRcdFx0dmFyIG5hbWVzcGFjZSA9IF9yZWYubmFtZXNwYWNlLFxuXHRcdFx0XHQgICAgZG9tTmFtZSA9IF9yZWYuZG9tTmFtZSxcblx0XHRcdFx0ICAgIG1vZHVsZSA9IF9yZWYubW9kdWxlLFxuXHRcdFx0XHQgICAgcmVuZGVyID0gX3JlZi5yZW5kZXIsXG5cdFx0XHRcdCAgICBjYiA9IF9yZWYuY2IsXG5cdFx0XHRcdCAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuXHRcblx0XHRcdFx0dmFyIG5hbWVTcGFjZSA9IG5hbWVzcGFjZSA/IG5hbWVzcGFjZSA6IGRvbU5hbWU7XG5cdFxuXHRcdFx0XHRpZiAoIW1vZHVsZSkgdGhyb3cgbmV3IEVycm9yKCdWZWFtc01vZHVsZXMgOjogSW4gb3JkZXIgdG8gd29yayB3aXRoIHJlZ2lzdGVyKCkgb3IgYWRkKCkgeW91IG5lZWQgdG8gZGVmaW5lIGEgbW9kdWxlIScpO1xuXHRcdFx0XHRpZiAoIW5hbWVTcGFjZSkgdGhyb3cgbmV3IEVycm9yKCdWZWFtc01vZHVsZXMgOjogSW4gb3JkZXIgdG8gd29yayB3aXRoIHJlZ2lzdGVyKCkgb3IgYWRkKCkgeW91IG5lZWQgdG8gZGVmaW5lIGEgbW9kdWxlIScpO1xuXHRcblx0XHRcdFx0dGhpcy5pbml0TW9kdWxlcyh7XG5cdFx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lU3BhY2UsXG5cdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGUsXG5cdFx0XHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHRcdFx0Y2I6IGNiLFxuXHRcdFx0XHRcdG9wdGlvbnM6IG9wdGlvbnNcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAndW5yZWdpc3Rlck9uZScsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gdW5yZWdpc3Rlck9uZShfcmVmMikge1xuXHRcdFx0XHR2YXIgbmFtZXNwYWNlID0gX3JlZjIubmFtZXNwYWNlO1xuXHRcblx0XHRcdFx0aWYgKHRoaXMuY29uc3RydWN0b3IuY2hlY2tNb2R1bGVJbkNhY2hlKG5hbWVzcGFjZSwgJ25hbWVzcGFjZScpID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0dGhpcy5jb25zdHJ1Y3Rvci5yZW1vdmVGcm9tQ2FjaGVCeUtleShuYW1lc3BhY2UsICduYW1lc3BhY2UnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdFx0Ly8gSU5JVCBIQU5ETEVSXG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XG5cdFx0XHQvKipcblx0ICAgKiBJbml0aWFsaXplIGEgbW9kdWxlIGFuZCByZW5kZXIgaXQgYW5kL29yIHByb3ZpZGUgYSBjYWxsYmFjayBmdW5jdGlvblxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZSAtIFJlcXVpcmVkOiBkb20gbmFtZSBvZiB0aGUgZWxlbWVudFxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgLSBSZXF1aXJlZDogY2xhc3Mgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHJlbmRlciB5b3VyIG1vZHVsZVxuXHQgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbmRlcj10cnVlXSAtIE9wdGlvbmFsOiByZW5kZXIgdGhlIGNsYXNzLCBpZiBmYWxzZSB0aGUgY2xhc3Mgd2lsbCBvbmx5IGJlIGluaXRpYWxpemVkXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsOiBZb3UgY2FuIHBhc3Mgb3B0aW9ucyB0byB0aGUgbW9kdWxlIHZpYSBKUyAoVXNlZnVsIGZvciBET01DaGFuZ2VkKVxuXHQgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYl0gLSBPcHRpb25hbDogcHJvdmlkZSBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgaW5pdGlhbGlzYXRpb25cblx0ICAgKlxuXHQgICAqL1xuXHRcblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdpbml0TW9kdWxlcycsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gaW5pdE1vZHVsZXMoX3JlZjMpIHtcblx0XHRcdFx0dmFyIF90aGlzNyA9IHRoaXM7XG5cdFxuXHRcdFx0XHR2YXIgbmFtZXNwYWNlID0gX3JlZjMubmFtZXNwYWNlLFxuXHRcdFx0XHQgICAgbW9kdWxlID0gX3JlZjMubW9kdWxlLFxuXHRcdFx0XHQgICAgcmVuZGVyID0gX3JlZjMucmVuZGVyLFxuXHRcdFx0XHQgICAgb3B0aW9ucyA9IF9yZWYzLm9wdGlvbnMsXG5cdFx0XHRcdCAgICBjYiA9IF9yZWYzLmNiO1xuXHRcblx0XHRcdFx0VmVhbXMuaGVscGVycy5mb3JFYWNoKF9fcmVnaXN0ZXIubW9kdWxlc0luQ29udGV4dCwgZnVuY3Rpb24gKGksIGVsKSB7XG5cdFx0XHRcdFx0X3RoaXM3LmluaXRNb2R1bGUoe1xuXHRcdFx0XHRcdFx0ZWw6IGVsLFxuXHRcdFx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UsXG5cdFx0XHRcdFx0XHRvcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGUsXG5cdFx0XHRcdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdFx0XHRcdGNiOiBjYlxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdpbml0TW9kdWxlJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiBpbml0TW9kdWxlKF9yZWY0KSB7XG5cdFx0XHRcdHZhciBlbCA9IF9yZWY0LmVsLFxuXHRcdFx0XHQgICAgbmFtZXNwYWNlID0gX3JlZjQubmFtZXNwYWNlLFxuXHRcdFx0XHQgICAgb3B0aW9ucyA9IF9yZWY0Lm9wdGlvbnMsXG5cdFx0XHRcdCAgICBtb2R1bGUgPSBfcmVmNC5tb2R1bGUsXG5cdFx0XHRcdCAgICByZW5kZXIgPSBfcmVmNC5yZW5kZXIsXG5cdFx0XHRcdCAgICBjYiA9IF9yZWY0LmNiO1xuXHRcblx0XHRcdFx0dmFyIG5vUmVuZGVyID0gZWwuZ2V0QXR0cmlidXRlKHRoaXMub3B0aW9ucy5hdHRyUHJlZml4ICsgJy1uby1yZW5kZXInKSB8fCByZW5kZXIgPT09IGZhbHNlIHx8IGZhbHNlO1xuXHRcdFx0XHR2YXIgZGF0YU1vZHVsZXMgPSBlbC5nZXRBdHRyaWJ1dGUodGhpcy5vcHRpb25zLmF0dHJQcmVmaXggKyAnLScgKyB0aGlzLm9wdGlvbnMuYXR0ck5hbWUpLnNwbGl0KCcgJyk7XG5cdFxuXHRcdFx0XHRpZiAoZGF0YU1vZHVsZXMuaW5kZXhPZihuYW1lc3BhY2UpICE9PSAtMSkge1xuXHRcdFx0XHRcdC8vIENoZWNrIGluaXQgc3RhdGVcblx0XHRcdFx0XHRpZiAodGhpcy5jb25zdHJ1Y3Rvci5jaGVja01vZHVsZUluQ2FjaGUoZWwsICdlbGVtZW50JywgbmFtZXNwYWNlKSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5pbmZvKCdWZWFtc01vZHVsZXMgOjogRWxlbWVudCBpcyBhbHJlYWR5IGluIGNhY2hlIGFuZCBpbml0aWFsaXplZDogJyk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhlbCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBHbyBhaGVhZCB3aGVuIGNvbmRpdGlvbiBpcyB0cnVlXG5cdFx0XHRcdFx0dmFyIGF0dHJzID0gZWwuZ2V0QXR0cmlidXRlKHRoaXMub3B0aW9ucy5hdHRyUHJlZml4ICsgJy0nICsgdGhpcy5vcHRpb25zLmF0dHJPcHRpb25zKTtcblx0XHRcdFx0XHR2YXIgbWVyZ2VkT3B0aW9ucyA9IFZlYW1zLmhlbHBlcnMuZXh0ZW5kKEpTT04ucGFyc2UoYXR0cnMpLCBvcHRpb25zIHx8IHt9KTtcblx0XHRcdFx0XHR2YXIgTW9kdWxlID0gbW9kdWxlO1xuXHRcdFx0XHRcdHZhciBpbnN0YW5jZSA9IG5ldyBNb2R1bGUoe1xuXHRcdFx0XHRcdFx0ZWw6IGVsLFxuXHRcdFx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UsXG5cdFx0XHRcdFx0XHRvcHRpb25zOiBtZXJnZWRPcHRpb25zLFxuXHRcdFx0XHRcdFx0YXBwSW5zdGFuY2U6IFZlYW1zXG5cdFx0XHRcdFx0fSk7XG5cdFxuXHRcdFx0XHRcdHRoaXMuY29uc3RydWN0b3IuYWRkVG9DYWNoZSh7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiBlbCxcblx0XHRcdFx0XHRcdG1vZHVsZTogbW9kdWxlLFxuXHRcdFx0XHRcdFx0aW5zdGFuY2U6IGluc3RhbmNlLFxuXHRcdFx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2Vcblx0XHRcdFx0XHR9KTtcblx0XG5cdFx0XHRcdFx0Ly8gTW91bnQgcHJvY2Vzc1xuXHRcdFx0XHRcdGlmIChpbnN0YW5jZS53aWxsTW91bnQpIGluc3RhbmNlLndpbGxNb3VudCgpO1xuXHRcblx0XHRcdFx0XHQvLyBSZW5kZXIgYWZ0ZXIgaW5pdGlhbCBtb2R1bGUgbG9hZGluZ1xuXHRcdFx0XHRcdGlmICghbm9SZW5kZXIpIGluc3RhbmNlLnJlbmRlcigpO1xuXHRcblx0XHRcdFx0XHQvLyBQcm92aWRlIGNhbGxiYWNrIGZ1bmN0aW9uIGluIHdoaWNoIHlvdSBjYW4gdXNlIG1vZHVsZSBhbmQgb3B0aW9uc1xuXHRcdFx0XHRcdGlmIChjYiAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIGNiKG1vZHVsZSwgbWVyZ2VkT3B0aW9ucyk7XG5cdFxuXHRcdFx0XHRcdC8vIE1vdW50IHByb2Nlc3Ncblx0XHRcdFx0XHRpZiAoaW5zdGFuY2UuZGlkTW91bnQpIGluc3RhbmNlLmRpZE1vdW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvKipcblx0ICAgKiBBZGQgbXV0YXRpb24gb2JzZXJ2ZXIgdG8gb2JzZXJ2ZSBuZXcgbW9kdWxlcy5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IC0gQ29udGV4dCBmb3IgdGhlIG11dGF0aW9uIG9ic2VydmVyXG5cdCAgICpcblx0ICAgKiBUT0RPOiBJbXByb3ZlIGZvciBsb29wc1xuXHQgICAqL1xuXHRcblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdvYnNlcnZlJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiBvYnNlcnZlKGNvbnRleHQpIHtcblx0XHRcdFx0dmFyIF90aGlzOCA9IHRoaXM7XG5cdFxuXHRcdFx0XHR2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7XG5cdFx0XHRcdFx0Ly8gbG9vayB0aHJvdWdoIGFsbCBtdXRhdGlvbnMgdGhhdCBqdXN0IG9jY3VyZWRcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdFx0Ly8gbG9vayB0aHJvdWdoIGFsbCBhZGRlZCBub2RlcyBvZiB0aGlzIG11dGF0aW9uXG5cdFxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBtdXRhdGlvbnNbaV0uYWRkZWROb2Rlcy5sZW5ndGg7ICsraikge1xuXHRcdFx0XHRcdFx0XHR2YXIgYWRkZWROb2RlID0gbXV0YXRpb25zW2ldLmFkZGVkTm9kZXNbal07XG5cdFxuXHRcdFx0XHRcdFx0XHRpZiAoYWRkZWROb2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoYWRkZWROb2RlLmdldEF0dHJpYnV0ZShfdGhpczgub3B0aW9ucy5hdHRyUHJlZml4ICsgJy0nICsgX3RoaXM4Lm9wdGlvbnMuYXR0ck5hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgbmFtZXNwYWNlID0gYWRkZWROb2RlLmdldEF0dHJpYnV0ZShfdGhpczgub3B0aW9ucy5hdHRyUHJlZml4ICsgJy0nICsgX3RoaXM4Lm9wdGlvbnMuYXR0ck5hbWUpO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChfdGhpczgub3B0aW9ucy5sb2dzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUuaW5mbygnVmVhbXNNb2R1bGVzIDo6IFJlY29yZGluZyBhIG5ldyBtb2R1bGUgd2l0aCB0aGUgbmFtZXNwYWNlICcgKyBuYW1lc3BhY2UgKyAnIGF0OiAnLCBhZGRlZE5vZGUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIF9pdGVyYXRvciA9IF9fcmVnaXN0ZXIubW9kdWxlc0luUmVnaXN0ZXJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIG1vZHVsZSA9IF9zdGVwLnZhbHVlO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAobW9kdWxlLm5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfdGhpczguaW5pdE1vZHVsZSh7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVsOiBhZGRlZE5vZGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZTogbW9kdWxlLm1vZHVsZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmFtZXNwYWNlOiBtb2R1bGUubmFtZXNwYWNlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9pdGVyYXRvckVycm9yID0gZXJyO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yLnJldHVybigpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRcdFx0aWYgKF90aGlzOC5nZXRNb2R1bGVzSW5Db250ZXh0KGFkZGVkTm9kZSkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRfX3JlZ2lzdGVyLm1vZHVsZXNJbkNvbnRleHQgPSBfdGhpczguZ2V0TW9kdWxlc0luQ29udGV4dChhZGRlZE5vZGUpO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChfdGhpczgub3B0aW9ucy5sb2dzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUuaW5mbygnVmVhbXNNb2R1bGVzIDo6IFJlY29yZGluZyBuZXcgY29udGV4dC4gV2hlbiBhdmFpbGFibGUgbmV3IG1vZHVsZXMgd2lsbCBiZSBpbml0aWFsaXNlZCBpbjogJywgYWRkZWROb2RlKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRfdGhpczgucmVnaXN0ZXJBbGwoKTtcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRfX3JlZ2lzdGVyLm1vZHVsZXNJbkNvbnRleHQgPSBfdGhpczguZ2V0TW9kdWxlc0luQ29udGV4dChkb2N1bWVudCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgX2ogPSAwOyBfaiA8IG11dGF0aW9uc1tpXS5yZW1vdmVkTm9kZXMubGVuZ3RoOyArK19qKSB7XG5cdFx0XHRcdFx0XHRcdHZhciByZW1vdmVkTm9kZSA9IG11dGF0aW9uc1tpXS5yZW1vdmVkTm9kZXNbX2pdO1xuXHRcblx0XHRcdFx0XHRcdFx0aWYgKHJlbW92ZWROb2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAocmVtb3ZlZE5vZGUuZ2V0QXR0cmlidXRlKF90aGlzOC5vcHRpb25zLmF0dHJQcmVmaXggKyAnLScgKyBfdGhpczgub3B0aW9ucy5hdHRyTmFtZSkpIHtcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoX3RoaXM4Lm9wdGlvbnMubG9ncykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmluZm8oJ1ZlYW1zTW9kdWxlcyA6OiBSZWNvcmRpbmcgZGVsZXRpb24gb2YgbW9kdWxlOiAnLCByZW1vdmVkTm9kZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0XHRcdFx0X3RoaXM4LmNvbnN0cnVjdG9yLnJlbW92ZUZyb21DYWNoZUJ5S2V5KHJlbW92ZWROb2RlKTtcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRfX3JlZ2lzdGVyLm1vZHVsZXNJbkNvbnRleHQgPSBfdGhpczguZ2V0TW9kdWxlc0luQ29udGV4dChkb2N1bWVudCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0XHRpZiAoX3RoaXM4LmdldE1vZHVsZXNJbkNvbnRleHQocmVtb3ZlZE5vZGUpLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0X19yZWdpc3Rlci5tb2R1bGVzSW5Db250ZXh0ID0gX3RoaXM4LmdldE1vZHVsZXNJbkNvbnRleHQocmVtb3ZlZE5vZGUpO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChfdGhpczgub3B0aW9ucy5sb2dzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUuaW5mbygnVmVhbXNNb2R1bGVzIDo6IFJlY29yZGluZyBkZWxldGlvbiBvZiBET00gZWxlbWVudC4gV2hlbiBhdmFpbGFibGUgbW9kdWxlcyB3aWxsIGJlIHVuYm91bmQgaW4gJywgcmVtb3ZlZE5vZGUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0XHRcdF9fcmVnaXN0ZXIubW9kdWxlc0luQ29udGV4dC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF90aGlzOC5jb25zdHJ1Y3Rvci5yZW1vdmVGcm9tQ2FjaGVCeUtleShub2RlKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRcdF9fcmVnaXN0ZXIubW9kdWxlc0luQ29udGV4dCA9IF90aGlzOC5nZXRNb2R1bGVzSW5Db250ZXh0KGRvY3VtZW50KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcblx0XHRcdFx0b2JzZXJ2ZXIub2JzZXJ2ZShjb250ZXh0LCB7XG5cdFx0XHRcdFx0Y2hpbGRMaXN0OiB0cnVlLFxuXHRcdFx0XHRcdHN1YnRyZWU6IHRydWVcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyoqXG5cdCAgICogR2V0IE1vZHVsZXMgaW4gYSBzcGVjaWZpYyBjb250ZXh0LlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgLSBDb250ZXh0IGZvciBxdWVyeSBzcGVjaWZpYyBzdHJpbmdcblx0ICAgKi9cblx0XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAnZ2V0TW9kdWxlc0luQ29udGV4dCcsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0TW9kdWxlc0luQ29udGV4dChjb250ZXh0KSB7XG5cdFx0XHRcdHJldHVybiBWZWFtcy5oZWxwZXJzLnF1ZXJ5U2VsZWN0b3JBcnJheSh0aGlzLnF1ZXJ5U3RyaW5nLCBjb250ZXh0KTtcblx0XHRcdH1cblx0XHR9XSwgW3tcblx0XHRcdGtleTogJ2FkZFRvQ2FjaGUnLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIGFkZFRvQ2FjaGUoX3JlZjUpIHtcblx0XHRcdFx0dmFyIG1vZHVsZSA9IF9yZWY1Lm1vZHVsZSxcblx0XHRcdFx0ICAgIGVsZW1lbnQgPSBfcmVmNS5lbGVtZW50LFxuXHRcdFx0XHQgICAgaW5zdGFuY2UgPSBfcmVmNS5pbnN0YW5jZSxcblx0XHRcdFx0ICAgIG5hbWVzcGFjZSA9IF9yZWY1Lm5hbWVzcGFjZTtcblx0XG5cdFx0XHRcdF9fY2FjaGUucHVzaCh7XG5cdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGUsXG5cdFx0XHRcdFx0ZWxlbWVudDogZWxlbWVudCxcblx0XHRcdFx0XHRpbnN0YW5jZTogaW5zdGFuY2UsXG5cdFx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2Vcblx0XHRcdFx0fSk7XG5cdFxuXHRcdFx0XHRpZiAoVmVhbXMuVmVudCAmJiBWZWFtcy5FVkVOVFMubW9kdWxlQ2FjaGVkKSB7XG5cdFx0XHRcdFx0VmVhbXMuVmVudC50cmlnZ2VyKFZlYW1zLkVWRU5UUy5tb2R1bGVDYWNoZWQsIHtcblx0XHRcdFx0XHRcdG1vZHVsZTogbW9kdWxlLFxuXHRcdFx0XHRcdFx0ZWxlbWVudDogZWxlbWVudFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAncmVtb3ZlRnJvbUNhY2hlQnlLZXknLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUZyb21DYWNoZUJ5S2V5KG9iaikge1xuXHRcdFx0XHR2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnZWxlbWVudCc7XG5cdFxuXHRcdFx0XHR2YXIgZGVsZXRlSW5kZXggPSB2b2lkIDA7XG5cdFxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IF9fY2FjaGUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2FjaGVJdGVtID0gX19jYWNoZVtpXTtcblx0XG5cdFx0XHRcdFx0aWYgKGNhY2hlSXRlbVtrZXldID09PSBvYmopIHtcblx0XHRcdFx0XHRcdGlmIChjYWNoZUl0ZW0uaW5zdGFuY2Uud2lsbFVubW91bnQpIGNhY2hlSXRlbS5pbnN0YW5jZS53aWxsVW5tb3VudCgpO1xuXHRcdFx0XHRcdFx0aWYgKGNhY2hlSXRlbS5pbnN0YW5jZS51bnJlZ2lzdGVyRXZlbnRzKSBjYWNoZUl0ZW0uaW5zdGFuY2UudW5yZWdpc3RlckV2ZW50cygpO1xuXHRcdFx0XHRcdFx0aWYgKGNhY2hlSXRlbS5pbnN0YW5jZS5kaWRVbm1vdW50KSBjYWNoZUl0ZW0uaW5zdGFuY2UuZGlkVW5tb3VudCgpO1xuXHRcblx0XHRcdFx0XHRcdGRlbGV0ZUluZGV4ID0gaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGlmIChkZWxldGVJbmRleCkgX19jYWNoZS5zcGxpY2UoZGVsZXRlSW5kZXgsIDEpO1xuXHRcdFx0fVxuXHRcdH0sIHtcblx0XHRcdGtleTogJ2NoZWNrTW9kdWxlSW5DYWNoZScsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gY2hlY2tNb2R1bGVJbkNhY2hlKG9iaikge1xuXHRcdFx0XHR2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnZWxlbWVudCc7XG5cdFx0XHRcdHZhciBuYW1lc3BhY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcblx0XG5cdFx0XHRcdHZhciBzdGF0ZSA9IGZhbHNlO1xuXHRcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBfX2NhY2hlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlSXRlbSA9IF9fY2FjaGVbaV07XG5cdFxuXHRcdFx0XHRcdHN0YXRlID0gbmFtZXNwYWNlICE9PSB1bmRlZmluZWQgPyBjYWNoZUl0ZW1ba2V5XSA9PT0gb2JqICYmIGNhY2hlSXRlbS5uYW1lc3BhY2UgPT09IG5hbWVzcGFjZSA6IGNhY2hlSXRlbVtrZXldID09PSBvYmo7XG5cdFxuXHRcdFx0XHRcdGlmIChzdGF0ZSkgYnJlYWs7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHRcdC8vIENPTkRJVElPTlMgSEFORExFUlxuXHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFxuXHRcdH0sIHtcblx0XHRcdGtleTogJ2lzQ29uZGl0aW9uJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiBpc0NvbmRpdGlvbihfcmVmNikge1xuXHRcdFx0XHR2YXIgY29uZGl0aW9ucyA9IF9yZWY2LmNvbmRpdGlvbnM7XG5cdFxuXHRcdFx0XHRyZXR1cm4gY29uZGl0aW9ucyAmJiB0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ2Z1bmN0aW9uJztcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdtYWtlQ29uZGl0aW9uQ2hlY2snLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIG1ha2VDb25kaXRpb25DaGVjayhfcmVmNykge1xuXHRcdFx0XHR2YXIgY29uZGl0aW9ucyA9IF9yZWY3LmNvbmRpdGlvbnM7XG5cdFxuXHRcdFx0XHRpZiAoY29uZGl0aW9ucyAmJiB0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHJldHVybiBjb25kaXRpb25zKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XSk7XG5cdFxuXHRcdHJldHVybiBNb2R1bGVzO1xuXHR9KCk7XG5cdFxuXHQvKipcblx0ICogUGx1Z2luIG9iamVjdFxuXHQgKi9cblx0XG5cdFxuXHR2YXIgVmVhbXNNb2R1bGVzID0ge1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdERFQlVHOiBmYWxzZSxcblx0XHRcdGF0dHJQcmVmaXg6ICdkYXRhLWpzJyxcblx0XHRcdGF0dHJOYW1lOiAnbW9kdWxlJyxcblx0XHRcdGF0dHJPcHRpb25zOiAnb3B0aW9ucycsXG5cdFx0XHRsb2dzOiBmYWxzZSxcblx0XHRcdGludGVybmFsQ2FjaGVPbmx5OiB0cnVlLFxuXHRcdFx0aW50ZXJuYWxSZWdpc3Rlck9ubHk6IGZhbHNlLFxuXHRcdFx0dXNlTXV0YXRpb25PYnNlcnZlcjogZmFsc2Vcblx0XHR9LFxuXHRcdHBsdWdpbk5hbWU6ICdNb2R1bGVzSGFuZGxlcicsXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShWZWFtcywgb3B0cykge1xuXHRcdFx0dGhpcy5vcHRpb25zID0gVmVhbXMuaGVscGVycy5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRzIHx8IHt9KTtcblx0XHRcdFZlYW1zLm1vZHVsZXMgPSBWZWFtcy5tb2R1bGVzIHx8IG5ldyBNb2R1bGVzKFZlYW1zLCB0aGlzLm9wdGlvbnMpO1xuXHRcdH1cblx0fTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IFZlYW1zTW9kdWxlcztcblx0ZXhwb3J0cy5Nb2R1bGVzID0gTW9kdWxlcztcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJpbmRleFwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJpbmRleFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJpbmRleFwiXSA9IHJvb3RbXCJpbmRleFwiXSB8fCB7fSwgcm9vdFtcImluZGV4XCJdW1wiaW5kZXhcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0LyoqXG5cdCAqIFJlcHJlc2VudHMgdGhlIFRlbXBsYXRlciBjbGFzcyB3aGljaCB3aWxsIGJlIHVzZWQgaW4gVmVhbXNUZW1wbGF0ZXIgcGx1Z2luLlxuXHQgKiBAbW9kdWxlIFRlbXBsYXRlclxuXHQgKlxuXHQgKiBAYXV0aG9yIFNlYmFzdGlhbiBGaXR6bmVyXG5cdCAqL1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0dmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdHZhciBWZWFtcyA9IHt9O1xuXHRcblx0dmFyIFRlbXBsYXRlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBUZW1wbGF0ZXIoKSB7XG5cdFx0XHR2YXIgVkVBTVMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHdpbmRvdy5WZWFtcztcblx0XHRcdHZhciBfcmVmID0gYXJndW1lbnRzWzFdO1xuXHRcdFx0dmFyIGVuZ2luZSA9IF9yZWYuZW5naW5lLFxuXHRcdFx0ICAgIHRlbXBsYXRlcyA9IF9yZWYudGVtcGxhdGVzLFxuXHRcdFx0ICAgIHBhcnRpYWxzID0gX3JlZi5wYXJ0aWFscyxcblx0XHRcdCAgICBoZWxwZXJzID0gX3JlZi5oZWxwZXJzO1xuXHRcblx0XHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZW1wbGF0ZXIpO1xuXHRcblx0XHRcdFZlYW1zID0gVkVBTVM7XG5cdFxuXHRcdFx0aWYgKCF0ZW1wbGF0ZXMpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVmVhbXNUZW1wbGF0ZXIgOjogWW91IG5lZWQgdG8gcGFzcyBhbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgeW91ciB0ZW1wbGF0ZXMgKG9iai50ZW1wbGF0ZXMpIScpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCFlbmdpbmUpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVmVhbXNUZW1wbGF0ZXIgOjogWW91IG5lZWQgdG8gcGFzcyBhIGhhbmRsZWJhcnMgaW5zdGFuY2UgYnkgcHJvdmlkaW5nIG9iai5lbmdpbmUhJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSB7XG5cdFx0XHRcdG5hbWVzcGFjZTogVmVhbXMub3B0aW9ucy5uYW1lc3BhY2UsXG5cdFx0XHRcdGVuZ2luZTogZW5naW5lLFxuXHRcdFx0XHR0ZW1wbGF0ZXM6IHRlbXBsYXRlcyxcblx0XHRcdFx0cGFydGlhbHM6IHBhcnRpYWxzLFxuXHRcdFx0XHRoZWxwZXJzOiBoZWxwZXJzXG5cdFx0XHR9O1xuXHRcblx0XHRcdHRoaXMuaW5pdGlhbGl6ZSgpO1xuXHRcdH1cblx0XG5cdFx0X2NyZWF0ZUNsYXNzKFRlbXBsYXRlciwgW3tcblx0XHRcdGtleTogJ2luaXRpYWxpemUnLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMuaGVscGVycykge1xuXHRcdFx0XHRcdHRoaXMucmVnaXN0ZXJIZWxwZXJzKCk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHRoaXMuYWRkVGVtcGxhdGVyKCk7XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAncmVnaXN0ZXJIZWxwZXJzJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlckhlbHBlcnMoKSB7XG5cdFx0XHRcdGlmICghQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuaGVscGVycykpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdWZWFtc1RlbXBsYXRlciA6OiBZb3UgbmVlZCB0byBwYXNzIHRoZSBoZWxwZXJzIGFzIGFuIGFycmF5IScpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMuaGVscGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBoZWxwZXIgPSB0aGlzLm9wdGlvbnMuaGVscGVyc1tpXTtcblx0XG5cdFx0XHRcdFx0aWYgKGhlbHBlci5yZWdpc3Rlcikge1xuXHRcdFx0XHRcdFx0dGhpcy5vcHRpb25zLmVuZ2luZS5yZWdpc3RlckhlbHBlcihoZWxwZXIucmVnaXN0ZXIodGhpcy5vcHRpb25zLmVuZ2luZSkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdWZWFtc1RlbXBsYXRlciA6OiBZb3VyIGhlbHBlciBkb2VzIG5vdCBoYXZlIGEgcmVnaXN0ZXIgZnVuY3Rpb24sIHNlZTogJyArIGhlbHBlcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAnYWRkVGVtcGxhdGVyJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiBhZGRUZW1wbGF0ZXIoKSB7XG5cdFx0XHRcdGlmIChWZWFtcy50ZW1wbGF0ZXIpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ0l0IHNlZW1zIHRoYXQgeW91IGFyZSBhbHJlYWR5IHVzaW5nIFZlYW1zLnRlbXBsYXRlciEgVmVhbXMgaXMgb3ZlcnJpZGluZyBpdCBub3chJyk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdFZlYW1zLnRlbXBsYXRlciA9IHtcblx0XHRcdFx0XHRlbmdpbmU6IHRoaXMub3B0aW9ucy5lbmdpbmUsXG5cdFx0XHRcdFx0dGVtcGxhdGVzOiB0aGlzLm9wdGlvbnMudGVtcGxhdGVzKHRoaXMub3B0aW9ucy5lbmdpbmUpLFxuXHRcdFx0XHRcdHBhcnRpYWxzOiB0aGlzLm9wdGlvbnMucGFydGlhbHMgPyB0aGlzLm9wdGlvbnMucGFydGlhbHModGhpcy5vcHRpb25zLmVuZ2luZSkgOiB7fSxcblx0XHRcdFx0XHRoZWxwZXJzOiB0aGlzLm9wdGlvbnMuaGVscGVycyxcblx0XHRcdFx0XHRyZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcih0cGxOYW1lLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRpZiAoIWRhdGEgJiYgVmVhbXMudGVtcGxhdGVyLnRlbXBsYXRlc1t0cGxOYW1lXSkge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdWZWFtc1RlbXBsYXRlciA6OiBZb3UgbmVlZCB0byBwcm92aWRlIHNvbWUgZGF0YSBmb3IgJyArIHRwbE5hbWUgKyAnLicpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCFWZWFtcy50ZW1wbGF0ZXIudGVtcGxhdGVzW3RwbE5hbWVdKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1ZlYW1zVGVtcGxhdGVyIDo6IFRlbXBsYXRlICcgKyB0cGxOYW1lICsgJyBub3QgZm91bmQuJyk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRyZXR1cm4gVmVhbXMudGVtcGxhdGVyLnRlbXBsYXRlc1t0cGxOYW1lXShkYXRhKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fV0pO1xuXHRcblx0XHRyZXR1cm4gVGVtcGxhdGVyO1xuXHR9KCk7XG5cdFxuXHQvKipcblx0ICogUmVwcmVzZW50cyBhIHRlbXBsYXRlciBwbHVnaW4gd2hpY2ggeW91IGNhbiB1c2UgdG8gcmVuZGVyIHlvdXIgcHJlY29tcGlsZWQgaGFuZGxlYmFycyB0ZW1wbGF0ZXMuXG5cdCAqIFlvdSBjYW4gYWxzbyByZWdpc3RlciBjdXN0b20gaGVscGVycyBieSBwcm92aWRpbmcgdGhlbSBpbiBhbiBhcnJheSFcblx0ICpcblx0ICogQG1vZHVsZSBWZWFtc1RlbXBsYXRlclxuXHQgKlxuXHQgKiBAYXV0aG9yIFNlYmFzdGlhbiBGaXR6bmVyXG5cdCAqL1xuXHRcblx0XG5cdHZhciBWZWFtc1RlbXBsYXRlciA9IHtcblx0XHRvcHRpb25zOiB7XG5cdFx0XHRlbmdpbmU6IGZ1bmN0aW9uIGVuZ2luZSgpIHt9LFxuXHRcdFx0dGVtcGxhdGVzOiBmdW5jdGlvbiB0ZW1wbGF0ZXMoKSB7fSxcblx0XHRcdHBhcnRpYWxzOiBmdW5jdGlvbiBwYXJ0aWFscygpIHt9LFxuXHRcdFx0aGVscGVyczogW11cblx0XHR9LFxuXHRcdHBsdWdpbk5hbWU6ICdUZW1wbGF0ZXInLFxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUoVmVhbXMsIF9yZWYyKSB7XG5cdFx0XHR2YXIgZW5naW5lID0gX3JlZjIuZW5naW5lLFxuXHRcdFx0ICAgIHRlbXBsYXRlcyA9IF9yZWYyLnRlbXBsYXRlcyxcblx0XHRcdCAgICBwYXJ0aWFscyA9IF9yZWYyLnBhcnRpYWxzLFxuXHRcdFx0ICAgIGhlbHBlcnMgPSBfcmVmMi5oZWxwZXJzO1xuXHRcblx0XHRcdG5ldyBUZW1wbGF0ZXIoVmVhbXMsIHtcblx0XHRcdFx0ZW5naW5lOiBlbmdpbmUsXG5cdFx0XHRcdHRlbXBsYXRlczogdGVtcGxhdGVzLFxuXHRcdFx0XHRwYXJ0aWFsczogcGFydGlhbHMsXG5cdFx0XHRcdGhlbHBlcnM6IGhlbHBlcnNcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IFZlYW1zVGVtcGxhdGVyO1xuXHRleHBvcnRzLlRlbXBsYXRlciA9IFRlbXBsYXRlcjtcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJpbmRleFwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJpbmRleFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJpbmRleFwiXSA9IHJvb3RbXCJpbmRleFwiXSB8fCB7fSwgcm9vdFtcImluZGV4XCJdW1wiaW5kZXhcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBSZXByZXNlbnRzIGEgVmVudCBwbHVnaW4gd2hpY2ggY3JlYXRlcyBhbiBlbXB0eSBvYmplY3QuXG5cdCAqIFRoZSBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIHB1Ymxpc2gvc3Vic2NyaWJlIHBsdWdpbi5cblx0ICpcblx0ICogVGhlIG1vZHVsZSBleHRlbmRzIHRoZSBkZWZhdWx0IEVWRU5UUyBvYmplY3Qgb2YgVmVhbXNcblx0ICogd2hlbiB5b3UgcGFzcyB0aGUgb3B0aW9uIGNhbGxlZCAnZnVydGhlckV2ZW50cycuXG5cdCAqXG5cdCAqIEBtb2R1bGUgVmVhbXNWZW50XG5cdCAqXG5cdCAqIEBhdXRob3IgU2ViYXN0aWFuIEZpdHpuZXJcblx0ICovXG5cdFxuXHQvKipcblx0ICogQG1vZHVsZSBFdmVudHNIYW5kbGVyXG5cdCAqXG5cdCAqIFB1Yi9TdWIgc3lzdGVtIGZvciBMb29zZWx5IENvdXBsZWQgbG9naWMuXG5cdCAqIEJhc2VkIG9uIFBldGVyIEhpZ2dpbnMnIHBvcnQgZnJvbSBEb2pvIHRvIGpRdWVyeVxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vcGhpZ2dpbnM0Mi9ibG9vZHktanF1ZXJ5LXBsdWdpbnMvYmxvYi9tYXN0ZXIvcHVic3ViLmpzXG5cdCAqIGFkb3B0ZWQgaHR0cHM6Ly9naXRodWIuY29tL3BoaWdnaW5zNDIvYmxvb2R5LWpxdWVyeS1wbHVnaW5zL2Jsb2IvNTVlNDFkZjliZjA4ZjQyMzc4YmIwOGI5M2VmY2IyODU1NWI2MWFlYi9wdWJzdWIuanNcblx0ICpcblx0ICogbW9kaWZpZWQgYnkgU2ViYXN0aWFuIEZpdHpuZXJcblx0ICpcblx0ICovXG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHR2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0dmFyIEV2ZW50c0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNhY2hlID0ge30sXG5cdFxuXHRcdC8qKlxuXHQgICogICAgRXZlbnRzLnB1Ymxpc2hcblx0ICAqICAgIGUuZy46IEV2ZW50cy5wdWJsaXNoKFwiL0FydGljbGUvYWRkZWRcIiwge2FydGljbGU6IGFydGljbGV9LCB0aGlzKTtcblx0ICAqXG5cdCAgKiAgICBAY2xhc3MgRXZlbnRzXG5cdCAgKiAgICBAbWV0aG9kIHB1Ymxpc2hcblx0ICAqICAgIEBwYXJhbSB0b3BpYyB7U3RyaW5nfVxuXHQgICogICAgQHBhcmFtIGFyZ3MgICAge09iamVjdH1cblx0ICAqICAgIEBwYXJhbSBzY29wZSB7T2JqZWN0fSBPcHRpb25hbFxuXHQgICovXG5cdFx0cHVibGlzaCA9IGZ1bmN0aW9uIHB1Ymxpc2godG9waWMsIGFyZ3MsIHNjb3BlKSB7XG5cdFx0XHRpZiAoY2FjaGVbdG9waWNdKSB7XG5cdFx0XHRcdHZhciB0aGlzVG9waWMgPSBjYWNoZVt0b3BpY107XG5cdFx0XHRcdHZhciBpID0gdGhpc1RvcGljLmxlbmd0aCAtIDE7XG5cdFxuXHRcdFx0XHRmb3IgKGk7IGkgPj0gMDsgaSAtPSAxKSB7XG5cdFx0XHRcdFx0dGhpc1RvcGljW2ldLmNhbGwoc2NvcGUgfHwgdGhpcywgYXJncyB8fCB7fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0ICAqICAgIEV2ZW50cy5zdWJzY3JpYmVcblx0ICAqICAgIGUuZy46IEV2ZW50cy5zdWJzY3JpYmUoXCIvQXJ0aWNsZS9hZGRlZFwiLCBBcnRpY2xlcy52YWxpZGF0ZSlcblx0ICAqXG5cdCAgKiAgICBAY2xhc3MgRXZlbnRzXG5cdCAgKiAgICBAbWV0aG9kIHN1YnNjcmliZVxuXHQgICogICAgQHBhcmFtIHRvcGljIHtTdHJpbmd9XG5cdCAgKiAgICBAcGFyYW0gY2FsbGJhY2sge0Z1bmN0aW9ufVxuXHQgICogICAgQHJldHVybiBFdmVudCBoYW5kbGVyIHtBcnJheX1cblx0ICAqL1xuXHRcdHN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZSh0b3BpYywgY2FsbGJhY2spIHtcblx0XHRcdHZhciB0b3BpY3MgPSB0b3BpYy5zcGxpdCgnICcpO1xuXHRcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdG9waWNzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBfdG9waWMgPSB0b3BpY3NbaV07XG5cdFxuXHRcdFx0XHRpZiAoIWNhY2hlW190b3BpY10pIHtcblx0XHRcdFx0XHRjYWNoZVtfdG9waWNdID0gW107XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGNhY2hlW190b3BpY10ucHVzaChjYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHQgICogICAgRXZlbnRzLnVuc3Vic2NyaWJlXG5cdCAgKiAgICBlLmcuOiB2YXIgaGFuZGxlID0gRXZlbnRzLnN1YnNjcmliZShcIi9BcnRpY2xlL2FkZGVkXCIsIEFydGljbGVzLnZhbGlkYXRlKTtcblx0ICAqICAgICAgICBFdmVudHMudW5zdWJzY3JpYmUoXCIvQXJ0aWNsZS9hZGRlZFwiLCBBcnRpY2xlcy52YWxpZGF0ZSk7XG5cdCAgKlxuXHQgICogICAgQGNsYXNzIEV2ZW50c1xuXHQgICogICAgQG1ldGhvZCB1bnN1YnNjcmliZVxuXHQgICogICAgQHBhcmFtIHRvcGljIHtTdHJpbmd9XG5cdCAgKiAgICBAcGFyYW0gaGFuZGxlIHtGdW5jdGlvbn1cblx0ICAqICAgIEBwYXJhbSBjb21wbGV0bHkge0Jvb2xlYW59XG5cdCAgKi9cblx0XHR1bnN1YnNjcmliZSA9IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKHRvcGljLCBoYW5kbGUpIHtcblx0XHRcdHZhciBjb21wbGV0bHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXHRcblx0XHRcdHZhciBpID0gY2FjaGVbdG9waWNdLmxlbmd0aCAtIDE7XG5cdFxuXHRcdFx0aWYgKGNhY2hlW3RvcGljXSkge1xuXHRcdFx0XHRmb3IgKGk7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0aWYgKGNhY2hlW3RvcGljXVtpXSA9PT0gaGFuZGxlKSB7XG5cdFx0XHRcdFx0XHRjYWNoZVt0b3BpY10uc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0aWYgKGNvbXBsZXRseSkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgY2FjaGVbdG9waWNdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdHJldHVybiB7XG5cdFx0XHRwdWJsaXNoOiBwdWJsaXNoLFxuXHRcdFx0c3Vic2NyaWJlOiBzdWJzY3JpYmUsXG5cdFx0XHR1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUsXG5cdFx0XHR0cmlnZ2VyOiBwdWJsaXNoLFxuXHRcdFx0b246IHN1YnNjcmliZSxcblx0XHRcdG9mZjogdW5zdWJzY3JpYmVcblx0XHR9O1xuXHR9KCk7XG5cdFxuXHR2YXIgVmVhbXNWZW50ID0ge1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdGZ1cnRoZXJFdmVudHM6IHt9XG5cdFx0fSxcblx0XHRwbHVnaW5OYW1lOiAnVmVudCcsXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShWZWFtcywgb3B0cykge1xuXHRcdFx0aWYgKG9wdHMpIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zID0gVmVhbXMuaGVscGVycy5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRzIHx8IHt9KTtcblx0XHRcdH1cblx0XG5cdFx0XHRWZWFtcy5WZW50ID0gRXZlbnRzSGFuZGxlcjtcblx0XHRcdFZlYW1zLkVWRU5UUyA9IFZlYW1zLmhlbHBlcnMuZXh0ZW5kKFZlYW1zLkVWRU5UUywgdGhpcy5vcHRpb25zLmZ1cnRoZXJFdmVudHMpO1xuXHRcdH1cblx0fTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IFZlYW1zVmVudDtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwidmVhbXNcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1widmVhbXNcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1widmVhbXNcIl0gPSByb290W1widmVhbXNcIl0gfHwge30sIHJvb3RbXCJ2ZWFtc1wiXVtcInZlYW1zXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogSW1wb3J0c1xuXHQgKi9cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9zdGFydGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdFxuXHR2YXIgX3N0YXJ0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RhcnRlcik7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0LyoqXG5cdCAqIFZhcmlhYmxlc1xuXHQgKi9cblxuXHRleHBvcnRzLmRlZmF1bHQgPSBfc3RhcnRlcjIuZGVmYXVsdDtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH0sXG4vKiAxICovLFxuLyogMiAqLyxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBtaXhpbjtcblx0XG5cdHZhciBfZGVmYXVsdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcblx0dmFyIF9kZWZhdWx0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZhdWx0cyk7XG5cdFxuXHR2YXIgX21ldGhvZEV4dGVuZCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFxuXHR2YXIgX21ldGhvZEV4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZXRob2RFeHRlbmQpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdC8qKlxuXHQgKiBNZXJnZSBtZXRob2QgZnVuY3Rpb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZnJvbSAtIE1peGluIG9iamVjdCB3aGljaCB3aWxsIGJlIG1lcmdlZCB2aWEgSGVscGVycy5kZWZhdWx0cyB3aXRoIHRoZSBtZXRob2RzIG9mIG91ciBjbGFzc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBtZXRob2RzIC0gQXJyYXkgb2YgbWV0aG9kIG5hbWVzIHdoaWNoIHdpbGwgYmUgZXh0ZW5kZWQuXG5cdCAqL1xuXHRmdW5jdGlvbiBtaXhpbihmcm9tKSB7XG5cdFx0dmFyIG1ldGhvZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFsnaW5pdGlhbGl6ZScsICdyZW5kZXInXTtcblx0XG5cdFx0aWYgKGZyb20gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignVmVhbXNIZWxwZXJzIDogTWl4aW4gOjogTWl4aW4gbm90IGZvdW5kIScpO1xuXHRcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdHZhciB0byA9IHRoaXMucHJvdG90eXBlO1xuXHRcblx0XHQvKiogQWRkIHRob3NlIG1ldGhvZHMgd2hpY2ggZXhpc3RzIG9uIGBmcm9tYCBidXQgbm90IG9uIGB0b2AgdG8gdGhlIGxhdHRlciAqL1xuXHRcdCgwLCBfZGVmYXVsdHMyLmRlZmF1bHQpKHRvLCBmcm9tKTtcblx0XG5cdFx0LyoqIHdlIGRvIHRoZSBzYW1lIGZvciBldmVudHMgKi9cblx0XHRpZiAodG8uZXZlbnRzKSB7XG5cdFx0XHQoMCwgX2RlZmF1bHRzMi5kZWZhdWx0KSh0by5ldmVudHMsIGZyb20uZXZlbnRzKTtcblx0XHR9XG5cdFxuXHRcdC8vIEV4dGVuZCB0bydzIG1ldGhvZHNcblx0XHRtZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuXHRcdFx0KDAsIF9tZXRob2RFeHRlbmQyLmRlZmF1bHQpKHRvLCBmcm9tLCBtZXRob2QpO1xuXHRcdH0pO1xuXHR9O1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBTaW1wbGUgZXh0ZW5kIG1ldGhvZCwgd2hpY2ggZXh0ZW5kcyBhbiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBvYmplY3Qgd2hpY2ggd2lsbCBiZSBleHRlbmRlZFxuXHQgKlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IG9iaiAtIGV4dGVuZGVkIG9iamVjdFxuXHQgKi9cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0c0hlbHBlcjtcblx0ZnVuY3Rpb24gZGVmYXVsdHNIZWxwZXIob2JqKSB7XG5cdCAgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgIGZvciAodmFyIGtleSBpbiBpdGVtKSB7XG5cdCAgICAgIGlmIChvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSBvYmpba2V5XSA9IGl0ZW1ba2V5XTtcblx0ICAgIH1cblx0ICB9KTtcblx0ICByZXR1cm4gb2JqO1xuXHR9O1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBIZWxwZXIgbWV0aG9kIHRvIGV4dGVuZCBhbiBhbHJlYWR5IGV4aXN0aW5nIG1ldGhvZC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHRvIC0gdmlldyB3aGljaCB3aWxsIGJlIGV4dGVuZGVkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tIC0gbWV0aG9kcyB3aGljaCBjb21lcyBmcm9tIG1peGluXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIC0gZnVuY3Rpb24gbmFtZVxuXHQgKi9cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBtZXRob2RFeHRlbmQ7XG5cdGZ1bmN0aW9uIG1ldGhvZEV4dGVuZCh0bywgZnJvbSwgbWV0aG9kTmFtZSkge1xuXHRcdGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcblx0XHR9XG5cdFxuXHRcdGlmIChmcm9tID09PSB1bmRlZmluZWQpIHJldHVybjtcblx0XG5cdFx0Ly8gaWYgdGhlIG1ldGhvZCBpcyBkZWZpbmVkIG9uIGZyb20gLi4uXG5cdFx0aWYgKCFpc1VuZGVmaW5lZChmcm9tW21ldGhvZE5hbWVdKSkge1xuXHRcdFx0dmFyIG9sZCA9IHRvW21ldGhvZE5hbWVdO1xuXHRcblx0XHRcdC8vIC4uLiB3ZSBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb24gdG9cblx0XHRcdHRvW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuXHRcblx0XHRcdFx0Ly8gd2hlcmVpbiB3ZSBmaXJzdCBjYWxsIHRoZSBtZXRob2Qgd2hpY2ggZXhpc3RzIG9uIGB0b2Bcblx0XHRcdFx0dmFyIG9sZFJldHVybiA9IG9sZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcblx0XHRcdFx0Ly8gYW5kIHRoZW4gY2FsbCB0aGUgbWV0aG9kIG9uIGBmcm9tYFxuXHRcdFx0XHRmcm9tW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFxuXHRcdFx0XHQvLyBhbmQgdGhlbiByZXR1cm4gdGhlIGV4cGVjdGVkIHJlc3VsdCxcblx0XHRcdFx0Ly8gaS5lLiB3aGF0IHRoZSBtZXRob2Qgb24gYHRvYCByZXR1cm5zXG5cdFx0XHRcdHJldHVybiBvbGRSZXR1cm47XG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogU2ltcGxlIGV4dGVuZCBtZXRob2QgdG8gZXh0ZW5kIHRoZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIG9iamVjdCB3aGljaCB3aWxsIGJlIGV4dGVuZGVkXG5cdCAqXG5cdCAqIEByZXR1cm4ge09iamVjdH0gb2JqIC0gZXh0ZW5kZWQgb2JqZWN0XG5cdCAqL1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGV4dGVuZDtcblx0ZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuXHQgIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gaXRlbSkge1xuXHQgICAgICBvYmpba2V5XSA9IGl0ZW1ba2V5XTtcblx0ICAgIH1cblx0ICB9KTtcblx0ICByZXR1cm4gb2JqO1xuXHR9O1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgbnVtZXJpYyBpZC5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzZWdtZW50cz0xXSAtIG51bWJlciBvZiBzZWdtZW50cyBvZiBnZW5lcmF0ZWQgaWQgKHNlZ21lbnRzIGNvbnNpc3Qgb2YgMTAgZGlnaXRzLCBzZXBhcmF0ZWQgYnkgJy0nKS5cblx0ICpcblx0ICogQHJldHVybiB7U3RyaW5nfSAtIGdlbmVyYXRlZCBpZFxuXHQgKi9cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBtYWtlSWQ7XG5cdGZ1bmN0aW9uIG1ha2VJZCgpIHtcblx0XHR2YXIgc2VnbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG5cdFxuXHRcdHZhciBjcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0bztcblx0XHR2YXIgYXJyYXkgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShzZWdtZW50cykpO1xuXHRcdHZhciBpZCA9ICcnO1xuXHRcdHZhciBpID0gMDtcblx0XG5cdFx0Zm9yICg7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWQgKz0gYXJyYXlbaV0gKyAnLSc7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gaWQuc2xpY2UoMCwgLTEpO1xuXHR9O1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSxcbi8qIDggKi8sXG4vKiA5ICovLFxuLyogMTAgKi8sXG4vKiAxMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0LyoqXG5cdCAqIFBvbHlmaWxsc1xuXHQgKi9cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdFxuXHR2YXIgX2NvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblx0XG5cdHZhciBfY29yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb3JlKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHR2YXIgVmVhbXMgPSB7fTtcblx0XG5cdC8qKlxuXHQgKiBJbXBvcnRzXG5cdCAqL1xuXHRcblx0XG5cdChmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG5cdFx0J3VzZSBzdHJpY3QnO1xuXHRcblx0XHRWZWFtcyA9IG5ldyBfY29yZTIuZGVmYXVsdCh7XG5cdFx0XHRuYW1lc3BhY2U6ICdWZWFtcycsXG5cdFx0XHRhZGRUb0dsb2JhbDogdHJ1ZVxuXHRcdH0pO1xuXHRcblx0XHRWZWFtcy5pbml0aWFsaXplKCk7XG5cdH0pKHdpbmRvdywgZG9jdW1lbnQpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gVmVhbXM7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9LFxuLyogMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8vIFBvbHlmaWxsIGZvciBjdXN0b20gZXZlbnRzXG5cdChmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0XG5cdFx0ZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuXHRcdFx0dmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuXHRcblx0XHRcdHBhcmFtcyA9IHBhcmFtcyB8fCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB1bmRlZmluZWQgfTtcblx0XG5cdFx0XHRldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuXHRcdFx0cmV0dXJuIGV2dDtcblx0XHR9XG5cdFxuXHRcdEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG5cdFxuXHRcdHdpbmRvdy5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50O1xuXHR9KSgpO1xuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyoqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBSZXByZXNlbnRzIFZlYW1zQ29yZS5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgVmVhbXNDb3JlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGF1dGhvciBTZWJhc3RpYW4gRml0em5lclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdFxuXHRcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdFxuXHR2YXIgX3VzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXHRcblx0dmFyIF91c2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlKTtcblx0XG5cdHZhciBfZXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cdFxuXHR2YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXHRcblx0dmFyIF9oZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cdFxuXHR2YXIgX2hlbHBlcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGVscGVycyk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdHZhciBpbml0U3RhdGUgPSBmYWxzZTtcblx0XG5cdHZhciBWZWFtc0NvcmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gVmVhbXNDb3JlKG9wdHMpIHtcblx0XHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWZWFtc0NvcmUpO1xuXHRcblx0XHRcdHRoaXMuX29wdGlvbnMgPSB7XG5cdFx0XHRcdG5hbWVzcGFjZTogJ1ZlYW1zJyxcblx0XHRcdFx0YWRkVG9HbG9iYWw6IGZhbHNlXG5cdFx0XHR9O1xuXHRcblx0XHRcdHRoaXMuYmFzZSA9IHtcblx0XHRcdFx0bmFtZTogJ1ZlYW1zJyxcblx0XHRcdFx0dmVyc2lvbjogJzUuMC4xJ1xuXHRcdFx0fTtcblx0XG5cdFx0XHR0aGlzLnVzZSA9IF91c2UyLmRlZmF1bHQuYmluZCh0aGlzKTtcblx0XHRcdHRoaXMuUGx1Z2lucyA9IHt9O1xuXHRcdFx0dGhpcy5FVkVOVFMgPSBfZXZlbnRzMi5kZWZhdWx0O1xuXHRcdFx0dGhpcy5oZWxwZXJzID0ge307XG5cdFx0XHR0aGlzLmRldGVjdGlvbnMgPSB7XG5cdFx0XHRcdHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcblx0XHRcdFx0aGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcblx0XHRcdH07XG5cdFxuXHRcdFx0aW5pdFN0YXRlID0gZmFsc2U7XG5cdFxuXHRcdFx0dGhpcy5zZXR1cChvcHRzKTtcblx0XHR9XG5cdFxuXHRcdF9jcmVhdGVDbGFzcyhWZWFtc0NvcmUsIFt7XG5cdFx0XHRrZXk6ICdzZXR1cCcsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0dXAob3B0cykge1xuXHRcdFx0XHR0aGlzLnVzZShfaGVscGVyczIuZGVmYXVsdCk7XG5cdFxuXHRcdFx0XHR0aGlzLmRldGVjdGlvbnMgPSB0aGlzLmhlbHBlcnMuZXh0ZW5kKHtcblx0XHRcdFx0XHR0b3VjaDogdGhpcy5oZWxwZXJzLmlzVG91Y2goKVxuXHRcdFx0XHR9LCB0aGlzLmRldGVjdGlvbnMpO1xuXHRcblx0XHRcdFx0dGhpcy5vcHRpb25zID0gb3B0cztcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdpbml0aWFsaXplJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplKG9wdHMpIHtcblx0XHRcdFx0aWYgKGluaXRTdGF0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHJldHVybiBjb25zb2xlLmluZm8oJ1ZlYW1zIDo6IFlvdSBhbHJlYWR5IGluaXRpYWxpemVkIFZlYW1zIScpO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQvKipcblx0ICAgICogU2V0IGdsb2JhbCBvcHRpb25zIG9uIGluaXRpYWxpemVcblx0ICAgICovXG5cdFx0XHRcdHRoaXMub3B0aW9ucyA9IG9wdHM7XG5cdFxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLmFkZFRvR2xvYmFsKSB7XG5cdFx0XHRcdFx0aWYgKHdpbmRvdyAmJiAhd2luZG93W3RoaXMub3B0aW9ucy5uYW1lc3BhY2VdKSB7XG5cdFx0XHRcdFx0XHR3aW5kb3dbdGhpcy5vcHRpb25zLm5hbWVzcGFjZV0gPSB0aGlzIHx8IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0aW5pdFN0YXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdvbkluaXRpYWxpemUnLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIG9uSW5pdGlhbGl6ZShjYikge1xuXHRcdFx0XHRpZiAoIWNiIHx8IHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdWZWFtcyA6OiBDYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbiEnKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGlmIChpbml0U3RhdGUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0dGhpcy5pbml0aWFsaXplKCk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGNiKCk7XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAnb25ET01SZWFkeScsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gb25ET01SZWFkeShjYikge1xuXHRcdFx0XHRpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ1ZlYW1zIDo6IENhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2IpO1xuXHRcdFx0fVxuXHRcdH0sIHtcblx0XHRcdGtleTogJ3ZlcnNpb24nLFxuXHRcdFx0c2V0OiBmdW5jdGlvbiBzZXQodmVyc2lvbikge1xuXHRcdFx0XHR0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcblx0XHRcdH0sXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3ZlcnNpb247XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAnaW5pdGlhbGl6ZWQnLFxuXHRcdFx0c2V0OiBmdW5jdGlvbiBzZXQoYm9vbCkge1xuXHRcdFx0XHR0aGlzLl9pbml0aWFsaXplZCA9IGJvb2w7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9pbml0aWFsaXplZDtcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdvcHRpb25zJyxcblx0XHRcdHNldDogZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5fb3B0aW9ucyA9IHRoaXMuaGVscGVycy5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcblx0XHRcdH0sXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX29wdGlvbnM7XG5cdFx0XHR9XG5cdFx0fV0pO1xuXHRcblx0XHRyZXR1cm4gVmVhbXNDb3JlO1xuXHR9KCk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBWZWFtc0NvcmU7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9LFxuLyogMTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBSZXByZXNlbnRzIGEgc2ltcGxlIHBsdWdpbiBzeXN0ZW0gaW4gd2hpY2ggYHRoaXNgIGlzIFZlYW1zLlxuXHQgKiBAbW9kdWxlIHBsdWdpblxuXHQgKlxuXHQgKiBAYXV0aG9yIFNlYmFzdGlhbiBGaXR6bmVyXG5cdCAqL1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG5cdCAgaWYgKHBsdWdpbi5wbHVnaW5OYW1lKSB7XG5cdCAgICB0aGlzLlBsdWdpbnNbcGx1Z2luLnBsdWdpbk5hbWVdID0gcGx1Z2luO1xuXHQgIH1cblx0XG5cdCAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdCAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICB9XG5cdFxuXHQgIHBsdWdpbi5pbml0aWFsaXplLmFwcGx5KHBsdWdpbiwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG5cdH07XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSxcbi8qIDE1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogQ29uc3QgZm9yIGV2ZW50cyAocHViL3N1Yilcblx0ICpcblx0ICogQGF1dGhvcjogU2ViYXN0aWFuIEZpdHpuZXJcblx0ICovXG5cdFxuXHQvKipcblx0ICogRXZlbnRzIEdsb2JhbFxuXHQgKi9cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHR2YXIgRVZFTlRTID0ge1xuXHRcdGJsdXI6ICdibHVyJyxcblx0XHRjaGFuZ2U6ICdjaGFuZ2UnLFxuXHRcdGNsaWNrOiAnY2xpY2snLFxuXHRcdGRibGNsaWNrOiAnZGJsY2xpY2snLFxuXHRcdERPTWNoYW5nZWQ6ICdkb206Y2hhbmdlZCcsXG5cdFx0RE9NcmVkaXJlY3Q6ICdkb206cmVkaXJlY3QnLFxuXHRcdGhhc2hjaGFuZ2U6ICdoYXNoY2hhbmdlJyxcblx0XHRpbnB1dDogJ2lucHV0Jyxcblx0XHRrZXlkb3duOiAna2V5ZG93bicsXG5cdFx0a2V5cHJlc3M6ICdrZXlwcmVzcycsXG5cdFx0a2V5dXA6ICdrZXl1cCcsXG5cdFx0bWVkaWFjaGFuZ2U6ICdtZWRpYWNoYW5nZScsXG5cdFx0bW9kdWxlQ2FjaGVkOiAnbW9kdWxlOmNhY2hlZCcsXG5cdFx0bW91c2Vkb3duOiAnbW91c2Vkb3duJyxcblx0XHRtb3VzZWVudGVyOiAnbW91c2VlbnRlcicsXG5cdFx0bW91c2VsZWF2ZTogJ21vdXNlbGVhdmUnLFxuXHRcdG1vdXNlb3V0OiAnbW91c2VvdXQnLFxuXHRcdG1vdXNlb3ZlcjogJ21vdXNlb3ZlcicsXG5cdFx0bW91c2V1cDogJ21vdXNldXAnLFxuXHRcdHJlc2V0OiAncmVzZXQnLFxuXHRcdHJlc2l6ZTogJ3Jlc2l6ZScsXG5cdFx0c2Nyb2xsOiAnc2Nyb2xsJyxcblx0XHRzdWJtaXQ6ICdzdWJtaXQnLFxuXHRcdHN3aXBlOiAnc3dpcGUnXG5cdH07XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBFVkVOVFM7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9LFxuLyogMTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXHRcblx0dmFyIF9leHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcblx0dmFyIF9leHRlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXh0ZW5kKTtcblx0XG5cdHZhciBfbWl4aW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcblx0dmFyIF9taXhpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9taXhpbik7XG5cdFxuXHR2YXIgX21ldGhvZEV4dGVuZCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFxuXHR2YXIgX21ldGhvZEV4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZXRob2RFeHRlbmQpO1xuXHRcblx0dmFyIF9pc1RvdWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cdFxuXHR2YXIgX2lzVG91Y2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNUb3VjaCk7XG5cdFxuXHR2YXIgX3Rocm90dGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cdFxuXHR2YXIgX3Rocm90dGxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Rocm90dGxlKTtcblx0XG5cdHZhciBfcXVlcnlTZWxlY3RvckFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cdFxuXHR2YXIgX3F1ZXJ5U2VsZWN0b3JBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWVyeVNlbGVjdG9yQXJyYXkpO1xuXHRcblx0dmFyIF9mb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cdFxuXHR2YXIgX2ZvckVhY2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9yRWFjaCk7XG5cdFxuXHR2YXIgX21ha2VJZCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdFxuXHR2YXIgX21ha2VJZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYWtlSWQpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdHZhciBWZWFtc0hlbHBlcnMgPSB7XG5cdFx0cGx1Z2luTmFtZTogJ0hlbHBlcnMnLFxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUoVmVhbXMpIHtcblx0XHRcdFZlYW1zLmFkZEhlbHBlciA9IGZ1bmN0aW9uIGFkZEhlbHBlcigpIHtcblx0XHRcdFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0XHRcdFx0XHRhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHR2YXIgcGFyYW1zID0gW10uY29uY2F0KGFyZ3MpO1xuXHRcblx0XHRcdFx0aWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRpZiAoX3R5cGVvZihwYXJhbXNbMF0pICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVmVhbXNIZWxwZXJzIDo6IFlvdSBuZWVkIHRvIHBhc3MgYW4gb2JqZWN0IScpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHBhcmFtc1swXSkge1xuXHRcdFx0XHRcdFx0aWYgKHBhcmFtc1swXS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghVmVhbXMuaGVscGVyc1trZXldKSB7XG5cdFx0XHRcdFx0XHRcdFx0VmVhbXMuaGVscGVyc1trZXldID0gcGFyYW1zWzBdW2tleV07XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5pbmZvKCdWZWFtc0hlbHBlcnMgOjogVGhlIGhlbHBlciAnICsga2V5ICsgJyBpcyBhbHJlYWR5IGRlZmluZWQhIFBsZWFzZSBkZWZpbmUgYSBuZXcgbmFtZSBmb3I6ICcsIHBhcmFtc1swXVtrZXldKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChwYXJhbXMubGVuZ3RoID09PSAyKSB7XG5cdFxuXHRcdFx0XHRcdGlmICghVmVhbXMuaGVscGVyc1twYXJhbXNbMF1dKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHBhcmFtc1swXSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHBhcmFtc1sxXSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdWZWFtc0hlbHBlcnMgOjogWW91IG5lZWQgdG8gcGFzcyBhIHN0cmluZyBhcyBmaXJzdCBhcmd1bWVudCBhbmQgdGhlIGhlbHBlciBmdW5jdGlvbiBhcyBzZWNvbmQgb25lLicpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRWZWFtcy5oZWxwZXJzW3BhcmFtc1swXV0gPSBwYXJhbXNbMV07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuaW5mbygnVmVhbXNIZWxwZXJzIDo6IFRoZSBoZWxwZXIgJyArIHBhcmFtc1swXSArICcgaXMgYWxyZWFkeSBkZWZpbmVkISBQbGVhc2UgZGVmaW5lIGEgbmV3IG5hbWUgZm9yOiAnLCBwYXJhbXNbMV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XG5cdFx0XHR0aGlzLmFkZERlZmF1bHRIZWxwZXJzKFZlYW1zKTtcblx0XHR9LFxuXHRcblx0XHRhZGREZWZhdWx0SGVscGVyczogZnVuY3Rpb24gYWRkRGVmYXVsdEhlbHBlcnMoVmVhbXMpIHtcblx0XHRcdFZlYW1zLmFkZEhlbHBlcigncXVlcnlTZWxlY3RvckFycmF5JywgX3F1ZXJ5U2VsZWN0b3JBcnJheTIuZGVmYXVsdCk7XG5cdFx0XHRWZWFtcy5hZGRIZWxwZXIoJ2V4dGVuZCcsIF9leHRlbmQyLmRlZmF1bHQpO1xuXHRcdFx0VmVhbXMuYWRkSGVscGVyKCdpc1RvdWNoJywgX2lzVG91Y2gyLmRlZmF1bHQpO1xuXHRcdFx0VmVhbXMuYWRkSGVscGVyKCdtaXhpbicsIF9taXhpbjIuZGVmYXVsdCk7XG5cdFx0XHRWZWFtcy5hZGRIZWxwZXIoJ21ldGhvZEV4dGVuZCcsIF9tZXRob2RFeHRlbmQyLmRlZmF1bHQpO1xuXHRcdFx0VmVhbXMuYWRkSGVscGVyKCd0aHJvdHRsZScsIF90aHJvdHRsZTIuZGVmYXVsdCk7XG5cdFx0XHRWZWFtcy5hZGRIZWxwZXIoJ2ZvckVhY2gnLCBfZm9yRWFjaDIuZGVmYXVsdCk7XG5cdFx0XHRWZWFtcy5hZGRIZWxwZXIoJ21ha2VJZCcsIF9tYWtlSWQyLmRlZmF1bHQpO1xuXHRcdH1cblx0fTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IFZlYW1zSGVscGVycztcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH0sXG4vKiAxNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0LyoqXG5cdCAqIFRvdWNoIERldGVjdGlvblxuXHQgKi9cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBpc1RvdWNoO1xuXHRmdW5jdGlvbiBpc1RvdWNoKCkge1xuXHQgIHJldHVybiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG5cdH07XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9LFxuLyogMTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBUaHJvdHRsZSBtZXRob2QgZm9yIHJlc2l6ZSBldmVudHMgYW5kIG1vcmVcblx0ICpcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IC0gbnVtYmVyIHRvIHdhaXQgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGltbWVkaWF0ZSAtIGV4ZWN1dGUgZnVuY3Rpb24gaW1tZWRpYXRlbHkuXG5cdCAqL1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0dmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IHRocm90dGxlO1xuXHRmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcblx0XHR2YXIgdGltZW91dCA9IHZvaWQgMDtcblx0XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjb250ZXh0ID0gdGhpcztcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHRcdFx0dmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG5cdFx0XHR2YXIgbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcblx0XHRcdFx0dGltZW91dCA9IG51bGw7XG5cdFx0XHRcdGlmICghaW1tZWRpYXRlKSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXHRcdFx0fTtcblx0XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFxuXHRcdFx0dGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuXHRcblx0XHRcdGlmIChjYWxsTm93KSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXHRcdH07XG5cdH07XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9LFxuLyogMTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBHZXQgZG9tIGVsZW1lbnRzIGluIGFuIGFycmF5XG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBlbGVtIC0gUmVxdWlyZWQ6IHNlbGVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gLSBPcHRpb25hbDogY29udGV4dFxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICovXG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5kZWZhdWx0ID0gcXVlcnlTZWxlY3RvckFycmF5O1xuXHRmdW5jdGlvbiBxdWVyeVNlbGVjdG9yQXJyYXkoZWxlbSwgY29udGV4dCkge1xuXHQgIGlmICghZWxlbSkgdGhyb3cgbmV3IEVycm9yKCdJbiBvcmRlciB0byB3b3JrIHdpdGggcXVlcnlTZWxlY3RvckFycmF5IHlvdSBuZWVkIHRvIGRlZmluZSBhbiBlbGVtZW50IGFzIHN0cmluZyEnKTtcblx0ICB2YXIgZWwgPSBlbGVtO1xuXHQgIHZhciBjdXN0b21Db250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblx0XG5cdCAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1c3RvbUNvbnRleHQucXVlcnlTZWxlY3RvckFsbChlbCkpO1xuXHR9O1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSxcbi8qIDIwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogU2ltcGxlIGZvckVhY2ggbWV0aG9kXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gYXJyYXkgb2Ygb2JqZWN0c1xuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGNhbGxiYWNrIGZ1bmN0aW9uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZSAtIHNjb3BlIG9mIGZ1bmN0aW9uXG5cdCAqL1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGZvckVhY2g7XG5cdGZ1bmN0aW9uIGZvckVhY2goYXJyYXksIGNhbGxiYWNrLCBzY29wZSkge1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcblx0ICAgIGNhbGxiYWNrLmNhbGwoc2NvcGUsIGksIGFycmF5W2ldKTtcblx0ICB9XG5cdH07XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZWFtcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBiYXNlIGNvbnN0cnVjdG9yIHdoaWNoIHN1cHBvcnRzXG4gKiBvcHRpb25zIG1lcmdpbmcgYW5kXG4gKiBzYXZpbmcgb2Ygc3RhbmRhcmQgc3R1ZmYuXG4gKlxuICogQG1vZHVsZSBWZWFtc0Jhc2VcbiAqIEBhdXRob3IgU2ViYXN0aWFuIEZpdHpuZXJcbiAqL1xuXG4vKipcbiAqIEltcG9ydHNcbiAqL1xuaW1wb3J0IHN0cmluZ0hlbHBlcnMgZnJvbSAnLi4vdXRpbHMvaW50ZXJuYWwtaGVscGVycy9zdHJpbmcnO1xuaW1wb3J0IG1peGluSGVscGVyIGZyb20gJy4uL3V0aWxzL2hlbHBlcnMvbWl4aW4nO1xuaW1wb3J0IGV4dGVuZEhlbHBlciBmcm9tICcuLi91dGlscy9oZWxwZXJzL2V4dGVuZCc7XG5pbXBvcnQgbWFrZUlkSGVscGVyIGZyb20gJy4uL3V0aWxzL2hlbHBlcnMvbWFrZS1pZCc7XG5cbmNsYXNzIFZlYW1zQmFzZSB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RvclxuXHQgKlxuXHQgKiB0byBzYXZlIHN0YW5kYXJkIGVsZW1lbnRzIGxpa2UgZWwgYW5kIG9wdGlvbnMgYW5kXG5cdCAqIGV4ZWN1dGUgaW5pdGlhbGl6ZSBhcyBkZWZhdWx0IG1ldGhvZC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSAtIEFkZCBjdXN0b20gbmFtZXNwYWNlIHRvIHlvdXIgY2xhc3MuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlbCAtIFNhdmUgZWxlbWVudCBpbiBjbGFzcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIHBhc3NlZCBieSBpbml0IHByb2Nlc3MuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFt7fV0gLSBPYmplY3Qgd2hpY2ggY29udGFpbnMgb3B0aW9ucyBvZiB0aGUgZXh0ZW5kZWQgY2xhc3MuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih7bmFtZXNwYWNlLCBlbCwgb3B0aW9uc30sIG9wdHMgPSB7fSkge1xuXHRcdHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlIHx8ICdiYXNlJztcblx0XHR0aGlzLmluc3RhbmNlSWQgPSB0aGlzLm5hbWVzcGFjZTtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRzO1xuXHRcdHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuXG5cdFx0aWYgKGVsKSB7XG5cdFx0XHR0aGlzLmVsID0gZWw7XG5cdFx0fVxuXHR9XG5cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyBHRVRURVIgJiBTRVRURVJTXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRzZXQgbmFtZXNwYWNlKG5hbWVzcGFjZSkge1xuXHRcdHRoaXMuX25hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0fVxuXG5cdGdldCBuYW1lc3BhY2UoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX25hbWVzcGFjZTtcblx0fVxuXG5cdGdldCBpbnN0YW5jZUlkKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbnN0YW5jZUlkO1xuXHR9XG5cblx0c2V0IGluc3RhbmNlSWQoaWQpIHtcblx0XHR0aGlzLl9pbnN0YW5jZUlkID0gYCR7aWR9X2AgKyBEYXRlLm5vdygpICsgJ18nICsgbWFrZUlkSGVscGVyKCk7XG5cdH1cblxuXHRnZXQgX29wdGlvbnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucztcblx0fVxuXG5cdHNldCBfb3B0aW9ucyhvcHRpb25zKSB7XG5cdFx0dGhpcy5vcHRpb25zID0gZXh0ZW5kSGVscGVyKHRoaXMub3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG5cdH1cblxuXHRzZXQgZWwoZWxlbWVudCkge1xuXHRcdHRoaXMuX2VsID0gZWxlbWVudDtcblx0fVxuXG5cdGdldCBlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZWw7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IG1vZHVsZSBpbmZvcm1hdGlvblxuXHQgKi9cblx0Z2V0IG1ldGFEYXRhKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRuYW1lOiB0eXBlb2YgdGhpcy5uYW1lc3BhY2UgPT09ICdzdHJpbmcnID8gc3RyaW5nSGVscGVycy5jYXBpdGFsaXplRmlyc3RMZXR0ZXIoc3RyaW5nSGVscGVycy50b0NhbWVsQ2FzZSh0aGlzLm5hbWVzcGFjZSkpIDogJydcblx0XHR9O1xuXHR9XG59XG5cbi8qKlxuICogQWRkIG1peGluIGZ1bmN0aW9uYWxpdHkgdG8gZXh0ZW5kIG1vZHVsZSBjbGFzcyBieSB1c2luZyBzaW1wbGUgb2JqZWN0c1xuICovXG5WZWFtc0Jhc2UubWl4aW4gPSBtaXhpbkhlbHBlcjtcblxuZXhwb3J0IGRlZmF1bHQgVmVhbXNCYXNlOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29tcG9uZW50IGNvbnN0cnVjdG9yIHdoaWNoIHN1cHBvcnRzXG4gKiBvcHRpb25zIG1lcmdpbmcsXG4gKiBiaW5kaW5nIGFuZCB1bmJpbmRpbmcgb2YgZXZlbnRzIGFuZCBzdWJzY3JpcHRpb25zIHdpdGggdGVtcGxhdGUgc3RyaW5ncyxcbiAqIHJlbmRlcmluZyBvZiB0ZW1wbGF0ZXNcbiAqIGFuZCBhIGRlc3Ryb3kgYmVoYXZpb3VyLlxuICpcbiAqIEtlZXAgaW4gbWluZCwgdGhhdCB0aGlzIGNsYXNzIGlzIGEgZGVwZW5kZW50IG9mIFZlYW1zLlxuICpcbiAqIFRPRE86IE1ha2UgYSBuYXRpdmUgb25lIHdoaWNoIGRvZXMgbm90IG5lZWQgYW55IFZlYW1zIHNwZWNpZmljIHN0dWZmLlxuICpcbiAqIEBtb2R1bGUgVmVhbXNDb21wb25lbnRcbiAqIEBhdXRob3IgU2ViYXN0aWFuIEZpdHpuZXJcbiAqL1xuXG4vKipcbiAqIEltcG9ydHNcbiAqL1xuaW1wb3J0IFZlYW1zQmFzZSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IGdldFN0cmluZ1ZhbHVlIGZyb20gJy4uL3V0aWxzL2ludGVybmFsLWhlbHBlcnMvZ2V0LXN0cmluZy12YWx1ZSc7XG5pbXBvcnQgdHBsRW5naW5lIGZyb20gJy4uL3V0aWxzL2ludGVybmFsLWhlbHBlcnMvdGVtcGxhdGUtZW5naW5lJztcblxuLyoqXG4gKiBDdXN0b20gRnVuY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRXZ0SWQoZXZ0S2V5QXJyLCBmbk5hbWUpIHtcblx0cmV0dXJuIGV2dEtleUFyci5qb2luKCdfJykgKyAnXycgKyBmbk5hbWU7XG59XG5cbmNsYXNzIFZlYW1zQ29tcG9uZW50IGV4dGVuZHMgVmVhbXNCYXNlIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0b3Jcblx0ICpcblx0ICogdG8gc2F2ZSBzdGFuZGFyZCBlbGVtZW50cyBsaWtlIGVsIGFuZCBvcHRpb25zIGFuZFxuXHQgKiBleGVjdXRlIGluaXRpYWxpemUgYXMgZGVmYXVsdCBtZXRob2QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogW3t9XSAtIE9iamVjdCB3aGljaCBjb250YWlucyBlbCwgb3B0aW9ucyBmcm9tIHRoZSBET00gYW5kIG5hbWVzcGFjZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgW3t9XSAtIE9iamVjdCB3aGljaCBjb250YWlucyBvcHRpb25zIG9mIHRoZSBleHRlbmRlZCBjbGFzcy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKG9iaiA9IHt9LCBvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcihvYmosIG9wdGlvbnMpO1xuXHRcdHRoaXMuYXBwSW5zdGFuY2UgPSBvYmouYXBwSW5zdGFuY2UgfHwgd2luZG93LlZlYW1zO1xuXG5cdFx0aWYgKCF0aGlzLmFwcEluc3RhbmNlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1ZlYW1zQ29tcG9uZW50IDo6IFBsZWFzZSBwcm92aWRlIHlvdXIgYXBwIGluc3RhbmNlIScpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5hcHBJbnN0YW5jZS4kKSB7XG5cdFx0XHRjb25zb2xlLmluZm8oJ1ZlYW1zQ29tcG9uZW50IDo6IFBsZWFzZSBhZGQgYSBET00gaGFuZGxlciBsaWtlIGpRdWVyeSB0byB0aGUgYXBwIGluc3RhbmNlIScpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmFwcEluc3RhbmNlLiQpIHtcblx0XHRcdHRoaXMuJGVsID0gdGhpcy5hcHBJbnN0YW5jZS4kKG9iai5lbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5pbml0aWFsaXplKG9iaiwgb3B0aW9ucyk7XG5cdFx0dGhpcy5fY3JlYXRlKCk7XG5cdH1cblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vIEdFVFRFUiAmIFNFVFRFUlNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBldmVudHMgb2JqZWN0XG5cdCAqL1xuXHRzZXQgZXZlbnRzKG9iaikge1xuXHRcdHRoaXMuX2V2ZW50cyA9IG9iajtcblx0fVxuXG5cdGdldCBldmVudHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2V2ZW50cztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBzdWJzY3JpYmUgb2JqZWN0XG5cdCAqL1xuXHRzZXQgc3Vic2NyaWJlKG9iaikge1xuXHRcdHRoaXMuX3N1YnNjcmliZSA9IG9iajtcblx0fVxuXG5cdGdldCBzdWJzY3JpYmUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N1YnNjcmliZTtcblx0fVxuXG5cdHNldCBfc3Vic2NyaWJlcnMob2JqKSB7XG5cdFx0aWYgKCF0aGlzLl9fc3Vic2NyaWJlcnMpIHtcblx0XHRcdHRoaXMuX19zdWJzY3JpYmVycyA9IHt9O1xuXHRcdH1cblxuXHRcdHRoaXMuX19zdWJzY3JpYmVyc1tvYmouaWRdID0ge1xuXHRcdFx0ZGVsZWdhdGU6IG9iai5kZWxlZ2F0ZSxcblx0XHRcdHR5cGU6IG9iai50eXBlLFxuXHRcdFx0ZXZlbnQ6IG9iai5ldmVudCxcblx0XHRcdGhhbmRsZXI6IG9iai5oYW5kbGVyXG5cdFx0fTtcblx0fVxuXG5cdGdldCBfc3Vic2NyaWJlcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX19zdWJzY3JpYmVycztcblx0fVxuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gU1RBTkRBUkQgTUVUSE9EU1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdGluaXRpYWxpemUoKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUHJpdmF0ZSBtZXRob2QgdG8gY3JlYXRlIGFsbCBuZWNlc3NhcnkgZWxlbWVudHMgYW5kIGJpbmRpbmdzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NyZWF0ZSgpIHtcblx0XHR0aGlzLnByZVJlbmRlcigpO1xuXHRcdHRoaXMucmVnaXN0ZXJFdmVudHModGhpcy5ldmVudHMsIGZhbHNlKTtcblx0XHR0aGlzLnJlZ2lzdGVyRXZlbnRzKHRoaXMuc3Vic2NyaWJlLCB0cnVlKTtcblx0XHR0aGlzLmJpbmRFdmVudHMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kIGxvY2FsIGFuZCBnbG9iYWwgZXZlbnRzXG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdGJpbmRFdmVudHMoKSB7XG5cdH1cblxuXHQvKipcblx0ICogVW5iaW5kIGV2ZW50c1xuXHQgKlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHR1bmJpbmRFdmVudHMoKSB7XG5cdH1cblxuXHQvKipcblx0ICogUHJlLVJlbmRlciB0ZW1wbGF0ZXNcblx0ICogd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVuZGVyIGNvbnRlbnQgaW50byBpdFxuXHQgKlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRwcmVSZW5kZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVyIHlvdXIgbW9kdWxlXG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXN0cm95IGNvbXBvbmVudCBieSB1bmJpbmRpbmcgZXZlbnRzIGFuZFxuXHQgKiByZW1vdmluZyBlbGVtZW50IGZyb20gRE9NXG5cdCAqL1xuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMudW5yZWdpc3RlckV2ZW50cygpO1xuXHRcdHRoaXMudW5iaW5kRXZlbnRzKCk7XG5cdFx0dGhpcy4kZWwucmVtb3ZlKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVyIHRlbXBsYXRlIHdpdGggZGF0YVxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHBsTmFtZSAtIFRlbXBsYXRlIG5hbWUgd2hpY2ggZ2V0cyByZXR1cm5lZCBhcyByZW5kZXJlZCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIERhdGEgd2hpY2ggZ2V0cyBoYW5kbGVkIGJ5IHRoZSB0ZW1wbGF0ZS5cblx0ICovXG5cdHJlbmRlclRlbXBsYXRlKHRwbE5hbWUsIGRhdGEpIHtcblx0XHRpZiAoIXRoaXMuYXBwSW5zdGFuY2UudGVtcGxhdGVyKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBcblx0XHRcdFx0VmVhbXNDb21wb25lbnQgOjogSXQgc2VlbXMgdGhhdCB5b3UgaGF2ZW5cXCd0IGFkZGVkIHRoZSBWZWFtc1RlbXBsYXRlciBwbHVnaW4uIEluIG9yZGVyIHRvIHdvcmsgd2l0aCAncmVuZGVyVGVtcGxhdGUoKScgeW91IG5lZWQgdG8gYWRkIGl0IVxuXHRcdFx0YCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmFwcEluc3RhbmNlLnRlbXBsYXRlci5yZW5kZXIodHBsTmFtZSwgZGF0YSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyBNT1VOVCBQUk9DRVNTIE1FVEhPRFNcblx0Ly8gTW91bnQgcHJvY2VzcyBtZXRob2RzIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgVmVhbXNNb2R1bGVzIHBsdWdpblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgaW5pdGlhbGlzZVxuXHQgKi9cblx0d2lsbE1vdW50KCkge1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgZXhlY3V0ZWQgYmVmb3JlIHVucmVnaXN0ZXJpbmcgZXZlbnRzXG5cdCAqL1xuXHR3aWxsVW5tb3VudCgpIHtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHJlbmRlclxuXHQgKi9cblx0ZGlkTW91bnQoKSB7XG5cdH1cblxuXHQvKipcblx0ICogVGhpcyBtZXRob2Qgd2lsbCBiZSBleGVjdXRlZCBhZnRlciB1bnJlZ2lzdGVyaW5nIGV2ZW50c1xuXHQgKi9cblx0ZGlkVW5tb3VudCgpIHtcblx0fVxuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gRVZFTlRTIE1FVEhPRFNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBtdWx0aXBsZSBldmVudHMgd2hpY2ggYXJlIHNhdmVkIGluIGFuIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dHMgLSBFdmVudHMgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGFuIG9iamVjdCB3aXRoIGV2ZW50cyBhcyBrZXkgYW5kIGZ1bmN0aW9ucyBhcyB2YWx1ZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBnbG9iYWwgLSBGbGFnIHRvIHN3aXRjaCBiZXR3ZWVuIGdsb2JhbCBhbmQgbG9jYWwgZXZlbnRzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmVnaXN0ZXJFdmVudHMoZXZ0cywgZ2xvYmFsID0gZmFsc2UpIHtcblx0XHRpZiAoZXZ0cykge1xuXHRcdFx0T2JqZWN0LmtleXMoZXZ0cykuZm9yRWFjaCgoa2V5KSA9PiB7XG5cdFx0XHRcdHRoaXMucmVnaXN0ZXJFdmVudChrZXksIGV2dHNba2V5XSwgZ2xvYmFsKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhbiBldmVudCBieSB1c2luZyBhIHNpbXBsZSB0ZW1wbGF0ZSBlbmdpbmUgYW5kXG5cdCAqIGEga2V5L3ZhbHVlIHBhaXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldnRLZXkgLSBFdmVudCBrZXkgd2hpY2ggY29udGFpbnMgZXZlbnQgYW5kIGFkZGl0aW9uYWxseSBhIGRlbGVnYXRlZCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZm4gLSBGdW5jdGlvbiBkZWZpbmVkIGFzIHN0cmluZyB3aGljaCB3aWxsIGJlIGJvdW5kIHRvIHRoaXMuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZ2xvYmFsIC0gRmxhZyBpZiBnbG9iYWwgb3IgbG9jYWwgZXZlbnQgLlxuXHQgKlxuXHQgKiBAcHVibGljXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIHRoaXMucmVnaXN0ZXJFdmVudCgnY2xpY2sgLmJ0bicsICdyZW5kZXInKTtcblx0ICogdGhpcy5yZWdpc3RlckV2ZW50KCdjbGljayB7e3RoaXMub3B0aW9ucy5idG59fScsICdyZW5kZXInKTtcblx0ICogdGhpcy5yZWdpc3RlckV2ZW50KCd7e0FwcC5FVkVOVFMuY3VzdG9tLmV2ZW50JywgJ3JlbmRlcicpO1xuXHQgKiB0aGlzLnJlZ2lzdGVyRXZlbnQoJ3t7QXBwLkVWRU5UUy5yZXNpemUnLCAncmVuZGVyJywgdHJ1ZSk7XG5cdCAqL1xuXHRyZWdpc3RlckV2ZW50KGV2dEtleSwgZm4sIGdsb2JhbCA9IGZhbHNlKSB7XG5cdFx0aWYgKHR5cGVvZiBldnRLZXkgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdWZWFtc0NvbXBvbmVudCA6OiBZb3VyIGV2ZW50IGlzIG5vdCBhIHN0cmluZyEnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIGZuICE9PSAnc3RyaW5nJykge1xuXHRcdFx0Y29uc29sZS5lcnJvcignVmVhbXNDb21wb25lbnQgOjogWW91ciBldmVudCBoYW5kbGVyIGZ1bmN0aW9uIGlzIG5vdCBhIHN0cmluZyEnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgZXZ0S2V5QXJyID0gZXZ0S2V5LnNwbGl0KCcgJyk7XG5cdFx0bGV0IGFycmxlbiA9IGV2dEtleUFyci5sZW5ndGg7XG5cdFx0bGV0IGV2dFR5cGUgPSBnZXRTdHJpbmdWYWx1ZS5hcHBseSh0aGlzLCBbdHBsRW5naW5lKGV2dEtleUFyclswXSksIHRoaXMuYXBwSW5zdGFuY2VdKTtcblx0XHRsZXQgYmluZEZuID0gdGhpc1tmbl0uYmluZCh0aGlzKTtcblx0XHRsZXQgaWQgPSBidWlsZEV2dElkKGV2dEtleUFyciwgZm4pO1xuXG5cdFx0aWYgKGFycmxlbiA+IDIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSXQgc2VlbXMgbGlrZSB5b3UgaGF2ZSBtb3JlIHRoYW4gdHdvIHN0cmluZ3MgaW4geW91ciBldmVudHMgb2JqZWN0IScpO1xuXHRcdH1cblxuXHRcdC8vIEJpbmQgb24gdGhpcy4kZWxcblx0XHRpZiAoYXJybGVuID09PSAxICYmICFnbG9iYWwpIHtcblx0XHRcdHRoaXMuJGVsLm9uKGV2dFR5cGUsIGJpbmRGbik7XG5cblx0XHRcdHRoaXMuX3N1YnNjcmliZXJzID0ge1xuXHRcdFx0XHR0eXBlOiAnZXZlbnQnLFxuXHRcdFx0XHRpZDogaWQsXG5cdFx0XHRcdGV2ZW50OiBldnRUeXBlLFxuXHRcdFx0XHRoYW5kbGVyOiBiaW5kRm5cblx0XHRcdH07XG5cblx0XHR9IGVsc2UgaWYgKGFycmxlbiA9PT0gMSAmJiBnbG9iYWwpIHtcblx0XHRcdHRoaXMuYXBwSW5zdGFuY2UuVmVudC5zdWJzY3JpYmUoZXZ0VHlwZSwgYmluZEZuKTtcblxuXHRcdFx0dGhpcy5fc3Vic2NyaWJlcnMgPSB7XG5cdFx0XHRcdHR5cGU6ICdnbG9iYWxFdmVudCcsXG5cdFx0XHRcdGlkOiBpZCxcblx0XHRcdFx0ZXZlbnQ6IGV2dFR5cGUsXG5cdFx0XHRcdGhhbmRsZXI6IGJpbmRGblxuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGRlbGVnYXRlID0gZ2V0U3RyaW5nVmFsdWUuYXBwbHkodGhpcywgW3RwbEVuZ2luZShldnRLZXlBcnJbMV0pXSk7XG5cblx0XHRcdHRoaXMuJGVsLm9uKGV2dFR5cGUsIGRlbGVnYXRlLCBiaW5kRm4pO1xuXG5cdFx0XHR0aGlzLl9zdWJzY3JpYmVycyA9IHtcblx0XHRcdFx0dHlwZTogJ2RlbGVnYXRlZEV2ZW50Jyxcblx0XHRcdFx0ZGVsZWdhdGU6IGRlbGVnYXRlLFxuXHRcdFx0XHRpZDogaWQsXG5cdFx0XHRcdGV2ZW50OiBldnRUeXBlLFxuXHRcdFx0XHRoYW5kbGVyOiBiaW5kRm5cblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIERlbGV0ZSBhbGwgcmVnaXN0ZXJlZCBldmVudHMuXG5cdCAqL1xuXHR1bnJlZ2lzdGVyRXZlbnRzKCkge1xuXHRcdGZvciAobGV0IGtleSBpbiB0aGlzLl9zdWJzY3JpYmVycykge1xuXHRcdFx0aWYgKHRoaXMuX3N1YnNjcmliZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0bGV0IG9iaiA9IHRoaXMuX3N1YnNjcmliZXJzW2tleV07XG5cblx0XHRcdFx0aWYgKG9iai50eXBlID09PSAnZ2xvYmFsRXZlbnQnKSB7XG5cdFx0XHRcdFx0dGhpcy5hcHBJbnN0YW5jZS5WZW50LnVuc3Vic2NyaWJlKG9iai5ldmVudCwgb2JqLmhhbmRsZXIpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG9iai50eXBlID09PSAnZGVsZWdhdGVkRXZlbnQnKSB7XG5cdFx0XHRcdFx0dGhpcy4kZWwub2ZmKG9iai5ldmVudCwgb2JqLmRlbGVnYXRlLCBvYmouaGFuZGxlcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy4kZWwub2ZmKG9iai5ldmVudCwgb2JqLmhhbmRsZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVucmVnaXN0ZXIgYW4gZXZlbnQgYnkgdXNpbmcgdGhlIHNhdmVkIHN1YnNjcmliZXJzIGFuZFxuXHQgKiBhIGtleS92YWx1ZSBwYWlyLlxuXHQgKlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZ0S2V5IC0gRXZlbnQga2V5IHdoaWNoIGNvbnRhaW5zIGV2ZW50IGFuZCBhZGRpdGlvbmFsbHkgYSBkZWxlZ2F0ZWQgZWxlbWVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGZuIC0gRnVuY3Rpb24gZGVmaW5lZCBhcyBzdHJpbmcgd2hpY2ggd2lsbCBiZSB1bmJvdW5kIHRvIHRoaXMuXG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogdGhpcy51bnJlZ2lzdGVyRXZlbnQoJ2NsaWNrIC5idG4nLCAncmVuZGVyJyk7XG5cdCAqIHRoaXMudW5yZWdpc3RlckV2ZW50KCdjbGljayB7e3RoaXMub3B0aW9ucy5idG59fScsICdyZW5kZXInKTtcblx0ICogdGhpcy51bnJlZ2lzdGVyRXZlbnQoJ3t7QXBwLkVWRU5UUy5jdXN0b20uZXZlbnQnLCAncmVuZGVyJyk7XG5cdCAqIHRoaXMudW5yZWdpc3RlckV2ZW50KCd7e0FwcC5FVkVOVFMucmVzaXplJywgJ3JlbmRlcicpO1xuXHQgKi9cblx0dW5yZWdpc3RlckV2ZW50KGV2dEtleSwgZm4pIHtcblx0XHRsZXQgZXZ0S2V5QXJyID0gZXZ0S2V5LnNwbGl0KCcgJyk7XG5cdFx0bGV0IGlkID0gYnVpbGRFdnRJZChldnRLZXlBcnIsIGZuKTtcblxuXHRcdGlmICh0aGlzLl9zdWJzY3JpYmVyc1tpZF0pIHtcblx0XHRcdGxldCBvYmogPSB0aGlzLl9zdWJzY3JpYmVyc1tpZF07XG5cblx0XHRcdGlmIChvYmoudHlwZSA9PT0gJ2dsb2JhbEV2ZW50Jykge1xuXHRcdFx0XHR0aGlzLmFwcEluc3RhbmNlLlZlbnQudW5zdWJzY3JpYmUob2JqLmV2ZW50LCBvYmouaGFuZGxlcik7XG5cdFx0XHR9IGVsc2UgaWYgKG9iai50eXBlID09PSAnZGVsZWdhdGVkRXZlbnQnKSB7XG5cdFx0XHRcdHRoaXMuJGVsLm9mZihvYmouZXZlbnQsIG9iai5kZWxlZ2F0ZSwgb2JqLmhhbmRsZXIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy4kZWwub2ZmKG9iai5ldmVudCwgb2JqLmhhbmRsZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBWZWFtc0NvbXBvbmVudDsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltcGxlIGV4dGVuZCBtZXRob2QsIHdoaWNoIGV4dGVuZHMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBvYmplY3Qgd2hpY2ggd2lsbCBiZSBleHRlbmRlZFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gb2JqIC0gZXh0ZW5kZWQgb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlZmF1bHRzSGVscGVyKG9iaikge1xuXHRcdFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKS5mb3JFYWNoKChpdGVtKSA9PiB7XG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gaXRlbSkge1xuXHRcdFx0XHRpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkgb2JqW2tleV0gPSBpdGVtW2tleV07XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIG9iajtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbXBsZSBleHRlbmQgbWV0aG9kIHRvIGV4dGVuZCB0aGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIG9iamVjdCB3aGljaCB3aWxsIGJlIGV4dGVuZGVkXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBvYmogLSBleHRlbmRlZCBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuXHRbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuXHRcdGZvciAobGV0IGtleSBpbiBpdGVtKSBvYmpba2V5XSA9IGl0ZW1ba2V5XTtcblx0fSk7XG5cdHJldHVybiBvYmo7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiBlbGVtZW50IGlzIGluIHZpZXdwb3J0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW0gLSBPYmplY3QsIHdoaWNoIHdlIHdhbnQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQm91bmRzIC0gaWYgdHJ1ZSwgd2hvbGUgZWxlbWVudCBtdXN0IGJlIHZpc2libGVcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0luVmlld3BvcnQoZWxlbSwgdXNlQm91bmRzKSB7XG5cdGxldCBlbCA9IGVsZW07XG5cdGxldCB0b3AgPSBlbC5vZmZzZXRUb3A7XG5cdGxldCBsZWZ0ID0gZWwub2Zmc2V0TGVmdDtcblx0bGV0IHdpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG5cdGxldCBoZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG5cdGxldCBjb25kID0gZmFsc2U7XG5cblx0d2hpbGUgKGVsLm9mZnNldFBhcmVudCkge1xuXHRcdGVsID0gZWwub2Zmc2V0UGFyZW50O1xuXHRcdHRvcCArPSBlbC5vZmZzZXRUb3A7XG5cdFx0bGVmdCArPSBlbC5vZmZzZXRMZWZ0O1xuXHR9XG5cblx0aWYgKHVzZUJvdW5kcykge1xuXHRcdGNvbmQgPSB0b3AgPj0gd2luZG93LnBhZ2VZT2Zmc2V0ICYmIGxlZnQgPj0gd2luZG93LnBhZ2VYT2Zmc2V0ICYmICh0b3AgKyBoZWlnaHQpIDw9ICh3aW5kb3cucGFnZVlPZmZzZXQgKyB3aW5kb3cuaW5uZXJIZWlnaHQpICYmIChsZWZ0ICsgd2lkdGgpIDw9ICh3aW5kb3cucGFnZVhPZmZzZXQgKyB3aW5kb3cuaW5uZXJXaWR0aCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uZCA9IHRvcCA8ICh3aW5kb3cucGFnZVlPZmZzZXQgKyB3aW5kb3cuaW5uZXJIZWlnaHQpICYmIGxlZnQgPCAod2luZG93LnBhZ2VYT2Zmc2V0ICsgd2luZG93LmlubmVyV2lkdGgpICYmICh0b3AgKyBoZWlnaHQpID4gd2luZG93LnBhZ2VZT2Zmc2V0ICYmIChsZWZ0ICsgd2lkdGgpID4gd2luZG93LnBhZ2VYT2Zmc2V0O1xuXHR9XG5cblx0cmV0dXJuIGNvbmQ7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZW5lcmF0ZXMgbnVtZXJpYyBpZC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW3NlZ21lbnRzPTFdIC0gbnVtYmVyIG9mIHNlZ21lbnRzIG9mIGdlbmVyYXRlZCBpZCAoc2VnbWVudHMgY29uc2lzdCBvZiAxMCBkaWdpdHMsIHNlcGFyYXRlZCBieSAnLScpLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gLSBnZW5lcmF0ZWQgaWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWFrZUlkKHNlZ21lbnRzID0gMSkge1xuXHRsZXQgY3J5cHRvID0gd2luZG93LmNyeXB0byB8fCB3aW5kb3cubXNDcnlwdG87XG5cdGxldCBhcnJheSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KHNlZ21lbnRzKSk7XG5cdGxldCBpZCA9ICcnO1xuXHRsZXQgaSA9IDA7XG5cblx0Zm9yICg7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdGlkICs9IGFycmF5W2ldICsgJy0nO1xuXHR9XG5cblx0cmV0dXJuIGlkLnNsaWNlKDAsIC0xKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gZXh0ZW5kIGFuIGFscmVhZHkgZXhpc3RpbmcgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0byAtIHZpZXcgd2hpY2ggd2lsbCBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGZyb20gLSBtZXRob2RzIHdoaWNoIGNvbWVzIGZyb20gbWl4aW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIC0gZnVuY3Rpb24gbmFtZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXRob2RFeHRlbmQodG8sIGZyb20sIG1ldGhvZE5hbWUpIHtcblx0ZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcblx0fVxuXG5cdGlmIChmcm9tID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuXHQvLyBpZiB0aGUgbWV0aG9kIGlzIGRlZmluZWQgb24gZnJvbSAuLi5cblx0aWYgKCFpc1VuZGVmaW5lZChmcm9tW21ldGhvZE5hbWVdKSkge1xuXHRcdGxldCBvbGQgPSB0b1ttZXRob2ROYW1lXTtcblxuXHRcdC8vIC4uLiB3ZSBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb24gdG9cblx0XHR0b1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gd2hlcmVpbiB3ZSBmaXJzdCBjYWxsIHRoZSBtZXRob2Qgd2hpY2ggZXhpc3RzIG9uIGB0b2Bcblx0XHRcdGxldCBvbGRSZXR1cm4gPSBvbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdFx0Ly8gYW5kIHRoZW4gY2FsbCB0aGUgbWV0aG9kIG9uIGBmcm9tYFxuXHRcdFx0ZnJvbVttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0XHQvLyBhbmQgdGhlbiByZXR1cm4gdGhlIGV4cGVjdGVkIHJlc3VsdCxcblx0XHRcdC8vIGkuZS4gd2hhdCB0aGUgbWV0aG9kIG9uIGB0b2AgcmV0dXJuc1xuXHRcdFx0cmV0dXJuIG9sZFJldHVybjtcblx0XHR9O1xuXHR9XG59OyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGRlZmF1bHRzSGVscGVyIGZyb20gJy4vZGVmYXVsdHMnO1xuaW1wb3J0IG1ldGhvZEV4dGVuZEhlbHBlciBmcm9tICcuL21ldGhvZC1leHRlbmQnO1xuXG4vKipcbiAqIE1lcmdlIG1ldGhvZCBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZyb20gLSBNaXhpbiBvYmplY3Qgd2hpY2ggd2lsbCBiZSBtZXJnZWQgdmlhIEhlbHBlcnMuZGVmYXVsdHMgd2l0aCB0aGUgbWV0aG9kcyBvZiBvdXIgY2xhc3NcbiAqIEBwYXJhbSB7QXJyYXl9IG1ldGhvZHMgLSBBcnJheSBvZiBtZXRob2QgbmFtZXMgd2hpY2ggd2lsbCBiZSBleHRlbmRlZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWl4aW4oZnJvbSwgbWV0aG9kcyA9IFsnaW5pdGlhbGl6ZScsICdyZW5kZXInXSkge1xuXHRpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y29uc29sZS5lcnJvcihgVmVhbXNIZWxwZXJzIDogTWl4aW4gOjogTWl4aW4gbm90IGZvdW5kIWApO1xuXG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0bGV0IHRvID0gdGhpcy5wcm90b3R5cGU7XG5cblx0LyoqIEFkZCB0aG9zZSBtZXRob2RzIHdoaWNoIGV4aXN0cyBvbiBgZnJvbWAgYnV0IG5vdCBvbiBgdG9gIHRvIHRoZSBsYXR0ZXIgKi9cblx0ZGVmYXVsdHNIZWxwZXIodG8sIGZyb20pO1xuXG5cdC8qKiB3ZSBkbyB0aGUgc2FtZSBmb3IgZXZlbnRzICovXG5cdGlmICh0by5ldmVudHMpIHtcblx0XHRkZWZhdWx0c0hlbHBlcih0by5ldmVudHMsIGZyb20uZXZlbnRzKTtcblx0fVxuXG5cdC8vIEV4dGVuZCB0bydzIG1ldGhvZHNcblx0bWV0aG9kcy5mb3JFYWNoKChtZXRob2QpID0+IHtcblx0XHRtZXRob2RFeHRlbmRIZWxwZXIodG8sIGZyb20sIG1ldGhvZCk7XG5cdH0pO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZWN0IHRyYW5zaXRpb25lbmQgZXZlbnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zaXRpb25FbmRFdmVudCgpIHtcblx0bGV0IHQ7XG5cdGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zha2VlbGVtZW50Jyk7XG5cdGxldCB0cmFuc2l0aW9ucyA9IHtcblx0XHQndHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcblx0XHQnT1RyYW5zaXRpb24nOiAnb1RyYW5zaXRpb25FbmQnLFxuXHRcdCdNb3pUcmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxuXHRcdCdXZWJraXRUcmFuc2l0aW9uJzogJ3dlYmtpdFRyYW5zaXRpb25FbmQnXG5cdH07XG5cblx0Zm9yICh0IGluIHRyYW5zaXRpb25zKSB7XG5cdFx0aWYgKGVsLnN0eWxlW3RdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0cmFuc2l0aW9uc1t0XTtcblx0XHR9XG5cdH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldCB2YWx1ZSBvdXQgb2YgdmFyaWFibGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBTdHJpbmcgd2hpY2ggaXMgYSByZWZlcmVuY2UgdG8gYSB2YXIuXG4gKlxuICogQHJldHVybiBTdHJpbmdcbiAqL1xuY29uc3QgZ2V0U3RyaW5nVmFsdWUgPSBmdW5jdGlvbiBnZXRTdHJpbmdWYWx1ZShzdHIsIGluc3RhbmNlT2JqZWN0KSB7XG5cdGlmIChzdHIuaW5kZXhPZignLicpID09PSAtMSkgcmV0dXJuIHN0cjtcblx0bGV0IGFyciA9IHN0ci5zcGxpdCgnLicpO1xuXHRsZXQgY29udGV4dCA9IGFyclswXTtcblx0bGV0IGZpbmFsU3RyID0gY29udGV4dCA9PT0gJ3RoaXMnID8gdGhpcyA6IGluc3RhbmNlT2JqZWN0ID8gaW5zdGFuY2VPYmplY3QgOiB3aW5kb3dbY29udGV4dF07XG5cblx0bGV0IHN0clJlcGxhY2VyID0gKGVsLCBwcmV2KSA9PiB7XG5cdFx0cmV0dXJuIHByZXZbZWxdO1xuXHR9O1xuXG5cdGFyci5zaGlmdCgpO1xuXHRhcnIuZm9yRWFjaCgoaXRlbSkgPT4ge1xuXHRcdGZpbmFsU3RyID0gc3RyUmVwbGFjZXIoaXRlbSwgZmluYWxTdHIpO1xuXHRcdHJldHVybiBmaW5hbFN0cjtcblx0fSk7XG5cblx0aWYgKHR5cGVvZiBmaW5hbFN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXN1bHRpbmcgdmFyaWFibGUgb3V0IG9mIHlvdXIgZXZlbnRzIG9iamVjdCBtdXN0IGJlIGEgc3RyaW5nIScpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBmaW5hbFN0cjtcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0U3RyaW5nVmFsdWU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzdHJpbmdIZWxwZXJzID0ge307XG5cbi8qKlxuICogQ2FtZWxDYXNlIHN0cmluZ3MgYnkgcmVwbGFjaW5nIGh5cGhlbnMsIHdoaXRlIHNwYWNlIGFuZCBwb2ludHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFN0cmluZyB3aGljaCB3aWxsIGJlIGNhbWVsY2FzZWRcbiAqL1xuc3RyaW5nSGVscGVycy50b0NhbWVsQ2FzZSA9IGZ1bmN0aW9uIChzdHIpIHtcblx0Ly8gTG93ZXIgY2FzZXMgdGhlIHN0cmluZ1xuXHRyZXR1cm4gc3RyLnRvTG93ZXJDYXNlKClcblx0Ly8gUmVwbGFjZXMgYW55IC0gb3IgXyBjaGFyYWN0ZXJzIHdpdGggYSBzcGFjZVxuXHRcdC5yZXBsYWNlKC9bLV9dKy9nLCAnICcpXG5cdFx0Ly8gUmVtb3ZlcyBhbnkgbm9uIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXG5cdFx0LnJlcGxhY2UoL1teXFx3XFxzXS9nLCAnJylcblx0XHQvLyBVcHBlcmNhc2VzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gZWFjaCBncm91cCBpbW1lZGlhdGVseSBmb2xsb3dpbmcgYSBzcGFjZVxuXHRcdC8vIChkZWxpbWl0ZWQgYnkgc3BhY2VzKVxuXHRcdC5yZXBsYWNlKC8gKC4pL2csIGZ1bmN0aW9uICgkMSkge1xuXHRcdFx0cmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSlcblx0XHQvLyBSZW1vdmVzIHNwYWNlc1xuXHRcdC5yZXBsYWNlKC8gL2csICcnKTtcbn07XG5cbi8qKlxuICogU3RyaW5nIHdoaWNoIHdpbGwgYmUgaHlwaGVuYXRlZCBieSByZXBsYWNpbmcgd2hpdGUgc3BhY2UgYW5kIGxvd2VyIGNhc2UgdGhlIGNoYXJhY3RlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gU3RyaW5nXG4gKi9cbnN0cmluZ0hlbHBlcnMuaHlwaGVuYXRlID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gc3RyLnJlcGxhY2UoL1xccy9nLCAnLScpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG4vKipcbiAqIFN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBTdHJpbmcgd2hlcmUgZmlyc3QgY2hhciBpcyB1cHBlciBjYXNlZFxuICovXG5zdHJpbmdIZWxwZXJzLmNhcGl0YWxpemVGaXJzdExldHRlciA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ0hlbHBlcnM7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbXBsZSB0ZW1wbGF0ZSBlbmdpbmUgZm9yIGV2ZW50IHN5c3RlbS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHBsU3RyIC0gVGVtcGxhdGUgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gU3RyaW5nXG4gKi9cbmNvbnN0IHRlbXBsYXRlRW5naW5lID0gZnVuY3Rpb24gdGVtcGxhdGVFbmdpbmUodHBsU3RyKSB7XG5cdGxldCByZWcgPSBuZXcgUmVnRXhwKCcoXFx7XFx7XFxzPykoLispKFxccz9cXH1cXH0pJyk7XG5cdGxldCBtYXRjaCA9IHJlZy5leGVjKHRwbFN0cik7XG5cdGxldCByZXR1cm5WYWwgPSAnJztcblxuXHRpZiAobWF0Y2gpIHtcblx0XHRyZXR1cm5WYWwgPSBtYXRjaFsyXTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm5WYWwgPSB0cGxTdHI7XG5cdH1cblxuXHRyZXR1cm4gcmV0dXJuVmFsO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGVFbmdpbmU7IiwiLyoqXG4gKiBDb25zdCBmb3IgZXZlbnRzIChwdWIvc3ViKVxuICpcbiAqIEBhdXRob3I6IFNlYmFzdGlhbiBGaXR6bmVyXG4gKi9cblxuLyoqXG4gKiBFdmVudHMgR2xvYmFsXG4gKi9cblxuY29uc3QgRVZFTlRTID0ge307XG5cblxuXG4vKipcbiAqIEV2ZW50cyBmb3IgU2xpZGVyXG4gKi9cbkVWRU5UUy5zbGlkZXIgPSB7XG5cdHNsaWRlU3RhcnQ6ICdzbGlkZTpzdGFydCdcbn07XG5cblxuLyoqXG4gKiBFdmVudHMgQWNjb3JkaW9uXG4gKi9cbkVWRU5UUy5hY2NvcmRpb24gPSB7XG5cdG9wZW5BbGw6ICdhY2NvcmRpb246b3BlbkFsbCcsXG5cdGNsb3NlQWxsOiAnYWNjb3JkaW9uOmNsb3NlQWxsJ1xufTtcblxuXG4vKipcbiAqIEV2ZW50cyBmb3IgVG9nZ2xlclxuICovXG5FVkVOVFMudG9nZ2xlciA9IHtcblx0ZXZlbnROYW1lOiAndG9nZ2xlcjpldmVudE5hbWUnXG59O1xuXG5cbi8qKlxuICogRXZlbnRzIEZvcm1cbiAqL1xuRVZFTlRTLmZvcm0gPSB7XG5cdGNvbXBsZXRlOiAnZm9ybTpjb21wbGV0ZScsXG5cdHJlc2V0OiAnZm9ybTpyZXNldCdcbn07XG5cblxuLyoqXG4gKiBFdmVudHMgT3ZlcmxheVxuICovXG5FVkVOVFMub3ZlcmxheSA9IHtcblx0b3BlbjogJ292ZXJsYXk6b3Blbidcbn07XG5cbi8vIEBJTlNFUlRQT0lOVCA6OiBAcmVmOiBqcy1ldmVudHNcblxuZXhwb3J0IGRlZmF1bHQgRVZFTlRTOyIsIi8vIEdsb2JhbCBkZXBlbmRlbmNpZXNcbmltcG9ydCB7QXBwLCBWZWFtc30gZnJvbSAnLi9hcHAnO1xuXG5jb25zb2xlLmxvZygnSlMgaW5pdGlhbGl6ZWQgaW4gdmVyc2lvbjonLCBBcHAudmVyc2lvbik7XG5jb25zb2xlLmxvZygnVmVhbXMgaW5pdGlhbGl6ZWQgaW4gdmVyc2lvbjonLCBWZWFtcy5iYXNlLnZlcnNpb24pO1xuXG4vLyBJbXBvcnRzXG5cbmltcG9ydCBTbGlkZXIgZnJvbSAnLi4vdGVtcGxhdGluZy9wYXJ0aWFscy9jb21wb25lbnRzL3NsaWRlci9qcy9zbGlkZXInO1xuaW1wb3J0IEFjY29yZGlvbiBmcm9tICcuLi90ZW1wbGF0aW5nL3BhcnRpYWxzL2NvbXBvbmVudHMvYWNjb3JkaW9uL2pzL2FjY29yZGlvbic7XG5cbmltcG9ydCBUb2dnbGVyIGZyb20gJy4uL3RlbXBsYXRpbmcvcGFydGlhbHMvY29tcG9uZW50cy90b2dnbGVyL2pzL3RvZ2dsZXInO1xuXG5cbmltcG9ydCBDVEEgZnJvbSAnLi4vdGVtcGxhdGluZy9wYXJ0aWFscy9jb21wb25lbnRzL2N0YS9qcy9jdGEnO1xuXG5cbmltcG9ydCBGb3JtQWpheCBmcm9tICcuLi90ZW1wbGF0aW5nL3BhcnRpYWxzL2NvbXBvbmVudHMvZm9ybS9qcy9mb3JtLWFqYXgnO1xuaW1wb3J0IEZvcm1EYXRlcGlja2VyIGZyb20gJy4uL3RlbXBsYXRpbmcvcGFydGlhbHMvY29tcG9uZW50cy9mb3JtL2pzL2Zvcm0tZGF0ZXBpY2tlcic7XG5cblxuaW1wb3J0IENvbXBhcmVyIGZyb20gJy4uL3RlbXBsYXRpbmcvcGFydGlhbHMvY29tcG9uZW50cy9jb21wYXJlci9qcy9jb21wYXJlcic7XG5cblxuaW1wb3J0IE92ZXJsYXkgZnJvbSAnLi4vdGVtcGxhdGluZy9wYXJ0aWFscy9jb21wb25lbnRzL292ZXJsYXkvanMvb3ZlcmxheSc7XG5cblxuaW1wb3J0IFNsaWRlRm94IGZyb20gJy4uL3RlbXBsYXRpbmcvcGFydGlhbHMvY29tcG9uZW50cy9zbGlkZS1mb3gvanMvc2xpZGUtZm94JztcblxuLy8gQElOU0VSVFBPSU5UIDo6IEByZWY6IGpzLXNlbGYtY29udGFpbmVkLWltcG9ydCwgQGtlZXA6IHRydWUgLy9cblxuLy8gSW5pdGlhbGl6ZSBtb2R1bGVzIHdpdGggVmVhbXNcblZlYW1zLm1vZHVsZXMucmVnaXN0ZXIoW1xuICAgIC8qKlxuICAgICAqIEluaXQgU2xpZGVyXG4gICAgICovXG4gICAge1xuICAgICAgICBuYW1lc3BhY2U6ICdzbGlkZXInLFxuICAgICAgICBtb2R1bGU6IFNsaWRlclxuICAgIH0sXG4gXHQvLyBJbml0IEFjY29yZGlvblxuIFx0e1xuIFx0XHRuYW1lc3BhY2U6ICdhY2NvcmRpb24nLFxuIFx0XHRtb2R1bGU6IEFjY29yZGlvblxuIFx0fSxcblx0Ly8gSW5pdCBUb2dnbGVyIC8vXG5cdHtcblx0XHRkb21OYW1lOiAndG9nZ2xlcicsXG5cdFx0bW9kdWxlOiBUb2dnbGVyLFxuXHR9LFxuIFx0Ly8gSW5pdCBDYWxsLVRvLUFjdGlvblxuIFx0e1xuIFx0XHRuYW1lc3BhY2U6ICdjdGEnLFxuIFx0XHRtb2R1bGU6IENUQVxuIFx0fVxuICAgICxcbiAgICAvKipcbiAgICAgKiBJbml0IEFKQVggRm9ybVxuICAgICAqL1xuICAgIHtcbiAgICAgICAgbmFtZXNwYWNlOiAnZm9ybS1hamF4JyxcbiAgICAgICAgbW9kdWxlOiBGb3JtQWpheFxuICAgIH1cbiAgICAsXG4gICAgLyoqXG4gICAgICogSW5pdCBGb3JtIERhdGVwaWNrZXJcbiAgICAgKi9cbiAgICB7XG5cdCAgICBuYW1lc3BhY2U6ICdmb3JtLWRhdGVwaWNrZXInLFxuXHQgICAgbW9kdWxlOiBGb3JtRGF0ZXBpY2tlclxuICAgIH1cblxuIFx0LFxuIFx0Ly8gSW5pdCBDb21wYXJlclxuIFx0e1xuIFx0XHRuYW1lc3BhY2U6ICdjb21wYXJlcicsXG4gXHRcdG1vZHVsZTogQ29tcGFyZXJcbiBcdH1cblxuXG5cblxuICAgICxcbiAgICAvKipcbiAgICAgKiBJbml0IFNsaWRlRm94XG4gICAgICovXG4gICAge1xuICAgICAgICBuYW1lc3BhY2U6ICdzbGlkZS1mb3gnLFxuICAgICAgICBtb2R1bGU6IFNsaWRlRm94XG4gICAgfVxuXG4gICAgLy8gQElOU0VSVFBPSU5UIDo6IEByZWY6IGpzLWluaXQtdjUsIEBrZWVwOiB0cnVlIC8vXG5dKTtcblxuXG5cbi8qKlxuICogSW5pdCBPdmVybGF5XG4gKi9cbm5ldyBPdmVybGF5KHtcbiAgICBhcHBJbnN0YW5jZTogVmVhbXNcbn0pO1xuXG4vLyBASU5TRVJUUE9JTlQgOjogQHJlZjoganMtaW5pdC1vbmNlLXY1LCBAa2VlcDogdHJ1ZSAvL1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihIYW5kbGViYXJzKSB7XG5cbndpbmRvd1tcIkFwcFwiXSA9IHdpbmRvd1tcIkFwcFwiXSB8fCB7fTtcbndpbmRvd1tcIkFwcFwiXVtcIlRlbXBsYXRlc1wiXSA9IHdpbmRvd1tcIkFwcFwiXVtcIlRlbXBsYXRlc1wiXSB8fCB7fTtcblxud2luZG93W1wiQXBwXCJdW1wiVGVtcGxhdGVzXCJdW1wiT1ZFUkxBWVwiXSA9IEhhbmRsZWJhcnMudGVtcGxhdGUoe1wiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwiYy1vdmVybGF5LS1kZWZhdWx0XFxcIiBkYXRhLWNzcz1cXFwiYy1vdmVybGF5XFxcIiBkYXRhLWpzLWl0ZW09XFxcIm92ZXJsYXlcXFwiPlxcblx0PGRpdiBjbGFzcz1cXFwib3ZlcmxheV9fd3JhcHBlclxcXCI+XFxuXHRcdDxidXR0b24gY2xhc3M9XFxcIm92ZXJsYXlfX2Nsb3NlXFxcIiBkYXRhLWpzLWl0ZW09XFxcIm92ZXJsYXktY2xvc2VcXFwiPjwvYnV0dG9uPlxcblx0XHQ8ZGl2IGNsYXNzPVxcXCJvdmVybGF5X19jb250ZW50XFxcIj5cXG5cdFx0XHQ8ZGl2IGNsYXNzPVxcXCJvdmVybGF5X19pbm5lclxcXCIgZGF0YS1qcy1pdGVtPVxcXCJvdmVybGF5LWNvbnRlbnRcXFwiPlxcblxcblx0XHRcdDwvZGl2Plxcblx0XHQ8L2Rpdj5cXG5cdDwvZGl2Plxcblx0PGRpdiBjbGFzcz1cXFwib3ZlcmxheV9fbWFza1xcXCIgZGF0YS1qcy1pdGVtPVxcXCJvdmVybGF5LW1hc2tcXFwiPjwvZGl2PlxcbjwvZGl2PlwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG5cbnJldHVybiB3aW5kb3dbXCJBcHBcIl1bXCJUZW1wbGF0ZXNcIl07XG5cbn07IiwiLyoqXG4gKiBSZXByZXNlbnRzIGEgc2ltcGxlIGFjY29yZGlvbiB3aXRoIHRyYW5zaXRpb25zIGFuZCBtYXgtaGVpZ2h0LlxuICpcbiAqIEBtb2R1bGUgQWNjb3JkaW9uXG4gKiBAdmVyc2lvbiB2My4wLjJcbiAqXG4gKiBAYXV0aG9yIFNlYmFzdGlhbiBGaXR6bmVyXG4gKiBAYXV0aG9yIEFuZHkgR3V0c2NoZVxuICovXG5cbi8qKlxuICogUmVxdWlyZW1lbnRzXG4gKi9cbmltcG9ydCB7IFZlYW1zIH0gZnJvbSAnYXBwJztcbmltcG9ydCBWZWFtc0NvbXBvbmVudCBmcm9tICd2ZWFtcy9zcmMvanMvY29tbW9uL2NvbXBvbmVudCc7XG5cbmNvbnN0ICQgPSBWZWFtcy4kO1xuY29uc3QgSGVscGVycyA9IFZlYW1zLmhlbHBlcnM7XG5cbi8qKlxuICogQ2xhc3MgQWNjb3JkaW9uXG4gKi9cbmNsYXNzIEFjY29yZGlvbiBleHRlbmRzIFZlYW1zQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3Iob2JqKSB7XG5cdFx0bGV0IG9wdGlvbnMgPSB7XG5cdFx0XHRhY3RpdmVDbGFzczogJ2lzLWFjdGl2ZScsXG5cdFx0XHRhY2NvcmRpb25CdG46ICdbZGF0YS1qcy1pdGVtPVwiYWNjb3JkaW9uLWJ0blwiXScsXG5cdFx0XHRhY2NvcmRpb25Db250ZW50OiAnW2RhdGEtanMtaXRlbT1cImFjY29yZGlvbi1jb250ZW50XCJdJyxcblx0XHRcdGNhbGN1bGF0aW5nQ2xhc3M6ICdpcy1jYWxjdWxhdGluZycsXG5cdFx0XHRjbGlja0hhbmRsZXI6ICdjbGljaycsXG5cdFx0XHRjbG9zZUNsYXNzOiAnaXMtY2xvc2VkJyxcblx0XHRcdGRhdGFNYXhBdHRyOiAnZGF0YS1qcy1oZWlnaHQnLFxuXHRcdFx0b3BlbkFsbE9uSW5pdDogZmFsc2UsXG5cdFx0XHRvcGVuQnlIYXNoOiBmYWxzZSxcblx0XHRcdG9wZW5DbGFzczogJ2lzLW9wZW4nLFxuXHRcdFx0b3BlbkluZGV4OiBudWxsLFxuXHRcdFx0b3Blbk9uVmlld3BvcnRzOiBbXG5cdFx0XHRcdCd0YWJsZXQtc21hbGwnLFxuXHRcdFx0XHQndGFibGV0LWxhcmdlJyxcblx0XHRcdFx0J2Rlc2t0b3AnXG5cdFx0XHRdLCAvLyBhcnJheTogdmlld3BvcnQgbmFtZXMgLSBlZy46IFsnbW9iaWxlJywgJ3RhYmxldCcsICdkZXNrdG9wLXNtYWxsJywgJ2Rlc2t0b3AnXVxuXHRcdFx0cmVtb3ZlU3R5bGVzOiBmYWxzZSwgLy8gVE9ET1xuXHRcdFx0c2luZ2xlT3BlbjogZmFsc2UsXG5cdFx0XHR0YWJNb2RlOiBmYWxzZSxcblx0XHRcdHVucmVzb2x2ZWRDbGFzczogJ2lzLXVucmVzb2x2ZWQnXG5cdFx0fTtcblxuXHRcdHN1cGVyKG9iaiwgb3B0aW9ucyk7XG5cdH1cblxuXHQvKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBHRVRURVIgJiBTRVRURVJcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblx0LyoqXG5cdCAqIEdldCBtb2R1bGUgaW5mb3JtYXRpb25cblx0ICovXG5cdHN0YXRpYyBnZXQgaW5mbygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogJ0FjY29yZGlvbicsXG5cdFx0XHR2ZXJzaW9uOiAnMy4wLjInLFxuXHRcdFx0dmM6IHRydWUsXG5cdFx0XHRtb2Q6IGZhbHNlIC8vIHNldCB0byB0cnVlIGlmIHNvdXJjZSB3YXMgbW9kaWZpZWQgaW4gcHJvamVjdFxuXHRcdH07XG5cdH1cblxuXHRzZXQgJGFjY29yZGlvbkNvbnRlbnRzKGl0ZW1zKSB7XG5cdFx0dGhpcy5fJGFjY29yZGlvbkNvbnRlbnRzID0gaXRlbXM7XG5cdH1cblxuXHRnZXQgJGFjY29yZGlvbkNvbnRlbnRzKCkge1xuXHRcdHJldHVybiB0aGlzLl8kYWNjb3JkaW9uQ29udGVudHM7XG5cdH1cblxuXHRzZXQgJGFjY29yZGlvbkJ0bnMoaXRlbXMpIHtcblx0XHR0aGlzLl8kYWNjb3JkaW9uQnRucyA9IGl0ZW1zO1xuXHR9XG5cblx0Z2V0ICRhY2NvcmRpb25CdG5zKCkge1xuXHRcdHJldHVybiB0aGlzLl8kYWNjb3JkaW9uQnRucztcblx0fVxuXG5cdHNldCAkdGFyZ2V0KGl0ZW0pIHtcblx0XHR0aGlzLl8kdGFyZ2V0ID0gaXRlbTtcblx0fVxuXG5cdGdldCAkdGFyZ2V0KCkge1xuXHRcdHJldHVybiB0aGlzLl8kdGFyZ2V0O1xuXHR9XG5cblx0c2V0ICRidG4oaXRlbSkge1xuXHRcdHRoaXMuXyRidG4gPSBpdGVtO1xuXHR9XG5cblx0Z2V0ICRidG4oKSB7XG5cdFx0cmV0dXJuIHRoaXMuXyRidG47XG5cdH1cblxuXHQvKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBFVkVOVFNcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cdGdldCBldmVudHMoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdCd7e3RoaXMub3B0aW9ucy5jbGlja0hhbmRsZXJ9fSB7e3RoaXMub3B0aW9ucy5hY2NvcmRpb25CdG59fSc6ICdoYW5kbGVDbGljaydcblx0XHR9XG5cdH1cblxuXHRnZXQgc3Vic2NyaWJlKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHQne3tWZWFtcy5FVkVOVFMucmVzaXplfX0nOiAncmVuZGVyJyxcblx0XHRcdCd7e1ZlYW1zLkVWRU5UUy5hY2NvcmRpb24uY2xvc2VBbGx9fSc6ICdjbG9zZUFsbCcsXG5cdFx0XHQne3tWZWFtcy5FVkVOVFMuYWNjb3JkaW9uLm9wZW5BbGx9fSc6ICdvcGVuQWxsJ1xuXHRcdH1cblx0fVxuXG5cdC8qKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIFNUQU5EQVJEIE1FVEhPRFNcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cdC8qKlxuXHQgKiBJbml0IG1ldGhvZCB0byBzYXZlIGFsbCBuZWNlc3NhcnkgcmVmZXJlbmNlcy5cblx0ICovXG5cdGluaXRpYWxpemUoKSB7XG5cdFx0dGhpcy4kYWNjb3JkaW9uQ29udGVudHMgPSAkKHRoaXMub3B0aW9ucy5hY2NvcmRpb25Db250ZW50LCB0aGlzLiRlbCk7XG5cdFx0dGhpcy4kYWNjb3JkaW9uQnRucyA9ICQodGhpcy5vcHRpb25zLmFjY29yZGlvbkJ0biwgdGhpcy4kZWwpO1xuXHRcdHRoaXMuJHRhcmdldCA9IG51bGw7XG5cdFx0dGhpcy4kYnRuID0gbnVsbDtcblx0XHR0aGlzLm9wZW5JbmRleCA9IHRoaXMub3B0aW9ucy5vcGVuSW5kZXg7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm9wZW5CeUhhc2gpIHtcblx0XHRcdGxldCBpZHggPSB0aGlzLmdldEluZGV4QnlIYXNoKCk7XG5cblx0XHRcdHRoaXMub3BlbkluZGV4ID0gdHlwZW9mIGlkeCA9PT0gJ251bWJlcicgPyBpZHggOiB0aGlzLm9wdGlvbnMub3BlbkluZGV4O1xuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLm9wdGlvbnMudGFiTW9kZSAmJiAhdGhpcy5vcHRpb25zLm9wZW5JbmRleCkge1xuXHRcdFx0dGhpcy5vcGVuSW5kZXggPSAwO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kIGFsbCBldmVudHNcblx0ICovXG5cdGJpbmRFdmVudHMoKSB7XG5cdFx0bGV0IGZuT25IYXNoQ2hhbmdlID0gdGhpcy5vbkhhc2hDaGFuZ2UuYmluZCh0aGlzKTtcblxuXHRcdC8vIEdsb2JhbCBldmVudHNcblx0XHRpZiAodGhpcy5vcHRpb25zLm9wZW5CeUhhc2gpIHtcblx0XHRcdCQod2luZG93KS5vbihWZWFtcy5FVkVOVFMuaGFzaGNoYW5nZSwgZm5Pbkhhc2hDaGFuZ2UpO1xuXHRcdH1cblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRpZiAoIVZlYW1zLmN1cnJlbnRNZWRpYSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdBY2NvcmRpb246IFZlYW1zLmN1cnJlbnRNZWRpYSBpcyBuZWNlc3NhcnkgdG8gc3VwcG9ydCB0aGUgc2xpZGVyIG1vZHVsZSEnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnJlbW92ZVN0eWxlcygpO1xuXHRcdHRoaXMuc2F2ZUhlaWdodHModGhpcy4kYWNjb3JkaW9uQ29udGVudHMpO1xuXHRcdHRoaXMuY2xvc2VBbGwoKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMub3BlbkFsbE9uSW5pdCkge1xuXHRcdFx0dGhpcy5vcGVuQWxsKCk7XG5cdFx0fVxuXG5cdFx0Ly8gT3BlbiBvbiBpbmRleCBpZiBzZXQgaW4gb3B0aW9uc1xuXHRcdGlmICh0eXBlb2YgdGhpcy5vcGVuSW5kZXggPT09ICdudW1iZXInKSB7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnRhYk1vZGUgfHwgdGhpcy5vcHRpb25zLm9wZW5PblZpZXdwb3J0cy5pbmRleE9mKFZlYW1zLmN1cnJlbnRNZWRpYSkgIT09IC0xKSB7XG5cdFx0XHRcdHRoaXMuYWN0aXZhdGVCdG4odGhpcy4kYWNjb3JkaW9uQnRucy5lcSh0aGlzLm9wZW5JbmRleCkpO1xuXHRcdFx0XHR0aGlzLnNsaWRlRG93bih0aGlzLiRhY2NvcmRpb25Db250ZW50cy5lcSh0aGlzLm9wZW5JbmRleCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLiRlbC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMudW5yZXNvbHZlZENsYXNzKSkge1xuXHRcdFx0dGhpcy4kZWwucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnVucmVzb2x2ZWRDbGFzcyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogQ1VTVE9NIEFDQ09SRElPTiBNRVRIT0RTXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXHQvKipcblx0ICogR2V0IGluZGV4IG9mIGFjY29yZGlvbiBjb250ZW50IHJlZmVyZW5jZWQgYnkgaGFzaFxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ8Ym9vbGVhbn0gLSBpbmRleCBvZiBlbGVtZW50IG9yIGZhbHNlIGlmIG5vIG1hdGNoXG5cdCAqL1xuXHRnZXRJbmRleEJ5SGFzaCgpIHtcblx0XHRsZXQgaGFzaCA9IGRvY3VtZW50LmxvY2F0aW9uLmhhc2guc3BsaXQoJyMnKTtcblx0XHRsZXQgcmV0VmFsID0gZmFsc2U7XG5cdFx0bGV0IGkgPSAwO1xuXG5cdFx0aWYgKGhhc2ggPCAyKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yIChpOyBpIDwgdGhpcy4kYWNjb3JkaW9uQ29udGVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLiRhY2NvcmRpb25Db250ZW50c1tpXS5pZCA9PT0gaGFzaFsxXSkge1xuXHRcdFx0XHRyZXRWYWwgPSBpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0VmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIE9wZW4gYWNjb3JkaW9uIGNvbnRlbnQgcmVmZXJlbmNlZCBieSBoYXNoXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBlIC0gZXZlbnQgb2JqZWN0XG5cdCAqL1xuXHRvbkhhc2hDaGFuZ2UoZSkge1xuXHRcdGxldCBpZHggPSB0aGlzLmdldEluZGV4QnlIYXNoKCk7XG5cblx0XHRpZiAodHlwZW9mIGlkeCA9PT0gJ251bWJlcicpIHtcblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zaW5nbGVPcGVuKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2VBbGwoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hY3RpdmF0ZUJ0bih0aGlzLiRhY2NvcmRpb25CdG5zLmVxKGlkeCkpO1xuXHRcdFx0dGhpcy5zbGlkZURvd24odGhpcy4kYWNjb3JkaW9uQ29udGVudHMuZXEoaWR4KSk7XG5cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2F2ZSBoZWlnaHRzIG9mIGFsbCBhY2NvcmRpb24gY29udGVudHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIC0gYXJyYXkgb2YgaXRlbXNcblx0ICovXG5cdHNhdmVIZWlnaHRzKGl0ZW1zKSB7XG5cdFx0SGVscGVycy5mb3JFYWNoKGl0ZW1zLCAoaWR4LCBpdGVtKSA9PiB7XG5cdFx0XHR0aGlzLnNhdmVIZWlnaHQoaXRlbSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogU2F2ZSB0aGUgaGVpZ2h0IG9mIHRoZSBub2RlIGl0ZW0uXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIC0gaXRlbSB0byBjYWxjdWxhdGUgdGhlIGhlaWdodFxuXHQgKi9cblx0c2F2ZUhlaWdodChpdGVtKSB7XG5cdFx0bGV0ICRlbCA9ICQoaXRlbSk7XG5cblx0XHQvLyB0aGUgZWwgaXMgaGlkZGVuIHNvOlxuXHRcdC8vIG1ha2luZyB0aGUgZWwgYmxvY2sgc28gd2UgY2FuIG1lYXN1cmUgaXRzIGhlaWdodCBidXQgc3RpbGwgYmUgaGlkZGVuXG5cdFx0JGVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jYWxjdWxhdGluZ0NsYXNzKTtcblxuXHRcdGxldCB3YW50ZWRIZWlnaHQgPSAkZWwub3V0ZXJIZWlnaHQoKTtcblxuXHRcdC8vIHJldmVydGluZyB0byB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0JGVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jYWxjdWxhdGluZ0NsYXNzKTtcblxuXHRcdC8vIHNhdmUgaGVpZ2h0IGluIGRhdGEgYXR0cmlidXRlXG5cdFx0JGVsLmF0dHIodGhpcy5vcHRpb25zLmRhdGFNYXhBdHRyLCB3YW50ZWRIZWlnaHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZSB0aGUgY2xpY2ssXG5cdCAqIGdldCB0aGUgaWQgb2YgdGhlIGNsaWNrZWQgYnV0dG9uIGFuZFxuXHQgKiBleGVjdXRlIHRoZSB0b2dnbGVDb250ZW50IG1ldGhvZC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGUgLSBldmVudCBvYmplY3Rcblx0ICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRUYXJnZXQgLSBUYXJnZXQgdG8gd2hpY2ggbGlzdGVuZXIgd2FzIGF0dGFjaGVkLlxuXHQgKi9cblx0aGFuZGxlQ2xpY2soZSwgY3VycmVudFRhcmdldCkge1xuXHRcdHRoaXMuJGJ0biA9IGN1cnJlbnRUYXJnZXQgPyAkKGN1cnJlbnRUYXJnZXQpIDogJChlLmN1cnJlbnRUYXJnZXQpO1xuXHRcdGxldCB0YXJnZXRJZCA9IHRoaXMuJGJ0bi5hdHRyKCdocmVmJyk7XG5cblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLnRhYk1vZGUgJiYgdGhpcy4kYnRuLmhhc0NsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnRvZ2dsZUNvbnRlbnQodGFyZ2V0SWQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRvZ2dsZSB0aGUgYWNjb3JkaW9uIGNvbnRlbnQgYnkgdXNpbmcgdGhlIGlkIG9mIHRoZSBhY2NvcmRpb24gYnV0dG9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBpZCBvZiB0aGUgdGFyZ2V0XG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdHRvZ2dsZUNvbnRlbnQoaWQpIHtcblx0XHR0aGlzLiR0YXJnZXQgPSB0aGlzLiRlbC5maW5kKGlkKTtcblxuXHRcdGlmICh0aGlzLiR0YXJnZXQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLm9wZW5DbGFzcykpIHtcblx0XHRcdHRoaXMuc2xpZGVVcCh0aGlzLiR0YXJnZXQpO1xuXHRcdFx0dGhpcy5kZWFjdGl2YXRlQnRuKHRoaXMuJGJ0bik7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zaW5nbGVPcGVuIHx8IHRoaXMub3B0aW9ucy50YWJNb2RlKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2VBbGwoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hY3RpdmF0ZUJ0bih0aGlzLiRidG4pO1xuXHRcdFx0dGhpcy5zbGlkZURvd24odGhpcy4kdGFyZ2V0KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTWltaWNzIHRoZSBzbGlkZVVwIGZ1bmN0aW9uYWxpdHkgb2YgalF1ZXJ5IGJ5IHVzaW5nIGhlaWdodCBhbmQgdHJhbnNpdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9ICRpdGVtIC0galF1ZXJ5IG9iamVjdCBvZiBpdGVtXG5cdCAqL1xuXHRzbGlkZVVwKCRpdGVtKSB7XG5cdFx0JGl0ZW1cblx0XHRcdC5jc3MoJ2hlaWdodCcsIDApXG5cdFx0XHQucmVtb3ZlQXR0cignc3R5bGUnKVxuXHRcdFx0LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKVxuXHRcdFx0LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5vcGVuQ2xhc3MpXG5cdFx0XHQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNsb3NlQ2xhc3MpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1pbWljcyB0aGUgc2xpZGVEb3duIGZ1bmN0aW9uYWxpdHkgb2YgalF1ZXJ5IGJ5IHVzaW5nIGhlaWdodCBhbmQgdHJhbnNpdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9ICRpdGVtIC0galF1ZXJ5IG9iamVjdCBvZiBpdGVtXG5cdCAqL1xuXHRzbGlkZURvd24oJGl0ZW0pIHtcblx0XHQkaXRlbVxuXHRcdFx0LmNzcygnaGVpZ2h0JywgJGl0ZW0uYXR0cignZGF0YS1qcy1oZWlnaHQnKSArICdweCcpXG5cdFx0XHQuYXR0cignYXJpYS1leHBhbmRlZCcsICd0cnVlJylcblx0XHRcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuY2xvc2VDbGFzcylcblx0XHRcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMub3BlbkNsYXNzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFjdGl2ZSBjbGFzcyB0byB0aGUgY2xpY2tlZCBidXR0b24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSAkaXRlbSAtIGpRdWVyeSBvYmplY3Qgb2YgYnV0dG9uXG5cdCAqL1xuXHRhY3RpdmF0ZUJ0bigkaXRlbSkge1xuXHRcdCRpdGVtLmFkZENsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhY3RpdmUgY2xhc3MgZnJvbSB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gJGl0ZW0gLSBqUXVlcnkgb2JqZWN0IG9mIGJ1dHRvblxuXHQgKi9cblx0ZGVhY3RpdmF0ZUJ0bigkaXRlbSkge1xuXHRcdCRpdGVtLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlIGFsbCBzdHlsZXMgb2YgdGhlIGFjY29yZGlvbiBjb250ZW50IGVsZW1lbnRzXG5cdCAqL1xuXHRyZW1vdmVTdHlsZXMoKSB7XG5cdFx0dGhpcy4kYWNjb3JkaW9uQ29udGVudHMucmVtb3ZlQXR0cignc3R5bGUnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9zZSBhbGwgYWNjb3JkaW9uIGNvbnRlbnRzIGFuZCBhY3RpdmUgYnV0dG9uc1xuXHQgKlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRjbG9zZUFsbCgpIHtcblx0XHRIZWxwZXJzLmZvckVhY2godGhpcy4kYWNjb3JkaW9uQ29udGVudHMsIChpZHgsIGl0ZW0pID0+IHtcblx0XHRcdHRoaXMuc2xpZGVVcCgkKGl0ZW0pKTtcblx0XHR9KTtcblx0XHRIZWxwZXJzLmZvckVhY2godGhpcy4kYWNjb3JkaW9uQnRucywgKGlkeCwgaXRlbSkgPT4ge1xuXHRcdFx0dGhpcy5kZWFjdGl2YXRlQnRuKCQoaXRlbSkpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsb3NlIGFsbCBhY2NvcmRpb24gY29udGVudHMgYW5kIGFjdGl2ZSBidXR0b25zXG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdG9wZW5BbGwoKSB7XG5cdFx0SGVscGVycy5mb3JFYWNoKHRoaXMuJGFjY29yZGlvbkNvbnRlbnRzLCAoaWR4LCBpdGVtKSA9PiB7XG5cdFx0XHR0aGlzLnNsaWRlRG93bigkKGl0ZW0pKTtcblx0XHR9KTtcblx0XHRIZWxwZXJzLmZvckVhY2godGhpcy4kYWNjb3JkaW9uQnRucywgKGlkeCwgaXRlbSkgPT4ge1xuXHRcdFx0dGhpcy5hY3RpdmF0ZUJ0bigkKGl0ZW0pKTtcblx0XHR9KTtcblx0fVxufVxuXG4vLyBSZXR1cm5zIGNvbnN0cnVjdG9yXG5leHBvcnQgZGVmYXVsdCBBY2NvcmRpb247IiwiLyoqXG4gKiBEZXNjcmlwdGlvbiBvZiBDb250ZW50Q29tcGFyZXIuXG4gKlxuICogQG1vZHVsZSBDb250ZW50Q29tcGFyZXJcbiAqIEB2ZXJzaW9uIHYzLjAuMFxuICpcbiAqIEBhdXRob3Iga29lbi56aWd0ZXJtYW5cbiAqL1xuXG5pbXBvcnQgeyBWZWFtcyB9IGZyb20gJ2FwcCc7XG5pbXBvcnQgVmVhbXNDb21wb25lbnQgZnJvbSAndmVhbXMvc3JjL2pzL2NvbW1vbi9jb21wb25lbnQnO1xuXG5jb25zdCAkID0gVmVhbXMuJDtcblxuY2xhc3MgQ29tcGFyZXIgZXh0ZW5kcyBWZWFtc0NvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RvciBmb3Igb3VyIGNsYXNzXG5cdCAqXG5cdCAqIEBzZWUgbW9kdWxlLmpzXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBPYmplY3Qgd2hpY2ggaXMgcGFzc2VkIHRvIG91ciBjbGFzc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqLmVsIC0gZWxlbWVudCB3aGljaCB3aWxsIGJlIHNhdmVkIGluIHRoaXMuZWxcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iai5vcHRpb25zIC0gb3B0aW9ucyB3aGljaCB3aWxsIGJlIHBhc3NlZCBpbiBhcyBKU09OIG9iamVjdFxuXHQgKi9cblx0Y29uc3RydWN0b3Iob2JqKSB7XG5cdFx0bGV0IG9wdGlvbnMgPSB7XG5cdFx0XHRoYW5kbGU6ICdbZGF0YS1qcy1pdGVtPVwiY29tcGFyZXItaGFuZGxlXCJdJyxcblx0XHRcdHRvcENvbnRhaW5lcjogJ1tkYXRhLWpzLWl0ZW09XCJjb21wYXJlci10b3AtY29udGFpbmVyXCJdJyxcblx0XHRcdHRvcENvbnRlbnQ6ICdbZGF0YS1qcy1pdGVtPVwiY29tcGFyZXItdG9wLWNvbnRlbnRcIl0nLFxuXHRcdFx0ZHJhZ2dDbGFzczogJ2lzLWRyYWdnaW5nJyxcblx0XHRcdGRyYWdNb2RlOiB0cnVlLFxuXHRcdFx0dG9wQ29udGVudFJpZ2h0OiBmYWxzZSxcblx0XHRcdGRpc2FibGVkOiB7XG5cdFx0XHRcdCdkZXNrdG9wJzogZmFsc2UsXG5cdFx0XHRcdCd0YWJsZXQtbGFyZ2UnOiBmYWxzZSxcblx0XHRcdFx0J3RhYmxldC1zbWFsbCc6IGZhbHNlLFxuXHRcdFx0XHQnbW9iaWxlLWxhcmdlJzogZmFsc2UsXG5cdFx0XHRcdCdtb2JpbGUtbWVkaXVtJzogZmFsc2UsXG5cdFx0XHRcdCdtb2JpbGUtc21hbGwnOiBmYWxzZVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRzdXBlcihvYmosIG9wdGlvbnMpO1xuXHR9XG5cblx0LyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogR0VUVEVSICYgU0VUVEVSXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cdC8qKlxuXHQgKiBHZXQgbW9kdWxlIGluZm9ybWF0aW9uXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IGluZm8oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHZlcnNpb246ICczLjAuMCdcblx0XHR9O1xuXHR9XG5cblx0LyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogRVZFTlRTXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cdC8qKlxuXHQgKiBTdWJzY3JpYmUgdG8gZ2xvYmFsIGV2ZW50cyBvZiBWZWFtcyBvciBBcHAgbmFtZXNwYWNlLlxuXHQgKi9cblx0Z2V0IHN1YnNjcmliZSgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0J3t7VmVhbXMuRVZFTlRTLnJlc2l6ZX19JzogJ3ByZVJlbmRlcicsXG5cdFx0XHQne3tWZWFtcy5FVkVOVFMubWVkaWFjaGFuZ2V9fSc6ICdyZW5kZXInXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kIGxvY2FsIGV2ZW50cyB0byB0aGlzLiRlbC5cblx0ICovXG5cdGdldCBldmVudHMoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdCdtb3VzZWRvd24ge3t0aGlzLm9wdGlvbnMuaGFuZGxlfX0nOiAnbW91c2VEb3duJyxcblx0XHRcdCdtb3VzZXVwJzogJ21vdXNlVXAnLFxuXHRcdFx0J3RvdWNoc3RhcnQge3t0aGlzLm9wdGlvbnMuaGFuZGxlfX0nOiAnbW91c2VEb3duJyxcblx0XHRcdCd0b3VjaGVuZCc6ICdtb3VzZVVwJyxcblx0XHRcdCdtb3VzZW1vdmUnOiAncmVzaXplQ29udGFpbmVyJ1xuXHRcdH07XG5cdH1cblxuXHQvKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBTVEFOREFSRCBNRVRIT0RTXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgdmlldyBhbmQgbWVyZ2Ugb3B0aW9uc1xuXHQgKlxuXHQgKi9cblx0aW5pdGlhbGl6ZSgpIHtcblx0XHR0aGlzLiR0b3BDb250YWluZXIgPSAkKHRoaXMub3B0aW9ucy50b3BDb250YWluZXIsIHRoaXMuJGVsKTtcblx0XHR0aGlzLiR0b3BDb250ZW50ID0gJCh0aGlzLm9wdGlvbnMudG9wQ29udGVudCwgdGhpcy4kZWwpO1xuXHRcdHRoaXMuJGhhbmRsZSA9ICQodGhpcy5vcHRpb25zLmhhbmRsZSwgdGhpcy4kZWwpO1xuXHR9XG5cblxuXHQvKipcblx0ICogUHJlLVJlbmRlciBtZXRob2Rcblx0ICovXG5cdHByZVJlbmRlcigpe1xuXHRcdC8vIFJldHVybiBpZiBtb2R1bGUgaXMgZGlzYWJsZWRcblx0XHRpZih0aGlzLmRpc2FibGVkKSByZXR1cm47XG5cblx0XHR0aGlzLmVsV2lkdGggPSB0aGlzLmVsLmNsaWVudFdpZHRoO1xuXHRcdHRoaXMuJHRvcENvbnRlbnQuY3NzKCd3aWR0aCcsIHRoaXMuZWxXaWR0aCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVyIG1ldGhvZFxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmKHRoaXMub3B0aW9ucy5kaXNhYmxlZFtWZWFtcy5jdXJyZW50TWVkaWFdICYmICF0aGlzLmRpc2FibGVkKXtcblx0XHRcdHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5yZXNldFN0eWxlcygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmRpc2FibGVkID0gdGhpcy5vcHRpb25zLmRpc2FibGVkW1ZlYW1zLmN1cnJlbnRNZWRpYV07XG5cdFx0fVxuXG5cdH1cblxuXHQvKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBDVVNUT00gQ09NUEFSRVIgTUVUSE9EU1xuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblx0bW91c2VEb3duKGUpIHtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHR0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcblx0XHR0aGlzLiRoYW5kbGUuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmRyYWdnQ2xhc3MpO1xuXHR9XG5cblx0bW91c2VVcCgpIHtcblx0XHR0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cdFx0dGhpcy4kaGFuZGxlLmFkZENsYXNzKHRoaXMub3B0aW9ucy5kcmFnZ0NsYXNzKTtcblx0fVxuXHQvKipcblx0ICogUmVzaXplIHRvcCBjb250YWluZXJcblx0ICovXG5cdHJlc2l6ZUNvbnRhaW5lcihlKSB7XG5cdFx0Ly8gUmV0dXJuIGlmIG1vZHVsZSBpcyBkaXNhYmxlZCBvciBpZiBpdCBpcyBub3QgZHJhZ2dpbmcgd2hlbiBkcmFnZ2luZyBtb2RlIGlzIGVuYWJsZWRcblx0XHRpZih0aGlzLmRpc2FibGVkIHx8ICF0aGlzLmRyYWdnaW5nICYmIHRoaXMub3B0aW9ucy5kcmFnTW9kZSApIHJldHVybjtcblxuXHRcdGxldCBtb3VzZVBvcyA9IHRoaXMuZ2V0TW91c2VQb3MoZSk7XG5cdFx0bGV0IGNvbnRlbnRXaWR0aCA9IHRoaXMub3B0aW9ucy50b3BDb250ZW50UmlnaHQgPyB0aGlzLmVsV2lkdGggLSBtb3VzZVBvcyA6IDAgKyBtb3VzZVBvcztcblxuXHRcdHRoaXMuJHRvcENvbnRhaW5lci5jc3MoJ3dpZHRoJywgY29udGVudFdpZHRoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNldCBzdHlsZXNcblx0ICovXG5cdHJlc2V0U3R5bGVzKCl7XG5cdFx0dGhpcy4kdG9wQ29udGVudC5yZW1vdmVBdHRyKCdzdHlsZScpO1xuXHRcdHRoaXMuJHRvcENvbnRhaW5lci5yZW1vdmVBdHRyKCdzdHlsZScpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBtb3VzZSBwb3NpdGlvblxuXHQgKi9cblx0Z2V0TW91c2VQb3MoZSkge1xuXHRcdHJldHVybiAoZS5wYWdlWCAtIHRoaXMuJGVsLm9mZnNldCgpLmxlZnQpO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcGFyZXI7XG4iLCIvKipcbiAqIFJlcHJlc2VudHMgYSBidXR0b24gd2l0aCBjdXN0b20gY2xpY2sgaGFuZGxlcnMuXG4gKlxuICogQG1vZHVsZSBDVEFcbiAqIEB2ZXJzaW9uIHYzLjAuMlxuICpcbiAqIEBhdXRob3IgU2ViYXN0aWFuIEZpdHpuZXJcbiAqIEBhdXRob3IgQW5keSBHdXRzY2hlXG4gKi9cblxuLyoqXG4gKiBSZXF1aXJlbWVudHNcbiAqL1xuaW1wb3J0IHtWZWFtc30gZnJvbSAnYXBwJztcbmltcG9ydCBWZWFtc0NvbXBvbmVudCBmcm9tICd2ZWFtcy9zcmMvanMvY29tbW9uL2NvbXBvbmVudCc7XG5jb25zdCAkID0gVmVhbXMuJDtcblxuY2xhc3MgQ1RBIGV4dGVuZHMgVmVhbXNDb21wb25lbnQge1xuXHQvKipcblx0ICogQ29uc3RydWN0b3IgZm9yIG91ciBjbGFzc1xuXHQgKlxuXHQgKiBAc2VlIG1vZHVsZS5qc1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gT2JqZWN0IHdoaWNoIGlzIHBhc3NlZCB0byBvdXIgY2xhc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IG9iai5lbCAtIGVsZW1lbnQgd2hpY2ggd2lsbCBiZSBzYXZlZCBpbiB0aGlzLmVsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmoub3B0aW9ucyAtIG9wdGlvbnMgd2hpY2ggd2lsbCBiZSBwYXNzZWQgaW4gYXMgSlNPTiBvYmplY3Rcblx0ICovXG5cdGNvbnN0cnVjdG9yKG9iaikge1xuXHRcdGxldCBvcHRpb25zID0ge1xuXHRcdFx0YWN0aXZlQ2xhc3M6ICdpcy1hY3RpdmUnLFxuXHRcdFx0Y2xpY2tIYW5kbGVyOiAnY2xpY2snLFxuXHRcdFx0Y2xvc2VkTGFiZWw6IG51bGwsXG5cdFx0XHRjdGFDb250ZW50OiAnW2RhdGEtanMtaXRlbT1cImN0YS1jb250ZW50XCJdJyxcblx0XHRcdGdsb2JhbEV2ZW50OiAnY3RhOmNsaWNrJyxcblx0XHRcdG9wZW5lZExhYmVsOiBudWxsXG5cdFx0fTtcblxuXHRcdHN1cGVyKG9iaiwgb3B0aW9ucyk7XG5cdH1cblxuXHQvKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBHRVRURVIgJiBTRVRURVJcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblx0LyoqXG5cdCAqIEdldCBtb2R1bGUgaW5mb3JtYXRpb25cblx0ICovXG5cdHN0YXRpYyBnZXQgaW5mbygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dmVyc2lvbjogJzMuMC4yJyxcblx0XHRcdHZjOiB0cnVlLFxuXHRcdFx0bW9kOiBmYWxzZSAvLyBzZXQgdG8gdHJ1ZSBpZiBzb3VyY2Ugd2FzIG1vZGlmaWVkIGluIHByb2plY3Rcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBhbmQgc2V0IHRoZSBhY3RpdmUgc3RhdGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGUgLSBhY3RpdmUgc3RhdGVcblx0ICovXG5cdGdldCBhY3RpdmUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZTtcblx0fVxuXG5cdHNldCBhY3RpdmUoc3RhdGUpIHtcblx0XHR0aGlzLl9hY3RpdmUgPSBzdGF0ZTtcblx0fVxuXG5cdC8qKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIEVWRU5UU1xuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblx0Z2V0IGV2ZW50cygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0J3t7dGhpcy5vcHRpb25zLmNsaWNrSGFuZGxlcn19JzogJ29uQ2xpY2snXG5cdFx0fTtcblx0fVxuXG5cdC8qKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIFNUQU5EQVJEIE1FVEhPRFNcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgdmlldyBhbmQgbWVyZ2Ugb3B0aW9uc1xuXHQgKlxuXHQgKi9cblx0aW5pdGlhbGl6ZSgpIHtcblx0XHR0aGlzLiRjdGFDb250ZW50ID0gJCh0aGlzLm9wdGlvbnMuY3RhQ29udGVudCwgdGhpcy4kZWwpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZWRMYWJlbCAmJiAhdGhpcy5vcHRpb25zLm9wZW5lZExhYmVsIHx8XG5cdFx0XHQhdGhpcy5vcHRpb25zLmNsb3NlZExhYmVsICYmIHRoaXMub3B0aW9ucy5vcGVuZWRMYWJlbCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdDVEE6IFlvdSBoYXZlIHRvIHNldCBjbG9zZWRMYWJlbCBhbmQgb3BlbmVkTGFiZWwgb3Igbm9uZS4nKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlZExhYmVsICYmIHRoaXMub3B0aW9ucy5vcGVuZWRMYWJlbCAmJiAhdGhpcy4kY3RhQ29udGVudC5sZW5ndGgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdDVEE6IExhYmVscyBzZXQsIGJ1dCAnICsgdGhpcy5vcHRpb25zLmN0YUNvbnRlbnQgK1xuXHRcdFx0XHRcdCcgbm90IGZvdW5kLCBwbGVhc2UgbWFrZSBzdXJlIHNldHRpbmdzLmN0YUNvbnRlbnRKc0l0ZW0gaXMgc2V0IHRvIHRydWUgZm9yIGMtY3RhX19jb250ZW50LicpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLiRlbC5pcygnLicgKyB0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpKSB7XG5cdFx0XHR0aGlzLmFjdGl2ZSA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIENVU1RPTSBDVEEgTUVUSE9EU1xuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cdC8qKlxuXHQgKiBDbG9zZSBtZXRob2Rcblx0ICpcblx0ICogUmVtb3ZlIHRoZSBhY3RpdmUgY2xhc3MsIHNldCBsYWJlbCBhbmQgdHJpZ2dlciBnbG9iYWwgZXZlbnRcblx0ICpcblx0ICogQHB1YmxpY1xuXHQgKi9cblx0Y2xvc2UoKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZWRMYWJlbCkge1xuXHRcdFx0dGhpcy4kY3RhQ29udGVudC50ZXh0KHRoaXMub3B0aW9ucy5jbG9zZWRMYWJlbCk7XG5cdFx0XHR0aGlzLiRlbC5hdHRyKCd0aXRsZScsIHRoaXMub3B0aW9ucy5jbG9zZWRMYWJlbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy4kZWwucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHR0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIE9wZW4gbWV0aG9kXG5cdCAqXG5cdCAqIEFkZCB0aGUgYWN0aXZlIGNsYXNzLCBzZXQgbGFiZWwgYW5kIHRyaWdnZXIgZ2xvYmFsIGV2ZW50XG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdG9wZW4oKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5vcGVuZWRMYWJlbCkge1xuXHRcdFx0dGhpcy4kY3RhQ29udGVudC50ZXh0KHRoaXMub3B0aW9ucy5vcGVuZWRMYWJlbCk7XG5cdFx0XHR0aGlzLiRlbC5hdHRyKCd0aXRsZScsIHRoaXMub3B0aW9ucy5vcGVuZWRMYWJlbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy4kZWwuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHR0aGlzLmFjdGl2ZSA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQ2xpY2sgZXZlbnQgbWV0aG9kXG5cdCAqXG5cdCAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZW4gd2hlbiB5b3Ugd2FudCB0byB1c2UgdGhlIGJ1dHRvbiB2aWV3XG5cdCAqIEBzZWUgYnV0dG9uLWluaXQuanNcblx0ICpcblx0ICogQHBhcmFtIHtldmVudH0gZSAtIGV2ZW50IG9iamVjdFxuXHQgKi9cblx0b25DbGljayhlKSB7XG5cdFx0Y29uc29sZS5sb2coJ3JlYWR5Jyk7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0aWYgKHR5cGVvZiB0aGlzLmNsaWNrSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYgKHRoaXMuYWN0aXZlKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2UoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLm9wZW4oKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jbGlja0hhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS53YXJuKCdDVEE6IFlvdSBuZWVkIHRvIGluaGVyaXQgZnJvbSAnICsgdGhpcyArXG5cdFx0XHRcdCcgYW5kIG92ZXJyaWRlIHRoZSBvbkNsaWNrIG1ldGhvZCBvciBwYXNzIGEgZnVuY3Rpb24gdG8gJyArXG5cdFx0XHRcdHRoaXMgKyAnLmNsaWNrSGFuZGxlciAhJyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENsaWNrIGhhbmRsZXJcblx0ICpcblx0ICogVGhpcyBtZXRob2QgaXMgcHVibGljIGFuZCBjYW4gYmUgb3ZlcnJpZGRlbiBieVxuXHQgKiBvdGhlciBpbnN0YW5jZXMgdG8gc3VwcG9ydCBhIGdlbmVyaWMgYnV0dG9uIG1vZHVsZVxuXHQgKlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRjbGlja0hhbmRsZXIoKSB7XG5cdFx0VmVhbXMuVmVudC50cmlnZ2VyKHRoaXMub3B0aW9ucy5nbG9iYWxFdmVudCwge1xuXHRcdFx0ZWw6IHRoaXMuZWwsXG5cdFx0XHRpc0FjdGl2ZTogdGhpcy5hY3RpdmUsXG5cdFx0XHRvcHRpb25zOiB0aGlzLm9wdGlvbnNcblx0XHR9KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBDVEE7XG4iLCIvKipcbiAqIFJlcHJlc2VudHMgYSBhamF4IGZvcm0gY2xhc3MuXG4gKlxuICogQG1vZHVsZSBGb3JtQWpheFxuICogQHZlcnNpb24gdjMuMC4xXG4gKlxuICogQGF1dGhvciBTZWJhc3RpYW4gRml0em5lclxuICovXG5pbXBvcnQgeyBWZWFtcyB9IGZyb20gJ2FwcCc7XG5pbXBvcnQgVmVhbXNDb21wb25lbnQgZnJvbSAndmVhbXMvc3JjL2pzL2NvbW1vbi9jb21wb25lbnQnO1xuY29uc3QgJCA9IFZlYW1zLiQ7XG5cbmNsYXNzIEZvcm1BamF4IGV4dGVuZHMgVmVhbXNDb21wb25lbnQge1xuXHQvKipcblx0ICogQ29uc3RydWN0b3IgZm9yIG91ciBjbGFzc1xuXHQgKlxuXHQgKiBAc2VlIG1vZHVsZS5qc1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gT2JqZWN0IHdoaWNoIGlzIHBhc3NlZCB0byBvdXIgY2xhc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IG9iai5lbCAtIGVsZW1lbnQgd2hpY2ggd2lsbCBiZSBzYXZlZCBpbiB0aGlzLmVsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmoub3B0aW9ucyAtIG9wdGlvbnMgd2hpY2ggd2lsbCBiZSBwYXNzZWQgaW4gYXMgSlNPTiBvYmplY3Rcblx0ICovXG5cdGNvbnN0cnVjdG9yKG9iaikge1xuXHRcdGxldCBvcHRpb25zID0ge1xuXHRcdFx0c3VibWl0T25Mb2FkOiBmYWxzZSxcblx0XHRcdHN1Ym1pdE9uQ2hhbmdlOiB0cnVlLFxuXHRcdFx0bG9hZGluZ0NsYXNzOiBudWxsLFxuXHRcdFx0c3VjY2Vzc0NsYXNzOiAnaXMtc3VjY2VzcycsXG5cdFx0XHRlcnJvckNsYXNzOiAnaXMtZXJyb3InLFxuXHRcdFx0ZXZlbnROYW1lOiBWZWFtcy5FVkVOVFMuZm9ybS5jb21wbGV0ZVxuXHRcdH07XG5cblx0XHRzdXBlcihvYmosIG9wdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBtb2R1bGUgaW5mb3JtYXRpb25cblx0ICovXG5cdHN0YXRpYyBnZXQgaW5mbygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dmVyc2lvbjogJzMuMC4xJyxcblx0XHRcdHZjOiB0cnVlLFxuXHRcdFx0bW9kOiBmYWxzZSAvLyBzZXQgdG8gdHJ1ZSBpZiBzb3VyY2Ugd2FzIG1vZGlmaWVkIGluIHByb2plY3Rcblx0XHR9O1xuXHR9XG5cblx0aW5pdGlhbGl6ZSgpIHtcblx0XHQvLyBzYXZlIHNvbWUgcmVmZXJlbmNlc1xuXHRcdHRoaXMuZmllbGRzID0gJCgnaW5wdXQnLCB0aGlzLiRlbCk7XG5cdFx0dGhpcy5zZWxlY3RzID0gJCgnc2VsZWN0JywgdGhpcy4kZWwpO1xuXG5cdFx0Ly8gRmV0Y2ggZGF0YSBpZiBvcHRpb24gaXMgdHJ1ZVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc3VibWl0T25Mb2FkKSB7XG5cdFx0XHR0aGlzLmZldGNoRGF0YSh0aGlzLiRlbCk7XG5cdFx0fVxuXG5cdFx0Ly8gY2FsbCBzdXBlclxuXHRcdHN1cGVyLmluaXRpYWxpemUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kIGFsbCBldmVudGVcblx0ICovXG5cdGJpbmRFdmVudHMoKSB7XG5cdFx0bGV0IGZuRmV0Y2hEYXRhID0gdGhpcy5mZXRjaERhdGEuYmluZCh0aGlzKTtcblx0XHRsZXQgZm5SZXNldCA9IHRoaXMucmVzZXRGaWx0ZXJzLmJpbmQodGhpcyk7XG5cdFx0LyoqXG5cdFx0ICogT24gc3VibWl0IGV2ZW50IGZldGNoIGRhdGFcblx0XHQgKi9cblx0XHR0aGlzLiRlbC5vbihWZWFtcy5FVkVOVFMuc3VibWl0ICsgJyAnICsgVmVhbXMuRVZFTlRTLnJlc2V0LCBmbkZldGNoRGF0YSk7XG5cblx0XHQvKipcblx0XHQgKiBSZXNldCBmaWx0ZXJzIG9uIHJlc2V0IGV2ZW50XG5cdFx0ICovXG5cdFx0VmVhbXMuVmVudC5vbihWZWFtcy5FVkVOVFMuZm9ybS5yZXNldCwgZm5SZXNldCk7XG5cblx0XHQvKipcblx0XHQgKiBJZiBzdWJtaXRPbkNoYW5nZSBpcyB0cnVlXG5cdFx0ICpcblx0XHQgKiBmZXRjaCBkYXRhXG5cdFx0ICogc2hvdyByZXNldCBidXR0b25cblx0XHQgKlxuXHRcdCAqL1xuXHRcdGlmICh0aGlzLm9wdGlvbnMuc3VibWl0T25DaGFuZ2UpIHtcblx0XHRcdHRoaXMuJGVsLm9uKFZlYW1zLkVWRU5UUy5ibHVyICsgJyAnICsgVmVhbXMuRVZFTlRTLmNoYW5nZSwgdGhpcy5maWVsZHMsIGZuRmV0Y2hEYXRhKTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBBamF4IGNhbGwgdG8gZ2V0IGRhdGEgb2JqZWN0IHdpdGggcmVzdWx0cyBvciBlcnJvciBtZXNzYWdlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZSAtIG9iamVjdCBvciBldmVudC5cblx0ICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRUYXJnZXQgLSBUYXJnZXQgdG8gd2hpY2ggbGlzdGVuZXIgd2FzIGF0dGFjaGVkLlxuXHQgKi9cblx0ZmV0Y2hEYXRhKGUsIGN1cnJlbnRUYXJnZXQpIHtcblx0XHRsZXQgZWw7XG5cblx0XHRpZiAoZSAmJiB0eXBlb2YgZS5wcmV2ZW50RGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0ZWwgPSBjdXJyZW50VGFyZ2V0IHx8IGUuY3VycmVudFRhcmdldCA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsID0gZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLmxvYWRpbmdDbGFzcykge1xuXHRcdFx0dGhpcy4kZWwuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRpbmdDbGFzcyk7XG5cdFx0fVxuXG5cdFx0bGV0IGFjdGlvbiA9IHRoaXMuJGVsLmF0dHIoJ2FjdGlvbicpO1xuXHRcdGxldCBtZXRob2QgPSB0aGlzLiRlbC5hdHRyKCdtZXRob2QnKTtcblx0XHRsZXQgc2VyaWFsaXplID0gdGhpcy4kZWwuc2VyaWFsaXplKCk7XG5cdFx0bGV0IHVybCA9IGFjdGlvbiArICc/JyArIHNlcmlhbGl6ZTtcblxuXHRcdCQuYWpheCh7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdGRhdGFUeXBlOiAnanNvbicsXG5cdFx0XHRzdWNjZXNzOiAoZGF0YSkgPT4ge1xuXHRcdFx0XHR0aGlzLm9uU3VjY2VzcyhkYXRhLCBlbCk7XG5cdFx0XHR9LFxuXHRcdFx0ZXJyb3I6IChzdGF0dXMsIHN0YXR1c1RleHQpID0+IHtcblx0XHRcdFx0dGhpcy5vbkVycm9yKHN0YXR1cywgc3RhdHVzVGV4dClcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9XG5cblx0b25TdWNjZXNzKGRhdGEsIGVsKSB7XG5cdFx0dGhpcy5maWVsZHMgPSAkKCdpbnB1dCcsIHRoaXMuJGVsKTtcblx0XHR0aGlzLnNlbGVjdHMgPSAkKCdzZWxlY3QnLCB0aGlzLiRlbCk7XG5cblx0XHRWZWFtcy5WZW50LnRyaWdnZXIodGhpcy5vcHRpb25zLmV2ZW50TmFtZSwge1xuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdGVsOiBlbFxuXHRcdH0pO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5sb2FkaW5nQ2xhc3MpIHtcblx0XHRcdHRoaXMuJGVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sb2FkaW5nQ2xhc3MpO1xuXHRcdH1cblxuXHRcdHRoaXMuJGVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy5zdWNjZXNzQ2xhc3MpO1xuXHR9XG5cblx0b25FcnJvcihzdGF0dXMsIHN0YXR1c1RleHQpIHtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubG9hZGluZ0NsYXNzKSB7XG5cdFx0XHR0aGlzLiRlbC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGluZ0NsYXNzKTtcblx0XHR9XG5cblx0XHR0aGlzLiRlbC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcyk7XG5cblx0XHRjb25zb2xlLndhcm4oJ0Zvcm1BamF4OicsIHN0YXR1c1RleHQsICcoJyArIHN0YXR1cyArICcpJyk7XG5cdH1cblxuXHQvKipcblx0ICogUmVzZXQgZmlsdGVycywgY3VycmVudGx5IHN1cHBvcnRlZFxuXHQgKlxuXHQgKiBjaGVja2JveGVzXG5cdCAqIHNlbGVjdHNcblx0ICovXG5cdHJlc2V0RmlsdGVycygpIHtcblx0XHR0aGlzLnJlc2V0Q2hlY2tzKCk7XG5cdFx0dGhpcy5yZXNldFNlbGVjdHMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNldCBjaGVja2JveGVzXG5cdCAqL1xuXHRyZXNldENoZWNrcygpIHtcblx0XHR0aGlzLmZpZWxkcy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdCQodGhpcykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNlc3Qgc2VsZWN0c1xuXHQgKi9cblx0cmVzZXRTZWxlY3RzKCkge1xuXHRcdHRoaXMuc2VsZWN0cy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdCQodGhpcykucHJvcCgnc2VsZWN0ZWRJbmRleCcsIDApO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8vIFJldHVybnMgY29uc3RydWN0b3JcbmV4cG9ydCBkZWZhdWx0IEZvcm1BamF4OyIsIi8qKlxuICogZm9ybSBjb21wb25lbnQgZGF0ZXBpY2tlclxuICpcbiAqIEBtb2R1bGUgRm9ybURhdGVwaWNrZXJcbiAqIEB2ZXJzaW9uIHYxLjAuMFxuICpcbiAqIEBhdXRob3IgU2FuZy1JbiBIYWV0emVsXG4gKiBAYXV0aG9yIFNlYmFzdGlhbiBGaXR6bmVyXG4gKi9cbnJlcXVpcmUoJ21vbWVudCcpO1xuaW1wb3J0IHsgVmVhbXMgfSBmcm9tICdhcHAnO1xuaW1wb3J0IFZlYW1zQ29tcG9uZW50IGZyb20gJ3ZlYW1zL3NyYy9qcy9jb21tb24vY29tcG9uZW50JztcbmNvbnN0ICQgPSBWZWFtcy4kO1xuY29uc3QgUGlrYWRheSA9IHJlcXVpcmUoJ3Bpa2FkYXknKTtcblxuY2xhc3MgRm9ybURhdGVwaWNrZXIgZXh0ZW5kcyBWZWFtc0NvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RvciBmb3Igb3VyIGNsYXNzXG5cdCAqXG5cdCAqIEBzZWUgbW9kdWxlLmpzXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBPYmplY3Qgd2hpY2ggaXMgcGFzc2VkIHRvIG91ciBjbGFzc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqLmVsIC0gZWxlbWVudCB3aGljaCB3aWxsIGJlIHNhdmVkIGluIHRoaXMuZWxcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iai5vcHRpb25zIC0gb3B0aW9ucyB3aGljaCB3aWxsIGJlIHBhc3NlZCBpbiBhcyBKU09OIG9iamVjdFxuXHQgKi9cblx0Y29uc3RydWN0b3Iob2JqKSB7XG5cdFx0bGV0IG9wdGlvbnMgPSB7fTtcblx0XHRzdXBlcihvYmosIG9wdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBtb2R1bGUgaW5mb3JtYXRpb25cblx0ICovXG5cdHN0YXRpYyBnZXQgaW5mbygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogJ0Zvcm1EYXRlcGlja2VyJyxcblx0XHRcdHZlcnNpb246ICcxLjAuMCdcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdFVFRFUlMgQU5EIFNFVFRFUlNcblx0ICovXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBkYXRlXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEYXRlXG5cdCAqL1xuXHRzZXQgZGF0ZShkYXRlKSB7XG5cdFx0dGhpcy5fZGF0ZSA9IGRhdGU7XG5cdFx0dGhpcy5kYXRldGltZXBpY2tlci5zZXREYXRlKHRoaXMuX2RhdGUsIHRydWUpO1xuXHR9XG5cblx0Z2V0IGRhdGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGU7XG5cdH1cblxuXHQvKipcblx0ICogaTE4blxuXHQgKi9cblx0Z2V0IGkxOG5GYWxsYmFjaygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0cHJldmlvdXNNb250aDogJ1ByZXZpb3VzIE1vbnRoJyxcblx0XHRcdG5leHRNb250aDogJ05leHQgTW9udGgnLFxuXHRcdFx0bW9udGhzOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXSxcblx0XHRcdHdlZWtkYXlzOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J10sXG5cdFx0XHR3ZWVrZGF5c1Nob3J0OiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuXHRcdFx0Y2FsZW5kYXJGb3JtYXQ6ICdERC5NTS5ZWVlZJ1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIGNsYXNzXG5cdCAqL1xuXHRpbml0aWFsaXplKCkge1xuXHRcdGxldCBpMThuID0gVmVhbXMuaTE4biAmJiBWZWFtcy5pMThuLmRhdGVwaWNrZXIgPyBWZWFtcy5pMThuLmRhdGVwaWNrZXIgOiB0aGlzLmkxOG5GYWxsYmFjaztcblxuXHRcdGxldCBfdGhpcyA9IHRoaXM7XG5cdFx0dGhpcy4kaW5wdXQgPSAkKCdpbnB1dCcsIHRoaXMuJGVsKTtcblx0XHR0aGlzLmRhdGVGb3JtYXQgPSBpMThuLmNhbGVuZGFyRm9ybWF0O1xuXHRcdHRoaXMuZGF0ZXRpbWVwaWNrZXIgPSBuZXcgUGlrYWRheSh7XG5cdFx0XHRmaWVsZDogdGhpcy4kaW5wdXRbMF0sXG5cdFx0XHRpMThuOiBpMThuLFxuXHRcdFx0Y29udGFpbmVyOiB0aGlzLmVsLFxuXHRcdFx0b25TZWxlY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X3RoaXMuZGF0ZSA9IHRoaXMuZ2V0TW9tZW50KCkuZm9ybWF0KF90aGlzLmRhdGVGb3JtYXQpO1xuXHRcdFx0XHRfdGhpcy4kaW5wdXQudmFsKF90aGlzLmRhdGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG4vLyBSZXR1cm5zIGNvbnN0cnVjdG9yXG5leHBvcnQgZGVmYXVsdCBGb3JtRGF0ZXBpY2tlcjsiLCIvKipcbiAqIFJlcHJlc2VudHMgYW4gb3ZlcmxheSBtb2R1bGUuXG4gKlxuICogVGhpcyBtb2R1bGUgaXMgcmVzcG9uc2libGUgdG8gY3JlYXRlIGFuIG92ZXJsYXlcbiAqIHdpdGhvdXQgcHJlZGVmaW5pbmcgYW55IGlubmVyIG92ZXJsYXkgdGVtcGxhdGUuXG4gKlxuICogSXQgc2hvdWxkIGJlIHVzZWQgYnkgb3RoZXIgbW9kdWxlc1xuICogdG8gZGlzcGxheSB0aGVpciBjb250ZW50IGluIGFuIG92ZXJsYXkuXG4gKlxuICogQG1vZHVsZSBPdmVybGF5XG4gKiBAdmVyc2lvbiB2My4wLjBcbiAqXG4gKiBAYXV0aG9yIFNlYmFzdGlhbiBGaXR6bmVyXG4gKi9cbmltcG9ydCB7VmVhbXN9IGZyb20gJ2FwcCc7XG5pbXBvcnQgVmVhbXNDb21wb25lbnQgZnJvbSAndmVhbXMvc3JjL2pzL2NvbW1vbi9jb21wb25lbnQnO1xuY29uc3QgJCA9IFZlYW1zLiQ7XG5sZXQgVGVtcGxhdGUgPSBWZWFtcy50ZW1wbGF0ZXIudGVtcGxhdGVzO1xuXG5jbGFzcyBPdmVybGF5IGV4dGVuZHMgVmVhbXNDb21wb25lbnQge1xuXHQvKipcblx0ICogQ29uc3RydWN0b3IgZm9yIG91ciBjbGFzc1xuXHQgKlxuXHQgKiBAc2VlIG1vZHVsZS5qc1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gT2JqZWN0IHdoaWNoIGlzIHBhc3NlZCB0byBvdXIgY2xhc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IG9iai5lbCAtIGVsZW1lbnQgd2hpY2ggd2lsbCBiZSBzYXZlZCBpbiB0aGlzLmVsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmoub3B0aW9ucyAtIG9wdGlvbnMgd2hpY2ggd2lsbCBiZSBwYXNzZWQgaW4gYXMgSlNPTiBvYmplY3Rcblx0ICovXG5cdGNvbnN0cnVjdG9yKG9iaikge1xuXHRcdGxldCBvcHRpb25zID0ge1xuXHRcdFx0b3BlbkNsYXNzOiAnaXMtb3BlbicsXG5cdFx0XHRjbG9zZUJ0bjogJ1tkYXRhLWpzLWl0ZW09XCJvdmVybGF5LWNsb3NlXCJdJyxcblx0XHRcdG92ZXJsYXk6ICdbZGF0YS1qcy1pdGVtPVwib3ZlcmxheVwiXScsXG5cdFx0XHRyZWdpb25Db250ZW50OiAnW2RhdGEtanMtaXRlbT1cIm92ZXJsYXktY29udGVudFwiXScsXG5cdFx0XHR0ZW1wbGF0ZTogVGVtcGxhdGVbJ09WRVJMQVknXVxuXHRcdH07XG5cblx0XHRzdXBlcihvYmosIG9wdGlvbnMpO1xuXHR9XG5cblx0LyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogR0VUVEVSICYgU0VUVEVSXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cdC8qKlxuXHQgKiBHZXQgbW9kdWxlIGluZm9ybWF0aW9uXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IGluZm8oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHZlcnNpb246ICczLjAuMCcsXG5cdFx0XHR2YzogdHJ1ZSxcblx0XHRcdG1vZDogZmFsc2UgLy8gc2V0IHRvIHRydWUgaWYgc291cmNlIHdhcyBtb2RpZmllZCBpbiBwcm9qZWN0XG5cdFx0fTtcblx0fVxuXG5cdC8vIHNldCBhbmQgZ2V0IG92ZXJsYXkgdGVtcGxhdGVcblx0Z2V0IHRlbXBsYXRlKCkge1xuXHRcdHJldHVybiB0aGlzLl90ZW1wbGF0ZTtcblx0fVxuXG5cdHNldCB0ZW1wbGF0ZSh0cGwpIHtcblx0XHR0aGlzLl90ZW1wbGF0ZSA9IHRwbDtcblx0fVxuXG5cdC8vIHNldCBhbmQgZ2V0IGluZm9zIGlmIG92ZXJsYXkgaXMgY3JlYXRlZFxuXHRnZXQgb3ZlcmxheUNyZWF0ZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX292ZXJsYXlDcmVhdGVkO1xuXHR9XG5cblx0c2V0IG92ZXJsYXlDcmVhdGVkKGJvbCkge1xuXHRcdHRoaXMuX292ZXJsYXlDcmVhdGVkID0gYm9sO1xuXHR9XG5cblx0Ly8gc2V0IGFuZCBnZXQgaW5mb3MgaWYgb3ZlcmxheSBpcyBvcGVuXG5cdGdldCBpc09wZW4oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lzT3Blbjtcblx0fVxuXG5cdHNldCBpc09wZW4oYm9sKSB7XG5cdFx0dGhpcy5faXNPcGVuID0gYm9sO1xuXHR9XG5cblx0Ly8gc2V0IGFuZCBnZXQgb3ZlcmxheSBlbGVtZW50IGFmdGVyIGNyZWF0aW9uXG5cdGdldCAkb3ZlcmxheSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fJG92ZXJsYXk7XG5cdH1cblxuXHRzZXQgJG92ZXJsYXkoZWwpIHtcblx0XHR0aGlzLl8kb3ZlcmxheSA9IGVsO1xuXHR9XG5cblx0Ly8gc2V0IGFuZCBnZXQgY2xvc2UgYnV0dG9uIGFmdGVyIGNyZWF0aW9uXG5cdGdldCAkY2xvc2VCdG4oKSB7XG5cdFx0cmV0dXJuIHRoaXMuXyRjbG9zZUJ0bjtcblx0fVxuXG5cdHNldCAkY2xvc2VCdG4oZWwpIHtcblx0XHR0aGlzLl8kY2xvc2VCdG4gPSBlbDtcblx0fVxuXG5cdC8vIHNldCBhbmQgZ2V0IGNvbnRlbnQgcmVnaW9uXG5cdGdldCAkcmVnaW9uQ29udGVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fJHJlZ2lvbkNvbnRlbnQ7XG5cdH1cblxuXHRzZXQgJHJlZ2lvbkNvbnRlbnQoZWwpIHtcblx0XHR0aGlzLl8kcmVnaW9uQ29udGVudCA9IGVsO1xuXHR9XG5cblx0LyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogRVZFTlRTXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cdGdldCBzdWJzY3JpYmUoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdCd7e1ZlYW1zLkVWRU5UUy5vdmVybGF5Lm9wZW59fSc6ICdyZW5kZXInXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kIGdsb2JhbCBldmVudHNcblx0ICpcblx0ICogTGlzdGVuIHRvIG9wZW4gYW5kIGNsb3NlIGV2ZW50c1xuXHQgKi9cblx0YmluZEV2ZW50cygpIHtcblx0XHQvLyBDbG9zZSBvdmVybGF5IHdpdGggRVNDXG5cdFx0JCh3aW5kb3cpLm9uKFZlYW1zLkVWRU5UUy5rZXl1cCwgKGUpID0+IHtcblx0XHRcdGlmIChlLmtleUNvZGUgPT0gMjcgJiYgdGhpcy5pc09wZW4pIHtcblx0XHRcdFx0dGhpcy5jbG9zZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpbmQgbG9jYWwgZXZlbnRzXG5cdCAqL1xuXHRiaW5kTG9jYWxFdmVudHMoKSB7XG5cdFx0bGV0IGZuQ2xvc2UgPSB0aGlzLmNsb3NlLmJpbmQodGhpcyk7XG5cblx0XHQvLyBMb2NhbCBldmVudHNcblx0XHR0aGlzLiRjbG9zZUJ0bi5vbihWZWFtcy5FVkVOVFMuY2xpY2ssIGZuQ2xvc2UpO1xuXHR9XG5cblx0LyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogU1RBTkRBUkQgTUVUSE9EU1xuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIHZpZXcgYW5kIG1lcmdlIG9wdGlvbnNcblx0ICpcblx0ICovXG5cdGluaXRpYWxpemUoKSB7XG5cdFx0dGhpcy4kYm9keSA9ICQoJ2JvZHknKTtcblx0XHR0aGlzLnRlbXBsYXRlID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlO1xuXG5cdH1cblxuXHQvKipcblx0ICogUHJlLVJlbmRlciB0aGUgb3ZlcmxheSBhbmQgc2F2ZSByZWZlcmVuY2VzXG5cdCAqL1xuXHRwcmVSZW5kZXIoKSB7XG5cdFx0Ly8gQXBwZW5kIEZFIHRlbXBsYXRlXG5cdFx0dGhpcy4kYm9keS5hcHBlbmQodGhpcy50ZW1wbGF0ZSgpKTtcblxuXHRcdC8vIFNldCBzb21lIHJlZmVyZW5jZXNcblx0XHR0aGlzLiRvdmVybGF5ID0gJCh0aGlzLm9wdGlvbnMub3ZlcmxheSk7XG5cdFx0dGhpcy4kY2xvc2VCdG4gPSAkKHRoaXMub3B0aW9ucy5jbG9zZUJ0biwgdGhpcy4kb3ZlcmxheSk7XG5cdFx0dGhpcy4kcmVnaW9uQ29udGVudCA9ICQodGhpcy5vcHRpb25zLnJlZ2lvbkNvbnRlbnQsIHRoaXMuJG92ZXJsYXkpO1xuXG5cdFx0dGhpcy5vdmVybGF5Q3JlYXRlZCA9IHRydWU7XG5cdFx0dGhpcy5iaW5kTG9jYWxFdmVudHMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXIgdGhlIG92ZXJsYXlcblx0ICovXG5cdHJlbmRlcihvYmopIHtcblx0XHRsZXQgZGF0YSA9IG9iai5kYXRhIHx8IChvYmoub3B0aW9ucyAmJiBvYmoub3B0aW9ucy5kYXRhKTtcblxuXHRcdC8vIENoZWNrIGlmIGRhdGEgb2JqZWN0IGlzIHByb3ZpZGVkXG5cdFx0aWYgKCFkYXRhKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ092ZXJsYXk6IFlvdSBoYXZlIHRvIHByb3ZpZGUgYW4gb2JqZWN0IHdpdGggZGF0YSAob2JqLmRhdGEgfHwgb2JqLm9wdGlvbnMuZGF0YSkhJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQXBwZW5kIGRhdGEgdG8gb3ZlcmxheSByZWdpb25cblx0XHR0aGlzLiRyZWdpb25Db250ZW50Lmh0bWwoZGF0YSk7XG5cblx0XHQvLyBPcGVuIG92ZXJsYXlcblx0XHR0aGlzLm9wZW4oKTtcblx0fVxuXG5cdC8qKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIENVU1RPTSBPVkVSTEFZIE1FVEhPRFNcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cdC8qKlxuXHQgKiBPcGVuIE92ZXJsYXlcblx0ICovXG5cdG9wZW4oKSB7XG5cdFx0dGhpcy4kb3ZlcmxheS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMub3BlbkNsYXNzKTtcblx0XHR0aGlzLmlzT3BlbiA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQ2xvc2Ugb3ZlcmxheVxuXHQgKi9cblx0Y2xvc2UoKSB7XG5cdFx0dGhpcy4kb3ZlcmxheS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMub3BlbkNsYXNzKTtcblx0XHR0aGlzLmlzT3BlbiA9IGZhbHNlO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE92ZXJsYXk7IiwiLyoqXG4gKiBSZXByZXNlbnRzIGFuIGVsZW1lbnQgdGhhdCBzbGlkZXMgaW50byB2aWV3IHdoZW4gaXQncyBzY3JvbGxlZCBpbnRvIHZpZXdwb3J0LlxuICpcbiAqIEBtb2R1bGUgU2xpZGVGb3hcbiAqIEB2ZXJzaW9uIHYzLjAuMVxuICpcbiAqIEBhdXRob3IgQW5keSBHdXRzY2hlXG4gKiBAcmVmYWN0b3JpbmcgU2ViYXN0aWFuIEZpdHpuZXJcbiAqL1xuXG5pbXBvcnQgeyBWZWFtcyB9IGZyb20gJ2FwcCc7XG5pbXBvcnQgVmVhbXNDb21wb25lbnQgZnJvbSAndmVhbXMvc3JjL2pzL2NvbW1vbi9jb21wb25lbnQnO1xuaW1wb3J0IGlzSW5WaWV3cG9ydCBmcm9tICd2ZWFtcy9zcmMvanMvdXRpbHMvaGVscGVycy9pcy1pbi12aWV3cG9ydCc7XG5cbmNvbnN0ICQgPSBWZWFtcy4kO1xuY29uc3QgSGVscGVycyA9IFZlYW1zLmhlbHBlcnM7XG5cbmNsYXNzIFNsaWRlRm94IGV4dGVuZHMgVmVhbXNDb21wb25lbnQge1xuXHQvKipcblx0ICogQ29uc3RydWN0b3IgZm9yIG91ciBjbGFzc1xuXHQgKlxuXHQgKiBAc2VlIG1vZHVsZS5qc1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gT2JqZWN0IHdoaWNoIGlzIHBhc3NlZCB0byBvdXIgY2xhc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IG9iai5lbCAtIGVsZW1lbnQgd2hpY2ggd2lsbCBiZSBzYXZlZCBpbiB0aGlzLmVsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmoub3B0aW9ucyAtIG9wdGlvbnMgd2hpY2ggd2lsbCBiZSBwYXNzZWQgaW4gYXMgSlNPTiBvYmplY3Rcblx0ICovXG5cdGNvbnN0cnVjdG9yKG9iaikge1xuXHRcdGxldCBvcHRpb25zID0ge1xuXHRcdFx0dmlzaWJsZUNsYXNzOiAnaXMtdmlzaWJsZSdcblx0XHR9O1xuXG5cdFx0c3VwZXIob2JqLCBvcHRpb25zKTtcblx0fVxuXG5cdC8qKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIEdFVFRFUiAmIFNFVFRFUlxuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXHQvKipcblx0ICogR2V0IG1vZHVsZSBpbmZvcm1hdGlvblxuXHQgKi9cblx0c3RhdGljIGdldCBpbmZvKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR2ZXJzaW9uOiAnMy4wLjEnLFxuXHRcdFx0dmM6IHRydWUsXG5cdFx0XHRtb2Q6IGZhbHNlIC8vIHNldCB0byB0cnVlIGlmIHNvdXJjZSB3YXMgbW9kaWZpZWQgaW4gcHJvamVjdFxuXHRcdH07XG5cdH1cblxuXHQvKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBFVkVOVFNcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblx0Z2V0IHN1YnNjcmliZSgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0J3t7VmVhbXMuRVZFTlRTLnNjcm9sbH19JzogJ3JlbmRlcidcblx0XHR9O1xuXHR9XG5cblx0Ly8gYmluZEV2ZW50cygpIHtcblx0Ly8gXHRsZXQgZm5SZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpO1xuICAgIC8vXG5cdC8vIFx0JCh3aW5kb3cpLm9uKCdzY3JvbGwnLCBmblJlbmRlcik7XG5cdC8vIH1cblxuXHQvKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBTVEFOREFSRCBNRVRIT0RTXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXHRyZW5kZXIoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdpbml0YWxpemVkJyk7XG5cdFx0aXNJblZpZXdwb3J0KHRoaXMuZWwpID8gdGhpcy5zaG93U2xpZGVGb3goKSA6IHRoaXMuaGlkZVNsaWRlRm94KCk7XG5cdH1cblxuXHQvKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBDVVNUT00gU0xJREVGT1ggTUVUSE9EU1xuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblx0c2hvd1NsaWRlRm94KCkge1xuXHRcdHRoaXMuJGVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy52aXNpYmxlQ2xhc3MpO1xuXHR9XG5cblx0aGlkZVNsaWRlRm94KCkge1xuXHRcdHRoaXMuJGVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy52aXNpYmxlQ2xhc3MpO1xuXHR9XG5cblxufVxuXG4vLyBSZXR1cm5zIHRoZSBjb25zdHJ1Y3RvclxuZXhwb3J0IGRlZmF1bHQgU2xpZGVGb3g7XG4iLCIvKipcbiAqIFJlcHJlc2VudHMgYSByZXNwb25zaXZlIHNsaWRlciB3aGljaCBjYW4gYmUgdXNlZCBhcyByaWJib24uXG4gKlxuICogQG1vZHVsZSBTbGlkZXJcbiAqIEB2ZXJzaW9uIHYzLjAuM1xuICpcbiAqIEBhdXRob3IgU2ViYXN0aWFuIEZpdHpuZXJcbiAqIEBhdXRob3IgQW5keSBHdXRzY2hlXG4gKi9cblxuaW1wb3J0IHsgVmVhbXMgfSBmcm9tICdhcHAnO1xuaW1wb3J0IFZlYW1zQ29tcG9uZW50IGZyb20gJ3ZlYW1zL3NyYy9qcy9jb21tb24vY29tcG9uZW50JztcbmltcG9ydCB0cmFuc2l0aW9uRW5kRXZlbnQgZnJvbSAndmVhbXMvc3JjL2pzL3V0aWxzL2hlbHBlcnMvdHJhbnNpdGlvbi1lbmQtZXZlbnQnXG5cbmNvbnN0ICQgPSBWZWFtcy4kO1xuY29uc3QgSGVscGVycyA9IFZlYW1zLmhlbHBlcnM7XG5cbmNsYXNzIFNsaWRlciBleHRlbmRzIFZlYW1zQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdG9yIGZvciBvdXIgY2xhc3Ncblx0ICpcblx0ICogQHNlZSBtb2R1bGUuanNcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIE9iamVjdCB3aGljaCBpcyBwYXNzZWQgdG8gb3VyIGNsYXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmouZWwgLSBlbGVtZW50IHdoaWNoIHdpbGwgYmUgc2F2ZWQgaW4gdGhpcy5lbFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqLm9wdGlvbnMgLSBvcHRpb25zIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGluIGFzIEpTT04gb2JqZWN0XG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvYmopIHtcblx0XHRsZXQgb3B0aW9ucyA9IHtcblx0XHRcdGFjdGl2ZUNsYXNzOiAnaXMtYWN0aXZlJywgLy8gQWN0aXZlIGNsYXNzIGZvciBzbGlkZXMgYW5kIHBhZ2luYXRpb24gaXRlbXNcblx0XHRcdGFjdGlvbnM6ICdbZGF0YS1qcy1pdGVtPVwic2xpZGVyLWFjdGlvbnNcIl0nLCAvLyBQcmV2aW91cyBCdXR0b25cblx0XHRcdGF1dG9QbGF5OiBmYWxzZSwgLy8gRW5hYmxlIGF1dG9wbGF5XG5cdFx0XHRhdXRvUGxheUludGVydmFsOiA0ODAwLCAvLyBBdXRvcGxheSBpbnRlcnZhbGwgaW4gbWlsbGlzZWNvbmRzXG5cdFx0XHRjbG9uZUNsYXNzOiAnaXMtY2xvbmVkJywgLy8gQ2xvbmUgY2xhc3MgZm9yIGNsb25lZCBpdGVtcyAob25seSB1c2VkIHdpdGggaW5maW5pdGUpXG5cdFx0XHRkaXNhYmxlUGFnaW5hdGlvbjogZmFsc2UsIC8vIERpc2FibGUgcGFnaW5hdGlvbiBkaXNwbGF5XG5cdFx0XHRlbmFibGVUb3VjaFN3aXBlOiB0cnVlLCAvLyBFbmFibGUvRGlzYWJsZSBzd2lwZSBzdXBwb3J0XG5cdFx0XHRncm91cFBhZ2luYXRpb25JdGVtczogZmFsc2UsIC8vIEdyb3VwIHRoZSBwYWdpbmF0aW9uIGVsZW1lbnRzICh1c2VmdWwgZm9yIG11bHRpcGxlIHZpc2libGUgaXRlbXMpXG5cdFx0XHRoaWRkZW5DbGFzczogJ2lzLWhpZGRlbicsIC8vIGhpZGRlbiBjbGFzcyBmb3IgcGFnaW5hdGlvblxuXHRcdFx0aW5maW5pdGU6IGZhbHNlLCAvLyBJbmZpbml0ZSBsb29waW5nIChvbmx5IHBvc3NpYmxlIHdpdGhvdXQgbXVsdGlwbGUgdmlzaWJsZSBpdGVtcylcblx0XHRcdGl0ZW1zOiAnW2RhdGEtanMtaXRlbT1cInNsaWRlci1pdGVtXCJdJywgLy8gU2xpZGUgSXRlbXNcblx0XHRcdG5leHQ6ICdbZGF0YS1qcy1pdGVtPVwic2xpZGVyLW5leHRcIl0nLCAvLyBOZXh0IEJ1dHRvblxuXHRcdFx0cHJldjogJ1tkYXRhLWpzLWl0ZW09XCJzbGlkZXItcHJldlwiXScsIC8vIFByZXZpb3VzIEJ1dHRvblxuXHRcdFx0cGFnaW5hdGlvbjogJ1tkYXRhLWpzLWl0ZW09XCJzbGlkZXItcGFnaW5hdGlvblwiXScsIC8vIFBhZ2luYXRpb25cblx0XHRcdHBhZ2luYXRpb25JdGVtQ2xhc3M6ICdzbGlkZXJfX3BhZ2luYXRpb24tbGlzdC1pdGVtJywgLy8gRGVmaW5lIHlvdXIgY2xhc3Mgd2hpY2ggd2UgdXNlIGluIG91ciBtaW5pIHRtcGxcblx0XHRcdHBhZ2luYXRpb25JdGVtSnNJdGVtOiAnc2xpZGVyLXBhZ2luYXRpb24taXRlbScsIC8vIGRhdGEtanMtaXRlbSBmb3IgcGFnaW5hdGlvbiBsaXN0IGl0ZW1cblx0XHRcdHBhZ2luYXRpb25MaXN0OiAnW2RhdGEtanMtaXRlbT1cInNsaWRlci1wYWdpbmF0aW9uLWxpc3RcIl0nLCAvLyBQYWdpbmF0aW9uIExpc3Rcblx0XHRcdHJpYmJvbjogJ1tkYXRhLWpzLWl0ZW09XCJzbGlkZXItcmliYm9uXCJdJywgLy8gUmliYm9uIGVsZW1lbnRcblx0XHRcdHBhdXNlT25Ib3ZlcjogdHJ1ZSwgLy8gVXNlZCB3aGVuIG9wdGlvbnMuYXV0b1BsYXkgaXMgdHJ1ZVxuXHRcdFx0c2xpZGVCeUl0ZW1OdW1iZXI6IGZhbHNlLCAvLyBVc2UgdGhlIG9wdGlvbiB0byBvdmVycmlkZSB0aGUgaW5pdGlhbCBzbGlkZSBzdGVwXG5cdFx0XHRzdGFydEF0SW5kZXg6IDAsIC8vIFN0YXJ0IGF0IGEgZGlmZmVyZW50IGluZGV4XG5cdFx0XHR1bnJlc29sdmVkQ2xhc3M6ICdpcy11bnJlc29sdmVkJywgLy8gVW5yZXNvbHZlZCBjbGFzcyB3aGljaCBnZXRzIHJlbW92ZWQgd2hlbiBpbml0aWFsaXplZFxuXHRcdFx0dmlzaWJsZUl0ZW1zOiB7IC8vIFZpc2libGUgaXRlbXMgcGVyIHZpZXdwb3J0XG5cdFx0XHRcdCdkZXNrdG9wJzogMSxcblx0XHRcdFx0J3RhYmxldC1sYXJnZSc6IDEsXG5cdFx0XHRcdCd0YWJsZXQtc21hbGwnOiAxLFxuXHRcdFx0XHQnbW9iaWxlLWxhcmdlJzogMSxcblx0XHRcdFx0J21vYmlsZS1tZWRpdW0nOiAxLFxuXHRcdFx0XHQnbW9iaWxlLXNtYWxsJzogMVxuXHRcdFx0fSxcblx0XHRcdHdyYXBwZXI6ICdbZGF0YS1qcy1pdGVtPVwic2xpZGVyLXdyYXBwZXJcIl0nIC8vIFdyYXBwZXIgZWxlbWVudFxuXHRcdH07XG5cblx0XHRzdXBlcihvYmosIG9wdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEN1c3RvbSBnZXR0ZXJzIGFuZCBzZXR0ZXJcblx0ICovXG5cblx0LyoqXG5cdCAqIEdldCBtb2R1bGUgaW5mb3JtYXRpb25cblx0ICovXG5cdHN0YXRpYyBnZXQgaW5mbygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dmVyc2lvbjogJzMuMC4zJyxcblx0XHRcdHZjOiB0cnVlLFxuXHRcdFx0bW9kOiBmYWxzZVxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGFuZCBzZXQgdmlzaWJsZSBpdGVtcy5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZpc2libGUgLSBOdW1iZXIgb2YgdmlzaWJsZSBpdGVtc1xuXHQgKi9cblx0Z2V0IHZpc2libGVzKCkge1xuXHRcdHJldHVybiB0aGlzLl9udW1WaXNpYmxlO1xuXHR9XG5cblx0c2V0IHZpc2libGVzKHZpc2libGUpIHtcblx0XHR0aGlzLl9udW1WaXNpYmxlID0gdmlzaWJsZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBpdGVtcyBsZW5ndGggZm9yIHNsaWRlci5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGxlbiAtIE51bWJlciBvZiBpdGVtIGxlbmd0aFxuXHQgKi9cblx0Z2V0IGl0ZW1zTGVuZ3RoKCkge1xuXHRcdHJldHVybiB0aGlzLl9pdGVtTGVuZ3RoO1xuXHR9XG5cblx0c2V0IGl0ZW1zTGVuZ3RoKGxlbikge1xuXHRcdHRoaXMuX2l0ZW1MZW5ndGggPSBsZW47XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGFuZCBzZXQgdGhlIGluZGV4IG9mIHNsaWRlci5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGlkeCAtIGluZGV4IG51bWJlciBvZiBzbGlkZVxuXHQgKi9cblx0Z2V0IGluZGV4KCkge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleDtcblx0fVxuXG5cdHNldCBpbmRleChpZHgpIHtcblx0XHR0aGlzLl9pbmRleCA9IGlkeDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgcGF1c2VkIHByb3BlcnR5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJvb2wgLSBwYXVzZSBzdGF0ZVxuXHQgKi9cblx0Z2V0IHBhdXNlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF1c2VkO1xuXHR9XG5cblx0c2V0IHBhdXNlZChib29sKSB7XG5cdFx0dGhpcy5fcGF1c2VkID0gYm9vbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgYXV0b1BsYXkgcHJvcGVydHkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYm9vbCAtIGF1dG9wbGF5IHN0YXRlXG5cdCAqL1xuXHRnZXQgYXV0b1BsYXkoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2F1dG9QbGF5O1xuXHR9XG5cblx0c2V0IGF1dG9QbGF5KGJvb2wpIHtcblx0XHR0aGlzLl9hdXRvUGxheSA9IGJvb2w7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGNvbnRyb2xzIGhlaWdodC5cblx0ICovXG5cdGdldCBjb250cm9sSGVpZ2h0KCkge1xuXHRcdHJldHVybiBIZWxwZXJzLmdldE91dGVySGVpZ2h0KHRoaXMuJHByZXYpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgZGVmaW5lZCBvcHRpb24gb3IgY3VycmVudCB2aXNpYmxlIGl0ZW1zXG5cdCAqIHdoaWNoIHdpbGwgYmUgdXNlZCBmb3IgdGhlIG5leHQgYW5kIHByZXZpb3VzIHNsaWRlIGFuaW1hdGlvbi5cblx0ICovXG5cdGdldCBzbGlkZUJ5KCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc2xpZGVCeUl0ZW1OdW1iZXIgfHwgdGhpcy52aXNpYmxlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgcmliYm9uIHdpZHRoLlxuXHQgKi9cblx0Z2V0IHJpYmJvbldpZHRoKCkge1xuXHRcdHJldHVybiB0aGlzLiRpdGVtcy5sZW5ndGggKiAodGhpcy50aHVtYldpZHRoKTtcblx0fVxuXG5cdC8qKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIEVWRU5UU1xuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXHQvKipcblx0ICogQmluZCBsb2NhbCBldmVudHMgdG8gdGhpcy4kZWwuXG5cdCAqL1xuXHRnZXQgZXZlbnRzKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHQnY2xpY2sge3t0aGlzLm9wdGlvbnMucHJldn19JzogJ3Nob3dQcmV2RWxlbWVudCcsXG5cdFx0XHQndG91Y2hzdGFydCB7e3RoaXMub3B0aW9ucy5wcmV2fX0nOiAnc2hvd1ByZXZFbGVtZW50Jyxcblx0XHRcdCdjbGljayB7e3RoaXMub3B0aW9ucy5uZXh0fX0nOiAnc2hvd05leHRFbGVtZW50Jyxcblx0XHRcdCd0b3VjaHN0YXJ0IHt7dGhpcy5vcHRpb25zLm5leHR9fSc6ICdzaG93TmV4dEVsZW1lbnQnLFxuXHRcdFx0J2NsaWNrIHt7dGhpcy5wYWdpbmF0aW9uSXRlbVNlbH19JzogJ25hdmlnYXRlVG9FbGVtZW50Jyxcblx0XHRcdCd0b3VjaHN0YXJ0IHt7dGhpcy5wYWdpbmF0aW9uSXRlbVNlbH19JzogJ25hdmlnYXRlVG9FbGVtZW50J1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogU3Vic2NyaWJlIHRvIGdsb2JhbCBldmVudHMgb2YgVmVhbXMgb3IgQXBwIG5hbWVzcGFjZS5cblx0ICovXG5cdGdldCBzdWJzY3JpYmUoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdCd7e1ZlYW1zLkVWRU5UUy5yZXNpemV9fSc6ICdyZW5kZXInXG5cdFx0fTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEJpbmQgYWxsIGV2ZW50c1xuXHQgKi9cblx0YmluZEV2ZW50cygpIHtcblx0XHRpZiAodGhpcy5hdXRvUGxheSAmJiB0aGlzLm9wdGlvbnMucGF1c2VPbkhvdmVyKSB7XG5cdFx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQoJ3t7VmVhbXMuRVZFTlRTLm1vdXNlZW50ZXJ9fScsICdwYXVzZScpO1xuXHRcdFx0dGhpcy5yZWdpc3RlckV2ZW50KCd7e1ZlYW1zLkVWRU5UUy5tb3VzZWxlYXZlfX0nLCAncGxheScpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVbmJpbmQgYWxsIGV2ZW50c1xuXHQgKi9cblx0dW5iaW5kRXZlbnRzKCkge1xuXHRcdC8vIEdsb2JhbCBFdmVudHNcblx0XHRWZWFtcy5WZW50Lm9mZihWZWFtcy5FVkVOVFMucmVzaXplKTtcblxuXHRcdC8vIExvY2FsIEV2ZW50c1xuXHRcdHRoaXMuJGVsLm9mZihWZWFtcy5jbGlja0hhbmRsZXIpO1xuXHR9XG5cblx0LyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogU1RBTkRBUkQgTUVUSE9EU1xuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIHZpZXdcblx0ICovXG5cdGluaXRpYWxpemUoKSB7XG5cdFx0dGhpcy5pbmRleCA9IDA7XG5cdFx0dGhpcy4kcHJldiA9IHRoaXMuJGVsLmZpbmQodGhpcy5vcHRpb25zLnByZXYpO1xuXHRcdHRoaXMuJG5leHQgPSB0aGlzLiRlbC5maW5kKHRoaXMub3B0aW9ucy5uZXh0KTtcblx0XHR0aGlzLiRpdGVtcyA9IHRoaXMuJGVsLmZpbmQodGhpcy5vcHRpb25zLml0ZW1zKTtcblx0XHR0aGlzLiRpbml0aWFsSXRlbXMgPSB0aGlzLiRpdGVtcztcblx0XHR0aGlzLiR3cmFwcGVyID0gdGhpcy4kZWwuZmluZCh0aGlzLm9wdGlvbnMud3JhcHBlcik7XG5cdFx0dGhpcy4kcmliYm9uID0gdGhpcy4kZWwuZmluZCh0aGlzLm9wdGlvbnMucmliYm9uKTtcblx0XHR0aGlzLnN0YXJ0QXRJbmRleCA9IH5+dGhpcy5vcHRpb25zLnN0YXJ0QXRJbmRleDtcblx0XHR0aGlzLiRsYXN0SXRlbSA9IHRoaXMuJGl0ZW1zLmVxKHRoaXMuJGl0ZW1zLmxlbmd0aCAtIDEpO1xuXHRcdHRoaXMuJGZpcnN0SXRlbSA9IHRoaXMuJGl0ZW1zLmVxKDApO1xuXHRcdHRoaXMudHJhbnNpdGlvbiA9IHRoaXMuJHJpYmJvbi5jc3MoJ3RyYW5zaXRpb24nKTtcblx0XHR0aGlzLnBhZ2luYXRpb25EaXNhYmxlZCA9IHRoaXMub3B0aW9ucy5kaXNhYmxlUGFnaW5hdGlvbiB8fCB0aGlzLiRpdGVtcy5sZW5ndGggPCAyO1xuXHRcdHRoaXMuaW5maW5pdGUgPSB0aGlzLm9wdGlvbnMuaW5maW5pdGUgJiYgdGhpcy4kaXRlbXMubGVuZ3RoID4gMTtcblx0XHR0aGlzLnRvdWNoU3dpcGVFbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5jbGlja0hhbmRsZXIgPSB0cnVlO1xuXHRcdHRoaXMuYXV0b1BsYXkgPSB0aGlzLm9wdGlvbnMuYXV0b1BsYXkgJiYgdGhpcy5pbmZpbml0ZTtcblx0XHR0aGlzLnBhZ2luYXRpb25JdGVtU2VsID0gJ1tkYXRhLWpzLWl0ZW09XCInICsgdGhpcy5vcHRpb25zLnBhZ2luYXRpb25JdGVtSnNJdGVtICsgJ1wiXSc7XG5cblxuXHRcdGlmICghdGhpcy5wYWdpbmF0aW9uRGlzYWJsZWQpIHtcblx0XHRcdHRoaXMuJHBhZ2luYXRpb25MaXN0ID0gdGhpcy4kZWwuZmluZCh0aGlzLm9wdGlvbnMucGFnaW5hdGlvbkxpc3QpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkgJiYgIXRoaXMuaW5maW5pdGUpIHtcblx0XHRcdGNvbnNvbGUud2FybignU2xpZGVyOiBTb3JyeSAtIG9wdGlvbiBcImF1dG9QbGF5XCIgaGFzIG5vIGVmZmVjdCB3aGlsZSBvcHRpb24gXCJpbmZpbml0ZVwiIGlzIHNldCB0byBmYWxzZSEnKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5pbmZpbml0ZSkge1xuXG5cdFx0XHRmb3IgKGxldCBpdGVtIGluIHRoaXMub3B0aW9ucy52aXNpYmxlSXRlbXMpIHtcblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy52aXNpYmxlSXRlbXMuaGFzT3duUHJvcGVydHkoaXRlbSkpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLnZpc2libGVJdGVtc1tpdGVtXSA+IDEpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XHRcdFx0J1NsaWRlcjogU29ycnkgLSBvcHRpb24gXCJ2aXNpYmxlSXRlbXNcIiBoYXMgbm8gZWZmZWN0IHdoaWxlIG9wdGlvbiBcImluZmluaXRlXCIgaXMgc2V0IHRvIHRydWUhJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVycyB0aGUgdmlldydzIHRlbXBsYXRlIHRvIHRoZSBVSVxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICghVmVhbXMuY3VycmVudE1lZGlhKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1NsaWRlcjogVmVhbXMuY3VycmVudE1lZGlhIGlzIG5lY2Vzc2FyeSB0byBzdXBwb3J0IHRoZSBzbGlkZXIgbW9kdWxlIScpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiRjbG9uZWRMYXN0ICYmIHRoaXMuJGNsb25lZEZpcnN0KSB7XG5cdFx0XHR0aGlzLiRjbG9uZWRMYXN0LnJlbW92ZSgpO1xuXHRcdFx0dGhpcy4kY2xvbmVkRmlyc3QucmVtb3ZlKCk7XG5cdFx0XHR0aGlzLiRpdGVtcyA9IHRoaXMuJGluaXRpYWxJdGVtcztcblx0XHR9XG5cblx0XHR0aGlzLnZpc2libGVzID0gdGhpcy5pbmZpbml0ZSA/IDEgOiB0aGlzLm9wdGlvbnMudmlzaWJsZUl0ZW1zW1ZlYW1zLmN1cnJlbnRNZWRpYV07XG5cdFx0dGhpcy5pdGVtc0xlbmd0aCA9IHRoaXMuJGl0ZW1zLmxlbmd0aDtcblxuXHRcdHRoaXMuaGFuZGxlVmlzaWJpbGl0eSgpO1xuXG5cdFx0aWYgKCF0aGlzLnBhZ2luYXRpb25EaXNhYmxlZCkge1xuXHRcdFx0dGhpcy5yZW1vdmVQYWdpbmF0aW9uKCk7XG5cdFx0XHR0aGlzLmFkZFBhZ2luYXRpb24oKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5pbmZpbml0ZSkge1xuXHRcdFx0dGhpcy5pbmZpbml0ZUxvb3AoKTtcblx0XHR9XG5cblx0XHR0aGlzLmJpbmRUcmFuc2l0aW9ucygpO1xuXHRcdHRoaXMuZ2V0QW5kU2V0RGltZW5zaW9ucygpO1xuXG5cdFx0aWYgKFZlYW1zLmRldGVjdGlvbnMudG91Y2ggJiYgdGhpcy5vcHRpb25zLmVuYWJsZVRvdWNoU3dpcGUgJiYgIXRoaXMudG91Y2hTd2lwZUVuYWJsZWQpIHtcblx0XHRcdHRoaXMuYmluZFN3aXBlcygpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7XG5cdFx0XHR0aGlzLmdvVG9JdGVtKHRoaXMuc3RhcnRBdEluZGV4ICsgdGhpcy52aXNpYmxlcyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5nb1RvSXRlbSh0aGlzLnN0YXJ0QXRJbmRleCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuYXV0b1BsYXkgJiYgdGhpcy5wYXVzZWQpIHtcblx0XHRcdHRoaXMucGxheSgpO1xuXHRcdH1cblx0fVxuXHRcblx0LyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogQ1VTVE9NIFNMSURFUiBNRVRIT0RTXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblx0XG5cdC8qKlxuXHQgKiBCaW5kIHRyYW5zaXRpb24gZXZlbnRzXG5cdCAqXG5cdCAqL1xuXHRiaW5kVHJhbnNpdGlvbnMoKSB7XG5cdFx0bGV0IG9uUmliYm9uVHJhbnNpdGlvbkVuZCA9IHRoaXMub25SaWJib25UcmFuc2l0aW9uRW5kLmJpbmQodGhpcyk7XG5cdFx0bGV0IG9uSXRlbXNUcmFuc2l0aW9uRW5kID0gdGhpcy5vbkl0ZW1zVHJhbnNpdGlvbkVuZC5iaW5kKHRoaXMpO1xuXG5cdFx0dGhpcy4kcmliYm9uLm9uKHRyYW5zaXRpb25FbmRFdmVudCgpLCBvblJpYmJvblRyYW5zaXRpb25FbmQpO1xuXHRcdHRoaXMuJGl0ZW1zLm9uKHRyYW5zaXRpb25FbmRFdmVudCgpLCBvbkl0ZW1zVHJhbnNpdGlvbkVuZCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVhY3QgdG8gdHJhbnNpdGlvbmVuZCBvbiByaWJib25cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGUgLSBFdmVudCBvYmplY3QuXG5cdCAqL1xuXHRvblJpYmJvblRyYW5zaXRpb25FbmQoZSkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHRpZiAodGhpcy5hdXRvUGxheSAmJiB0aGlzLnBhdXNlZCkge1xuXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnBhdXNlT25Ib3Zlcikge1xuXG5cdFx0XHRcdGlmICghdGhpcy4kZWwuaXMoJzpob3ZlcicpKSB7XG5cdFx0XHRcdFx0dGhpcy5wbGF5KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLnBsYXkoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy4kY2xvbmVkRmlyc3QgJiYgdGhpcy4kY2xvbmVkRmlyc3QuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSkge1xuXHRcdFx0dGhpcy4kY2xvbmVkRmlyc3QucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHRcdHRoaXMuaW5kZXggPSAxO1xuXG5cdFx0XHR0aGlzLmFuaW1hdGVTbGlkZSh7XG5cdFx0XHRcdGlkeDogdGhpcy5pbmRleCxcblx0XHRcdFx0YW5pbWF0ZTogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiRjbG9uZWRMYXN0ICYmIHRoaXMuJGNsb25lZExhc3QuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSkge1xuXHRcdFx0dGhpcy4kY2xvbmVkTGFzdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXHRcdFx0dGhpcy5pbmRleCA9IHRoaXMuJGl0ZW1zLmxlbmd0aCAtIHRoaXMudmlzaWJsZXMgLSAxO1xuXG5cdFx0XHR0aGlzLmFuaW1hdGVTbGlkZSh7XG5cdFx0XHRcdGlkeDogdGhpcy5pbmRleCxcblx0XHRcdFx0YW5pbWF0ZTogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuY2xpY2tIYW5kbGVyID0gdHJ1ZTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFJlYWN0IHRvIHRyYW5zaXRpb25lbmQgb24gaXRlbXNcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGUgLSBFdmVudCBvYmplY3QuXG5cdCAqL1xuXHRvbkl0ZW1zVHJhbnNpdGlvbkVuZChlKSB7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9uZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50XG5cdCAqXG5cdCAqL1xuXHRpbmZpbml0ZUxvb3AoKSB7XG5cdFx0dGhpcy4kY2xvbmVkRmlyc3QgPSB0aGlzLiRmaXJzdEl0ZW0uY2xvbmUodHJ1ZSkuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNsb25lQ2xhc3MpO1xuXHRcdHRoaXMuJGNsb25lZExhc3QgPSB0aGlzLiRsYXN0SXRlbS5jbG9uZSh0cnVlKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY2xvbmVDbGFzcyk7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLmluZmluaXRlKSB7XG5cdFx0XHR0aGlzLiRjbG9uZWRGaXJzdC5maW5kKHRoaXMucGFnaW5hdGlvbkl0ZW1TZWwpLmF0dHIoJ2RhdGEtaW5kZXgnLCB0aGlzLml0ZW1zTGVuZ3RoKTtcblx0XHRcdHRoaXMuJGNsb25lZExhc3QuZmluZCh0aGlzLnBhZ2luYXRpb25JdGVtU2VsKS5hdHRyKCdkYXRhLWluZGV4JywgLTEpO1xuXHRcdH1cblxuXHRcdHRoaXMuJGZpcnN0SXRlbS5iZWZvcmUodGhpcy4kY2xvbmVkTGFzdCk7XG5cdFx0dGhpcy4kbGFzdEl0ZW0uYWZ0ZXIodGhpcy4kY2xvbmVkRmlyc3QpO1xuXG5cdFx0dGhpcy4kaXRlbXMgPSAkKHRoaXMub3B0aW9ucy5pdGVtcywgdGhpcy4kZWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFuaW1hdGUgc2xpZGVcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIGFuaW1hdGlvbiBwcm9wZXJ0eSBvYmplY3QuXG5cdCAqL1xuXHRhbmltYXRlU2xpZGUob2JqKSB7XG5cdFx0aWYgKCFvYmouYW5pbWF0ZSkge1xuXHRcdFx0dGhpcy4kcmliYm9uLmNzcygndHJhbnNpdGlvbicsICdub25lJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuJHJpYmJvbi5jc3MoJ3RyYW5zaXRpb24nLCB0aGlzLnRyYW5zaXRpb24pO1xuXHRcdH1cblxuXHRcdHRoaXMuJHJpYmJvbi5jc3MoJ2xlZnQnLCAtb2JqLmlkeCAqICh0aGlzLnRodW1iV2lkdGgpICsgJ3B4Jyk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgZmlyc3QvbGFzdCBzbGlkZSBjbGFzc2VzXG5cdCAqXG5cdCAqL1xuXHRjaGVja1NsaWRlcygpIHtcblxuXHRcdGlmICh0aGlzLiRjbG9uZWRGaXJzdC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpKSB7XG5cdFx0XHR0aGlzLiRmaXJzdEl0ZW0uYWRkQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuJGNsb25lZExhc3QuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSkge1xuXHRcdFx0dGhpcy4kbGFzdEl0ZW0uYWRkQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogV2hlbiBpdGVtcyBsZW5ndGggaXMgMCB3ZSBoaWRlIHRoaXMgdmlldy5cblx0ICovXG5cdGhhbmRsZVZpc2liaWxpdHkoKSB7XG5cdFx0aWYgKHRoaXMuaXRlbXNMZW5ndGggPT09IDApIHtcblx0XHRcdHRoaXMuJGVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy5oaWRkZW5DbGFzcyk7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1NsaWRlcjogVGhlcmUgaXMgbm8gaXRlbSB3ZSBjYW4gdXNlIGluIG91ciBzbGlkZXIgOignKTtcblx0XHR9XG5cblx0XHR0aGlzLiRlbC5jc3MoJ21heC13aWR0aCcsICdub25lJyk7XG5cdH1cblxuXHQvKipcblx0ICogRW1wdHkgcGFnaW5hdGlvbi5cblx0ICovXG5cdHJlbW92ZVBhZ2luYXRpb24oKSB7XG5cdFx0dGhpcy4kcGFnaW5hdGlvbkxpc3QuZW1wdHkoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgcGFnaW5hdGlvbiBlbGVtZW50cyB3aXRoIGEgc2ltcGxlIHN0cmluZyB0ZW1wbGF0ZSBhbmRcblx0ICogc2F2ZSBhIHBhZ2luYXRpb24gaXRlbSByZWZlcmVuY2UuXG5cdCAqL1xuXHRhZGRQYWdpbmF0aW9uKCkge1xuXHRcdGxldCB0bXBsID0gJyc7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdGxldCBpdGVtID0gdGhpcy5vcHRpb25zLnBhZ2luYXRpb25JdGVtSnNJdGVtO1xuXHRcdGxldCBpdGVtQ2xhc3MgPSB0aGlzLm9wdGlvbnMucGFnaW5hdGlvbkl0ZW1DbGFzcztcblxuXHRcdGZvciAoaTsgaSA8IHRoaXMuJGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgaWR4ID0gaSArIDE7XG5cdFx0XHRsZXQgaGlkZGVuQ2xhc3MgPSAnJztcblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5ncm91cFBhZ2luYXRpb25JdGVtcykge1xuXHRcdFx0XHRoaWRkZW5DbGFzcyA9IGkgJSB0aGlzLnZpc2libGVzID09PSAwID8gJycgOiB0aGlzLm9wdGlvbnMuaGlkZGVuQ2xhc3M7XG5cdFx0XHR9XG5cblx0XHRcdHRtcGwgKz0gYFxuXHRcdFx0XHRcdDxsaSBjbGFzcz1cIiR7aXRlbUNsYXNzfSAke2hpZGRlbkNsYXNzfVwiIGRhdGEtanMtaXRlbT1cIiR7aXRlbX1cIiBkYXRhLWluZGV4PVwiJHtpfVwiPlxuXHRcdFx0XHRcdFx0PHN0cm9uZz4ke2lkeH08L3N0cm9uZz5cblx0XHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHRcdGA7XG5cdFx0fVxuXG5cdFx0dGhpcy4kcGFnaW5hdGlvbkxpc3QuYXBwZW5kKHRtcGwpO1xuXHRcdHRoaXMuJHBhZ2luYXRpb25JdGVtcyA9ICQoJ1tkYXRhLWpzLWl0ZW09XCInICsgdGhpcy5vcHRpb25zLnBhZ2luYXRpb25JdGVtSnNJdGVtICsgJ1wiXScsIHRoaXMuJGVsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBOYXZpZ2F0ZSB0byBhIHNwZWNpZmljIHNsaWRlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZSAtIEV2ZW50IG9iamVjdC5cblx0ICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRUYXJnZXQgLSBUYXJnZXQgdG8gd2hpY2ggbGlzdGVuZXIgd2FzIGF0dGFjaGVkLlxuXHQgKi9cblx0bmF2aWdhdGVUb0VsZW1lbnQoZSwgY3VycmVudFRhcmdldCkge1xuXHRcdGxldCAkY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQgPyAkKGN1cnJlbnRUYXJnZXQpIDogJChlLmN1cnJlbnRUYXJnZXQpO1xuXG5cdFx0aWYgKCRjdXJyZW50VGFyZ2V0Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgaWR4ID0gcGFyc2VJbnQoJGN1cnJlbnRUYXJnZXQuYXR0cignZGF0YS1pbmRleCcpLCAxMCkgfHwgJGN1cnJlbnRUYXJnZXQuaW5kZXgoKTtcblxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7XG5cdFx0XHRpZHggPSBpZHggKyB0aGlzLnNsaWRlQnk7XG5cdFx0fVxuXG5cdFx0dGhpcy5nb1RvSXRlbShpZHgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdvIHRvIHRoZSBuZXh0IHNsaWRlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZSAtIEV2ZW50IG9iamVjdC5cblx0ICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRUYXJnZXQgLSBUYXJnZXQgdG8gd2hpY2ggbGlzdGVuZXIgd2FzIGF0dGFjaGVkLlxuXHQgKi9cblx0c2hvd05leHRFbGVtZW50KGUsIGN1cnJlbnRUYXJnZXQpIHtcblx0XHRsZXQgJGN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0ID8gJChjdXJyZW50VGFyZ2V0KSA6ICQoZS5jdXJyZW50VGFyZ2V0KTtcblxuXHRcdGlmIChlICYmIHR5cGVvZiBlLnByZXZlbnREZWZhdWx0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKCRjdXJyZW50VGFyZ2V0LnByb3AoJ2Rpc2FibGVkJykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5jbGlja0hhbmRsZXIpIHtcblx0XHRcdHRoaXMuZ29Ub0l0ZW0odGhpcy5pbmRleCArIHRoaXMuc2xpZGVCeSk7XG5cdFx0XHR0aGlzLmNsaWNrSGFuZGxlciA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHbyB0byB0aGUgcHJldmlvdXMgc2xpZGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBlIC0gRXZlbnQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge29iamVjdH0gY3VycmVudFRhcmdldCAtIFRhcmdldCB0byB3aGljaCBsaXN0ZW5lciB3YXMgYXR0YWNoZWQuXG5cdCAqL1xuXHRzaG93UHJldkVsZW1lbnQoZSwgY3VycmVudFRhcmdldCkge1xuXHRcdGxldCAkY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQgPyAkKGN1cnJlbnRUYXJnZXQpIDogJChlLmN1cnJlbnRUYXJnZXQpO1xuXG5cdFx0aWYgKGUgJiYgdHlwZW9mIGUucHJldmVudERlZmF1bHQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHRpZiAoJGN1cnJlbnRUYXJnZXQucHJvcCgnZGlzYWJsZWQnKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmNsaWNrSGFuZGxlcikge1xuXHRcdFx0dGhpcy5nb1RvSXRlbSh0aGlzLmluZGV4IC0gdGhpcy5zbGlkZUJ5KTtcblx0XHRcdHRoaXMuY2xpY2tIYW5kbGVyID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgZGlyZWN0aW9uIGBuZXh0YCBvciBgcHJldmAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIEluZGV4IG9mIHRoZSBwYWdpbmF0aW9uIGVsZW1lbnQuXG5cdCAqL1xuXHRnZXREaXJlY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gaW5kZXggPiB0aGlzLmluZGV4ID8gXCJuZXh0XCIgOiBcInByZXZcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kIGFsbCBzd2lwZSBnZXN0dXJlcy5cblx0ICovXG5cdGJpbmRTd2lwZXMoKSB7XG5cblx0XHRpZiAodGhpcy4kaXRlbXMubGVuZ3RoID4gdGhpcy52aXNpYmxlcykge1xuXHRcdFx0SGVscGVycy5kZXRlY3RTd2lwZSh0aGlzLmVsLCA3NSk7XG5cblx0XHRcdHRoaXMuJGVsLm9uKFZlYW1zLkVWRU5UUy5zd2lwZSwgKGUpID0+IHtcblx0XHRcdFx0bGV0IGRpcmVjdGlvbiA9IGUuZGV0YWlsLmRpcmVjdGlvbjtcblxuXHRcdFx0XHRpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcblx0XHRcdFx0XHR0aGlzLmdvVG9JdGVtKHRoaXMuaW5kZXggKyB0aGlzLnZpc2libGVzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcblx0XHRcdFx0XHR0aGlzLmdvVG9JdGVtKHRoaXMuaW5kZXggLSB0aGlzLnZpc2libGVzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMudG91Y2hTd2lwZUVuYWJsZWQgPSB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGVzIGJ1dHRvblxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gJGJ0biAtIGJ1dHRvbiBlbGVtZW50LlxuXHQgKi9cblx0ZW5hYmxlQnRuKCRidG4pIHtcblx0XHQkYnRuLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5oaWRkZW5DbGFzcyk7XG5cdFx0JGJ0bi5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcblx0XHQkYnRuLnJlbW92ZUF0dHIoJ2FyaWEtZGlzYWJsZWQnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlcyBidXR0b25cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9ICRidG4gLSBidXR0b24gZWxlbWVudC5cblx0ICovXG5cdGRpc2FibGVCdG4oJGJ0bikge1xuXHRcdCRidG4uYWRkQ2xhc3ModGhpcy5vcHRpb25zLmhpZGRlbkNsYXNzKTtcblx0XHQkYnRuLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XG5cdFx0JGJ0bi5hdHRyKCdhcmlhLWRpc2FibGVkJywgdHJ1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyB0aGUgbWV0aG9kIHRvIGdvIHRvIGEgc3BlY2lmaWMgaXRlbS5cblx0ICogRnVydGhlciB3ZSBoYW5kbGUgdGhlIGNsYXNzXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpIC0gSW5kZXggbnVtYmVyLlxuXHQgKi9cblx0Z29Ub0l0ZW0oaSkge1xuXHRcdGxldCBtYXhJbmRleCA9IHRoaXMuJGl0ZW1zLmxlbmd0aCAtIHRoaXMudmlzaWJsZXM7XG5cblx0XHRpZiAobWF4SW5kZXggPCAwKSB7XG5cdFx0XHRtYXhJbmRleCA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLnBhdXNlZCkge1xuXHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7XG5cdFx0XHRpZiAoaSA8IDApIHtcblx0XHRcdFx0aSA9IG1heEluZGV4O1xuXHRcdFx0fSBlbHNlIGlmIChpID4gbWF4SW5kZXgpIHtcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5lbmFibGVCdG4odGhpcy4kcHJldik7XG5cdFx0XHR0aGlzLmVuYWJsZUJ0bih0aGlzLiRuZXh0KTtcblxuXHRcdFx0aWYgKGkgPCAxKSB7XG5cdFx0XHRcdHRoaXMuZGlzYWJsZUJ0bih0aGlzLiRwcmV2KTtcblxuXHRcdFx0XHRpZiAoaSA8IDApIHtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaSA+IG1heEluZGV4IC0gMSkge1xuXHRcdFx0XHR0aGlzLmRpc2FibGVCdG4odGhpcy4kbmV4dCk7XG5cblx0XHRcdFx0aWYgKGkgPiBtYXhJbmRleCkge1xuXHRcdFx0XHRcdGkgPSBtYXhJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuYW5pbWF0ZVNsaWRlKHtcblx0XHRcdGlkeDogaSxcblx0XHRcdGFuaW1hdGU6ICF0aGlzLiRlbC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMudW5yZXNvbHZlZENsYXNzKVxuXHRcdH0pO1xuXG5cdFx0aWYgKHRoaXMuJGVsLmhhc0NsYXNzKHRoaXMub3B0aW9ucy51bnJlc29sdmVkQ2xhc3MpKSB7XG5cdFx0XHR0aGlzLiRlbC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMudW5yZXNvbHZlZENsYXNzKTtcblx0XHR9XG5cblx0XHR0aGlzLmluZGV4ID0gaTtcblxuXHRcdHRoaXMuaGFuZGxlQWN0aXZpdHkoKTtcblxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7XG5cdFx0XHR0aGlzLmNoZWNrU2xpZGVzKCk7XG5cdFx0fVxuXHR9XG5cblx0aGFuZGxlQWN0aXZpdHkoKSB7XG5cdFx0dGhpcy4kaXRlbXMucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblxuXHRcdGlmICghdGhpcy5wYWdpbmF0aW9uRGlzYWJsZWQgJiYgdGhpcy4kcGFnaW5hdGlvbkl0ZW1zICYmIHRoaXMuJHBhZ2luYXRpb25JdGVtcy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuJHBhZ2luYXRpb25JdGVtcy5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoaXMgc2xpZGVyIGluc3RhbmNlIGlzbid0IGluZmluaXRlXG5cdFx0aWYgKCF0aGlzLmluZmluaXRlKSB7XG5cdFx0XHRmb3IgKGxldCBpZHggPSB0aGlzLmluZGV4OyBpZHggPCB0aGlzLmluZGV4ICsgdGhpcy52aXNpYmxlczsgaWR4KyspIHtcblxuXHRcdFx0XHQvLyBGaXJzdCBzZXQgYWN0aXZlIHNsaWRlIGVsZW1lbnQocylcblx0XHRcdFx0dGhpcy4kaXRlbXNcblx0XHRcdFx0XHQuZXEoaWR4KVxuXHRcdFx0XHRcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXG5cdFx0XHRcdC8vIERvIHRoYXQgYWxzbyBmb3IgcGFnaW5hdGlvbiBlbGVtZW50KHMpXG5cdFx0XHRcdGlmICghdGhpcy5wYWdpbmF0aW9uRGlzYWJsZWQpIHtcblx0XHRcdFx0XHR0aGlzLiRwYWdpbmF0aW9uSXRlbXNcblx0XHRcdFx0XHRcdC5lcShpZHgpXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGZvciAobGV0IGlkeCA9IHRoaXMuaW5kZXggLSAxOyBpZHggPCB0aGlzLmluZGV4IC0gMSArIHRoaXMudmlzaWJsZXM7IGlkeCsrKSB7XG5cdFx0XHRcdGxldCBzbGlkZUlkeCA9IGlkeDtcblx0XHRcdFx0dGhpcy4kaXRlbXNcblx0XHRcdFx0XHQuZXEoc2xpZGVJZHggKyAxKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXG5cdFx0XHRcdGlmICghdGhpcy5wYWdpbmF0aW9uRGlzYWJsZWQpIHtcblx0XHRcdFx0XHRpZiAoaWR4ID49IHRoaXMuJHBhZ2luYXRpb25JdGVtcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHNsaWRlSWR4ID0gMDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoaWR4IDwgMCkge1xuXHRcdFx0XHRcdFx0c2xpZGVJZHggPSB0aGlzLiRwYWdpbmF0aW9uSXRlbXMubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLiRwYWdpbmF0aW9uSXRlbXNcblx0XHRcdFx0XHRcdC5lcShzbGlkZUlkeClcblx0XHRcdFx0XHRcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXJ0IGF1dG9wbGF5LlxuXHQgKi9cblx0cGxheSgpIHtcblx0XHRjbGVhckludGVydmFsKHRoaXMuYXV0b1BsYXlJbnRlcnZhbCk7XG5cblx0XHR0aGlzLmF1dG9QbGF5SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG5cdFx0XHR0aGlzLmdvVG9JdGVtKHRoaXMuaW5kZXggKyB0aGlzLnZpc2libGVzKTtcblx0XHR9LCB0aGlzLm9wdGlvbnMuYXV0b1BsYXlJbnRlcnZhbCk7XG5cblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhdXNlIGF1dG9wbGF5LlxuXHQgKi9cblx0cGF1c2UoKSB7XG5cdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLmF1dG9QbGF5SW50ZXJ2YWwpO1xuXHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBkaW1lbnNpb25zIGZvciBvdXIgcHJvamVjdCBwcm9ncmVzcy5cblx0ICovXG5cdGdldEFuZFNldERpbWVuc2lvbnMoKSB7XG5cdFx0dGhpcy5yZXNldFN0eWxlcygpO1xuXHRcdHRoaXMud2lkdGggPSB0aGlzLiR3cmFwcGVyLm91dGVyV2lkdGgoKTtcblx0XHR0aGlzLnRodW1iV2lkdGggPSB0aGlzLndpZHRoIC8gdGhpcy52aXNpYmxlcztcblx0XHR0aGlzLiR3cmFwcGVyLmNzcygnd2lkdGgnLCB0aGlzLndpZHRoICsgJ3B4Jyk7XG5cdFx0dGhpcy4kaXRlbXMuY3NzKCd3aWR0aCcsIHRoaXMudGh1bWJXaWR0aCArICdweCcpO1xuXG5cdFx0dGhpcy4kcmliYm9uLmNzcyh7XG5cdFx0XHR3aWR0aDogdGhpcy5yaWJib25XaWR0aCArICdweCdcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNldCB3aWR0aCBzdHlsZXNcblx0ICovXG5cdHJlc2V0U3R5bGVzKCkge1xuXHRcdHRoaXMuJHdyYXBwZXJbMF0ucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuXHRcdHRoaXMuJGl0ZW1zLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG5cdFx0dGhpcy4kcmliYm9uLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2xpZGVyOyIsIi8qKlxuICogUmVwcmVzZW50cyBhIHNpbXBsZSB0b2dnbGVyIHdpdGggZ2xvYmFsIGV2ZW50IGJpbmRpbmcuXG4gKlxuICogQG1vZHVsZSBUb2dnbGVyXG4gKiBAdmVyc2lvbiB2My4wLjNcbiAqXG4gKiBAYXV0aG9yIEFuZHkgR3V0c2NoZVxuICovXG5cbi8vIEdsb2JhbCBkZXBlbmRlbmNpZXNcbmltcG9ydCB7VmVhbXN9IGZyb20gJ2FwcCc7XG5cbmltcG9ydCBWZWFtc0NvbXBvbmVudCBmcm9tICd2ZWFtcy9zcmMvanMvY29tbW9uL2NvbXBvbmVudCc7XG5cbmNvbnN0ICQgPSBWZWFtcy4kO1xuY29uc3QgSGVscGVycyA9IFZlYW1zLmhlbHBlcnM7XG5cbmNsYXNzIFRvZ2dsZXIgZXh0ZW5kcyBWZWFtc0NvbXBvbmVudCB7XG5cblxuXHQvKipcblx0ICogQ29uc3RydWN0b3IgZm9yIG91ciBjbGFzc1xuXHQgKlxuXHQgKiBAc2VlIG1vZHVsZS5qc1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gT2JqZWN0IHdoaWNoIGlzIHBhc3NlZCB0byBvdXIgY2xhc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IG9iai5lbCAtIGVsZW1lbnQgd2hpY2ggd2lsbCBiZSBzYXZlZCBpbiB0aGlzLmVsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmoub3B0aW9ucyAtIG9wdGlvbnMgd2hpY2ggd2lsbCBiZSBwYXNzZWQgaW4gYXMgSlNPTiBvYmplY3Rcblx0ICovXG5cdGNvbnN0cnVjdG9yKG9iaikge1xuXG5cdFx0bGV0IG9wdGlvbnMgPSB7XG5cdFx0XHRhMTF5Rm9jdXNLZXlDbGFzczogJ2ExMXktZm9jdXMta2V5Jyxcblx0XHRcdGNhbGN1bGF0aW5nQ2xhc3M6ICdpcy1jYWxjdWxhdGluZycsXG5cdFx0XHRjbG9zZUNsYXNzOiAnaXMtY2xvc2VkJyxcblx0XHRcdGNvbnRleHQ6IGZhbHNlLFxuXHRcdFx0ZGF0YU1heEF0dHI6ICdkYXRhLWpzLWhlaWdodCcsXG5cdFx0XHRnbG9iYWxFdmVudDogJycsXG5cdFx0XHRnbG9iYWxFdmVudElkOiAnJyxcblx0XHRcdG9wZW5DbGFzczogJ2lzLW9wZW4nLFxuXHRcdFx0c2V0T3ZlcmZsb3c6IGZhbHNlLFxuXHRcdFx0dG9nZ2xlVGFiaW5kZXhFbGVtczogJydcblx0XHR9O1xuXG5cdFx0c3VwZXIob2JqLCBvcHRpb25zKTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIEdldCBtb2R1bGUgaW5mb3JtYXRpb25cblx0ICovXG5cdHN0YXRpYyBnZXQgaW5mbygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dmVyc2lvbjogJzMuMC4zJyxcblx0XHRcdHZjOiB0cnVlLFxuXHRcdFx0bW9kOiBmYWxzZSAvLyBzZXQgdG8gdHJ1ZSBpZiBzb3VyY2Ugd2FzIG1vZGlmaWVkIGluIHByb2plY3Rcblx0XHR9O1xuXHR9XG5cblxuXHRnZXQgaGVpZ2h0KCkge1xuXHRcdHJldHVybiB0aGlzLl9oZWlnaHQ7XG5cdH1cblxuXG5cdHNldCBoZWlnaHQoaGVpZ2h0KSB7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHR9XG5cblxuXHRnZXQgaXNPcGVuKCkge1xuXHRcdHJldHVybiB0aGlzLl9pc09wZW47XG5cdH1cblxuXG5cdHNldCBpc09wZW4oYm9vbCkge1xuXHRcdHRoaXMuX2lzT3BlbiA9IGJvb2w7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBHZXQgZ2xvYmFsIGV2ZW50c1xuXHQgKlxuXHQgKi9cblx0Z2V0IHN1YnNjcmliZSgpIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHQne3tWZWFtcy5FVkVOVFMucmVzaXplfX0nOiAnb25SZXNpemUnXG5cdFx0fTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIHZpZXcgYW5kIG1lcmdlIG9wdGlvbnNcblx0ICpcblx0ICovXG5cdGluaXRpYWxpemUoKSB7XG5cdFx0bGV0IHNlbGZJbml0ID0gdGhpcy4kZWwuYXR0cignZGF0YS1qcy1tb2R1bGUnKSAmJiB0aGlzLiRlbC5hdHRyKCdkYXRhLWpzLW1vZHVsZScpLmluZGV4T2YoJ3RvZ2dsZXInKSA+IC0xO1xuXG5cdFx0aWYgKHNlbGZJbml0ICYmICF0aGlzLm9wdGlvbnMuZ2xvYmFsRXZlbnQpIHtcblx0XHRcdGNvbnNvbGUuaW5mbygnVG9nZ2xlcjogdGhpcy5vcHRpb25zLmdsb2JhbEV2ZW50IG5vdCBzZXQuJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5pc09wZW4gPSB0aGlzLiRlbC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMub3BlbkNsYXNzKTtcblxuXHRcdHRoaXMuY2FsY3VsYXRlSGVpZ2h0KCkudGhlbigoKSA9PiB7XG5cblx0XHRcdGlmICghdGhpcy5pc09wZW4pIHtcblx0XHRcdFx0dGhpcy5zZXRIZWlnaHQoMCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBCaW5kIGV2ZW50c1xuXHQgKlxuXHQgKiBMaXN0ZW4gdG8gb3BlbiBhbmQgY2xvc2UgZXZlbnRzXG5cdCAqL1xuXHRiaW5kRXZlbnRzKCkge1xuXG5cdFx0Ly8gR2xvYmFsIGV2ZW50c1xuXHRcdGlmICh0aGlzLm9wdGlvbnMuZ2xvYmFsRXZlbnQpIHtcblx0XHRcdHRoaXMucmVnaXN0ZXJFdmVudCgne3t0aGlzLm9wdGlvbnMuZ2xvYmFsRXZlbnR9fScsICd0b2dnbGUnLCB0cnVlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogaGFuZGxlIG9uIHJlc2l6ZSBldmVudFxuXHQgKlxuXHQgKiBjbG9zZSB0aGUgdG9nZ2xlclxuXHQgKlxuXHQgKi9cblx0b25SZXNpemUoKSB7XG5cblx0XHQvLyBnaXZlIGJyb3dzZXIgc29tZSB0aWUgdG8gcmVjYWxjdWxhdGVcblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblxuXHRcdFx0dGhpcy5jYWxjdWxhdGVIZWlnaHQoKS50aGVuKCgpID0+IHtcblx0XHRcdFx0dGhpcy5zZXRIZWlnaHQoKTtcblx0XHRcdH0pO1xuXHRcdH0sIDIwMCk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgY2FsYyBtb2RlLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZW5hYmxlQ2FsY01vZGUoKSB7XG5cblx0XHRpZiAoIXRoaXMuaXNPcGVuKSB7XG5cdFx0XHR0aGlzLiRlbC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMub3BlbkNsYXNzKTtcblx0XHRcdHRoaXMuJGVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jbG9zZUNsYXNzKTtcblx0XHR9XG5cblx0XHR0aGlzLiRlbC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY2FsY3VsYXRpbmdDbGFzcyk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlIGNhbGMgbW9kZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRpc2FibGVDYWxjTW9kZSgpIHtcblxuXHRcdHRoaXMuJGVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jYWxjdWxhdGluZ0NsYXNzKTtcblxuXHRcdGlmICghdGhpcy5pc09wZW4pIHtcblx0XHRcdHRoaXMuJGVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jbG9zZUNsYXNzKTtcblx0XHRcdHRoaXMuJGVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5vcGVuQ2xhc3MpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuc2V0SGVpZ2h0KCk7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogU2V0IGhlaWdodCBvZiBjdXJyZW50IHZpZXcgZWxlbWVudCB0byBnaXZlbiB2YWx1ZSBvciBsYXRlc3QgY2FsY3VsYXRlZCB2YWx1ZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHRdIC0gaGVpZ2h0XG5cdCAqL1xuXHRzZXRIZWlnaHQoaGVpZ2h0KSB7XG5cdFx0dGhpcy4kZWwuY3NzKCdoZWlnaHQnLFxuXHRcdFx0dHlwZW9mIGhlaWdodCA9PT0gJ251bWJlcicgPyBoZWlnaHQgKyAncHgnIDogdGhpcy4kZWwuYXR0cih0aGlzLm9wdGlvbnMuZGF0YU1heEF0dHIpICsgJ3B4Jyk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBDYWxjIHRoZSBoZWlnaHQgb2YgY3VycmVudCB2aWV3IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjYWxjSGVpZ2h0KCkge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0bGV0IHdhbnRlZEhlaWdodCA9IHRoaXMuJGVsLm91dGVySGVpZ2h0KCk7XG5cblx0XHRcdFx0dGhpcy4kZWwuYXR0cih0aGlzLm9wdGlvbnMuZGF0YU1heEF0dHIsIHdhbnRlZEhlaWdodCk7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gd2FudGVkSGVpZ2h0ICE9PSB0aGlzLmhlaWdodCA/IHdhbnRlZEhlaWdodCA6IHRoaXMuaGVpZ2h0O1xuXG5cdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdH0sIDEwKTtcblx0XHR9KTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFNhdmUgYWxsIHN0eWxlcyBmcm9tIGN1cnJlbnQgdmlldyBlbGVtZW50XG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzYXZlU3R5bGVzKCkge1xuXHRcdHRoaXMuc2F2ZWRTdHlsZXMgPSB0aGlzLiRlbC5hdHRyKCdzdHlsZScpO1xuXHR9XG5cblxuXHQvKipcblx0ICogUmVzdG9yZSBhbGwgc3R5bGVzIGZyb20gY3VycmVudCB2aWV3IGVsZW1lbnRcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlc3RvcmVTdHlsZXMoKSB7XG5cdFx0dGhpcy4kZWwuYXR0cignc3R5bGUnLCB0aGlzLnNhdmVkU3R5bGVzKTtcblx0XHRkZWxldGUgdGhpcy5zYXZlZFN0eWxlcztcblx0fVxuXG5cblx0LyoqXG5cdCAqIFRvZ2dsZXMgY29udGVudFxuXHQgKlxuXHQgKiBAcHVibGljXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgZXZlbnQgZGF0YVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IG9iai5pc0FjdGl2ZSAtIGluZGljYXRlcyBpZiBwYW5lbCBzaG91bGQgb3BlbiBvciBjbG9zZSBpdHNlbGZcblx0ICogQHBhcmFtIHtTdHJpbmd9IG9iai5vcHRpb25zLnNldEZvY3VzIC0gZWxlbWVudCB0byBzZXQgZm9jdXMgb24gb3BlblxuXHQgKi9cblx0dG9nZ2xlKG9iaikge1xuXG5cdFx0Ly9jb25zb2xlLmxvZygnb2JqJywgb2JqKTtcblxuXHRcdC8vIGlmIGdsb2JhbEV2ZW50SWQgaXMgc2V0IG9uIGJvdGggKGN0YSBhbmQgdG9nZ2xlcilcblx0XHRpZiAodGhpcy5vcHRpb25zLmdsb2JhbEV2ZW50SWQgJiYgb2JqLm9wdGlvbnMgJiYgb2JqLm9wdGlvbnMuZ2xvYmFsRXZlbnRJZCkge1xuXG5cdFx0XHQvLyBzdG9wIGhlcmUgaWYgZ2xvYmFsIGV2ZW50IGlkIGRvbid0IG1hdGNoXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmdsb2JhbEV2ZW50SWQgIT09IG9iai5vcHRpb25zLmdsb2JhbEV2ZW50SWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0aWYgKG9iai5pc0FjdGl2ZSkge1xuXHRcdFx0dGhpcy5vcGVuKG9iaik7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5jbG9zZSgpO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIE9wZW4gY3VycmVudCB2aWV3IGVsZW1lbnRcblx0ICpcblx0ICogQHB1YmxpY1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29ial0gLSB0aGUgZXZlbnQgb2JqZWN0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29iai5pc0FjdGl2ZV0gLSBpbmRpY2F0ZXMgaWYgcGFuZWwgc2hvdWxkIG9wZW4gb3IgY2xvc2UgaXRzZWxmXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbb2JqLm9wdGlvbnMuc2V0Rm9jdXNdIC0gZWxlbWVudCB0byBzZXQgZm9jdXMgb24gb3BlblxuXHQgKi9cblx0b3BlbihvYmopIHtcblx0XHR0aGlzLiRlbC5jc3MoJ2hlaWdodCcsIHRoaXMuJGVsLmF0dHIodGhpcy5vcHRpb25zLmRhdGFNYXhBdHRyKSArICdweCcpXG5cdFx0XHQuYXR0cignYXJpYS1oaWRkZW4nLCBmYWxzZSlcblx0XHRcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuY2xvc2VDbGFzcylcblx0XHRcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMub3BlbkNsYXNzKTtcblxuXHRcdGlmIChvYmogJiYgb2JqLmZvY3VzRWwpIHtcblxuXHRcdFx0dGhpcy4kZWwub24oSGVscGVycy50cmFuc2l0aW9uRW5kRXZlbnQoKSwgKCkgPT4ge1xuXHRcdFx0XHRvYmouZm9jdXNFbC5mb2N1cygpO1xuXHRcdFx0XHR0aGlzLiRlbC5vZmYoSGVscGVycy50cmFuc2l0aW9uRW5kRXZlbnQoKSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRWZWFtcy5WZW50LnRyaWdnZXIoVmVhbXMuRVZFTlRTLnRvZ2dsZXIub3Blbiwge1xuXHRcdFx0Y29udGV4dDogdGhpcy5vcHRpb25zLmNvbnRleHRcblx0XHR9KTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc2V0T3ZlcmZsb3cpIHtcblxuXHRcdFx0dGhpcy4kZWwub24oSGVscGVycy50cmFuc2l0aW9uRW5kRXZlbnQoKSwgKCkgPT4ge1xuXHRcdFx0XHR0aGlzLiRlbC5jc3MoJ292ZXJmbG93JywgJ3Zpc2libGUnKTtcblx0XHRcdFx0dGhpcy4kZWwub2ZmKEhlbHBlcnMudHJhbnNpdGlvbkVuZEV2ZW50KCkpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy50b2dnbGVUYWJpbmRleEVsZW1zKSB7XG5cdFx0XHQkKHRoaXMub3B0aW9ucy50b2dnbGVUYWJpbmRleEVsZW1zLCB0aGlzLmVsKS5hdHRyKCd0YWJpbmRleCcsIDApO1xuXHRcdH1cblxuXHRcdHRoaXMuaXNPcGVuID0gdHJ1ZTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIENsb3NlIGN1cnJlbnQgdmlldyBlbGVtZW50XG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdGNsb3NlKCkge1xuXHRcdHRoaXMuJGVsLmNzcygnaGVpZ2h0JywgMClcblx0XHRcdC5yZW1vdmVBdHRyKCdzdHlsZScpXG5cdFx0XHQuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpXG5cdFx0XHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLm9wZW5DbGFzcylcblx0XHRcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY2xvc2VDbGFzcyk7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLnNldE92ZXJmbG93KSB7XG5cdFx0XHR0aGlzLiRlbC5jc3MoJ292ZXJmbG93JywgJ2hpZGRlbicpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMudG9nZ2xlVGFiaW5kZXhFbGVtcykge1xuXHRcdFx0JCh0aGlzLm9wdGlvbnMudG9nZ2xlVGFiaW5kZXhFbGVtcywgdGhpcy5lbCkuYXR0cigndGFiaW5kZXgnLCAtMSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5pc09wZW4gPSBmYWxzZTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIGNhbGN1bGF0ZUhlaWdodCBjbGFzc1xuXHQgKi9cblx0Y2FsY3VsYXRlSGVpZ2h0KCkge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRpZiAodGhpcy5lbCAmJiB0aGlzLmVsLmhhc0F0dHJpYnV0ZSgnc3R5bGUnKSkge1xuXHRcdFx0XHR0aGlzLnNhdmVTdHlsZXMoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5lbmFibGVDYWxjTW9kZSh0cnVlKTtcblxuXHRcdFx0dGhpcy5jYWxjSGVpZ2h0KCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdGlmICh0aGlzLnNhdmVkU3R5bGVzKSB7XG5cdFx0XHRcdFx0dGhpcy5yZXN0b3JlU3R5bGVzKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmRpc2FibGVDYWxjTW9kZSgpO1xuXG5cdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvZ2dsZXI7IiwiLy8gR2xvYmFsIGRlcGVuZGVuY2llcyBcbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgVmVhbXMgZnJvbSAndmVhbXMnO1xuXG5jb25zdCBIYW5kbGViYXJzID0gcmVxdWlyZSgnaGFuZGxlYmFycy9ydW50aW1lJyk7XG5jb25zdCBUZW1wbGF0ZXMgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy90ZW1wbGF0ZXMnKTtcblxuaW1wb3J0IFZlYW1zTG9nZ2VyIGZyb20gJ3ZlYW1zLXBsdWdpbi1sb2dnZXInO1xuaW1wb3J0IFZlYW1zRE9NIGZyb20gJ3ZlYW1zLXBsdWdpbi1kb20nO1xuaW1wb3J0IFZlYW1zVmVudCBmcm9tICd2ZWFtcy1wbHVnaW4tdmVudCc7XG5pbXBvcnQgVmVhbXNNb2R1bGVzIGZyb20gJ3ZlYW1zLXBsdWdpbi1tb2R1bGVzJztcbmltcG9ydCBWZWFtc01lZGlhUXVlcnlIYW5kbGVyIGZyb20gJ3ZlYW1zLXBsdWdpbi1tZWRpYS1xdWVyeS1oYW5kbGVyJztcbi8vIGltcG9ydCBWZWFtc1N0b3JlIGZyb20gJ3ZlYW1zLXBsdWdpbi1zdG9yZSc7XG5pbXBvcnQgVmVhbXNUZW1wbGF0ZXIgZnJvbSAndmVhbXMtcGx1Z2luLXRlbXBsYXRlcic7XG5pbXBvcnQgRVZFTlRTIGZyb20gJy4vZXZlbnRzJztcblxuLy8gVHJpZ2dlciBnbG9iYWwgcmVzaXplIGV2ZW50XG53aW5kb3cub25zY3JvbGwgPSBWZWFtcy5oZWxwZXJzLnRocm90dGxlKChlKSA9PiB7XG4gICAgVmVhbXMuVmVudC50cmlnZ2VyKFZlYW1zLkVWRU5UUy5zY3JvbGwsIGUpO1xufSwgMjAwKTtcblxuXG5sZXQgQXBwID0ge307XG5BcHAuJCA9ICQ7XG5cbi8vIFZlcnNpb25pbmdcbkFwcC52ZXJzaW9uID0gXCIwLjAuMVwiO1xuXG4vLyBWZWFtc1xuVmVhbXMub25Jbml0aWFsaXplKCgpID0+IHtcblx0LyoqXG5cdCogVmVhbXMgUGx1Z2luc1xuXHQqL1xuXG5cdC8vIERvbSBQbHVnaW5cblx0VmVhbXMudXNlKFZlYW1zRE9NLCB7XG5cdFx0RE9NOiAkXG5cdH0pO1xuXG5cdC8vIFZlbnQgUGx1Z2luXG5cdFZlYW1zLnVzZShWZWFtc1ZlbnQsIHtcblx0XHRmdXJ0aGVyRXZlbnRzOiBFVkVOVFNcblx0fSk7XG5cblxuICAgIFZlYW1zLnVzZShWZWFtc1RlbXBsYXRlciwge1xuICAgICAgICB0ZW1wbGF0ZXM6IFRlbXBsYXRlcyxcbiAgICAgICAgZW5naW5lOiBIYW5kbGViYXJzXG4gICAgfSk7XG5cblxuICAgIC8vIExvZ2dlciBQbHVnaW4gZm9yIGRldm1vZGUgYW5kIGxvZ2dlclxuXHRWZWFtcy51c2UoVmVhbXNMb2dnZXIpO1xuXG5cdC8vIE1vZHVsZSBTeXN0ZW0gUGx1Z2luXG5cdFZlYW1zLnVzZShWZWFtc01vZHVsZXMsIHtcblx0XHR1c2VNdXRhdGlvbk9ic2VydmVyOiB0cnVlLFxuXHRcdGludGVybmFsQ2FjaGVPbmx5OiBmYWxzZVxuXHR9KTtcblxuXHQvLyBTdG9yZSBQbHVnaW5cblx0Ly8gVmVhbXMudXNlKFZlYW1zU3RvcmUsIHtcblx0Ly8gXHRyZWR1Y2VyOiByb290UmVkdWNlcixcblx0Ly8gXHRzdGF0ZTogSU5JVElBTF9TVEFURSxcblx0Ly8gXHRzdWJqZWN0czogc3ViamVjdHNcblx0Ly8gfSk7XG5cblx0Ly8gTWVkaWEgUXVlcnkgSGFuZGxlciBQbHVnaW5cblx0VmVhbXMudXNlKFZlYW1zTWVkaWFRdWVyeUhhbmRsZXIpO1xufSk7XG5cbmV4cG9ydCB7QXBwLCBWZWFtc307Il19
