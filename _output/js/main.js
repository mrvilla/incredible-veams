require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _handlebarsBase = require('./handlebars/base');

var base = _interopRequireWildcard(_handlebarsBase);

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)

var _handlebarsSafeString = require('./handlebars/safe-string');

var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);

var _handlebarsException = require('./handlebars/exception');

var _handlebarsException2 = _interopRequireDefault(_handlebarsException);

var _handlebarsUtils = require('./handlebars/utils');

var Utils = _interopRequireWildcard(_handlebarsUtils);

var _handlebarsRuntime = require('./handlebars/runtime');

var runtime = _interopRequireWildcard(_handlebarsRuntime);

var _handlebarsNoConflict = require('./handlebars/no-conflict');

var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
function create() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = _handlebarsSafeString2['default'];
  hb.Exception = _handlebarsException2['default'];
  hb.Utils = Utils;
  hb.escapeExpression = Utils.escapeExpression;

  hb.VM = runtime;
  hb.template = function (spec) {
    return runtime.template(spec, hb);
  };

  return hb;
}

var inst = create();
inst.create = create;

_handlebarsNoConflict2['default'](inst);

inst['default'] = inst;

exports['default'] = inst;
module.exports = exports['default'];


},{"./handlebars/base":2,"./handlebars/exception":5,"./handlebars/no-conflict":15,"./handlebars/runtime":16,"./handlebars/safe-string":17,"./handlebars/utils":18}],2:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('./utils');

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _helpers = require('./helpers');

var _decorators = require('./decorators');

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

var VERSION = '4.0.10';
exports.VERSION = VERSION;
var COMPILER_REVISION = 7;

exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '== 1.x.x',
  5: '== 2.0.0-alpha.x',
  6: '>= 2.0.0-beta.1',
  7: '>= 4.0.0'
};

exports.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials, decorators) {
  this.helpers = helpers || {};
  this.partials = partials || {};
  this.decorators = decorators || {};

  _helpers.registerDefaultHelpers(this);
  _decorators.registerDefaultDecorators(this);
}

HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: _logger2['default'],
  log: _logger2['default'].log,

  registerHelper: function registerHelper(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple helpers');
      }
      _utils.extend(this.helpers, name);
    } else {
      this.helpers[name] = fn;
    }
  },
  unregisterHelper: function unregisterHelper(name) {
    delete this.helpers[name];
  },

  registerPartial: function registerPartial(name, partial) {
    if (_utils.toString.call(name) === objectType) {
      _utils.extend(this.partials, name);
    } else {
      if (typeof partial === 'undefined') {
        throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
      }
      this.partials[name] = partial;
    }
  },
  unregisterPartial: function unregisterPartial(name) {
    delete this.partials[name];
  },

  registerDecorator: function registerDecorator(name, fn) {
    if (_utils.toString.call(name) === objectType) {
      if (fn) {
        throw new _exception2['default']('Arg not supported with multiple decorators');
      }
      _utils.extend(this.decorators, name);
    } else {
      this.decorators[name] = fn;
    }
  },
  unregisterDecorator: function unregisterDecorator(name) {
    delete this.decorators[name];
  }
};

var log = _logger2['default'].log;

exports.log = log;
exports.createFrame = _utils.createFrame;
exports.logger = _logger2['default'];


},{"./decorators":3,"./exception":5,"./helpers":6,"./logger":14,"./utils":18}],3:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultDecorators = registerDefaultDecorators;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _decoratorsInline = require('./decorators/inline');

var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);

function registerDefaultDecorators(instance) {
  _decoratorsInline2['default'](instance);
}


},{"./decorators/inline":4}],4:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerDecorator('inline', function (fn, props, container, options) {
    var ret = fn;
    if (!props.partials) {
      props.partials = {};
      ret = function (context, options) {
        // Create a new partials stack frame prior to exec.
        var original = container.partials;
        container.partials = _utils.extend({}, original, props.partials);
        var ret = fn(context, options);
        container.partials = original;
        return ret;
      };
    }

    props.partials[options.args[0]] = options.fn;

    return ret;
  });
};

module.exports = exports['default'];


},{"../utils":18}],5:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var loc = node && node.loc,
      line = undefined,
      column = undefined;
  if (loc) {
    line = loc.start.line;
    column = loc.start.column;

    message += ' - ' + line + ':' + column;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  /* istanbul ignore else */
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, Exception);
  }

  try {
    if (loc) {
      this.lineNumber = line;

      // Work around issue under safari where we can't directly set the column value
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(this, 'column', {
          value: column,
          enumerable: true
        });
      } else {
        this.column = column;
      }
    }
  } catch (nop) {
    /* Ignore if the browser is very particular */
  }
}

Exception.prototype = new Error();

exports['default'] = Exception;
module.exports = exports['default'];


},{}],6:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.registerDefaultHelpers = registerDefaultHelpers;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _helpersBlockHelperMissing = require('./helpers/block-helper-missing');

var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);

var _helpersEach = require('./helpers/each');

var _helpersEach2 = _interopRequireDefault(_helpersEach);

var _helpersHelperMissing = require('./helpers/helper-missing');

var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);

var _helpersIf = require('./helpers/if');

var _helpersIf2 = _interopRequireDefault(_helpersIf);

var _helpersLog = require('./helpers/log');

var _helpersLog2 = _interopRequireDefault(_helpersLog);

var _helpersLookup = require('./helpers/lookup');

var _helpersLookup2 = _interopRequireDefault(_helpersLookup);

var _helpersWith = require('./helpers/with');

var _helpersWith2 = _interopRequireDefault(_helpersWith);

function registerDefaultHelpers(instance) {
  _helpersBlockHelperMissing2['default'](instance);
  _helpersEach2['default'](instance);
  _helpersHelperMissing2['default'](instance);
  _helpersIf2['default'](instance);
  _helpersLog2['default'](instance);
  _helpersLookup2['default'](instance);
  _helpersWith2['default'](instance);
}


},{"./helpers/block-helper-missing":7,"./helpers/each":8,"./helpers/helper-missing":9,"./helpers/if":10,"./helpers/log":11,"./helpers/lookup":12,"./helpers/with":13}],7:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('blockHelperMissing', function (context, options) {
    var inverse = options.inverse,
        fn = options.fn;

    if (context === true) {
      return fn(this);
    } else if (context === false || context == null) {
      return inverse(this);
    } else if (_utils.isArray(context)) {
      if (context.length > 0) {
        if (options.ids) {
          options.ids = [options.name];
        }

        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      if (options.data && options.ids) {
        var data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
        options = { data: data };
      }

      return fn(context, options);
    }
  });
};

module.exports = exports['default'];


},{"../utils":18}],8:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _utils = require('../utils');

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('each', function (context, options) {
    if (!options) {
      throw new _exception2['default']('Must pass iterator to #each');
    }

    var fn = options.fn,
        inverse = options.inverse,
        i = 0,
        ret = '',
        data = undefined,
        contextPath = undefined;

    if (options.data && options.ids) {
      contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
    }

    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    if (options.data) {
      data = _utils.createFrame(options.data);
    }

    function execIteration(field, index, last) {
      if (data) {
        data.key = field;
        data.index = index;
        data.first = index === 0;
        data.last = !!last;

        if (contextPath) {
          data.contextPath = contextPath + field;
        }
      }

      ret = ret + fn(context[field], {
        data: data,
        blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
      });
    }

    if (context && typeof context === 'object') {
      if (_utils.isArray(context)) {
        for (var j = context.length; i < j; i++) {
          if (i in context) {
            execIteration(i, i, i === context.length - 1);
          }
        }
      } else {
        var priorKey = undefined;

        for (var key in context) {
          if (context.hasOwnProperty(key)) {
            // We're running the iterations one step out of sync so we can detect
            // the last iteration without have to scan the object twice and create
            // an itermediate keys array.
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1);
            }
            priorKey = key;
            i++;
          }
        }
        if (priorKey !== undefined) {
          execIteration(priorKey, i - 1, true);
        }
      }
    }

    if (i === 0) {
      ret = inverse(this);
    }

    return ret;
  });
};

module.exports = exports['default'];


},{"../exception":5,"../utils":18}],9:[function(require,module,exports){
'use strict';

exports.__esModule = true;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _exception = require('../exception');

var _exception2 = _interopRequireDefault(_exception);

exports['default'] = function (instance) {
  instance.registerHelper('helperMissing', function () /* [args, ]options */{
    if (arguments.length === 1) {
      // A missing field in a {{foo}} construct.
      return undefined;
    } else {
      // Someone is actually trying to call something, blow up.
      throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
    }
  });
};

module.exports = exports['default'];


},{"../exception":5}],10:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('if', function (conditional, options) {
    if (_utils.isFunction(conditional)) {
      conditional = conditional.call(this);
    }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function (conditional, options) {
    return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
  });
};

module.exports = exports['default'];


},{"../utils":18}],11:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('log', function () /* message, options */{
    var args = [undefined],
        options = arguments[arguments.length - 1];
    for (var i = 0; i < arguments.length - 1; i++) {
      args.push(arguments[i]);
    }

    var level = 1;
    if (options.hash.level != null) {
      level = options.hash.level;
    } else if (options.data && options.data.level != null) {
      level = options.data.level;
    }
    args[0] = level;

    instance.log.apply(instance, args);
  });
};

module.exports = exports['default'];


},{}],12:[function(require,module,exports){
'use strict';

exports.__esModule = true;

exports['default'] = function (instance) {
  instance.registerHelper('lookup', function (obj, field) {
    return obj && obj[field];
  });
};

module.exports = exports['default'];


},{}],13:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('../utils');

exports['default'] = function (instance) {
  instance.registerHelper('with', function (context, options) {
    if (_utils.isFunction(context)) {
      context = context.call(this);
    }

    var fn = options.fn;

    if (!_utils.isEmpty(context)) {
      var data = options.data;
      if (options.data && options.ids) {
        data = _utils.createFrame(options.data);
        data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
      }

      return fn(context, {
        data: data,
        blockParams: _utils.blockParams([context], [data && data.contextPath])
      });
    } else {
      return options.inverse(this);
    }
  });
};

module.exports = exports['default'];


},{"../utils":18}],14:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _utils = require('./utils');

var logger = {
  methodMap: ['debug', 'info', 'warn', 'error'],
  level: 'info',

  // Maps a given level value to the `methodMap` indexes above.
  lookupLevel: function lookupLevel(level) {
    if (typeof level === 'string') {
      var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
      if (levelMap >= 0) {
        level = levelMap;
      } else {
        level = parseInt(level, 10);
      }
    }

    return level;
  },

  // Can be overridden in the host environment
  log: function log(level) {
    level = logger.lookupLevel(level);

    if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
      var method = logger.methodMap[level];
      if (!console[method]) {
        // eslint-disable-line no-console
        method = 'log';
      }

      for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        message[_key - 1] = arguments[_key];
      }

      console[method].apply(console, message); // eslint-disable-line no-console
    }
  }
};

exports['default'] = logger;
module.exports = exports['default'];


},{"./utils":18}],15:[function(require,module,exports){
(function (global){
/* global window */
'use strict';

exports.__esModule = true;

exports['default'] = function (Handlebars) {
  /* istanbul ignore next */
  var root = typeof global !== 'undefined' ? global : window,
      $Handlebars = root.Handlebars;
  /* istanbul ignore next */
  Handlebars.noConflict = function () {
    if (root.Handlebars === Handlebars) {
      root.Handlebars = $Handlebars;
    }
    return Handlebars;
  };
};

module.exports = exports['default'];


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],16:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.checkRevision = checkRevision;
exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;
// istanbul ignore next

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// istanbul ignore next

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

var _utils = require('./utils');

var Utils = _interopRequireWildcard(_utils);

var _exception = require('./exception');

var _exception2 = _interopRequireDefault(_exception);

var _base = require('./base');

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = _base.COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
          compilerVersions = _base.REVISION_CHANGES[compilerRevision];
      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    }
  }
}

function template(templateSpec, env) {
  /* istanbul ignore next */
  if (!env) {
    throw new _exception2['default']('No environment passed to template');
  }
  if (!templateSpec || !templateSpec.main) {
    throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
  }

  templateSpec.main.decorator = templateSpec.main_d;

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  env.VM.checkRevision(templateSpec.compiler);

  function invokePartialWrapper(partial, context, options) {
    if (options.hash) {
      context = Utils.extend({}, context, options.hash);
      if (options.ids) {
        options.ids[0] = true;
      }
    }

    partial = env.VM.resolvePartial.call(this, partial, context, options);
    var result = env.VM.invokePartial.call(this, partial, context, options);

    if (result == null && env.compile) {
      options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
      result = options.partials[options.name](context, options);
    }
    if (result != null) {
      if (options.indent) {
        var lines = result.split('\n');
        for (var i = 0, l = lines.length; i < l; i++) {
          if (!lines[i] && i + 1 === l) {
            break;
          }

          lines[i] = options.indent + lines[i];
        }
        result = lines.join('\n');
      }
      return result;
    } else {
      throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
    }
  }

  // Just add water
  var container = {
    strict: function strict(obj, name) {
      if (!(name in obj)) {
        throw new _exception2['default']('"' + name + '" not defined in ' + obj);
      }
      return obj[name];
    },
    lookup: function lookup(depths, name) {
      var len = depths.length;
      for (var i = 0; i < len; i++) {
        if (depths[i] && depths[i][name] != null) {
          return depths[i][name];
        }
      }
    },
    lambda: function lambda(current, context) {
      return typeof current === 'function' ? current.call(context) : current;
    },

    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,

    fn: function fn(i) {
      var ret = templateSpec[i];
      ret.decorator = templateSpec[i + '_d'];
      return ret;
    },

    programs: [],
    program: function program(i, data, declaredBlockParams, blockParams, depths) {
      var programWrapper = this.programs[i],
          fn = this.fn(i);
      if (data || depths || blockParams || declaredBlockParams) {
        programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = wrapProgram(this, i, fn);
      }
      return programWrapper;
    },

    data: function data(value, depth) {
      while (value && depth--) {
        value = value._parent;
      }
      return value;
    },
    merge: function merge(param, common) {
      var obj = param || common;

      if (param && common && param !== common) {
        obj = Utils.extend({}, common, param);
      }

      return obj;
    },
    // An empty object to use as replacement for null-contexts
    nullContext: Object.seal({}),

    noop: env.VM.noop,
    compilerInfo: templateSpec.compiler
  };

  function ret(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var data = options.data;

    ret._setup(options);
    if (!options.partial && templateSpec.useData) {
      data = initData(context, data);
    }
    var depths = undefined,
        blockParams = templateSpec.useBlockParams ? [] : undefined;
    if (templateSpec.useDepths) {
      if (options.depths) {
        depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
      } else {
        depths = [context];
      }
    }

    function main(context /*, options*/) {
      return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
    }
    main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
    return main(context, options);
  }
  ret.isTop = true;

  ret._setup = function (options) {
    if (!options.partial) {
      container.helpers = container.merge(options.helpers, env.helpers);

      if (templateSpec.usePartial) {
        container.partials = container.merge(options.partials, env.partials);
      }
      if (templateSpec.usePartial || templateSpec.useDecorators) {
        container.decorators = container.merge(options.decorators, env.decorators);
      }
    } else {
      container.helpers = options.helpers;
      container.partials = options.partials;
      container.decorators = options.decorators;
    }
  };

  ret._child = function (i, data, blockParams, depths) {
    if (templateSpec.useBlockParams && !blockParams) {
      throw new _exception2['default']('must pass block params');
    }
    if (templateSpec.useDepths && !depths) {
      throw new _exception2['default']('must pass parent depths');
    }

    return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
  };
  return ret;
}

function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
  function prog(context) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var currentDepths = depths;
    if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
      currentDepths = [context].concat(depths);
    }

    return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
  }

  prog = executeDecorators(fn, prog, container, depths, data, blockParams);

  prog.program = i;
  prog.depth = depths ? depths.length : 0;
  prog.blockParams = declaredBlockParams || 0;
  return prog;
}

function resolvePartial(partial, context, options) {
  if (!partial) {
    if (options.name === '@partial-block') {
      partial = options.data['partial-block'];
    } else {
      partial = options.partials[options.name];
    }
  } else if (!partial.call && !options.name) {
    // This is a dynamic partial that returned a string
    options.name = partial;
    partial = options.partials[partial];
  }
  return partial;
}

function invokePartial(partial, context, options) {
  // Use the current closure context to save the partial-block if this partial
  var currentPartialBlock = options.data && options.data['partial-block'];
  options.partial = true;
  if (options.ids) {
    options.data.contextPath = options.ids[0] || options.data.contextPath;
  }

  var partialBlock = undefined;
  if (options.fn && options.fn !== noop) {
    (function () {
      options.data = _base.createFrame(options.data);
      // Wrapper function to get access to currentPartialBlock from the closure
      var fn = options.fn;
      partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
        var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        // Restore the partial-block from the closure for the execution of the block
        // i.e. the part inside the block of the partial call.
        options.data = _base.createFrame(options.data);
        options.data['partial-block'] = currentPartialBlock;
        return fn(context, options);
      };
      if (fn.partials) {
        options.partials = Utils.extend({}, options.partials, fn.partials);
      }
    })();
  }

  if (partial === undefined && partialBlock) {
    partial = partialBlock;
  }

  if (partial === undefined) {
    throw new _exception2['default']('The partial ' + options.name + ' could not be found');
  } else if (partial instanceof Function) {
    return partial(context, options);
  }
}

function noop() {
  return '';
}

function initData(context, data) {
  if (!data || !('root' in data)) {
    data = data ? _base.createFrame(data) : {};
    data.root = context;
  }
  return data;
}

function executeDecorators(fn, prog, container, depths, data, blockParams) {
  if (fn.decorator) {
    var props = {};
    prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
    Utils.extend(prog, props);
  }
  return prog;
}


},{"./base":2,"./exception":5,"./utils":18}],17:[function(require,module,exports){
// Build out our basic SafeString type
'use strict';

exports.__esModule = true;
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
  return '' + this.string;
};

exports['default'] = SafeString;
module.exports = exports['default'];


},{}],18:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.extend = extend;
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.createFrame = createFrame;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;',
  '=': '&#x3D;'
};

var badChars = /[&<>"'`=]/g,
    possible = /[&<>"'`=]/;

function escapeChar(chr) {
  return escape[chr];
}

function extend(obj /* , ...source */) {
  for (var i = 1; i < arguments.length; i++) {
    for (var key in arguments[i]) {
      if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
        obj[key] = arguments[i][key];
      }
    }
  }

  return obj;
}

var toString = Object.prototype.toString;

exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
/* eslint-disable func-style */
var isFunction = function isFunction(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
/* istanbul ignore next */
if (isFunction(/x/)) {
  exports.isFunction = isFunction = function (value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
exports.isFunction = isFunction;

/* eslint-enable func-style */

/* istanbul ignore next */
var isArray = Array.isArray || function (value) {
  return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
};

exports.isArray = isArray;
// Older IE versions do not directly support indexOf so we must implement our own, sadly.

function indexOf(array, value) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (array[i] === value) {
      return i;
    }
  }
  return -1;
}

function escapeExpression(string) {
  if (typeof string !== 'string') {
    // don't escape SafeStrings, since they're already safe
    if (string && string.toHTML) {
      return string.toHTML();
    } else if (string == null) {
      return '';
    } else if (!string) {
      return string + '';
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = '' + string;
  }

  if (!possible.test(string)) {
    return string;
  }
  return string.replace(badChars, escapeChar);
}

function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

function createFrame(object) {
  var frame = extend({}, object);
  frame._parent = object;
  return frame;
}

function blockParams(params, ids) {
  params.path = ids;
  return params;
}

function appendContextPath(contextPath, id) {
  return (contextPath ? contextPath + '.' : '') + id;
}


},{}],19:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime')['default'];

},{"./dist/cjs/handlebars.runtime":1}],20:[function(require,module,exports){
//! moment.js
//! version : 2.18.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
        // even if its not own property I'd still call it non-empty
        return false;
    }
    return true;
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

var some$1 = some;

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var keys$1 = keys;

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid()) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

var indexOf$1 = indexOf;

function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            require('./locale/' + name);
            // because defineLocale currently also sets the global locale, we
            // want to undo that for lazy loaded locales
            getSetGlobalLocale(oldLocale);
        } catch (e) { }
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys$1(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var string, match, dayFormat,
        dateFormat, timeFormat, tzFormat;
    var timezones = {
        ' GMT': ' +0000',
        ' EDT': ' -0400',
        ' EST': ' -0500',
        ' CDT': ' -0500',
        ' CST': ' -0600',
        ' MDT': ' -0600',
        ' MST': ' -0700',
        ' PDT': ' -0700',
        ' PST': ' -0800'
    };
    var military = 'YXWVUTSRQPONZABCDEFGHIKLM';
    var timezone, timezoneIndex;

    string = config._i
        .replace(/\([^\)]*\)|[\n\t]/g, ' ') // Remove comments and folding whitespace
        .replace(/(\s\s+)/g, ' ') // Replace multiple-spaces with a single space
        .replace(/^\s|\s$/g, ''); // Remove leading and trailing spaces
    match = basicRfcRegex.exec(string);

    if (match) {
        dayFormat = match[1] ? 'ddd' + ((match[1].length === 5) ? ', ' : ' ') : '';
        dateFormat = 'D MMM ' + ((match[2].length > 10) ? 'YYYY ' : 'YY ');
        timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');

        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        if (match[1]) { // day of week given
            var momentDate = new Date(match[2]);
            var momentDay = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][momentDate.getDay()];

            if (match[1].substr(0,3) !== momentDay) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return;
            }
        }

        switch (match[5].length) {
            case 2: // military
                if (timezoneIndex === 0) {
                    timezone = ' +0000';
                } else {
                    timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;
                    timezone = ((timezoneIndex < 0) ? ' -' : ' +') +
                        (('' + timezoneIndex).replace(/^-?/, '0')).match(/..$/)[0] + '00';
                }
                break;
            case 4: // Zone
                timezone = timezones[match[5]];
                break;
            default: // UT or +/-9999
                timezone = timezones[' GMT'];
        }
        match[5] = timezone;
        config._i = match.splice(1).join('');
        tzFormat = ' ZZ';
        config._f = dayFormat + dateFormat + timeFormat + tzFormat;
        configFromStringAndFormat(config);
        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
            output = output / 3;
        } else if (units === 'year') {
            output = output / 12;
        }
    } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : // 1000
            units === 'minute' ? delta / 6e4 : // 1000 * 60
            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
            delta;
    }
    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString() {
    if (!this.isValid()) {
        return null;
    }
    var m = this.clone().utc();
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        return this.toDate().toISOString();
    }
    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    return (total < 0 ? '-' : '') +
        'P' +
        (Y ? Y + 'Y' : '') +
        (M ? M + 'M' : '') +
        (D ? D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? h + 'H' : '') +
        (m ? m + 'M' : '') +
        (s ? s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.18.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));

},{}],21:[function(require,module,exports){
/*!
 * Pikaday
 *
 * Copyright © 2014 David Bushell | BSD & MIT license | https://github.com/dbushell/Pikaday
 */

(function (root, factory)
{
    'use strict';

    var moment;
    if (typeof exports === 'object') {
        // CommonJS module
        // Load moment.js as an optional dependency
        try { moment = require('moment'); } catch (e) {}
        module.exports = factory(moment);
    } else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(function (req)
        {
            // Load moment.js as an optional dependency
            var id = 'moment';
            try { moment = req(id); } catch (e) {}
            return factory(moment);
        });
    } else {
        root.Pikaday = factory(root.moment);
    }
}(this, function (moment)
{
    'use strict';

    /**
     * feature detection and helper functions
     */
    var hasMoment = typeof moment === 'function',

    hasEventListeners = !!window.addEventListener,

    document = window.document,

    sto = window.setTimeout,

    addEvent = function(el, e, callback, capture)
    {
        if (hasEventListeners) {
            el.addEventListener(e, callback, !!capture);
        } else {
            el.attachEvent('on' + e, callback);
        }
    },

    removeEvent = function(el, e, callback, capture)
    {
        if (hasEventListeners) {
            el.removeEventListener(e, callback, !!capture);
        } else {
            el.detachEvent('on' + e, callback);
        }
    },

    trim = function(str)
    {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g,'');
    },

    hasClass = function(el, cn)
    {
        return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
    },

    addClass = function(el, cn)
    {
        if (!hasClass(el, cn)) {
            el.className = (el.className === '') ? cn : el.className + ' ' + cn;
        }
    },

    removeClass = function(el, cn)
    {
        el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));
    },

    isArray = function(obj)
    {
        return (/Array/).test(Object.prototype.toString.call(obj));
    },

    isDate = function(obj)
    {
        return (/Date/).test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
    },

    isWeekend = function(date)
    {
        var day = date.getDay();
        return day === 0 || day === 6;
    },

    isLeapYear = function(year)
    {
        // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    },

    getDaysInMonth = function(year, month)
    {
        return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
    },

    setToStartOfDay = function(date)
    {
        if (isDate(date)) date.setHours(0,0,0,0);
    },

    compareDates = function(a,b)
    {
        // weak date comparison (use setToStartOfDay(date) to ensure correct result)
        return a.getTime() === b.getTime();
    },

    extend = function(to, from, overwrite)
    {
        var prop, hasProp;
        for (prop in from) {
            hasProp = to[prop] !== undefined;
            if (hasProp && typeof from[prop] === 'object' && from[prop] !== null && from[prop].nodeName === undefined) {
                if (isDate(from[prop])) {
                    if (overwrite) {
                        to[prop] = new Date(from[prop].getTime());
                    }
                }
                else if (isArray(from[prop])) {
                    if (overwrite) {
                        to[prop] = from[prop].slice(0);
                    }
                } else {
                    to[prop] = extend({}, from[prop], overwrite);
                }
            } else if (overwrite || !hasProp) {
                to[prop] = from[prop];
            }
        }
        return to;
    },

    fireEvent = function(el, eventName, data)
    {
        var ev;

        if (document.createEvent) {
            ev = document.createEvent('HTMLEvents');
            ev.initEvent(eventName, true, false);
            ev = extend(ev, data);
            el.dispatchEvent(ev);
        } else if (document.createEventObject) {
            ev = document.createEventObject();
            ev = extend(ev, data);
            el.fireEvent('on' + eventName, ev);
        }
    },

    adjustCalendar = function(calendar) {
        if (calendar.month < 0) {
            calendar.year -= Math.ceil(Math.abs(calendar.month)/12);
            calendar.month += 12;
        }
        if (calendar.month > 11) {
            calendar.year += Math.floor(Math.abs(calendar.month)/12);
            calendar.month -= 12;
        }
        return calendar;
    },

    /**
     * defaults and localisation
     */
    defaults = {

        // bind the picker to a form field
        field: null,

        // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
        bound: undefined,

        // position of the datepicker, relative to the field (default to bottom & left)
        // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
        position: 'bottom left',

        // automatically fit in the viewport even if it means repositioning from the position option
        reposition: true,

        // the default output format for `.toString()` and `field` value
        format: 'YYYY-MM-DD',

        // the toString function which gets passed a current date object and format
        // and returns a string
        toString: null,

        // used to create date object from current input string
        parse: null,

        // the initial date to view when first opened
        defaultDate: null,

        // make the `defaultDate` the initial selected value
        setDefaultDate: false,

        // first day of week (0: Sunday, 1: Monday etc)
        firstDay: 0,

        // the default flag for moment's strict date parsing
        formatStrict: false,

        // the minimum/earliest date that can be selected
        minDate: null,
        // the maximum/latest date that can be selected
        maxDate: null,

        // number of years either side, or array of upper/lower range
        yearRange: 10,

        // show week numbers at head of row
        showWeekNumber: false,

        // Week picker mode
        pickWholeWeek: false,

        // used internally (don't config outside)
        minYear: 0,
        maxYear: 9999,
        minMonth: undefined,
        maxMonth: undefined,

        startRange: null,
        endRange: null,

        isRTL: false,

        // Additional text to append to the year in the calendar title
        yearSuffix: '',

        // Render the month after year in the calendar title
        showMonthAfterYear: false,

        // Render days of the calendar grid that fall in the next or previous month
        showDaysInNextAndPreviousMonths: false,

        // Allows user to select days that fall in the next or previous month
        enableSelectionDaysInNextAndPreviousMonths: false,

        // how many months are visible
        numberOfMonths: 1,

        // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
        // only used for the first display or when a selected date is not visible
        mainCalendar: 'left',

        // Specify a DOM element to render the calendar in
        container: undefined,

        // Blur field when date is selected
        blurFieldOnSelect : true,

        // internationalization
        i18n: {
            previousMonth : 'Previous Month',
            nextMonth     : 'Next Month',
            months        : ['January','February','March','April','May','June','July','August','September','October','November','December'],
            weekdays      : ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],
            weekdaysShort : ['Sun','Mon','Tue','Wed','Thu','Fri','Sat']
        },

        // Theme Classname
        theme: null,

        // events array
        events: [],

        // callback function
        onSelect: null,
        onOpen: null,
        onClose: null,
        onDraw: null
    },


    /**
     * templating functions to abstract HTML rendering
     */
    renderDayName = function(opts, day, abbr)
    {
        day += opts.firstDay;
        while (day >= 7) {
            day -= 7;
        }
        return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
    },

    renderDay = function(opts)
    {
        var arr = [];
        var ariaSelected = 'false';
        if (opts.isEmpty) {
            if (opts.showDaysInNextAndPreviousMonths) {
                arr.push('is-outside-current-month');

                if(!opts.enableSelectionDaysInNextAndPreviousMonths) {
                    arr.push('is-selection-disabled');
                }

            } else {
                return '<td class="is-empty"></td>';
            }
        }
        if (opts.isDisabled) {
            arr.push('is-disabled');
        }
        if (opts.isToday) {
            arr.push('is-today');
        }
        if (opts.isSelected) {
            arr.push('is-selected');
            ariaSelected = 'true';
        }
        if (opts.hasEvent) {
            arr.push('has-event');
        }
        if (opts.isInRange) {
            arr.push('is-inrange');
        }
        if (opts.isStartRange) {
            arr.push('is-startrange');
        }
        if (opts.isEndRange) {
            arr.push('is-endrange');
        }
        return '<td data-day="' + opts.day + '" class="' + arr.join(' ') + '" aria-selected="' + ariaSelected + '">' +
                 '<button class="pika-button pika-day" type="button" ' +
                    'data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' +
                        opts.day +
                 '</button>' +
               '</td>';
    },

    renderWeek = function (d, m, y) {
        // Lifted from http://javascript.about.com/library/blweekyear.htm, lightly modified.
        var onejan = new Date(y, 0, 1),
            weekNum = Math.ceil((((new Date(y, m, d) - onejan) / 86400000) + onejan.getDay()+1)/7);
        return '<td class="pika-week">' + weekNum + '</td>';
    },

    renderRow = function(days, isRTL, pickWholeWeek, isRowSelected)
    {
        return '<tr class="pika-row' + (pickWholeWeek ? ' pick-whole-week' : '') + (isRowSelected ? ' is-selected' : '') + '">' + (isRTL ? days.reverse() : days).join('') + '</tr>';
    },

    renderBody = function(rows)
    {
        return '<tbody>' + rows.join('') + '</tbody>';
    },

    renderHead = function(opts)
    {
        var i, arr = [];
        if (opts.showWeekNumber) {
            arr.push('<th></th>');
        }
        for (i = 0; i < 7; i++) {
            arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + '</abbr></th>');
        }
        return '<thead><tr>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</tr></thead>';
    },

    renderTitle = function(instance, c, year, month, refYear, randId)
    {
        var i, j, arr,
            opts = instance._o,
            isMinYear = year === opts.minYear,
            isMaxYear = year === opts.maxYear,
            html = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">',
            monthHtml,
            yearHtml,
            prev = true,
            next = true;

        for (arr = [], i = 0; i < 12; i++) {
            arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' +
                (i === month ? ' selected="selected"': '') +
                ((isMinYear && i < opts.minMonth) || (isMaxYear && i > opts.maxMonth) ? 'disabled="disabled"' : '') + '>' +
                opts.i18n.months[i] + '</option>');
        }

        monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join('') + '</select></div>';

        if (isArray(opts.yearRange)) {
            i = opts.yearRange[0];
            j = opts.yearRange[1] + 1;
        } else {
            i = year - opts.yearRange;
            j = 1 + year + opts.yearRange;
        }

        for (arr = []; i < j && i <= opts.maxYear; i++) {
            if (i >= opts.minYear) {
                arr.push('<option value="' + i + '"' + (i === year ? ' selected="selected"': '') + '>' + (i) + '</option>');
            }
        }
        yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join('') + '</select></div>';

        if (opts.showMonthAfterYear) {
            html += yearHtml + monthHtml;
        } else {
            html += monthHtml + yearHtml;
        }

        if (isMinYear && (month === 0 || opts.minMonth >= month)) {
            prev = false;
        }

        if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
            next = false;
        }

        if (c === 0) {
            html += '<button class="pika-prev' + (prev ? '' : ' is-disabled') + '" type="button">' + opts.i18n.previousMonth + '</button>';
        }
        if (c === (instance._o.numberOfMonths - 1) ) {
            html += '<button class="pika-next' + (next ? '' : ' is-disabled') + '" type="button">' + opts.i18n.nextMonth + '</button>';
        }

        return html += '</div>';
    },

    renderTable = function(opts, data, randId)
    {
        return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data) + '</table>';
    },


    /**
     * Pikaday constructor
     */
    Pikaday = function(options)
    {
        var self = this,
            opts = self.config(options);

        self._onMouseDown = function(e)
        {
            if (!self._v) {
                return;
            }
            e = e || window.event;
            var target = e.target || e.srcElement;
            if (!target) {
                return;
            }

            if (!hasClass(target, 'is-disabled')) {
                if (hasClass(target, 'pika-button') && !hasClass(target, 'is-empty') && !hasClass(target.parentNode, 'is-disabled')) {
                    self.setDate(new Date(target.getAttribute('data-pika-year'), target.getAttribute('data-pika-month'), target.getAttribute('data-pika-day')));
                    if (opts.bound) {
                        sto(function() {
                            self.hide();
                            if (opts.blurFieldOnSelect && opts.field) {
                                opts.field.blur();
                            }
                        }, 100);
                    }
                }
                else if (hasClass(target, 'pika-prev')) {
                    self.prevMonth();
                }
                else if (hasClass(target, 'pika-next')) {
                    self.nextMonth();
                }
            }
            if (!hasClass(target, 'pika-select')) {
                // if this is touch event prevent mouse events emulation
                if (e.preventDefault) {
                    e.preventDefault();
                } else {
                    e.returnValue = false;
                    return false;
                }
            } else {
                self._c = true;
            }
        };

        self._onChange = function(e)
        {
            e = e || window.event;
            var target = e.target || e.srcElement;
            if (!target) {
                return;
            }
            if (hasClass(target, 'pika-select-month')) {
                self.gotoMonth(target.value);
            }
            else if (hasClass(target, 'pika-select-year')) {
                self.gotoYear(target.value);
            }
        };

        self._onKeyChange = function(e)
        {
            e = e || window.event;

            if (self.isVisible()) {

                switch(e.keyCode){
                    case 13:
                    case 27:
                        if (opts.field) {
                            opts.field.blur();
                        }
                        break;
                    case 37:
                        e.preventDefault();
                        self.adjustDate('subtract', 1);
                        break;
                    case 38:
                        self.adjustDate('subtract', 7);
                        break;
                    case 39:
                        self.adjustDate('add', 1);
                        break;
                    case 40:
                        self.adjustDate('add', 7);
                        break;
                }
            }
        };

        self._onInputChange = function(e)
        {
            var date;

            if (e.firedBy === self) {
                return;
            }
            if (opts.parse) {
                date = opts.parse(opts.field.value, opts.format);
            } else if (hasMoment) {
                date = moment(opts.field.value, opts.format, opts.formatStrict);
                date = (date && date.isValid()) ? date.toDate() : null;
            }
            else {
                date = new Date(Date.parse(opts.field.value));
            }
            if (isDate(date)) {
              self.setDate(date);
            }
            if (!self._v) {
                self.show();
            }
        };

        self._onInputFocus = function()
        {
            self.show();
        };

        self._onInputClick = function()
        {
            self.show();
        };

        self._onInputBlur = function()
        {
            // IE allows pika div to gain focus; catch blur the input field
            var pEl = document.activeElement;
            do {
                if (hasClass(pEl, 'pika-single')) {
                    return;
                }
            }
            while ((pEl = pEl.parentNode));

            if (!self._c) {
                self._b = sto(function() {
                    self.hide();
                }, 50);
            }
            self._c = false;
        };

        self._onClick = function(e)
        {
            e = e || window.event;
            var target = e.target || e.srcElement,
                pEl = target;
            if (!target) {
                return;
            }
            if (!hasEventListeners && hasClass(target, 'pika-select')) {
                if (!target.onchange) {
                    target.setAttribute('onchange', 'return;');
                    addEvent(target, 'change', self._onChange);
                }
            }
            do {
                if (hasClass(pEl, 'pika-single') || pEl === opts.trigger) {
                    return;
                }
            }
            while ((pEl = pEl.parentNode));
            if (self._v && target !== opts.trigger && pEl !== opts.trigger) {
                self.hide();
            }
        };

        self.el = document.createElement('div');
        self.el.className = 'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');

        addEvent(self.el, 'mousedown', self._onMouseDown, true);
        addEvent(self.el, 'touchend', self._onMouseDown, true);
        addEvent(self.el, 'change', self._onChange);
        addEvent(document, 'keydown', self._onKeyChange);

        if (opts.field) {
            if (opts.container) {
                opts.container.appendChild(self.el);
            } else if (opts.bound) {
                document.body.appendChild(self.el);
            } else {
                opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);
            }
            addEvent(opts.field, 'change', self._onInputChange);

            if (!opts.defaultDate) {
                if (hasMoment && opts.field.value) {
                    opts.defaultDate = moment(opts.field.value, opts.format).toDate();
                } else {
                    opts.defaultDate = new Date(Date.parse(opts.field.value));
                }
                opts.setDefaultDate = true;
            }
        }

        var defDate = opts.defaultDate;

        if (isDate(defDate)) {
            if (opts.setDefaultDate) {
                self.setDate(defDate, true);
            } else {
                self.gotoDate(defDate);
            }
        } else {
            self.gotoDate(new Date());
        }

        if (opts.bound) {
            this.hide();
            self.el.className += ' is-bound';
            addEvent(opts.trigger, 'click', self._onInputClick);
            addEvent(opts.trigger, 'focus', self._onInputFocus);
            addEvent(opts.trigger, 'blur', self._onInputBlur);
        } else {
            this.show();
        }
    };


    /**
     * public Pikaday API
     */
    Pikaday.prototype = {


        /**
         * configure functionality
         */
        config: function(options)
        {
            if (!this._o) {
                this._o = extend({}, defaults, true);
            }

            var opts = extend(this._o, options, true);

            opts.isRTL = !!opts.isRTL;

            opts.field = (opts.field && opts.field.nodeName) ? opts.field : null;

            opts.theme = (typeof opts.theme) === 'string' && opts.theme ? opts.theme : null;

            opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);

            opts.trigger = (opts.trigger && opts.trigger.nodeName) ? opts.trigger : opts.field;

            opts.disableWeekends = !!opts.disableWeekends;

            opts.disableDayFn = (typeof opts.disableDayFn) === 'function' ? opts.disableDayFn : null;

            var nom = parseInt(opts.numberOfMonths, 10) || 1;
            opts.numberOfMonths = nom > 4 ? 4 : nom;

            if (!isDate(opts.minDate)) {
                opts.minDate = false;
            }
            if (!isDate(opts.maxDate)) {
                opts.maxDate = false;
            }
            if ((opts.minDate && opts.maxDate) && opts.maxDate < opts.minDate) {
                opts.maxDate = opts.minDate = false;
            }
            if (opts.minDate) {
                this.setMinDate(opts.minDate);
            }
            if (opts.maxDate) {
                this.setMaxDate(opts.maxDate);
            }

            if (isArray(opts.yearRange)) {
                var fallback = new Date().getFullYear() - 10;
                opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
                opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
            } else {
                opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
                if (opts.yearRange > 100) {
                    opts.yearRange = 100;
                }
            }

            return opts;
        },

        /**
         * return a formatted string of the current selection (using Moment.js if available)
         */
        toString: function(format)
        {
            format = format || this._o.format;
            if (!isDate(this._d)) {
                return '';
            }
            if (this._o.toString) {
              return this._o.toString(this._d, format);
            }
            if (hasMoment) {
              return moment(this._d).format(format);
            }
            return this._d.toDateString();
        },

        /**
         * return a Moment.js object of the current selection (if available)
         */
        getMoment: function()
        {
            return hasMoment ? moment(this._d) : null;
        },

        /**
         * set the current selection from a Moment.js object (if available)
         */
        setMoment: function(date, preventOnSelect)
        {
            if (hasMoment && moment.isMoment(date)) {
                this.setDate(date.toDate(), preventOnSelect);
            }
        },

        /**
         * return a Date object of the current selection
         */
        getDate: function()
        {
            return isDate(this._d) ? new Date(this._d.getTime()) : null;
        },

        /**
         * set the current selection
         */
        setDate: function(date, preventOnSelect)
        {
            if (!date) {
                this._d = null;

                if (this._o.field) {
                    this._o.field.value = '';
                    fireEvent(this._o.field, 'change', { firedBy: this });
                }

                return this.draw();
            }
            if (typeof date === 'string') {
                date = new Date(Date.parse(date));
            }
            if (!isDate(date)) {
                return;
            }

            var min = this._o.minDate,
                max = this._o.maxDate;

            if (isDate(min) && date < min) {
                date = min;
            } else if (isDate(max) && date > max) {
                date = max;
            }

            this._d = new Date(date.getTime());
            setToStartOfDay(this._d);
            this.gotoDate(this._d);

            if (this._o.field) {
                this._o.field.value = this.toString();
                fireEvent(this._o.field, 'change', { firedBy: this });
            }
            if (!preventOnSelect && typeof this._o.onSelect === 'function') {
                this._o.onSelect.call(this, this.getDate());
            }
        },

        /**
         * change view to a specific date
         */
        gotoDate: function(date)
        {
            var newCalendar = true;

            if (!isDate(date)) {
                return;
            }

            if (this.calendars) {
                var firstVisibleDate = new Date(this.calendars[0].year, this.calendars[0].month, 1),
                    lastVisibleDate = new Date(this.calendars[this.calendars.length-1].year, this.calendars[this.calendars.length-1].month, 1),
                    visibleDate = date.getTime();
                // get the end of the month
                lastVisibleDate.setMonth(lastVisibleDate.getMonth()+1);
                lastVisibleDate.setDate(lastVisibleDate.getDate()-1);
                newCalendar = (visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate);
            }

            if (newCalendar) {
                this.calendars = [{
                    month: date.getMonth(),
                    year: date.getFullYear()
                }];
                if (this._o.mainCalendar === 'right') {
                    this.calendars[0].month += 1 - this._o.numberOfMonths;
                }
            }

            this.adjustCalendars();
        },

        adjustDate: function(sign, days) {

            var day = this.getDate() || new Date();
            var difference = parseInt(days)*24*60*60*1000;

            var newDay;

            if (sign === 'add') {
                newDay = new Date(day.valueOf() + difference);
            } else if (sign === 'subtract') {
                newDay = new Date(day.valueOf() - difference);
            }

            this.setDate(newDay);
        },

        adjustCalendars: function() {
            this.calendars[0] = adjustCalendar(this.calendars[0]);
            for (var c = 1; c < this._o.numberOfMonths; c++) {
                this.calendars[c] = adjustCalendar({
                    month: this.calendars[0].month + c,
                    year: this.calendars[0].year
                });
            }
            this.draw();
        },

        gotoToday: function()
        {
            this.gotoDate(new Date());
        },

        /**
         * change view to a specific month (zero-index, e.g. 0: January)
         */
        gotoMonth: function(month)
        {
            if (!isNaN(month)) {
                this.calendars[0].month = parseInt(month, 10);
                this.adjustCalendars();
            }
        },

        nextMonth: function()
        {
            this.calendars[0].month++;
            this.adjustCalendars();
        },

        prevMonth: function()
        {
            this.calendars[0].month--;
            this.adjustCalendars();
        },

        /**
         * change view to a specific full year (e.g. "2012")
         */
        gotoYear: function(year)
        {
            if (!isNaN(year)) {
                this.calendars[0].year = parseInt(year, 10);
                this.adjustCalendars();
            }
        },

        /**
         * change the minDate
         */
        setMinDate: function(value)
        {
            if(value instanceof Date) {
                setToStartOfDay(value);
                this._o.minDate = value;
                this._o.minYear  = value.getFullYear();
                this._o.minMonth = value.getMonth();
            } else {
                this._o.minDate = defaults.minDate;
                this._o.minYear  = defaults.minYear;
                this._o.minMonth = defaults.minMonth;
                this._o.startRange = defaults.startRange;
            }

            this.draw();
        },

        /**
         * change the maxDate
         */
        setMaxDate: function(value)
        {
            if(value instanceof Date) {
                setToStartOfDay(value);
                this._o.maxDate = value;
                this._o.maxYear = value.getFullYear();
                this._o.maxMonth = value.getMonth();
            } else {
                this._o.maxDate = defaults.maxDate;
                this._o.maxYear = defaults.maxYear;
                this._o.maxMonth = defaults.maxMonth;
                this._o.endRange = defaults.endRange;
            }

            this.draw();
        },

        setStartRange: function(value)
        {
            this._o.startRange = value;
        },

        setEndRange: function(value)
        {
            this._o.endRange = value;
        },

        /**
         * refresh the HTML
         */
        draw: function(force)
        {
            if (!this._v && !force) {
                return;
            }
            var opts = this._o,
                minYear = opts.minYear,
                maxYear = opts.maxYear,
                minMonth = opts.minMonth,
                maxMonth = opts.maxMonth,
                html = '',
                randId;

            if (this._y <= minYear) {
                this._y = minYear;
                if (!isNaN(minMonth) && this._m < minMonth) {
                    this._m = minMonth;
                }
            }
            if (this._y >= maxYear) {
                this._y = maxYear;
                if (!isNaN(maxMonth) && this._m > maxMonth) {
                    this._m = maxMonth;
                }
            }

            randId = 'pika-title-' + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 2);

            for (var c = 0; c < opts.numberOfMonths; c++) {
                html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId) + '</div>';
            }

            this.el.innerHTML = html;

            if (opts.bound) {
                if(opts.field.type !== 'hidden') {
                    sto(function() {
                        opts.trigger.focus();
                    }, 1);
                }
            }

            if (typeof this._o.onDraw === 'function') {
                this._o.onDraw(this);
            }

            if (opts.bound) {
                // let the screen reader user know to use arrow keys
                opts.field.setAttribute('aria-label', 'Use the arrow keys to pick a date');
            }
        },

        adjustPosition: function()
        {
            var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect;

            if (this._o.container) return;

            this.el.style.position = 'absolute';

            field = this._o.trigger;
            pEl = field;
            width = this.el.offsetWidth;
            height = this.el.offsetHeight;
            viewportWidth = window.innerWidth || document.documentElement.clientWidth;
            viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;

            if (typeof field.getBoundingClientRect === 'function') {
                clientRect = field.getBoundingClientRect();
                left = clientRect.left + window.pageXOffset;
                top = clientRect.bottom + window.pageYOffset;
            } else {
                left = pEl.offsetLeft;
                top  = pEl.offsetTop + pEl.offsetHeight;
                while((pEl = pEl.offsetParent)) {
                    left += pEl.offsetLeft;
                    top  += pEl.offsetTop;
                }
            }

            // default position is bottom & left
            if ((this._o.reposition && left + width > viewportWidth) ||
                (
                    this._o.position.indexOf('right') > -1 &&
                    left - width + field.offsetWidth > 0
                )
            ) {
                left = left - width + field.offsetWidth;
            }
            if ((this._o.reposition && top + height > viewportHeight + scrollTop) ||
                (
                    this._o.position.indexOf('top') > -1 &&
                    top - height - field.offsetHeight > 0
                )
            ) {
                top = top - height - field.offsetHeight;
            }

            this.el.style.left = left + 'px';
            this.el.style.top = top + 'px';
        },

        /**
         * render HTML for a particular month
         */
        render: function(year, month, randId)
        {
            var opts   = this._o,
                now    = new Date(),
                days   = getDaysInMonth(year, month),
                before = new Date(year, month, 1).getDay(),
                data   = [],
                row    = [];
            setToStartOfDay(now);
            if (opts.firstDay > 0) {
                before -= opts.firstDay;
                if (before < 0) {
                    before += 7;
                }
            }
            var previousMonth = month === 0 ? 11 : month - 1,
                nextMonth = month === 11 ? 0 : month + 1,
                yearOfPreviousMonth = month === 0 ? year - 1 : year,
                yearOfNextMonth = month === 11 ? year + 1 : year,
                daysInPreviousMonth = getDaysInMonth(yearOfPreviousMonth, previousMonth);
            var cells = days + before,
                after = cells;
            while(after > 7) {
                after -= 7;
            }
            cells += 7 - after;
            var isWeekSelected = false;
            for (var i = 0, r = 0; i < cells; i++)
            {
                var day = new Date(year, month, 1 + (i - before)),
                    isSelected = isDate(this._d) ? compareDates(day, this._d) : false,
                    isToday = compareDates(day, now),
                    hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false,
                    isEmpty = i < before || i >= (days + before),
                    dayNumber = 1 + (i - before),
                    monthNumber = month,
                    yearNumber = year,
                    isStartRange = opts.startRange && compareDates(opts.startRange, day),
                    isEndRange = opts.endRange && compareDates(opts.endRange, day),
                    isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange,
                    isDisabled = (opts.minDate && day < opts.minDate) ||
                                 (opts.maxDate && day > opts.maxDate) ||
                                 (opts.disableWeekends && isWeekend(day)) ||
                                 (opts.disableDayFn && opts.disableDayFn(day));

                if (isEmpty) {
                    if (i < before) {
                        dayNumber = daysInPreviousMonth + dayNumber;
                        monthNumber = previousMonth;
                        yearNumber = yearOfPreviousMonth;
                    } else {
                        dayNumber = dayNumber - days;
                        monthNumber = nextMonth;
                        yearNumber = yearOfNextMonth;
                    }
                }

                var dayConfig = {
                        day: dayNumber,
                        month: monthNumber,
                        year: yearNumber,
                        hasEvent: hasEvent,
                        isSelected: isSelected,
                        isToday: isToday,
                        isDisabled: isDisabled,
                        isEmpty: isEmpty,
                        isStartRange: isStartRange,
                        isEndRange: isEndRange,
                        isInRange: isInRange,
                        showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
                        enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths
                    };

                if (opts.pickWholeWeek && isSelected) {
                    isWeekSelected = true;
                }

                row.push(renderDay(dayConfig));

                if (++r === 7) {
                    if (opts.showWeekNumber) {
                        row.unshift(renderWeek(i - before, month, year));
                    }
                    data.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
                    row = [];
                    r = 0;
                    isWeekSelected = false;
                }
            }
            return renderTable(opts, data, randId);
        },

        isVisible: function()
        {
            return this._v;
        },

        show: function()
        {
            if (!this.isVisible()) {
                this._v = true;
                this.draw();
                removeClass(this.el, 'is-hidden');
                if (this._o.bound) {
                    addEvent(document, 'click', this._onClick);
                    this.adjustPosition();
                }
                if (typeof this._o.onOpen === 'function') {
                    this._o.onOpen.call(this);
                }
            }
        },

        hide: function()
        {
            var v = this._v;
            if (v !== false) {
                if (this._o.bound) {
                    removeEvent(document, 'click', this._onClick);
                }
                this.el.style.position = 'static'; // reset
                this.el.style.left = 'auto';
                this.el.style.top = 'auto';
                addClass(this.el, 'is-hidden');
                this._v = false;
                if (v !== undefined && typeof this._o.onClose === 'function') {
                    this._o.onClose.call(this);
                }
            }
        },

        /**
         * GAME OVER
         */
        destroy: function()
        {
            this.hide();
            removeEvent(this.el, 'mousedown', this._onMouseDown, true);
            removeEvent(this.el, 'touchend', this._onMouseDown, true);
            removeEvent(this.el, 'change', this._onChange);
            removeEvent(document, 'keydown', this._onKeyChange);
            if (this._o.field) {
                removeEvent(this._o.field, 'change', this._onInputChange);
                if (this._o.bound) {
                    removeEvent(this._o.trigger, 'click', this._onInputClick);
                    removeEvent(this._o.trigger, 'focus', this._onInputFocus);
                    removeEvent(this._o.trigger, 'blur', this._onInputBlur);
                }
            }
            if (this.el.parentNode) {
                this.el.parentNode.removeChild(this.el);
            }
        }

    };

    return Pikaday;

}));

},{"moment":20}],22:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define("index", [], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["index"] = factory();else root["index"] = root["index"] || {}, root["index"]["index"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports) {

			'use strict';

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var VeamsDOM = {
				options: {
					DOM: false
				},
				pluginName: '$',
				initialize: function initialize(Veams, _ref) {
					var DOM = _ref.DOM;

					if (!DOM) {
						console.error('VeamsDOM :: You need to pass an options object with a DOM handler: options.DOM!');
						return;
					}
					if (Veams.$) {
						console.log('VeamsDOM :: It seems that you have already defined a DOM handler. I am overwriting it now for you ;)');
					}

					Veams.$ = this.options.DOM = DOM;
				}
			};

			exports.default = VeamsDOM;
			module.exports = exports['default'];

			/***/
		}
		/******/])
	);
});
;


},{}],23:[function(require,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof2(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define("index", [], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object') exports["index"] = factory();else root["index"] = root["index"] || {}, root["index"]["index"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports) {

			'use strict';

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
				return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
			} : function (obj) {
				return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
			};

			var VeamsLogger = {
				pluginName: 'Logger',
				initialize: function initialize(Veams) {
					/**
      * Devmode and logger
      */
					Veams.devmode = false;
					Veams.logger = false;

					if (document.location.search.indexOf('devmode') > -1 || window.sessionStorage && sessionStorage.getItem('devmodeEnabled')) {
						Veams.devmode = true;

						if (window.sessionStorage && !sessionStorage.getItem('devmodeEnabled')) {
							sessionStorage.setItem('devmodeEnabled', true);
						}
					}

					if (document.location.search.indexOf('logger') > -1) {
						Veams.logger = true;
					}

					// hide all warnings and logs if not in devmode
					if (!Veams.devmode) {
						console.log = console.warn = function () {};
					}

					// add console output element (triggered by parameter 'devmode' and 'logger' in url)
					if (Veams.devmode && Veams.logger) {
						var logger = document.createElement('pre');

						logger.setAttribute('id', 'logger');
						document.body.appendChild(logger);

						console.write = function () {
							for (var i = 0; i < arguments.length; i++) {
								if (_typeof(arguments[i]) === 'object') {
									logger.innerHTML += (JSON && JSON.stringify ? JSON.stringify(arguments[i], undefined, 2) : arguments[i]) + '<br />';
								} else {
									logger.innerHTML += arguments[i] + '<br />';
								}
							}

							logger.innerHTML += '<br />';
							logger.scrollTop = logger.scrollHeight;
						};

						console.error = function () {
							logger.innerHTML += '[Error]<br />';
							console.write.apply(this, arguments);
						};

						console.warn = function () {
							logger.innerHTML += '[Warn]<br />';
							console.write.apply(this, arguments);
						};

						console.log = function () {
							logger.innerHTML += '[Log]<br />';
							console.write.apply(this, arguments);
						};
					}
				}
			};

			exports.default = VeamsLogger;
			module.exports = exports['default'];

			/***/
		}
		/******/])
	);
});
;


},{}],24:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define("index", [], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["index"] = factory();else root["index"] = root["index"] || {}, root["index"]["index"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Imports
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var VeamsMediaQueryHandler = {
				options: {
					mediaQueryProp: 'font-family',
					delay: 300
				},
				pluginName: 'MediaQueryHandler',
				initialize: function initialize(Veams, opts) {
					var _this = this;

					// Media Query
					var head = document.querySelectorAll('head');

					if (opts) {
						this.options = Veams.helpers.extend(this.options, opts || {});
					}

					/**
      * Add current media query to Veams
      */
					Veams.currentMedia = window.getComputedStyle(head[0], null).getPropertyValue(this.options.mediaQueryProp);

					if (!Veams.Vent) {
						console.info('VeamsMediaQueryHandler :: In order to work properly with the VeamsMediaQueryHandler plugin you should add the VeamsVent plugin!');
					}

					// Trigger global resize event
					window.onresize = Veams.helpers.throttle(function (e) {
						var currentMedia = window.getComputedStyle(head[0], null).getPropertyValue(_this.options.mediaQueryProp);
						var width = window.innerWidth;

						if (currentMedia !== Veams.currentMedia) {
							var oldMedia = Veams.currentMedia;

							Veams.currentMedia = currentMedia;

							console.info('VeamsMediaQueryHandler :: Current media is ' + Veams.currentMedia);

							if (Veams.Vent) {
								Veams.Vent.trigger(Veams.EVENTS.mediachange, {
									type: Veams.EVENTS.mediachange,
									currentMedia: currentMedia,
									oldMedia: oldMedia
								});
							}
						}

						Veams.detections.width = width;
						Veams.Vent.trigger(Veams.EVENTS.resize, e);
					}, this.options.delay);
				}
			};

			exports.default = VeamsMediaQueryHandler;
			module.exports = exports['default'];

			/***/
		}
		/******/])
	);
});
;


},{}],25:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define("index", [], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["index"] = factory();else root["index"] = root["index"] || {}, root["index"]["index"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports) {

			'use strict';

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var _createClass = function () {
				function defineProperties(target, props) {
					for (var i = 0; i < props.length; i++) {
						var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
					}
				}return function (Constructor, protoProps, staticProps) {
					if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
				};
			}();

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}

			var Veams = {};
			var __cache = [];
			var __register = {
				modulesInRegister: [],
				modulesOnConditions: [],
				modulesOnInit: [],
				modulesInContext: []
			};

			/**
    * TODO: Clean up mutation observer
    */

			/**
    * - Get modules in DOM
    * - Get classes and options from init process
    * - Split up conditional modules from initial modules
    * - Init other modules
    * - Bind events when available from conditional modules
    * -
    */

			var Modules = function () {
				function Modules() {
					var VEAMS = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.Veams;
					var opts = arguments[1];

					_classCallCheck(this, Modules);

					Veams = VEAMS;

					this.options = opts;

					if (!this.options.internalCacheOnly) {
						this._cache = __cache; // Module list
					}

					if (!this.options.internalRegisterOnly) {
						this._register = __register;
					}

					this.initialize();
				}

				_createClass(Modules, [{
					key: 'initialize',
					value: function initialize() {
						this.queryString = '[' + this.options.attrPrefix + '-' + this.options.attrName + ']';
						__register.modulesInContext = Veams.helpers.querySelectorArray(this.queryString);

						if (this.options.useMutationObserver) {
							this.observe(document.body);
						}

						this.bindEvents();
					}
				}, {
					key: 'bindEvents',
					value: function bindEvents() {
						var _this = this;

						if (!Veams.Vent && this.options.useMutationObserver === false) {
							console.info('VeamsModules :: In order to work with the the ajax handling in VeamsModulesHandler ' + 'you need to define "useMutationObserver" or use the VeamsVent plugin!');

							return;
						}

						if (Veams.Vent && this.options.useMutationObserver === false) {
							Veams.Vent.on(Veams.EVENTS.DOMchanged, function (e, context) {
								__register.modulesInContext = _this.getModulesInContext(context);

								if (_this.options.logs) {
									console.info('VeamsModules :: Recording new context. When available new modules will be initialised in: ', context);
								}

								_this.registerAll();
							});
						}
					}

					// ------------------------
					// STATIC CACHE HANDLER
					// ------------------------

					/**
      * Save the module in __cache.
      *
      * @param {Object} module - module metadata object (@see VeamsComponent.metaData())
      * @param {Object} element - module element (this.el)
      * @param {Object} instance - module instance
      * @param {String} namespace - module namespace
      */

				}, {
					key: 'bindConditions',
					value: function bindConditions() {
						var _this2 = this;

						__register.modulesOnConditions.forEach(function (module) {
							if (module.conditionsListenOn && module.conditionsListenOn.length) {
								_this2.bindCondition(module);
							}
						});
					}
				}, {
					key: 'bindCondition',
					value: function bindCondition(module) {
						var _this3 = this;

						var globalEvts = module.conditionsListenOn.join(' ');

						if (Veams.Vent) {
							Veams.Vent.subscribe(globalEvts, function () {
								_this3.registerConditionalModule(module);
							});
						}
					}

					// ------------------------
					// UN/REGISTER HANDLER
					// ------------------------

					/**
      * Split up modules depending on condition check
      */

				}, {
					key: 'splitUpModules',
					value: function splitUpModules() {
						var _this4 = this;

						__register.modulesInRegister.forEach(function (obj) {
							if (_this4.constructor.isCondition(obj)) {
								__register.modulesOnConditions.push(obj);
							} else {
								__register.modulesOnInit.push(obj);
							}
						});
					}

					/**
      * Register multiple modules.
      *
      * @param {Array} arr - Array which contains the modules as object.
      *
      * @public
      */

				}, {
					key: 'register',
					value: function register(arr) {
						if (!Array.isArray(arr)) {
							throw new Error('VeamsModules :: You need to pass an array to register()!');
						}

						__register.modulesInRegister = __register.modulesInRegister.concat(arr);

						this.splitUpModules();
						this.bindConditions();
						this.registerAll();
					}

					/**
      * Register all modules
      */

				}, {
					key: 'registerAll',
					value: function registerAll() {
						if (!__register.modulesInRegister) return;

						this.registerInitialModules();
						this.registerConditionalModules();
					}

					/**
      * Register all initial modules
      */

				}, {
					key: 'registerInitialModules',
					value: function registerInitialModules() {
						var _this5 = this;

						__register.modulesOnInit.forEach(function (obj) {
							_this5.registerOne(obj);
						});
					}

					/**
      * Register conditional modules
      *
      * Therefore we check the condition and
      * when true register the specific module
      * when false unregister the specific module
      */

				}, {
					key: 'registerConditionalModules',
					value: function registerConditionalModules() {
						var _this6 = this;

						__register.modulesOnConditions.forEach(function (obj) {
							_this6.registerConditionalModule(obj);
						});
					}
				}, {
					key: 'registerConditionalModule',
					value: function registerConditionalModule(obj) {
						if (this.constructor.makeConditionCheck(obj)) {
							this.registerOne(obj);
						} else {
							this.unregisterOne(obj);
						}
					}

					/**
      * Register one module and init the elements in the specific context
      *
      * @param {String} namespace - Required: element name in DOM
      * @param {String} domName - Required: element name in DOM
      * @param {Object} module - Required: class which will be used to render your module
      * @param {boolean} [render=true] - Optional: render the class, if false the class will only be initialized
      * @param {function} [cb] - Optional: provide a function which will be executed after initialisation
      * @param {Object} [options] - Optional: You can pass options to the module via JS (Useful for DOMChanged)
      *
      */

				}, {
					key: 'registerOne',
					value: function registerOne(_ref) {
						var namespace = _ref.namespace,
						    domName = _ref.domName,
						    module = _ref.module,
						    render = _ref.render,
						    cb = _ref.cb,
						    options = _ref.options;

						var nameSpace = namespace ? namespace : domName;

						if (!module) throw new Error('VeamsModules :: In order to work with register() you need to define a module!');
						if (!nameSpace) throw new Error('VeamsModules :: In order to work with register() you need to define a module!');

						this.initModules({
							namespace: nameSpace,
							module: module,
							render: render,
							cb: cb,
							options: options
						});
					}
				}, {
					key: 'unregisterOne',
					value: function unregisterOne(_ref2) {
						var namespace = _ref2.namespace;

						if (this.constructor.checkModuleInCache(namespace, 'namespace') === true) {
							this.constructor.removeFromCacheByKey(namespace, 'namespace');
						}
					}

					// ------------------------
					// INIT HANDLER
					// ------------------------

					/**
      * Initialize a module and render it and/or provide a callback function
      *
      * @param {string} namespace - Required: dom name of the element
      * @param {Object} module - Required: class which will be used to render your module
      * @param {boolean} [render=true] - Optional: render the class, if false the class will only be initialized
      * @param {Object} [options] - Optional: You can pass options to the module via JS (Useful for DOMChanged)
      * @param {function} [cb] - Optional: provide a function which will be executed after initialisation
      *
      */

				}, {
					key: 'initModules',
					value: function initModules(_ref3) {
						var _this7 = this;

						var namespace = _ref3.namespace,
						    module = _ref3.module,
						    render = _ref3.render,
						    options = _ref3.options,
						    cb = _ref3.cb;

						Veams.helpers.forEach(__register.modulesInContext, function (i, el) {
							_this7.initModule({
								el: el,
								namespace: namespace,
								options: options,
								module: module,
								render: render,
								cb: cb
							});
						});
					}
				}, {
					key: 'initModule',
					value: function initModule(_ref4) {
						var el = _ref4.el,
						    namespace = _ref4.namespace,
						    options = _ref4.options,
						    module = _ref4.module,
						    render = _ref4.render,
						    cb = _ref4.cb;

						var noRender = el.getAttribute(this.options.attrPrefix + '-no-render') || render === false || false;
						var dataModules = el.getAttribute(this.options.attrPrefix + '-' + this.options.attrName).split(' ');

						if (dataModules.indexOf(namespace) !== -1) {
							// Check init state
							if (this.constructor.checkModuleInCache(el, 'element', namespace) === true) {
								console.info('VeamsModules :: Element is already in cache and initialized: ');
								console.log(el);
								return;
							}

							// Go ahead when condition is true
							var attrs = el.getAttribute(this.options.attrPrefix + '-' + this.options.attrOptions);
							var mergedOptions = Veams.helpers.extend(JSON.parse(attrs), options || {});
							var Module = module;
							var instance = new Module({
								el: el,
								namespace: namespace,
								options: mergedOptions,
								appInstance: Veams
							});

							this.constructor.addToCache({
								element: el,
								module: module,
								instance: instance,
								namespace: namespace
							});

							// Mount process
							if (instance.willMount) instance.willMount();

							// Render after initial module loading
							if (!noRender) instance.render();

							// Provide callback function in which you can use module and options
							if (cb && typeof cb === 'function') cb(module, mergedOptions);

							// Mount process
							if (instance.didMount) instance.didMount();
						}
					}

					/**
      * Add mutation observer to observe new modules.
      *
      * @param {Object} context - Context for the mutation observer
      *
      * TODO: Improve for loops
      */

				}, {
					key: 'observe',
					value: function observe(context) {
						var _this8 = this;

						var observer = new MutationObserver(function (mutations) {
							// look through all mutations that just occured
							for (var i = 0; i < mutations.length; ++i) {
								// look through all added nodes of this mutation

								for (var j = 0; j < mutations[i].addedNodes.length; ++j) {
									var addedNode = mutations[i].addedNodes[j];

									if (addedNode instanceof HTMLElement) {
										if (addedNode.getAttribute(_this8.options.attrPrefix + '-' + _this8.options.attrName)) {
											var namespace = addedNode.getAttribute(_this8.options.attrPrefix + '-' + _this8.options.attrName);

											if (_this8.options.logs) {
												console.info('VeamsModules :: Recording a new module with the namespace ' + namespace + ' at: ', addedNode);
											}

											var _iteratorNormalCompletion = true;
											var _didIteratorError = false;
											var _iteratorError = undefined;

											try {
												for (var _iterator = __register.modulesInRegister[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
													var module = _step.value;

													if (module.namespace === namespace) {
														_this8.initModule({
															el: addedNode,
															module: module.module,
															namespace: module.namespace
														});

														break;
													}
												}
											} catch (err) {
												_didIteratorError = true;
												_iteratorError = err;
											} finally {
												try {
													if (!_iteratorNormalCompletion && _iterator.return) {
														_iterator.return();
													}
												} finally {
													if (_didIteratorError) {
														throw _iteratorError;
													}
												}
											}
										}

										if (_this8.getModulesInContext(addedNode).length) {
											__register.modulesInContext = _this8.getModulesInContext(addedNode);

											if (_this8.options.logs) {
												console.info('VeamsModules :: Recording new context. When available new modules will be initialised in: ', addedNode);
											}

											_this8.registerAll();

											__register.modulesInContext = _this8.getModulesInContext(document);
										}
									}
								}

								for (var _j = 0; _j < mutations[i].removedNodes.length; ++_j) {
									var removedNode = mutations[i].removedNodes[_j];

									if (removedNode instanceof HTMLElement) {
										if (removedNode.getAttribute(_this8.options.attrPrefix + '-' + _this8.options.attrName)) {

											if (_this8.options.logs) {
												console.info('VeamsModules :: Recording deletion of module: ', removedNode);
											}

											_this8.constructor.removeFromCacheByKey(removedNode);

											__register.modulesInContext = _this8.getModulesInContext(document);
										}

										if (_this8.getModulesInContext(removedNode).length) {
											__register.modulesInContext = _this8.getModulesInContext(removedNode);

											if (_this8.options.logs) {
												console.info('VeamsModules :: Recording deletion of DOM element. When available modules will be unbound in ', removedNode);
											}

											__register.modulesInContext.forEach(function (node) {
												_this8.constructor.removeFromCacheByKey(node);
											});

											__register.modulesInContext = _this8.getModulesInContext(document);
										}
									}
								}
							}
						});

						observer.observe(context, {
							childList: true,
							subtree: true
						});
					}

					/**
      * Get Modules in a specific context.
      *
      * @param {Object} context - Context for query specific string
      */

				}, {
					key: 'getModulesInContext',
					value: function getModulesInContext(context) {
						return Veams.helpers.querySelectorArray(this.queryString, context);
					}
				}], [{
					key: 'addToCache',
					value: function addToCache(_ref5) {
						var module = _ref5.module,
						    element = _ref5.element,
						    instance = _ref5.instance,
						    namespace = _ref5.namespace;

						__cache.push({
							module: module,
							element: element,
							instance: instance,
							namespace: namespace
						});

						if (Veams.Vent && Veams.EVENTS.moduleCached) {
							Veams.Vent.trigger(Veams.EVENTS.moduleCached, {
								module: module,
								element: element
							});
						}
					}
				}, {
					key: 'removeFromCacheByKey',
					value: function removeFromCacheByKey(obj) {
						var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'element';

						var deleteIndex = void 0;

						for (var i = 0; i < __cache.length; i++) {
							var cacheItem = __cache[i];

							if (cacheItem[key] === obj) {
								if (cacheItem.instance.willUnmount) cacheItem.instance.willUnmount();
								if (cacheItem.instance.unregisterEvents) cacheItem.instance.unregisterEvents();
								if (cacheItem.instance.didUnmount) cacheItem.instance.didUnmount();

								deleteIndex = i;
							}
						}

						if (deleteIndex) __cache.splice(deleteIndex, 1);
					}
				}, {
					key: 'checkModuleInCache',
					value: function checkModuleInCache(obj) {
						var key = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'element';
						var namespace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

						var state = false;

						for (var i = 0; i < __cache.length; i++) {
							var cacheItem = __cache[i];

							state = namespace !== undefined ? cacheItem[key] === obj && cacheItem.namespace === namespace : cacheItem[key] === obj;

							if (state) break;
						}

						return state;
					}

					// ------------------------
					// CONDITIONS HANDLER
					// ------------------------

				}, {
					key: 'isCondition',
					value: function isCondition(_ref6) {
						var conditions = _ref6.conditions;

						return conditions && typeof conditions === 'function';
					}
				}, {
					key: 'makeConditionCheck',
					value: function makeConditionCheck(_ref7) {
						var conditions = _ref7.conditions;

						if (conditions && typeof conditions === 'function') {
							return conditions();
						}
					}
				}]);

				return Modules;
			}();

			/**
    * Plugin object
    */

			var VeamsModules = {
				options: {
					DEBUG: false,
					attrPrefix: 'data-js',
					attrName: 'module',
					attrOptions: 'options',
					logs: false,
					internalCacheOnly: true,
					internalRegisterOnly: false,
					useMutationObserver: false
				},
				pluginName: 'ModulesHandler',
				initialize: function initialize(Veams, opts) {
					this.options = Veams.helpers.extend(this.options, opts || {});
					Veams.modules = Veams.modules || new Modules(Veams, this.options);
				}
			};

			exports.default = VeamsModules;
			exports.Modules = Modules;

			/***/
		}
		/******/])
	);
});
;


},{}],26:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define("index", [], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["index"] = factory();else root["index"] = root["index"] || {}, root["index"]["index"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports) {

			'use strict';
			/**
    * Represents the Templater class which will be used in VeamsTemplater plugin.
    * @module Templater
    *
    * @author Sebastian Fitzner
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var _createClass = function () {
				function defineProperties(target, props) {
					for (var i = 0; i < props.length; i++) {
						var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
					}
				}return function (Constructor, protoProps, staticProps) {
					if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
				};
			}();

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}

			var Veams = {};

			var Templater = function () {
				function Templater() {
					var VEAMS = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.Veams;
					var _ref = arguments[1];
					var engine = _ref.engine,
					    templates = _ref.templates,
					    partials = _ref.partials,
					    helpers = _ref.helpers;

					_classCallCheck(this, Templater);

					Veams = VEAMS;

					if (!templates) {
						console.error('VeamsTemplater :: You need to pass an object which contains your templates (obj.templates)!');
						return;
					}

					if (!engine) {
						console.error('VeamsTemplater :: You need to pass a handlebars instance by providing obj.engine!');
						return;
					}

					this.options = {
						namespace: Veams.options.namespace,
						engine: engine,
						templates: templates,
						partials: partials,
						helpers: helpers
					};

					this.initialize();
				}

				_createClass(Templater, [{
					key: 'initialize',
					value: function initialize() {
						if (this.options.helpers) {
							this.registerHelpers();
						}

						this.addTemplater();
					}
				}, {
					key: 'registerHelpers',
					value: function registerHelpers() {
						if (!Array.isArray(this.options.helpers)) {
							console.error('VeamsTemplater :: You need to pass the helpers as an array!');
							return;
						}

						for (var i = 0; i < this.options.helpers.length; i++) {
							var helper = this.options.helpers[i];

							if (helper.register) {
								this.options.engine.registerHelper(helper.register(this.options.engine));
							} else {
								console.error('VeamsTemplater :: Your helper does not have a register function, see: ' + helper);
							}
						}
					}
				}, {
					key: 'addTemplater',
					value: function addTemplater() {
						if (Veams.templater) {
							console.warn('It seems that you are already using Veams.templater! Veams is overriding it now!');
						}

						Veams.templater = {
							engine: this.options.engine,
							templates: this.options.templates(this.options.engine),
							partials: this.options.partials ? this.options.partials(this.options.engine) : {},
							helpers: this.options.helpers,
							render: function render(tplName, data) {
								if (!data && Veams.templater.templates[tplName]) {
									console.error('VeamsTemplater :: You need to provide some data for ' + tplName + '.');
									return;
								}

								if (!Veams.templater.templates[tplName]) {
									console.error('VeamsTemplater :: Template ' + tplName + ' not found.');
									return;
								}

								return Veams.templater.templates[tplName](data);
							}
						};
					}
				}]);

				return Templater;
			}();

			/**
    * Represents a templater plugin which you can use to render your precompiled handlebars templates.
    * You can also register custom helpers by providing them in an array!
    *
    * @module VeamsTemplater
    *
    * @author Sebastian Fitzner
    */

			var VeamsTemplater = {
				options: {
					engine: function engine() {},
					templates: function templates() {},
					partials: function partials() {},
					helpers: []
				},
				pluginName: 'Templater',
				initialize: function initialize(Veams, _ref2) {
					var engine = _ref2.engine,
					    templates = _ref2.templates,
					    partials = _ref2.partials,
					    helpers = _ref2.helpers;

					new Templater(Veams, {
						engine: engine,
						templates: templates,
						partials: partials,
						helpers: helpers
					});
				}
			};

			exports.default = VeamsTemplater;
			exports.Templater = Templater;

			/***/
		}
		/******/])
	);
});
;


},{}],27:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define("index", [], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["index"] = factory();else root["index"] = root["index"] || {}, root["index"]["index"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Represents a Vent plugin which creates an empty object.
    * The object will be used as publish/subscribe plugin.
    *
    * The module extends the default EVENTS object of Veams
    * when you pass the option called 'furtherEvents'.
    *
    * @module VeamsVent
    *
    * @author Sebastian Fitzner
    */

			/**
    * @module EventsHandler
    *
    * Pub/Sub system for Loosely Coupled logic.
    * Based on Peter Higgins' port from Dojo to jQuery
    * https://github.com/phiggins42/bloody-jquery-plugins/blob/master/pubsub.js
    * adopted https://github.com/phiggins42/bloody-jquery-plugins/blob/55e41df9bf08f42378bb08b93efcb28555b61aeb/pubsub.js
    *
    * modified by Sebastian Fitzner
    *
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var EventsHandler = function () {
				var cache = {},


				/**
     *    Events.publish
     *    e.g.: Events.publish("/Article/added", {article: article}, this);
     *
     *    @class Events
     *    @method publish
     *    @param topic {String}
     *    @param args    {Object}
     *    @param scope {Object} Optional
     */
				publish = function publish(topic, args, scope) {
					if (cache[topic]) {
						var thisTopic = cache[topic];
						var i = thisTopic.length - 1;

						for (i; i >= 0; i -= 1) {
							thisTopic[i].call(scope || this, args || {});
						}
					}
				},


				/**
     *    Events.subscribe
     *    e.g.: Events.subscribe("/Article/added", Articles.validate)
     *
     *    @class Events
     *    @method subscribe
     *    @param topic {String}
     *    @param callback {Function}
     *    @return Event handler {Array}
     */
				subscribe = function subscribe(topic, callback) {
					var topics = topic.split(' ');

					for (var i = 0; i < topics.length; i++) {
						var _topic = topics[i];

						if (!cache[_topic]) {
							cache[_topic] = [];
						}

						cache[_topic].push(callback);
					}
				},


				/**
     *    Events.unsubscribe
     *    e.g.: var handle = Events.subscribe("/Article/added", Articles.validate);
     *        Events.unsubscribe("/Article/added", Articles.validate);
     *
     *    @class Events
     *    @method unsubscribe
     *    @param topic {String}
     *    @param handle {Function}
     *    @param completly {Boolean}
     */
				unsubscribe = function unsubscribe(topic, handle) {
					var completly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

					var i = cache[topic].length - 1;

					if (cache[topic]) {
						for (i; i >= 0; i--) {
							if (cache[topic][i] === handle) {
								cache[topic].splice(i, 1);
								if (completly) {
									delete cache[topic];
								}
							}
						}
					}
				};

				return {
					publish: publish,
					subscribe: subscribe,
					unsubscribe: unsubscribe,
					trigger: publish,
					on: subscribe,
					off: unsubscribe
				};
			}();

			var VeamsVent = {
				options: {
					furtherEvents: {}
				},
				pluginName: 'Vent',
				initialize: function initialize(Veams, opts) {
					if (opts) {
						this.options = Veams.helpers.extend(this.options, opts || {});
					}

					Veams.Vent = EventsHandler;
					Veams.EVENTS = Veams.helpers.extend(Veams.EVENTS, this.options.furtherEvents);
				}
			};

			exports.default = VeamsVent;
			module.exports = exports['default'];

			/***/
		}
		/******/])
	);
});
;


},{}],28:[function(require,module,exports){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object' && (typeof module === 'undefined' ? 'undefined' : _typeof2(module)) === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define("veams", [], factory);else if ((typeof exports === 'undefined' ? 'undefined' : _typeof2(exports)) === 'object') exports["veams"] = factory();else root["veams"] = root["veams"] || {}, root["veams"]["veams"] = factory();
})(undefined, function () {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};
			/******/
			/******/ // The require function
			/******/function __webpack_require__(moduleId) {
				/******/
				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;
				/******/
				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };
				/******/
				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
				/******/
				/******/ // Flag the module as loaded
				/******/module.loaded = true;
				/******/
				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}
			/******/
			/******/
			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;
			/******/
			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;
			/******/
			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";
			/******/
			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			/**
    * Imports
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var _starter = __webpack_require__(11);

			var _starter2 = _interopRequireDefault(_starter);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			/**
    * Variables
    */

			exports.default = _starter2.default;
			module.exports = exports['default'];

			/***/
		},,,
		/* 1 */
		/* 2 */
		/* 3 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = mixin;

			var _defaults = __webpack_require__(4);

			var _defaults2 = _interopRequireDefault(_defaults);

			var _methodExtend = __webpack_require__(5);

			var _methodExtend2 = _interopRequireDefault(_methodExtend);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			/**
    * Merge method functions.
    *
    * @param {Object} from - Mixin object which will be merged via Helpers.defaults with the methods of our class
    * @param {Array} methods - Array of method names which will be extended.
    */
			function mixin(from) {
				var methods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['initialize', 'render'];

				if (from === undefined) {
					console.error('VeamsHelpers : Mixin :: Mixin not found!');

					return;
				}

				var to = this.prototype;

				/** Add those methods which exists on `from` but not on `to` to the latter */
				(0, _defaults2.default)(to, from);

				/** we do the same for events */
				if (to.events) {
					(0, _defaults2.default)(to.events, from.events);
				}

				// Extend to's methods
				methods.forEach(function (method) {
					(0, _methodExtend2.default)(to, from, method);
				});
			};
			module.exports = exports['default'];

			/***/
		},
		/* 4 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Simple extend method, which extends an object.
    *
    * @param {Object} obj - object which will be extended
    *
    * @return {Object} obj - extended object
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = defaultsHelper;
			function defaultsHelper(obj) {
				[].slice.call(arguments, 1).forEach(function (item) {
					for (var key in item) {
						if (obj[key] === undefined) obj[key] = item[key];
					}
				});
				return obj;
			};
			module.exports = exports['default'];

			/***/
		},
		/* 5 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Helper method to extend an already existing method.
    *
    * @param {Object} to - view which will be extended
    * @param {Object} from - methods which comes from mixin
    * @param {string} methodName - function name
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = methodExtend;
			function methodExtend(to, from, methodName) {
				function isUndefined(value) {
					return typeof value === 'undefined';
				}

				if (from === undefined) return;

				// if the method is defined on from ...
				if (!isUndefined(from[methodName])) {
					var old = to[methodName];

					// ... we create a new function on to
					to[methodName] = function () {

						// wherein we first call the method which exists on `to`
						var oldReturn = old.apply(this, arguments);

						// and then call the method on `from`
						from[methodName].apply(this, arguments);

						// and then return the expected result,
						// i.e. what the method on `to` returns
						return oldReturn;
					};
				}
			};
			module.exports = exports['default'];

			/***/
		},
		/* 6 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Simple extend method to extend the properties of an object.
    *
    * @param {Object} obj - object which will be extended
    *
    * @return {Object} obj - extended object
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = extend;
			function extend(obj) {
				[].slice.call(arguments, 1).forEach(function (item) {
					for (var key in item) {
						obj[key] = item[key];
					}
				});
				return obj;
			};
			module.exports = exports['default'];

			/***/
		},
		/* 7 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Generates numeric id.
    *
    * @param {Number} [segments=1] - number of segments of generated id (segments consist of 10 digits, separated by '-').
    *
    * @return {String} - generated id
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = makeId;
			function makeId() {
				var segments = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

				var crypto = window.crypto || window.msCrypto;
				var array = crypto.getRandomValues(new Uint32Array(segments));
				var id = '';
				var i = 0;

				for (; i < array.length; i++) {
					id += array[i] + '-';
				}

				return id.slice(0, -1);
			};
			module.exports = exports['default'];

			/***/
		},,,,
		/* 8 */
		/* 9 */
		/* 10 */
		/* 11 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			/**
    * Polyfills
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			__webpack_require__(12);

			var _core = __webpack_require__(13);

			var _core2 = _interopRequireDefault(_core);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			var Veams = {};

			/**
    * Imports
    */

			(function (window, document, undefined) {
				'use strict';

				Veams = new _core2.default({
					namespace: 'Veams',
					addToGlobal: true
				});

				Veams.initialize();
			})(window, document);

			exports.default = Veams;
			module.exports = exports['default'];

			/***/
		},
		/* 12 */
		/***/function (module, exports) {

			'use strict';

			// Polyfill for custom events

			(function () {
				if (typeof window.CustomEvent === 'function') return false;

				function CustomEvent(event, params) {
					var evt = document.createEvent('CustomEvent');

					params = params || { bubbles: false, cancelable: false, detail: undefined };

					evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
					return evt;
				}

				CustomEvent.prototype = window.Event.prototype;

				window.CustomEvent = CustomEvent;
			})();

			/***/
		},
		/* 13 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var _createClass = function () {
				function defineProperties(target, props) {
					for (var i = 0; i < props.length; i++) {
						var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
					}
				}return function (Constructor, protoProps, staticProps) {
					if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
				};
			}(); /**
         * Represents VeamsCore.
         * @module VeamsCore
         *
         * @author Sebastian Fitzner
         */

			__webpack_require__(12);

			var _use = __webpack_require__(14);

			var _use2 = _interopRequireDefault(_use);

			var _events = __webpack_require__(15);

			var _events2 = _interopRequireDefault(_events);

			var _helpers = __webpack_require__(16);

			var _helpers2 = _interopRequireDefault(_helpers);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			function _classCallCheck(instance, Constructor) {
				if (!(instance instanceof Constructor)) {
					throw new TypeError("Cannot call a class as a function");
				}
			}

			var initState = false;

			var VeamsCore = function () {
				function VeamsCore(opts) {
					_classCallCheck(this, VeamsCore);

					this._options = {
						namespace: 'Veams',
						addToGlobal: false
					};

					this.base = {
						name: 'Veams',
						version: '5.0.1'
					};

					this.use = _use2.default.bind(this);
					this.Plugins = {};
					this.EVENTS = _events2.default;
					this.helpers = {};
					this.detections = {
						width: window.innerWidth,
						height: window.innerHeight
					};

					initState = false;

					this.setup(opts);
				}

				_createClass(VeamsCore, [{
					key: 'setup',
					value: function setup(opts) {
						this.use(_helpers2.default);

						this.detections = this.helpers.extend({
							touch: this.helpers.isTouch()
						}, this.detections);

						this.options = opts;
					}
				}, {
					key: 'initialize',
					value: function initialize(opts) {
						if (initState === true) {
							return console.info('Veams :: You already initialized Veams!');
						}

						/**
       * Set global options on initialize
       */
						this.options = opts;

						if (this.options.addToGlobal) {
							if (window && !window[this.options.namespace]) {
								window[this.options.namespace] = this || {};
							}
						}

						initState = true;
					}
				}, {
					key: 'onInitialize',
					value: function onInitialize(cb) {
						if (!cb || typeof cb !== 'function') {
							console.log('Veams :: Callback is not a function!');
							return;
						}

						if (initState === false) {
							this.initialize();
						}

						cb();
					}
				}, {
					key: 'onDOMReady',
					value: function onDOMReady(cb) {
						if (typeof cb !== 'function') {
							console.log('Veams :: Callback is not a function!');
							return;
						}
						document.addEventListener('DOMContentLoaded', cb);
					}
				}, {
					key: 'version',
					set: function set(version) {
						this._version = version;
					},
					get: function get() {
						return this._version;
					}
				}, {
					key: 'initialized',
					set: function set(bool) {
						this._initialized = bool;
					},
					get: function get() {
						return this._initialized;
					}
				}, {
					key: 'options',
					set: function set(options) {
						this._options = this.helpers.extend(this.options, options || {});
					},
					get: function get() {
						return this._options;
					}
				}]);

				return VeamsCore;
			}();

			exports.default = VeamsCore;
			module.exports = exports['default'];

			/***/
		},
		/* 14 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Represents a simple plugin system in which `this` is Veams.
    * @module plugin
    *
    * @author Sebastian Fitzner
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			exports.default = function (plugin) {
				if (plugin.pluginName) {
					this.Plugins[plugin.pluginName] = plugin;
				}

				for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
					args[_key - 1] = arguments[_key];
				}

				plugin.initialize.apply(plugin, [this].concat(args));
			};

			module.exports = exports['default'];

			/***/
		},
		/* 15 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Const for events (pub/sub)
    *
    * @author: Sebastian Fitzner
    */

			/**
    * Events Global
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			var EVENTS = {
				blur: 'blur',
				change: 'change',
				click: 'click',
				dblclick: 'dblclick',
				DOMchanged: 'dom:changed',
				DOMredirect: 'dom:redirect',
				hashchange: 'hashchange',
				input: 'input',
				keydown: 'keydown',
				keypress: 'keypress',
				keyup: 'keyup',
				mediachange: 'mediachange',
				moduleCached: 'module:cached',
				mousedown: 'mousedown',
				mouseenter: 'mouseenter',
				mouseleave: 'mouseleave',
				mouseout: 'mouseout',
				mouseover: 'mouseover',
				mouseup: 'mouseup',
				reset: 'reset',
				resize: 'resize',
				scroll: 'scroll',
				submit: 'submit',
				swipe: 'swipe'
			};

			exports.default = EVENTS;
			module.exports = exports['default'];

			/***/
		},
		/* 16 */
		/***/function (module, exports, __webpack_require__) {

			'use strict';

			Object.defineProperty(exports, "__esModule", {
				value: true
			});

			var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
				return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
			} : function (obj) {
				return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
			};

			var _extend = __webpack_require__(6);

			var _extend2 = _interopRequireDefault(_extend);

			var _mixin = __webpack_require__(3);

			var _mixin2 = _interopRequireDefault(_mixin);

			var _methodExtend = __webpack_require__(5);

			var _methodExtend2 = _interopRequireDefault(_methodExtend);

			var _isTouch = __webpack_require__(17);

			var _isTouch2 = _interopRequireDefault(_isTouch);

			var _throttle = __webpack_require__(18);

			var _throttle2 = _interopRequireDefault(_throttle);

			var _querySelectorArray = __webpack_require__(19);

			var _querySelectorArray2 = _interopRequireDefault(_querySelectorArray);

			var _forEach = __webpack_require__(20);

			var _forEach2 = _interopRequireDefault(_forEach);

			var _makeId = __webpack_require__(7);

			var _makeId2 = _interopRequireDefault(_makeId);

			function _interopRequireDefault(obj) {
				return obj && obj.__esModule ? obj : { default: obj };
			}

			var VeamsHelpers = {
				pluginName: 'Helpers',
				initialize: function initialize(Veams) {
					Veams.addHelper = function addHelper() {
						for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
							args[_key] = arguments[_key];
						}

						var params = [].concat(args);

						if (params.length === 1) {
							if (_typeof(params[0]) !== 'object') {
								console.error('VeamsHelpers :: You need to pass an object!');
								return;
							}

							for (var key in params[0]) {
								if (params[0].hasOwnProperty(key)) {
									if (!Veams.helpers[key]) {
										Veams.helpers[key] = params[0][key];
									} else {
										console.info('VeamsHelpers :: The helper ' + key + ' is already defined! Please define a new name for: ', params[0][key]);
									}
								}
							}
						} else if (params.length === 2) {

							if (!Veams.helpers[params[0]]) {
								if (typeof params[0] !== 'string' || typeof params[1] !== 'function') {
									console.error('VeamsHelpers :: You need to pass a string as first argument and the helper function as second one.');
									return;
								}
								Veams.helpers[params[0]] = params[1];
							} else {
								console.info('VeamsHelpers :: The helper ' + params[0] + ' is already defined! Please define a new name for: ', params[1]);
							}
						}
					};

					this.addDefaultHelpers(Veams);
				},

				addDefaultHelpers: function addDefaultHelpers(Veams) {
					Veams.addHelper('querySelectorArray', _querySelectorArray2.default);
					Veams.addHelper('extend', _extend2.default);
					Veams.addHelper('isTouch', _isTouch2.default);
					Veams.addHelper('mixin', _mixin2.default);
					Veams.addHelper('methodExtend', _methodExtend2.default);
					Veams.addHelper('throttle', _throttle2.default);
					Veams.addHelper('forEach', _forEach2.default);
					Veams.addHelper('makeId', _makeId2.default);
				}
			};

			exports.default = VeamsHelpers;
			module.exports = exports['default'];

			/***/
		},
		/* 17 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Touch Detection
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = isTouch;
			function isTouch() {
				return 'ontouchstart' in window;
			};
			module.exports = exports['default'];

			/***/
		},
		/* 18 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Throttle method for resize events and more
    *
    * @param {function} func - Function which will be executed.
    * @param {number} wait - number to wait in milliseconds.
    * @param {boolean} immediate - execute function immediately.
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = throttle;
			function throttle(func, wait, immediate) {
				var timeout = void 0;

				return function () {
					var context = this;
					var args = arguments;
					var callNow = immediate && !timeout;
					var later = function later() {
						timeout = null;
						if (!immediate) func.apply(context, args);
					};

					clearTimeout(timeout);

					timeout = setTimeout(later, wait);

					if (callNow) func.apply(context, args);
				};
			};
			module.exports = exports['default'];

			/***/
		},
		/* 19 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Get dom elements in an array
    *
    * @param {String} elem - Required: selector
    * @param {Object} [context] - Optional: context
    *
    * @return {Array}
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = querySelectorArray;
			function querySelectorArray(elem, context) {
				if (!elem) throw new Error('In order to work with querySelectorArray you need to define an element as string!');
				var el = elem;
				var customContext = context || document;

				return Array.prototype.slice.call(customContext.querySelectorAll(el));
			};
			module.exports = exports['default'];

			/***/
		},
		/* 20 */
		/***/function (module, exports) {

			'use strict';

			/**
    * Simple forEach method
    *
    * @param {Array} array - array of objects
    * @param {function} callback - callback function
    * @param {string} scope - scope of function
    */

			Object.defineProperty(exports, "__esModule", {
				value: true
			});
			exports.default = forEach;
			function forEach(array, callback, scope) {
				for (var i = 0; i < array.length; i++) {
					callback.call(scope, i, array[i]);
				}
			};
			module.exports = exports['default'];

			/***/
		}
		/******/])
	);
});
;


},{}],29:[function(require,module,exports){
'use strict';
/**
 * Represents a base constructor which supports
 * options merging and
 * saving of standard stuff.
 *
 * @module VeamsBase
 * @author Sebastian Fitzner
 */

/**
 * Imports
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _string = require('../utils/internal-helpers/string');

var _string2 = _interopRequireDefault(_string);

var _mixin = require('../utils/helpers/mixin');

var _mixin2 = _interopRequireDefault(_mixin);

var _extend = require('../utils/helpers/extend');

var _extend2 = _interopRequireDefault(_extend);

var _makeId = require('../utils/helpers/make-id');

var _makeId2 = _interopRequireDefault(_makeId);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var VeamsBase = function () {
	/**
  * Constructor
  *
  * to save standard elements like el and options and
  * execute initialize as default method.
  *
  * @param {String} namespace - Add custom namespace to your class.
  * @param {Object} el - Save element in class.
  * @param {Object} options - Options passed by init process.
  * @param {Object} opts [{}] - Object which contains options of the extended class.
  */
	function VeamsBase(_ref) {
		var namespace = _ref.namespace,
		    el = _ref.el,
		    options = _ref.options;
		var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		_classCallCheck(this, VeamsBase);

		this.namespace = namespace || 'base';
		this.instanceId = this.namespace;
		this.options = opts;
		this._options = options;

		if (el) {
			this.el = el;
		}
	}

	// ----------------------------------------------------------
	// GETTER & SETTERS
	// ----------------------------------------------------------

	_createClass(VeamsBase, [{
		key: 'namespace',
		set: function set(namespace) {
			this._namespace = namespace;
		},
		get: function get() {
			return this._namespace;
		}
	}, {
		key: 'instanceId',
		get: function get() {
			return this._instanceId;
		},
		set: function set(id) {
			this._instanceId = id + '_' + Date.now() + '_' + (0, _makeId2.default)();
		}
	}, {
		key: '_options',
		get: function get() {
			return this.options;
		},
		set: function set(options) {
			this.options = (0, _extend2.default)(this.options, options || {});
		}
	}, {
		key: 'el',
		set: function set(element) {
			this._el = element;
		},
		get: function get() {
			return this._el;
		}

		/**
   * Get module information
   */

	}, {
		key: 'metaData',
		get: function get() {
			return {
				name: typeof this.namespace === 'string' ? _string2.default.capitalizeFirstLetter(_string2.default.toCamelCase(this.namespace)) : ''
			};
		}
	}]);

	return VeamsBase;
}();

/**
 * Add mixin functionality to extend module class by using simple objects
 */


VeamsBase.mixin = _mixin2.default;

exports.default = VeamsBase;
module.exports = exports['default'];

},{"../utils/helpers/extend":32,"../utils/helpers/make-id":34,"../utils/helpers/mixin":36,"../utils/internal-helpers/string":39}],30:[function(require,module,exports){
'use strict';

/**
 * Represents a component constructor which supports
 * options merging,
 * binding and unbinding of events and subscriptions with template strings,
 * rendering of templates
 * and a destroy behaviour.
 *
 * Keep in mind, that this class is a dependent of Veams.
 *
 * TODO: Make a native one which does not need any Veams specific stuff.
 *
 * @module VeamsComponent
 * @author Sebastian Fitzner
 */

/**
 * Imports
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _base = require('./base');

var _base2 = _interopRequireDefault(_base);

var _getStringValue = require('../utils/internal-helpers/get-string-value');

var _getStringValue2 = _interopRequireDefault(_getStringValue);

var _templateEngine = require('../utils/internal-helpers/template-engine');

var _templateEngine2 = _interopRequireDefault(_templateEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Custom Functions
 */
function buildEvtId(evtKeyArr, fnName) {
	return evtKeyArr.join('_') + '_' + fnName;
}

var VeamsComponent = function (_VeamsBase) {
	_inherits(VeamsComponent, _VeamsBase);

	/**
  * Constructor
  *
  * to save standard elements like el and options and
  * execute initialize as default method.
  *
  * @param {Object} obj [{}] - Object which contains el, options from the DOM and namespace.
  * @param {Object} options [{}] - Object which contains options of the extended class.
  */
	function VeamsComponent() {
		var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
		var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		_classCallCheck(this, VeamsComponent);

		var _this = _possibleConstructorReturn(this, (VeamsComponent.__proto__ || Object.getPrototypeOf(VeamsComponent)).call(this, obj, options));

		_this.appInstance = obj.appInstance || window.Veams;

		if (!_this.appInstance) {
			throw new Error('VeamsComponent :: Please provide your app instance!');
		}

		if (!_this.appInstance.$) {
			console.info('VeamsComponent :: Please add a DOM handler like jQuery to the app instance!');
		}

		if (_this.appInstance.$) {
			_this.$el = _this.appInstance.$(obj.el);
		}

		_this.initialize(obj, options);
		_this._create();
		return _this;
	}

	// ----------------------------------------------------------
	// GETTER & SETTERS
	// ----------------------------------------------------------

	/**
  * Get and set events object
  */


	_createClass(VeamsComponent, [{
		key: 'initialize',


		// ----------------------------------------------------------
		// STANDARD METHODS
		// ----------------------------------------------------------
		value: function initialize() {
			return this;
		}

		/**
   * Private method to create all necessary elements and bindings.
   *
   * @private
   */

	}, {
		key: '_create',
		value: function _create() {
			this.preRender();
			this.registerEvents(this.events, false);
			this.registerEvents(this.subscribe, true);
			this.bindEvents();
		}

		/**
   * Bind local and global events
   *
   * @public
   */

	}, {
		key: 'bindEvents',
		value: function bindEvents() {}

		/**
   * Unbind events
   *
   * @public
   */

	}, {
		key: 'unbindEvents',
		value: function unbindEvents() {}

		/**
   * Pre-Render templates
   * which can be used to render content into it
   *
   * @public
   */

	}, {
		key: 'preRender',
		value: function preRender() {
			return this;
		}

		/**
   * Render your module
   *
   * @public
   */

	}, {
		key: 'render',
		value: function render() {
			return this;
		}

		/**
   * Destroy component by unbinding events and
   * removing element from DOM
   */

	}, {
		key: 'destroy',
		value: function destroy() {
			this.unregisterEvents();
			this.unbindEvents();
			this.$el.remove();
		}

		/**
   * Render template with data
   *
   * @param {String} tplName - Template name which gets returned as rendered element.
   * @param {Object} data - Data which gets handled by the template.
   */

	}, {
		key: 'renderTemplate',
		value: function renderTemplate(tplName, data) {
			if (!this.appInstance.templater) {
				console.error('\n\t\t\t\tVeamsComponent :: It seems that you haven\'t added the VeamsTemplater plugin. In order to work with \'renderTemplate()\' you need to add it!\n\t\t\t');
			} else {
				return this.appInstance.templater.render(tplName, data);
			}
		}

		// ----------------------------------------------------------
		// MOUNT PROCESS METHODS
		// Mount process methods will be handled by the VeamsModules plugin
		// ----------------------------------------------------------

		/**
   * This method will be executed after initialise
   */

	}, {
		key: 'willMount',
		value: function willMount() {}

		/**
   * This method will be executed before unregistering events
   */

	}, {
		key: 'willUnmount',
		value: function willUnmount() {}

		/**
   * This method will be executed after render
   */

	}, {
		key: 'didMount',
		value: function didMount() {}

		/**
   * This method will be executed after unregistering events
   */

	}, {
		key: 'didUnmount',
		value: function didUnmount() {}

		// ----------------------------------------------------------
		// EVENTS METHODS
		// ----------------------------------------------------------

		/**
   * Register multiple events which are saved in an object.
   *
   * @param {Object} evts - Events object which contains an object with events as key and functions as value.
   * @param {Boolean} global - Flag to switch between global and local events.
   *
   * @private
   */

	}, {
		key: 'registerEvents',
		value: function registerEvents(evts) {
			var _this2 = this;

			var global = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

			if (evts) {
				Object.keys(evts).forEach(function (key) {
					_this2.registerEvent(key, evts[key], global);
				});
			}
		}

		/**
   * Register an event by using a simple template engine and
   * a key/value pair.
   *
   * @param {String} evtKey - Event key which contains event and additionally a delegated element.
   * @param {String} fn - Function defined as string which will be bound to this.
   * @param {Boolean} global - Flag if global or local event .
   *
   * @public
   *
   * @example
   * this.registerEvent('click .btn', 'render');
   * this.registerEvent('click {{this.options.btn}}', 'render');
   * this.registerEvent('{{App.EVENTS.custom.event', 'render');
   * this.registerEvent('{{App.EVENTS.resize', 'render', true);
   */

	}, {
		key: 'registerEvent',
		value: function registerEvent(evtKey, fn) {
			var global = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

			if (typeof evtKey !== 'string') {
				console.error('VeamsComponent :: Your event is not a string!');
				return;
			}

			if (typeof fn !== 'string') {
				console.error('VeamsComponent :: Your event handler function is not a string!');
				return;
			}

			var evtKeyArr = evtKey.split(' ');
			var arrlen = evtKeyArr.length;
			var evtType = _getStringValue2.default.apply(this, [(0, _templateEngine2.default)(evtKeyArr[0]), this.appInstance]);
			var bindFn = this[fn].bind(this);
			var id = buildEvtId(evtKeyArr, fn);

			if (arrlen > 2) {
				throw new Error('It seems like you have more than two strings in your events object!');
			}

			// Bind on this.$el
			if (arrlen === 1 && !global) {
				this.$el.on(evtType, bindFn);

				this._subscribers = {
					type: 'event',
					id: id,
					event: evtType,
					handler: bindFn
				};
			} else if (arrlen === 1 && global) {
				this.appInstance.Vent.subscribe(evtType, bindFn);

				this._subscribers = {
					type: 'globalEvent',
					id: id,
					event: evtType,
					handler: bindFn
				};
			} else {
				var delegate = _getStringValue2.default.apply(this, [(0, _templateEngine2.default)(evtKeyArr[1])]);

				this.$el.on(evtType, delegate, bindFn);

				this._subscribers = {
					type: 'delegatedEvent',
					delegate: delegate,
					id: id,
					event: evtType,
					handler: bindFn
				};
			}
		}

		/**
   * Delete all registered events.
   */

	}, {
		key: 'unregisterEvents',
		value: function unregisterEvents() {
			for (var key in this._subscribers) {
				if (this._subscribers.hasOwnProperty(key)) {
					var obj = this._subscribers[key];

					if (obj.type === 'globalEvent') {
						this.appInstance.Vent.unsubscribe(obj.event, obj.handler);
					} else if (obj.type === 'delegatedEvent') {
						this.$el.off(obj.event, obj.delegate, obj.handler);
					} else {
						this.$el.off(obj.event, obj.handler);
					}
				}
			}
		}

		/**
   * Unregister an event by using the saved subscribers and
   * a key/value pair.
   *
   *
   * @param {String} evtKey - Event key which contains event and additionally a delegated element.
   * @param {String} fn - Function defined as string which will be unbound to this.
   *
   * @public
   *
   * @example
   * this.unregisterEvent('click .btn', 'render');
   * this.unregisterEvent('click {{this.options.btn}}', 'render');
   * this.unregisterEvent('{{App.EVENTS.custom.event', 'render');
   * this.unregisterEvent('{{App.EVENTS.resize', 'render');
   */

	}, {
		key: 'unregisterEvent',
		value: function unregisterEvent(evtKey, fn) {
			var evtKeyArr = evtKey.split(' ');
			var id = buildEvtId(evtKeyArr, fn);

			if (this._subscribers[id]) {
				var obj = this._subscribers[id];

				if (obj.type === 'globalEvent') {
					this.appInstance.Vent.unsubscribe(obj.event, obj.handler);
				} else if (obj.type === 'delegatedEvent') {
					this.$el.off(obj.event, obj.delegate, obj.handler);
				} else {
					this.$el.off(obj.event, obj.handler);
				}
			}
		}
	}, {
		key: 'events',
		set: function set(obj) {
			this._events = obj;
		},
		get: function get() {
			return this._events;
		}

		/**
   * Get and set subscribe object
   */

	}, {
		key: 'subscribe',
		set: function set(obj) {
			this._subscribe = obj;
		},
		get: function get() {
			return this._subscribe;
		}
	}, {
		key: '_subscribers',
		set: function set(obj) {
			if (!this.__subscribers) {
				this.__subscribers = {};
			}

			this.__subscribers[obj.id] = {
				delegate: obj.delegate,
				type: obj.type,
				event: obj.event,
				handler: obj.handler
			};
		},
		get: function get() {
			return this.__subscribers;
		}
	}]);

	return VeamsComponent;
}(_base2.default);

exports.default = VeamsComponent;
module.exports = exports['default'];

},{"../utils/internal-helpers/get-string-value":38,"../utils/internal-helpers/template-engine":40,"./base":29}],31:[function(require,module,exports){
'use strict';

/**
 * Simple extend method, which extends an object.
 *
 * @param {Object} obj - object which will be extended
 *
 * @return {Object} obj - extended object
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = defaultsHelper;
function defaultsHelper(obj) {
  [].slice.call(arguments, 1).forEach(function (item) {
    for (var key in item) {
      if (obj[key] === undefined) obj[key] = item[key];
    }
  });
  return obj;
};
module.exports = exports['default'];

},{}],32:[function(require,module,exports){
'use strict';

/**
 * Simple extend method to extend the properties of an object.
 *
 * @param {Object} obj - object which will be extended
 *
 * @return {Object} obj - extended object
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extend;
function extend(obj) {
  [].slice.call(arguments, 1).forEach(function (item) {
    for (var key in item) {
      obj[key] = item[key];
    }
  });
  return obj;
};
module.exports = exports['default'];

},{}],33:[function(require,module,exports){
'use strict';

/**
 * Check if element is in viewport
 *
 * @param {Object} elem - Object, which we want to check
 * @param {boolean} useBounds - if true, whole element must be visible
 *
 * @return {boolean}
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = isInViewport;
function isInViewport(elem, useBounds) {
	var el = elem;
	var top = el.offsetTop;
	var left = el.offsetLeft;
	var width = el.offsetWidth;
	var height = el.offsetHeight;
	var cond = false;

	while (el.offsetParent) {
		el = el.offsetParent;
		top += el.offsetTop;
		left += el.offsetLeft;
	}

	if (useBounds) {
		cond = top >= window.pageYOffset && left >= window.pageXOffset && top + height <= window.pageYOffset + window.innerHeight && left + width <= window.pageXOffset + window.innerWidth;
	} else {
		cond = top < window.pageYOffset + window.innerHeight && left < window.pageXOffset + window.innerWidth && top + height > window.pageYOffset && left + width > window.pageXOffset;
	}

	return cond;
};
module.exports = exports['default'];

},{}],34:[function(require,module,exports){
'use strict';

/**
 * Generates numeric id.
 *
 * @param {Number} [segments=1] - number of segments of generated id (segments consist of 10 digits, separated by '-').
 *
 * @return {String} - generated id
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = makeId;
function makeId() {
	var segments = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

	var crypto = window.crypto || window.msCrypto;
	var array = crypto.getRandomValues(new Uint32Array(segments));
	var id = '';
	var i = 0;

	for (; i < array.length; i++) {
		id += array[i] + '-';
	}

	return id.slice(0, -1);
};
module.exports = exports['default'];

},{}],35:[function(require,module,exports){
'use strict';

/**
 * Helper method to extend an already existing method.
 *
 * @param {Object} to - view which will be extended
 * @param {Object} from - methods which comes from mixin
 * @param {string} methodName - function name
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = methodExtend;
function methodExtend(to, from, methodName) {
	function isUndefined(value) {
		return typeof value === 'undefined';
	}

	if (from === undefined) return;

	// if the method is defined on from ...
	if (!isUndefined(from[methodName])) {
		var old = to[methodName];

		// ... we create a new function on to
		to[methodName] = function () {

			// wherein we first call the method which exists on `to`
			var oldReturn = old.apply(this, arguments);

			// and then call the method on `from`
			from[methodName].apply(this, arguments);

			// and then return the expected result,
			// i.e. what the method on `to` returns
			return oldReturn;
		};
	}
};
module.exports = exports['default'];

},{}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = mixin;

var _defaults = require('./defaults');

var _defaults2 = _interopRequireDefault(_defaults);

var _methodExtend = require('./method-extend');

var _methodExtend2 = _interopRequireDefault(_methodExtend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Merge method functions.
 *
 * @param {Object} from - Mixin object which will be merged via Helpers.defaults with the methods of our class
 * @param {Array} methods - Array of method names which will be extended.
 */
function mixin(from) {
	var methods = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['initialize', 'render'];

	if (from === undefined) {
		console.error('VeamsHelpers : Mixin :: Mixin not found!');

		return;
	}

	var to = this.prototype;

	/** Add those methods which exists on `from` but not on `to` to the latter */
	(0, _defaults2.default)(to, from);

	/** we do the same for events */
	if (to.events) {
		(0, _defaults2.default)(to.events, from.events);
	}

	// Extend to's methods
	methods.forEach(function (method) {
		(0, _methodExtend2.default)(to, from, method);
	});
};
module.exports = exports['default'];

},{"./defaults":31,"./method-extend":35}],37:[function(require,module,exports){
'use strict';

/**
 * Detect transitionend event.
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = transitionEndEvent;
function transitionEndEvent() {
	var t = void 0;
	var el = document.createElement('fakeelement');
	var transitions = {
		'transition': 'transitionend',
		'OTransition': 'oTransitionEnd',
		'MozTransition': 'transitionend',
		'WebkitTransition': 'webkitTransitionEnd'
	};

	for (t in transitions) {
		if (el.style[t] !== undefined) {
			return transitions[t];
		}
	}
};
module.exports = exports['default'];

},{}],38:[function(require,module,exports){
'use strict';

/**
 * Get value out of variable string.
 *
 * @param {String} str - String which is a reference to a var.
 *
 * @return String
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
var getStringValue = function getStringValue(str, instanceObject) {
	if (str.indexOf('.') === -1) return str;
	var arr = str.split('.');
	var context = arr[0];
	var finalStr = context === 'this' ? this : instanceObject ? instanceObject : window[context];

	var strReplacer = function strReplacer(el, prev) {
		return prev[el];
	};

	arr.shift();
	arr.forEach(function (item) {
		finalStr = strReplacer(item, finalStr);
		return finalStr;
	});

	if (typeof finalStr !== 'string') {
		throw new Error('The resulting variable out of your events object must be a string!');
	} else {
		return finalStr;
	}
};

exports.default = getStringValue;
module.exports = exports['default'];

},{}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
var stringHelpers = {};

/**
 * CamelCase strings by replacing hyphens, white space and points.
 *
 * @param {String} str - String which will be camelcased
 */
stringHelpers.toCamelCase = function (str) {
	// Lower cases the string
	return str.toLowerCase()
	// Replaces any - or _ characters with a space
	.replace(/[-_]+/g, ' ')
	// Removes any non alphanumeric characters
	.replace(/[^\w\s]/g, '')
	// Uppercases the first character in each group immediately following a space
	// (delimited by spaces)
	.replace(/ (.)/g, function ($1) {
		return $1.toUpperCase();
	})
	// Removes spaces
	.replace(/ /g, '');
};

/**
 * String which will be hyphenated by replacing white space and lower case the characters.
 * @param {String} str - String
 */
stringHelpers.hyphenate = function (str) {
	return str.replace(/\s/g, '-').toLowerCase();
};

/**
 * String.
 * @param {String} str - String where first char is upper cased
 */
stringHelpers.capitalizeFirstLetter = function (str) {
	return str.charAt(0).toUpperCase() + str.slice(1);
};

exports.default = stringHelpers;
module.exports = exports['default'];

},{}],40:[function(require,module,exports){
'use strict';

/**
 * Simple template engine for event system.
 *
 * @param {String} tplStr - Template string.
 *
 * @return String
 */

Object.defineProperty(exports, "__esModule", {
	value: true
});
var templateEngine = function templateEngine(tplStr) {
	var reg = new RegExp('(\{\{\s?)(.+)(\s?\}\})');
	var match = reg.exec(tplStr);
	var returnVal = '';

	if (match) {
		returnVal = match[2];
	} else {
		returnVal = tplStr;
	}

	return returnVal;
};

exports.default = templateEngine;
module.exports = exports['default'];

},{}],41:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});/**
 * Const for events (pub/sub)
 *
 * @author: Sebastian Fitzner
 *//**
 * Events Global
 */var EVENTS={};/**
 * Events for Slider
 */EVENTS.slider={slideStart:'slide:start'};/**
 * Events Accordion
 */EVENTS.accordion={openAll:'accordion:openAll',closeAll:'accordion:closeAll'};/**
 * Events for Toggler
 */EVENTS.toggler={eventName:'toggler:eventName'};/**
 * Events Form
 */EVENTS.form={complete:'form:complete',reset:'form:reset'};/**
 * Events Overlay
 */EVENTS.overlay={open:'overlay:open'};// @INSERTPOINT :: @ref: js-events
exports.default=EVENTS;

},{}],42:[function(require,module,exports){
'use strict';var _app=require('./app');var _slider=require('../templating/partials/components/slider/js/slider');var _slider2=_interopRequireDefault(_slider);var _accordion=require('../templating/partials/components/accordion/js/accordion');var _accordion2=_interopRequireDefault(_accordion);var _toggler=require('../templating/partials/components/toggler/js/toggler');var _toggler2=_interopRequireDefault(_toggler);var _cta=require('../templating/partials/components/cta/js/cta');var _cta2=_interopRequireDefault(_cta);var _formAjax=require('../templating/partials/components/form/js/form-ajax');var _formAjax2=_interopRequireDefault(_formAjax);var _formDatepicker=require('../templating/partials/components/form/js/form-datepicker');var _formDatepicker2=_interopRequireDefault(_formDatepicker);var _comparer=require('../templating/partials/components/comparer/js/comparer');var _comparer2=_interopRequireDefault(_comparer);var _overlay=require('../templating/partials/components/overlay/js/overlay');var _overlay2=_interopRequireDefault(_overlay);var _slideFox=require('../templating/partials/components/slide-fox/js/slide-fox');var _slideFox2=_interopRequireDefault(_slideFox);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}console.log('JS initialized in version:',_app.App.version);// Global dependencies
console.log('Veams initialized in version:',_app.Veams.base.version);// Imports
// @INSERTPOINT :: @ref: js-self-contained-import, @keep: true //
// Initialize modules with Veams
_app.Veams.modules.register([/**
     * Init Slider
     */{namespace:'slider',module:_slider2.default},// Init Accordion
{namespace:'accordion',module:_accordion2.default},// Init Toggler //
{domName:'toggler',module:_toggler2.default},// Init Call-To-Action
{namespace:'cta',module:_cta2.default},/**
     * Init AJAX Form
     */{namespace:'form-ajax',module:_formAjax2.default},/**
     * Init Form Datepicker
     */{namespace:'form-datepicker',module:_formDatepicker2.default},// Init Comparer
{namespace:'comparer',module:_comparer2.default},/**
     * Init SlideFox
     */{namespace:'slide-fox',module:_slideFox2.default// @INSERTPOINT :: @ref: js-init-v5, @keep: true //
}]);/**
 * Init Overlay
 */new _overlay2.default({appInstance:_app.Veams});// @INSERTPOINT :: @ref: js-init-once-v5, @keep: true //

},{"../templating/partials/components/accordion/js/accordion":44,"../templating/partials/components/comparer/js/comparer":45,"../templating/partials/components/cta/js/cta":46,"../templating/partials/components/form/js/form-ajax":47,"../templating/partials/components/form/js/form-datepicker":48,"../templating/partials/components/overlay/js/overlay":49,"../templating/partials/components/slide-fox/js/slide-fox":50,"../templating/partials/components/slider/js/slider":51,"../templating/partials/components/toggler/js/toggler":52,"./app":"app"}],43:[function(require,module,exports){
"use strict";module.exports=function(Handlebars){window["App"]=window["App"]||{};window["App"]["Templates"]=window["App"]["Templates"]||{};window["App"]["Templates"]["OVERLAY"]=Handlebars.template({"compiler":[7,">= 4.0.0"],"main":function main(container,depth0,helpers,partials,data){return"<div class=\"c-overlay--default\" data-css=\"c-overlay\" data-js-item=\"overlay\">\n	<div class=\"overlay__wrapper\">\n		<button class=\"overlay__close\" data-js-item=\"overlay-close\"></button>\n		<div class=\"overlay__content\">\n			<div class=\"overlay__inner\" data-js-item=\"overlay-content\">\n\n			</div>\n		</div>\n	</div>\n	<div class=\"overlay__mask\" data-js-item=\"overlay-mask\"></div>\n</div>";},"useData":true});return window["App"]["Templates"];};

},{}],44:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * Represents a simple accordion with transitions and max-height.
 *
 * @module Accordion
 * @version v3.0.2
 *
 * @author Sebastian Fitzner
 * @author Andy Gutsche
 *//**
 * Requirements
 */var $=_app.Veams.$;var Helpers=_app.Veams.helpers;/**
 * Class Accordion
 */var Accordion=function(_VeamsComponent){_inherits(Accordion,_VeamsComponent);function Accordion(obj){_classCallCheck(this,Accordion);var options={activeClass:'is-active',accordionBtn:'[data-js-item="accordion-btn"]',accordionContent:'[data-js-item="accordion-content"]',calculatingClass:'is-calculating',clickHandler:'click',closeClass:'is-closed',dataMaxAttr:'data-js-height',openAllOnInit:false,openByHash:false,openClass:'is-open',openIndex:null,openOnViewports:['tablet-small','tablet-large','desktop'],// array: viewport names - eg.: ['mobile', 'tablet', 'desktop-small', 'desktop']
removeStyles:false,// TODO
singleOpen:false,tabMode:false,unresolvedClass:'is-unresolved'};return _possibleConstructorReturn(this,(Accordion.__proto__||Object.getPrototypeOf(Accordion)).call(this,obj,options));}/** =================================================
	 * GETTER & SETTER
	 * ================================================ *//**
	 * Get module information
	 */_createClass(Accordion,[{key:'initialize',/** =================================================
	 * STANDARD METHODS
	 * ================================================= *//**
	 * Init method to save all necessary references.
	 */value:function initialize(){this.$accordionContents=$(this.options.accordionContent,this.$el);this.$accordionBtns=$(this.options.accordionBtn,this.$el);this.$target=null;this.$btn=null;this.openIndex=this.options.openIndex;if(this.options.openByHash){var idx=this.getIndexByHash();this.openIndex=typeof idx==='number'?idx:this.options.openIndex;}else if(this.options.tabMode&&!this.options.openIndex){this.openIndex=0;}}/**
	 * Bind all events
	 */},{key:'bindEvents',value:function bindEvents(){var fnOnHashChange=this.onHashChange.bind(this);// Global events
if(this.options.openByHash){$(window).on(_app.Veams.EVENTS.hashchange,fnOnHashChange);}}},{key:'render',value:function render(){if(!_app.Veams.currentMedia){console.warn('Accordion: Veams.currentMedia is necessary to support the slider module!');return;}this.removeStyles();this.saveHeights(this.$accordionContents);this.closeAll();if(this.options.openAllOnInit){this.openAll();}// Open on index if set in options
if(typeof this.openIndex==='number'){if(this.options.tabMode||this.options.openOnViewports.indexOf(_app.Veams.currentMedia)!==-1){this.activateBtn(this.$accordionBtns.eq(this.openIndex));this.slideDown(this.$accordionContents.eq(this.openIndex));}}if(this.$el.hasClass(this.options.unresolvedClass)){this.$el.removeClass(this.options.unresolvedClass);}}/** =================================================
	 * CUSTOM ACCORDION METHODS
	 * ================================================= *//**
	 * Get index of accordion content referenced by hash
	 *
	 * @return {number|boolean} - index of element or false if no match
	 */},{key:'getIndexByHash',value:function getIndexByHash(){var hash=document.location.hash.split('#');var retVal=false;var i=0;if(hash<2){return false;}for(i;i<this.$accordionContents.length;i++){if(this.$accordionContents[i].id===hash[1]){retVal=i;break;}}return retVal;}/**
	 * Open accordion content referenced by hash
	 *
	 * @param {object} e - event object
	 */},{key:'onHashChange',value:function onHashChange(e){var idx=this.getIndexByHash();if(typeof idx==='number'){if(this.options.singleOpen){this.closeAll();}this.activateBtn(this.$accordionBtns.eq(idx));this.slideDown(this.$accordionContents.eq(idx));}}/**
	 * Save heights of all accordion contents.
	 *
	 * @param {Array} items - array of items
	 */},{key:'saveHeights',value:function saveHeights(items){var _this2=this;Helpers.forEach(items,function(idx,item){_this2.saveHeight(item);});}/**
	 * Save the height of the node item.
	 *
	 * @param {Object} item - item to calculate the height
	 */},{key:'saveHeight',value:function saveHeight(item){var $el=$(item);// the el is hidden so:
// making the el block so we can measure its height but still be hidden
$el.addClass(this.options.calculatingClass);var wantedHeight=$el.outerHeight();// reverting to the original values
$el.removeClass(this.options.calculatingClass);// save height in data attribute
$el.attr(this.options.dataMaxAttr,wantedHeight);}/**
	 * Handle the click,
	 * get the id of the clicked button and
	 * execute the toggleContent method.
	 *
	 * @param {Object} e - event object
	 * @param {object} currentTarget - Target to which listener was attached.
	 */},{key:'handleClick',value:function handleClick(e,currentTarget){this.$btn=currentTarget?$(currentTarget):$(e.currentTarget);var targetId=this.$btn.attr('href');e.preventDefault();if(this.options.tabMode&&this.$btn.hasClass(this.options.activeClass)){return;}this.toggleContent(targetId);}/**
	 * Toggle the accordion content by using the id of the accordion button.
	 *
	 * @param {String} id - id of the target
	 *
	 * @public
	 */},{key:'toggleContent',value:function toggleContent(id){this.$target=this.$el.find(id);if(this.$target.hasClass(this.options.openClass)){this.slideUp(this.$target);this.deactivateBtn(this.$btn);}else{if(this.options.singleOpen||this.options.tabMode){this.closeAll();}this.activateBtn(this.$btn);this.slideDown(this.$target);}}/**
	 * Mimics the slideUp functionality of jQuery by using height and transition.
	 *
	 * @param {Object} $item - jQuery object of item
	 */},{key:'slideUp',value:function slideUp($item){$item.css('height',0).removeAttr('style').attr('aria-expanded','false').removeClass(this.options.openClass).addClass(this.options.closeClass);}/**
	 * Mimics the slideDown functionality of jQuery by using height and transition.
	 *
	 * @param {Object} $item - jQuery object of item
	 */},{key:'slideDown',value:function slideDown($item){$item.css('height',$item.attr('data-js-height')+'px').attr('aria-expanded','true').removeClass(this.options.closeClass).addClass(this.options.openClass);}/**
	 * Adds active class to the clicked button.
	 *
	 * @param {Object} $item - jQuery object of button
	 */},{key:'activateBtn',value:function activateBtn($item){$item.addClass(this.options.activeClass);}/**
	 * Removes active class from the button.
	 *
	 * @param {Object} $item - jQuery object of button
	 */},{key:'deactivateBtn',value:function deactivateBtn($item){$item.removeClass(this.options.activeClass);}/**
	 * Remove all styles of the accordion content elements
	 */},{key:'removeStyles',value:function removeStyles(){this.$accordionContents.removeAttr('style');}/**
	 * Close all accordion contents and active buttons
	 *
	 * @public
	 */},{key:'closeAll',value:function closeAll(){var _this3=this;Helpers.forEach(this.$accordionContents,function(idx,item){_this3.slideUp($(item));});Helpers.forEach(this.$accordionBtns,function(idx,item){_this3.deactivateBtn($(item));});}/**
	 * Close all accordion contents and active buttons
	 *
	 * @public
	 */},{key:'openAll',value:function openAll(){var _this4=this;Helpers.forEach(this.$accordionContents,function(idx,item){_this4.slideDown($(item));});Helpers.forEach(this.$accordionBtns,function(idx,item){_this4.activateBtn($(item));});}},{key:'$accordionContents',set:function set(items){this._$accordionContents=items;},get:function get(){return this._$accordionContents;}},{key:'$accordionBtns',set:function set(items){this._$accordionBtns=items;},get:function get(){return this._$accordionBtns;}},{key:'$target',set:function set(item){this._$target=item;},get:function get(){return this._$target;}},{key:'$btn',set:function set(item){this._$btn=item;},get:function get(){return this._$btn;}/** =================================================
	 * EVENTS
	 * ================================================ */},{key:'events',get:function get(){return{'{{this.options.clickHandler}} {{this.options.accordionBtn}}':'handleClick'};}},{key:'subscribe',get:function get(){return{'{{Veams.EVENTS.resize}}':'render','{{Veams.EVENTS.accordion.closeAll}}':'closeAll','{{Veams.EVENTS.accordion.openAll}}':'openAll'};}}],[{key:'info',get:function get(){return{name:'Accordion',version:'3.0.2',vc:true,mod:false// set to true if source was modified in project
};}}]);return Accordion;}(_component2.default);// Returns constructor
exports.default=Accordion;

},{"app":"app","veams/src/js/common/component":30}],45:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * Description of ContentComparer.
 *
 * @module ContentComparer
 * @version v3.0.0
 *
 * @author koen.zigterman
 */var $=_app.Veams.$;var Comparer=function(_VeamsComponent){_inherits(Comparer,_VeamsComponent);/**
	 * Constructor for our class
	 *
	 * @see module.js
	 *
	 * @param {Object} obj - Object which is passed to our class
	 * @param {Object} obj.el - element which will be saved in this.el
	 * @param {Object} obj.options - options which will be passed in as JSON object
	 */function Comparer(obj){_classCallCheck(this,Comparer);var options={handle:'[data-js-item="comparer-handle"]',topContainer:'[data-js-item="comparer-top-container"]',topContent:'[data-js-item="comparer-top-content"]',draggClass:'is-dragging',dragMode:true,topContentRight:false,disabled:{'desktop':false,'tablet-large':false,'tablet-small':false,'mobile-large':false,'mobile-medium':false,'mobile-small':false}};return _possibleConstructorReturn(this,(Comparer.__proto__||Object.getPrototypeOf(Comparer)).call(this,obj,options));}/** =================================================
	 * GETTER & SETTER
	 * ================================================ *//**
	 * Get module information
	 */_createClass(Comparer,[{key:'initialize',/** =================================================
	 * STANDARD METHODS
	 * ================================================= *//**
	 * Initialize the view and merge options
	 *
	 */value:function initialize(){this.$topContainer=$(this.options.topContainer,this.$el);this.$topContent=$(this.options.topContent,this.$el);this.$handle=$(this.options.handle,this.$el);}/**
	 * Pre-Render method
	 */},{key:'preRender',value:function preRender(){// Return if module is disabled
if(this.disabled)return;this.elWidth=this.el.clientWidth;this.$topContent.css('width',this.elWidth);}/**
	 * Render method
	 */},{key:'render',value:function render(){if(this.options.disabled[_app.Veams.currentMedia]&&!this.disabled){this.disabled=true;this.resetStyles();}else{this.disabled=this.options.disabled[_app.Veams.currentMedia];}}/** =================================================
	 * CUSTOM COMPARER METHODS
	 * ================================================= */},{key:'mouseDown',value:function mouseDown(e){e.preventDefault();this.dragging=true;this.$handle.addClass(this.options.draggClass);}},{key:'mouseUp',value:function mouseUp(){this.dragging=false;this.$handle.addClass(this.options.draggClass);}/**
	 * Resize top container
	 */},{key:'resizeContainer',value:function resizeContainer(e){// Return if module is disabled or if it is not dragging when dragging mode is enabled
if(this.disabled||!this.dragging&&this.options.dragMode)return;var mousePos=this.getMousePos(e);var contentWidth=this.options.topContentRight?this.elWidth-mousePos:0+mousePos;this.$topContainer.css('width',contentWidth);}/**
	 * Reset styles
	 */},{key:'resetStyles',value:function resetStyles(){this.$topContent.removeAttr('style');this.$topContainer.removeAttr('style');}/**
	 * Get mouse position
	 */},{key:'getMousePos',value:function getMousePos(e){return e.pageX-this.$el.offset().left;}},{key:'subscribe',/** =================================================
	 * EVENTS
	 * ================================================ *//**
	 * Subscribe to global events of Veams or App namespace.
	 */get:function get(){return{'{{Veams.EVENTS.resize}}':'preRender','{{Veams.EVENTS.mediachange}}':'render'};}/**
	 * Bind local events to this.$el.
	 */},{key:'events',get:function get(){return{'mousedown {{this.options.handle}}':'mouseDown','mouseup':'mouseUp','touchstart {{this.options.handle}}':'mouseDown','touchend':'mouseUp','mousemove':'resizeContainer'};}}],[{key:'info',get:function get(){return{version:'3.0.0'};}}]);return Comparer;}(_component2.default);exports.default=Comparer;

},{"app":"app","veams/src/js/common/component":30}],46:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * Represents a button with custom click handlers.
 *
 * @module CTA
 * @version v3.0.2
 *
 * @author Sebastian Fitzner
 * @author Andy Gutsche
 *//**
 * Requirements
 */var $=_app.Veams.$;var CTA=function(_VeamsComponent){_inherits(CTA,_VeamsComponent);/**
	 * Constructor for our class
	 *
	 * @see module.js
	 *
	 * @param {Object} obj - Object which is passed to our class
	 * @param {Object} obj.el - element which will be saved in this.el
	 * @param {Object} obj.options - options which will be passed in as JSON object
	 */function CTA(obj){_classCallCheck(this,CTA);var options={activeClass:'is-active',clickHandler:'click',closedLabel:null,ctaContent:'[data-js-item="cta-content"]',globalEvent:'cta:click',openedLabel:null};return _possibleConstructorReturn(this,(CTA.__proto__||Object.getPrototypeOf(CTA)).call(this,obj,options));}/** =================================================
	 * GETTER & SETTER
	 * ================================================ *//**
	 * Get module information
	 */_createClass(CTA,[{key:'initialize',/** =================================================
	 * STANDARD METHODS
	 * ================================================= *//**
	 * Initialize the view and merge options
	 *
	 */value:function initialize(){this.$ctaContent=$(this.options.ctaContent,this.$el);if(this.options.closedLabel&&!this.options.openedLabel||!this.options.closedLabel&&this.options.openedLabel){console.warn('CTA: You have to set closedLabel and openedLabel or none.');}else{if(this.options.closedLabel&&this.options.openedLabel&&!this.$ctaContent.length){console.warn('CTA: Labels set, but '+this.options.ctaContent+' not found, please make sure settings.ctaContentJsItem is set to true for c-cta__content.');}}if(this.$el.is('.'+this.options.activeClass)){this.active=true;}}},{key:'render',value:function render(){return this;}/** =================================================
	 * CUSTOM CTA METHODS
	 * ================================================= *//**
	 * Close method
	 *
	 * Remove the active class, set label and trigger global event
	 *
	 * @public
	 */},{key:'close',value:function close(){if(this.options.closedLabel){this.$ctaContent.text(this.options.closedLabel);this.$el.attr('title',this.options.closedLabel);}this.$el.removeClass(this.options.activeClass);this.active=false;}/**
	 * Open method
	 *
	 * Add the active class, set label and trigger global event
	 *
	 * @public
	 */},{key:'open',value:function open(){if(this.options.openedLabel){this.$ctaContent.text(this.options.openedLabel);this.$el.attr('title',this.options.openedLabel);}this.$el.addClass(this.options.activeClass);this.active=true;}/**
	 * Click event method
	 *
	 * This method should be overriden when you want to use the button view
	 * @see button-init.js
	 *
	 * @param {event} e - event object
	 */},{key:'onClick',value:function onClick(e){e.preventDefault();if(typeof this.clickHandler==='function'){if(this.active){this.close();}else{this.open();}this.clickHandler.apply(this,arguments);}else{console.warn('CTA: You need to inherit from '+this+' and override the onClick method or pass a function to '+this+'.clickHandler !');}}/**
	 * Click handler
	 *
	 * This method is public and can be overridden by
	 * other instances to support a generic button module
	 *
	 * @public
	 */},{key:'clickHandler',value:function clickHandler(){_app.Veams.Vent.trigger(this.options.globalEvent,{el:this.el,isActive:this.active,options:this.options});}},{key:'active',/**
	 * Get and set the active state.
	 *
	 * @param {boolean} state - active state
	 */get:function get(){return this._active;},set:function set(state){this._active=state;}/** =================================================
	 * EVENTS
	 * ================================================ */},{key:'events',get:function get(){return{'{{this.options.clickHandler}}':'onClick'};}}],[{key:'info',get:function get(){return{version:'3.0.2',vc:true,mod:false// set to true if source was modified in project
};}}]);return CTA;}(_component2.default);exports.default=CTA;

},{"app":"app","veams/src/js/common/component":30}],47:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * Represents a ajax form class.
 *
 * @module FormAjax
 * @version v3.0.1
 *
 * @author Sebastian Fitzner
 */var $=_app.Veams.$;var FormAjax=function(_VeamsComponent){_inherits(FormAjax,_VeamsComponent);/**
	 * Constructor for our class
	 *
	 * @see module.js
	 *
	 * @param {Object} obj - Object which is passed to our class
	 * @param {Object} obj.el - element which will be saved in this.el
	 * @param {Object} obj.options - options which will be passed in as JSON object
	 */function FormAjax(obj){_classCallCheck(this,FormAjax);var options={submitOnLoad:false,submitOnChange:true,loadingClass:null,successClass:'is-success',errorClass:'is-error',eventName:_app.Veams.EVENTS.form.complete};return _possibleConstructorReturn(this,(FormAjax.__proto__||Object.getPrototypeOf(FormAjax)).call(this,obj,options));}/**
	 * Get module information
	 */_createClass(FormAjax,[{key:'initialize',value:function initialize(){// save some references
this.fields=$('input',this.$el);this.selects=$('select',this.$el);// Fetch data if option is true
if(this.options.submitOnLoad){this.fetchData(this.$el);}// call super
_get(FormAjax.prototype.__proto__||Object.getPrototypeOf(FormAjax.prototype),'initialize',this).call(this);}/**
	 * Bind all evente
	 */},{key:'bindEvents',value:function bindEvents(){var fnFetchData=this.fetchData.bind(this);var fnReset=this.resetFilters.bind(this);/**
		 * On submit event fetch data
		 */this.$el.on(_app.Veams.EVENTS.submit+' '+_app.Veams.EVENTS.reset,fnFetchData);/**
		 * Reset filters on reset event
		 */_app.Veams.Vent.on(_app.Veams.EVENTS.form.reset,fnReset);/**
		 * If submitOnChange is true
		 *
		 * fetch data
		 * show reset button
		 *
		 */if(this.options.submitOnChange){this.$el.on(_app.Veams.EVENTS.blur+' '+_app.Veams.EVENTS.change,this.fields,fnFetchData);}}/**
	 * Ajax call to get data object with results or error message.
	 *
	 * @param {Object} e - object or event.
	 * @param {object} currentTarget - Target to which listener was attached.
	 */},{key:'fetchData',value:function fetchData(e,currentTarget){var _this2=this;var el=void 0;if(e&&typeof e.preventDefault==='function'){e.preventDefault();el=currentTarget||e.currentTarget;}else{el=e;}if(this.options.loadingClass){this.$el.addClass(this.options.loadingClass);}var action=this.$el.attr('action');var method=this.$el.attr('method');var serialize=this.$el.serialize();var url=action+'?'+serialize;$.ajax({url:url,dataType:'json',success:function success(data){_this2.onSuccess(data,el);},error:function error(status,statusText){_this2.onError(status,statusText);}});}},{key:'onSuccess',value:function onSuccess(data,el){this.fields=$('input',this.$el);this.selects=$('select',this.$el);_app.Veams.Vent.trigger(this.options.eventName,{data:data,el:el});if(this.options.loadingClass){this.$el.removeClass(this.options.loadingClass);}this.$el.addClass(this.options.successClass);}},{key:'onError',value:function onError(status,statusText){if(this.options.loadingClass){this.$el.removeClass(this.options.loadingClass);}this.$el.addClass(this.options.errorClass);console.warn('FormAjax:',statusText,'('+status+')');}/**
	 * Reset filters, currently supported
	 *
	 * checkboxes
	 * selects
	 */},{key:'resetFilters',value:function resetFilters(){this.resetChecks();this.resetSelects();}/**
	 * Reset checkboxes
	 */},{key:'resetChecks',value:function resetChecks(){this.fields.each(function(){$(this).prop('checked',false);});}/**
	 * Resest selects
	 */},{key:'resetSelects',value:function resetSelects(){this.selects.each(function(){$(this).prop('selectedIndex',0);});}}],[{key:'info',get:function get(){return{version:'3.0.1',vc:true,mod:false// set to true if source was modified in project
};}}]);return FormAjax;}(_component2.default);// Returns constructor
exports.default=FormAjax;

},{"app":"app","veams/src/js/common/component":30}],48:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * form component datepicker
 *
 * @module FormDatepicker
 * @version v1.0.0
 *
 * @author Sang-In Haetzel
 * @author Sebastian Fitzner
 */require('moment');var $=_app.Veams.$;var Pikaday=require('pikaday');var FormDatepicker=function(_VeamsComponent){_inherits(FormDatepicker,_VeamsComponent);/**
	 * Constructor for our class
	 *
	 * @see module.js
	 *
	 * @param {Object} obj - Object which is passed to our class
	 * @param {Object} obj.el - element which will be saved in this.el
	 * @param {Object} obj.options - options which will be passed in as JSON object
	 */function FormDatepicker(obj){_classCallCheck(this,FormDatepicker);var options={};return _possibleConstructorReturn(this,(FormDatepicker.__proto__||Object.getPrototypeOf(FormDatepicker)).call(this,obj,options));}/**
	 * Get module information
	 */_createClass(FormDatepicker,[{key:'initialize',/**
	 * Initialize class
	 */value:function initialize(){var i18n=_app.Veams.i18n&&_app.Veams.i18n.datepicker?_app.Veams.i18n.datepicker:this.i18nFallback;var _this=this;this.$input=$('input',this.$el);this.dateFormat=i18n.calendarFormat;this.datetimepicker=new Pikaday({field:this.$input[0],i18n:i18n,container:this.el,onSelect:function onSelect(){_this.date=this.getMoment().format(_this.dateFormat);_this.$input.val(_this.date);}});}},{key:'date',/**
	 * GETTERS AND SETTERS
	 *//**
	 * Get and set date
	 *//**
	 * Date
	 */set:function set(date){this._date=date;this.datetimepicker.setDate(this._date,true);},get:function get(){return this._date;}/**
	 * i18n
	 */},{key:'i18nFallback',get:function get(){return{previousMonth:'Previous Month',nextMonth:'Next Month',months:['January','February','March','April','May','June','July','August','September','October','November','December'],weekdays:['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'],weekdaysShort:['Sun','Mon','Tue','Wed','Thu','Fri','Sat'],calendarFormat:'DD.MM.YYYY'};}}],[{key:'info',get:function get(){return{name:'FormDatepicker',version:'1.0.0'};}}]);return FormDatepicker;}(_component2.default);// Returns constructor
exports.default=FormDatepicker;

},{"app":"app","moment":20,"pikaday":21,"veams/src/js/common/component":30}],49:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * Represents an overlay module.
 *
 * This module is responsible to create an overlay
 * without predefining any inner overlay template.
 *
 * It should be used by other modules
 * to display their content in an overlay.
 *
 * @module Overlay
 * @version v3.0.0
 *
 * @author Sebastian Fitzner
 */var $=_app.Veams.$;var Template=_app.Veams.templater.templates;var Overlay=function(_VeamsComponent){_inherits(Overlay,_VeamsComponent);/**
	 * Constructor for our class
	 *
	 * @see module.js
	 *
	 * @param {Object} obj - Object which is passed to our class
	 * @param {Object} obj.el - element which will be saved in this.el
	 * @param {Object} obj.options - options which will be passed in as JSON object
	 */function Overlay(obj){_classCallCheck(this,Overlay);var options={openClass:'is-open',closeBtn:'[data-js-item="overlay-close"]',overlay:'[data-js-item="overlay"]',regionContent:'[data-js-item="overlay-content"]',template:Template['OVERLAY']};return _possibleConstructorReturn(this,(Overlay.__proto__||Object.getPrototypeOf(Overlay)).call(this,obj,options));}/** =================================================
	 * GETTER & SETTER
	 * ================================================ *//**
	 * Get module information
	 */_createClass(Overlay,[{key:'bindEvents',/**
	 * Bind global events
	 *
	 * Listen to open and close events
	 */value:function bindEvents(){var _this2=this;// Close overlay with ESC
$(window).on(_app.Veams.EVENTS.keyup,function(e){if(e.keyCode==27&&_this2.isOpen){_this2.close();}});}/**
	 * Bind local events
	 */},{key:'bindLocalEvents',value:function bindLocalEvents(){var fnClose=this.close.bind(this);// Local events
this.$closeBtn.on(_app.Veams.EVENTS.click,fnClose);}/** =================================================
	 * STANDARD METHODS
	 * ================================================= *//**
	 * Initialize the view and merge options
	 *
	 */},{key:'initialize',value:function initialize(){this.$body=$('body');this.template=this.options.template;}/**
	 * Pre-Render the overlay and save references
	 */},{key:'preRender',value:function preRender(){// Append FE template
this.$body.append(this.template());// Set some references
this.$overlay=$(this.options.overlay);this.$closeBtn=$(this.options.closeBtn,this.$overlay);this.$regionContent=$(this.options.regionContent,this.$overlay);this.overlayCreated=true;this.bindLocalEvents();}/**
	 * Render the overlay
	 */},{key:'render',value:function render(obj){var data=obj.data||obj.options&&obj.options.data;// Check if data object is provided
if(!data){console.warn('Overlay: You have to provide an object with data (obj.data || obj.options.data)!');return;}// Append data to overlay region
this.$regionContent.html(data);// Open overlay
this.open();}/** =================================================
	 * CUSTOM OVERLAY METHODS
	 * ================================================= *//**
	 * Open Overlay
	 */},{key:'open',value:function open(){this.$overlay.addClass(this.options.openClass);this.isOpen=true;}/**
	 * Close overlay
	 */},{key:'close',value:function close(){this.$overlay.removeClass(this.options.openClass);this.isOpen=false;}},{key:'template',// set and get overlay template
get:function get(){return this._template;},set:function set(tpl){this._template=tpl;}// set and get infos if overlay is created
},{key:'overlayCreated',get:function get(){return this._overlayCreated;},set:function set(bol){this._overlayCreated=bol;}// set and get infos if overlay is open
},{key:'isOpen',get:function get(){return this._isOpen;},set:function set(bol){this._isOpen=bol;}// set and get overlay element after creation
},{key:'$overlay',get:function get(){return this._$overlay;},set:function set(el){this._$overlay=el;}// set and get close button after creation
},{key:'$closeBtn',get:function get(){return this._$closeBtn;},set:function set(el){this._$closeBtn=el;}// set and get content region
},{key:'$regionContent',get:function get(){return this._$regionContent;},set:function set(el){this._$regionContent=el;}/** =================================================
	 * EVENTS
	 * ================================================ */},{key:'subscribe',get:function get(){return{'{{Veams.EVENTS.overlay.open}}':'render'};}}],[{key:'info',get:function get(){return{version:'3.0.0',vc:true,mod:false// set to true if source was modified in project
};}}]);return Overlay;}(_component2.default);exports.default=Overlay;

},{"app":"app","veams/src/js/common/component":30}],50:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);var _isInViewport=require('veams/src/js/utils/helpers/is-in-viewport');var _isInViewport2=_interopRequireDefault(_isInViewport);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * Represents an element that slides into view when it's scrolled into viewport.
 *
 * @module SlideFox
 * @version v3.0.1
 *
 * @author Andy Gutsche
 * @refactoring Sebastian Fitzner
 */var $=_app.Veams.$;var Helpers=_app.Veams.helpers;var SlideFox=function(_VeamsComponent){_inherits(SlideFox,_VeamsComponent);/**
	 * Constructor for our class
	 *
	 * @see module.js
	 *
	 * @param {Object} obj - Object which is passed to our class
	 * @param {Object} obj.el - element which will be saved in this.el
	 * @param {Object} obj.options - options which will be passed in as JSON object
	 */function SlideFox(obj){_classCallCheck(this,SlideFox);var options={visibleClass:'is-visible'};return _possibleConstructorReturn(this,(SlideFox.__proto__||Object.getPrototypeOf(SlideFox)).call(this,obj,options));}/** =================================================
	 * GETTER & SETTER
	 * ================================================ *//**
	 * Get module information
	 */_createClass(SlideFox,[{key:'render',// bindEvents() {
// 	let fnRender = this.render.bind(this);
//
// 	$(window).on('scroll', fnRender);
// }
/** =================================================
	 * STANDARD METHODS
	 * ================================================= */value:function render(){console.log('initalized');(0,_isInViewport2.default)(this.el)?this.showSlideFox():this.hideSlideFox();}/** =================================================
	 * CUSTOM SLIDEFOX METHODS
	 * ================================================= */},{key:'showSlideFox',value:function showSlideFox(){this.$el.addClass(this.options.visibleClass);}},{key:'hideSlideFox',value:function hideSlideFox(){this.$el.removeClass(this.options.visibleClass);}},{key:'subscribe',/** =================================================
	 * EVENTS
	 * ================================================ */get:function get(){return{'{{Veams.EVENTS.scroll}}':'render'};}}],[{key:'info',get:function get(){return{version:'3.0.1',vc:true,mod:false// set to true if source was modified in project
};}}]);return SlideFox;}(_component2.default);// Returns the constructor
exports.default=SlideFox;

},{"app":"app","veams/src/js/common/component":30,"veams/src/js/utils/helpers/is-in-viewport":33}],51:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);var _transitionEndEvent=require('veams/src/js/utils/helpers/transition-end-event');var _transitionEndEvent2=_interopRequireDefault(_transitionEndEvent);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * Represents a responsive slider which can be used as ribbon.
 *
 * @module Slider
 * @version v3.0.3
 *
 * @author Sebastian Fitzner
 * @author Andy Gutsche
 */var $=_app.Veams.$;var Helpers=_app.Veams.helpers;var Slider=function(_VeamsComponent){_inherits(Slider,_VeamsComponent);/**
	 * Constructor for our class
	 *
	 * @see module.js
	 *
	 * @param {Object} obj - Object which is passed to our class
	 * @param {Object} obj.el - element which will be saved in this.el
	 * @param {Object} obj.options - options which will be passed in as JSON object
	 */function Slider(obj){_classCallCheck(this,Slider);var options={activeClass:'is-active',// Active class for slides and pagination items
actions:'[data-js-item="slider-actions"]',// Previous Button
autoPlay:false,// Enable autoplay
autoPlayInterval:4800,// Autoplay intervall in milliseconds
cloneClass:'is-cloned',// Clone class for cloned items (only used with infinite)
disablePagination:false,// Disable pagination display
enableTouchSwipe:true,// Enable/Disable swipe support
groupPaginationItems:false,// Group the pagination elements (useful for multiple visible items)
hiddenClass:'is-hidden',// hidden class for pagination
infinite:false,// Infinite looping (only possible without multiple visible items)
items:'[data-js-item="slider-item"]',// Slide Items
next:'[data-js-item="slider-next"]',// Next Button
prev:'[data-js-item="slider-prev"]',// Previous Button
pagination:'[data-js-item="slider-pagination"]',// Pagination
paginationItemClass:'slider__pagination-list-item',// Define your class which we use in our mini tmpl
paginationItemJsItem:'slider-pagination-item',// data-js-item for pagination list item
paginationList:'[data-js-item="slider-pagination-list"]',// Pagination List
ribbon:'[data-js-item="slider-ribbon"]',// Ribbon element
pauseOnHover:true,// Used when options.autoPlay is true
slideByItemNumber:false,// Use the option to override the initial slide step
startAtIndex:0,// Start at a different index
unresolvedClass:'is-unresolved',// Unresolved class which gets removed when initialized
visibleItems:{// Visible items per viewport
'desktop':1,'tablet-large':1,'tablet-small':1,'mobile-large':1,'mobile-medium':1,'mobile-small':1},wrapper:'[data-js-item="slider-wrapper"]'// Wrapper element
};return _possibleConstructorReturn(this,(Slider.__proto__||Object.getPrototypeOf(Slider)).call(this,obj,options));}/**
	 * Custom getters and setter
	 *//**
	 * Get module information
	 */_createClass(Slider,[{key:'bindEvents',/**
	 * Bind all events
	 */value:function bindEvents(){if(this.autoPlay&&this.options.pauseOnHover){this.registerEvent('{{Veams.EVENTS.mouseenter}}','pause');this.registerEvent('{{Veams.EVENTS.mouseleave}}','play');}}/**
	 * Unbind all events
	 */},{key:'unbindEvents',value:function unbindEvents(){// Global Events
_app.Veams.Vent.off(_app.Veams.EVENTS.resize);// Local Events
this.$el.off(_app.Veams.clickHandler);}/** =================================================
	 * STANDARD METHODS
	 * ================================================= *//**
	 * Initialize the view
	 */},{key:'initialize',value:function initialize(){this.index=0;this.$prev=this.$el.find(this.options.prev);this.$next=this.$el.find(this.options.next);this.$items=this.$el.find(this.options.items);this.$initialItems=this.$items;this.$wrapper=this.$el.find(this.options.wrapper);this.$ribbon=this.$el.find(this.options.ribbon);this.startAtIndex=~~this.options.startAtIndex;this.$lastItem=this.$items.eq(this.$items.length-1);this.$firstItem=this.$items.eq(0);this.transition=this.$ribbon.css('transition');this.paginationDisabled=this.options.disablePagination||this.$items.length<2;this.infinite=this.options.infinite&&this.$items.length>1;this.touchSwipeEnabled=false;this.clickHandler=true;this.autoPlay=this.options.autoPlay&&this.infinite;this.paginationItemSel='[data-js-item="'+this.options.paginationItemJsItem+'"]';if(!this.paginationDisabled){this.$paginationList=this.$el.find(this.options.paginationList);}if(this.options.autoPlay&&!this.infinite){console.warn('Slider: Sorry - option "autoPlay" has no effect while option "infinite" is set to false!');}if(this.infinite){for(var item in this.options.visibleItems){if(this.options.visibleItems.hasOwnProperty(item)){if(this.options.visibleItems[item]>1){console.warn('Slider: Sorry - option "visibleItems" has no effect while option "infinite" is set to true!');break;}}}}}/**
	 * Renders the view's template to the UI
	 */},{key:'render',value:function render(){if(!_app.Veams.currentMedia){console.warn('Slider: Veams.currentMedia is necessary to support the slider module!');return;}if(this.$clonedLast&&this.$clonedFirst){this.$clonedLast.remove();this.$clonedFirst.remove();this.$items=this.$initialItems;}this.visibles=this.infinite?1:this.options.visibleItems[_app.Veams.currentMedia];this.itemsLength=this.$items.length;this.handleVisibility();if(!this.paginationDisabled){this.removePagination();this.addPagination();}if(this.infinite){this.infiniteLoop();}this.bindTransitions();this.getAndSetDimensions();if(_app.Veams.detections.touch&&this.options.enableTouchSwipe&&!this.touchSwipeEnabled){this.bindSwipes();}if(this.infinite){this.goToItem(this.startAtIndex+this.visibles);}else{this.goToItem(this.startAtIndex);}if(this.autoPlay&&this.paused){this.play();}}/** =================================================
	 * CUSTOM SLIDER METHODS
	 * ================================================= *//**
	 * Bind transition events
	 *
	 */},{key:'bindTransitions',value:function bindTransitions(){var onRibbonTransitionEnd=this.onRibbonTransitionEnd.bind(this);var onItemsTransitionEnd=this.onItemsTransitionEnd.bind(this);this.$ribbon.on((0,_transitionEndEvent2.default)(),onRibbonTransitionEnd);this.$items.on((0,_transitionEndEvent2.default)(),onItemsTransitionEnd);}/**
	 * React to transitionend on ribbon
	 *
	 * @param {Object} e - Event object.
	 */},{key:'onRibbonTransitionEnd',value:function onRibbonTransitionEnd(e){e.stopPropagation();if(this.autoPlay&&this.paused){if(this.options.pauseOnHover){if(!this.$el.is(':hover')){this.play();}}else{this.play();}}if(this.$clonedFirst&&this.$clonedFirst.hasClass(this.options.activeClass)){this.$clonedFirst.removeClass(this.options.activeClass);this.index=1;this.animateSlide({idx:this.index,animate:false});}if(this.$clonedLast&&this.$clonedLast.hasClass(this.options.activeClass)){this.$clonedLast.removeClass(this.options.activeClass);this.index=this.$items.length-this.visibles-1;this.animateSlide({idx:this.index,animate:false});}this.clickHandler=true;}/**
	 * React to transitionend on items
	 *
	 * @param {Object} e - Event object.
	 */},{key:'onItemsTransitionEnd',value:function onItemsTransitionEnd(e){e.stopPropagation();}/**
	 * Clone first and last element
	 *
	 */},{key:'infiniteLoop',value:function infiniteLoop(){this.$clonedFirst=this.$firstItem.clone(true).addClass(this.options.cloneClass);this.$clonedLast=this.$lastItem.clone(true).addClass(this.options.cloneClass);if(this.options.infinite){this.$clonedFirst.find(this.paginationItemSel).attr('data-index',this.itemsLength);this.$clonedLast.find(this.paginationItemSel).attr('data-index',-1);}this.$firstItem.before(this.$clonedLast);this.$lastItem.after(this.$clonedFirst);this.$items=$(this.options.items,this.$el);}/**
	 * Animate slide
	 *
	 * @param {Object} obj - animation property object.
	 */},{key:'animateSlide',value:function animateSlide(obj){if(!obj.animate){this.$ribbon.css('transition','none');}else{this.$ribbon.css('transition',this.transition);}this.$ribbon.css('left',-obj.idx*this.thumbWidth+'px');}/**
	 * Check first/last slide classes
	 *
	 */},{key:'checkSlides',value:function checkSlides(){if(this.$clonedFirst.hasClass(this.options.activeClass)){this.$firstItem.addClass(this.options.activeClass);}if(this.$clonedLast.hasClass(this.options.activeClass)){this.$lastItem.addClass(this.options.activeClass);}}/**
	 * When items length is 0 we hide this view.
	 */},{key:'handleVisibility',value:function handleVisibility(){if(this.itemsLength===0){this.$el.addClass(this.options.hiddenClass);console.warn('Slider: There is no item we can use in our slider :(');}this.$el.css('max-width','none');}/**
	 * Empty pagination.
	 */},{key:'removePagination',value:function removePagination(){this.$paginationList.empty();}/**
	 * Add pagination elements with a simple string template and
	 * save a pagination item reference.
	 */},{key:'addPagination',value:function addPagination(){var tmpl='';var i=0;var item=this.options.paginationItemJsItem;var itemClass=this.options.paginationItemClass;for(i;i<this.$items.length;i++){var idx=i+1;var hiddenClass='';if(this.options.groupPaginationItems){hiddenClass=i%this.visibles===0?'':this.options.hiddenClass;}tmpl+='\n\t\t\t\t\t<li class="'+itemClass+' '+hiddenClass+'" data-js-item="'+item+'" data-index="'+i+'">\n\t\t\t\t\t\t<strong>'+idx+'</strong>\n\t\t\t\t\t</li>\n\t\t\t\t\t';}this.$paginationList.append(tmpl);this.$paginationItems=$('[data-js-item="'+this.options.paginationItemJsItem+'"]',this.$el);}/**
	 * Navigate to a specific slide.
	 *
	 * @param {object} e - Event object.
	 * @param {object} currentTarget - Target to which listener was attached.
	 */},{key:'navigateToElement',value:function navigateToElement(e,currentTarget){var $currentTarget=currentTarget?$(currentTarget):$(e.currentTarget);if($currentTarget.hasClass(this.options.activeClass)){return;}var idx=parseInt($currentTarget.attr('data-index'),10)||$currentTarget.index();if(this.infinite){idx=idx+this.slideBy;}this.goToItem(idx);}/**
	 * Go to the next slide.
	 *
	 * @param {object} e - Event object.
	 * @param {object} currentTarget - Target to which listener was attached.
	 */},{key:'showNextElement',value:function showNextElement(e,currentTarget){var $currentTarget=currentTarget?$(currentTarget):$(e.currentTarget);if(e&&typeof e.preventDefault==='function'){e.preventDefault();}if($currentTarget.prop('disabled')){return;}if(this.clickHandler){this.goToItem(this.index+this.slideBy);this.clickHandler=false;}}/**
	 * Go to the previous slide.
	 *
	 * @param {object} e - Event object.
	 * @param {object} currentTarget - Target to which listener was attached.
	 */},{key:'showPrevElement',value:function showPrevElement(e,currentTarget){var $currentTarget=currentTarget?$(currentTarget):$(e.currentTarget);if(e&&typeof e.preventDefault==='function'){e.preventDefault();}if($currentTarget.prop('disabled')){return;}if(this.clickHandler){this.goToItem(this.index-this.slideBy);this.clickHandler=false;}}/**
	 * Return the direction `next` or `prev`.
	 *
	 * @param {number} index - Index of the pagination element.
	 */},{key:'getDirection',value:function getDirection(index){return index>this.index?"next":"prev";}/**
	 * Bind all swipe gestures.
	 */},{key:'bindSwipes',value:function bindSwipes(){var _this2=this;if(this.$items.length>this.visibles){Helpers.detectSwipe(this.el,75);this.$el.on(_app.Veams.EVENTS.swipe,function(e){var direction=e.detail.direction;if(direction==='left'){_this2.goToItem(_this2.index+_this2.visibles);}if(direction==='right'){_this2.goToItem(_this2.index-_this2.visibles);}});this.touchSwipeEnabled=true;}}/**
	 * Enables button
	 *
	 * @param {Object} $btn - button element.
	 */},{key:'enableBtn',value:function enableBtn($btn){$btn.removeClass(this.options.hiddenClass);$btn.prop('disabled',false);$btn.removeAttr('aria-disabled');}/**
	 * Disables button
	 *
	 * @param {Object} $btn - button element.
	 */},{key:'disableBtn',value:function disableBtn($btn){$btn.addClass(this.options.hiddenClass);$btn.prop('disabled',true);$btn.attr('aria-disabled',true);}/**
	 * Handles the method to go to a specific item.
	 * Further we handle the class
	 *
	 * @param {number} i - Index number.
	 */},{key:'goToItem',value:function goToItem(i){var maxIndex=this.$items.length-this.visibles;if(maxIndex<0){maxIndex=0;}if(!this.paused){this.pause();}if(this.infinite){if(i<0){i=maxIndex;}else if(i>maxIndex){i=0;}}else{this.enableBtn(this.$prev);this.enableBtn(this.$next);if(i<1){this.disableBtn(this.$prev);if(i<0){i=0;}}if(i>maxIndex-1){this.disableBtn(this.$next);if(i>maxIndex){i=maxIndex;}}}this.animateSlide({idx:i,animate:!this.$el.hasClass(this.options.unresolvedClass)});if(this.$el.hasClass(this.options.unresolvedClass)){this.$el.removeClass(this.options.unresolvedClass);}this.index=i;this.handleActivity();if(this.infinite){this.checkSlides();}}},{key:'handleActivity',value:function handleActivity(){this.$items.removeClass(this.options.activeClass);if(!this.paginationDisabled&&this.$paginationItems&&this.$paginationItems.length){this.$paginationItems.removeClass(this.options.activeClass);}// If this slider instance isn't infinite
if(!this.infinite){for(var idx=this.index;idx<this.index+this.visibles;idx++){// First set active slide element(s)
this.$items.eq(idx).addClass(this.options.activeClass);// Do that also for pagination element(s)
if(!this.paginationDisabled){this.$paginationItems.eq(idx).addClass(this.options.activeClass);}}}else{for(var _idx=this.index-1;_idx<this.index-1+this.visibles;_idx++){var slideIdx=_idx;this.$items.eq(slideIdx+1).addClass(this.options.activeClass);if(!this.paginationDisabled){if(_idx>=this.$paginationItems.length){slideIdx=0;}if(_idx<0){slideIdx=this.$paginationItems.length-1;}this.$paginationItems.eq(slideIdx).addClass(this.options.activeClass);}}}}/**
	 * Start autoplay.
	 */},{key:'play',value:function play(){var _this3=this;clearInterval(this.autoPlayInterval);this.autoPlayInterval=setInterval(function(){_this3.goToItem(_this3.index+_this3.visibles);},this.options.autoPlayInterval);this.paused=false;}/**
	 * Pause autoplay.
	 */},{key:'pause',value:function pause(){clearInterval(this.autoPlayInterval);this.paused=true;}/**
	 * Get and set dimensions for our project progress.
	 */},{key:'getAndSetDimensions',value:function getAndSetDimensions(){this.resetStyles();this.width=this.$wrapper.outerWidth();this.thumbWidth=this.width/this.visibles;this.$wrapper.css('width',this.width+'px');this.$items.css('width',this.thumbWidth+'px');this.$ribbon.css({width:this.ribbonWidth+'px'});}/**
	 * Reset width styles
	 */},{key:'resetStyles',value:function resetStyles(){this.$wrapper[0].removeAttribute('style');this.$items.removeAttr('style');this.$ribbon.removeAttr('style');}},{key:'visibles',/**
	 * Get and set visible items.
	 *
	 * @param {number} visible - Number of visible items
	 */get:function get(){return this._numVisible;},set:function set(visible){this._numVisible=visible;}/**
	 * Get and set items length for slider.
	 *
	 * @param {number} len - Number of item length
	 */},{key:'itemsLength',get:function get(){return this._itemLength;},set:function set(len){this._itemLength=len;}/**
	 * Get and set the index of slider.
	 *
	 * @param {number} idx - index number of slide
	 */},{key:'index',get:function get(){return this._index;},set:function set(idx){this._index=idx;}/**
	 * Get paused property.
	 *
	 * @param {Boolean} bool - pause state
	 */},{key:'paused',get:function get(){return this._paused;},set:function set(bool){this._paused=bool;}/**
	 * Get autoPlay property.
	 *
	 * @param {Boolean} bool - autoplay state
	 */},{key:'autoPlay',get:function get(){return this._autoPlay;},set:function set(bool){this._autoPlay=bool;}/**
	 * Get controls height.
	 */},{key:'controlHeight',get:function get(){return Helpers.getOuterHeight(this.$prev);}/**
	 * Return the defined option or current visible items
	 * which will be used for the next and previous slide animation.
	 */},{key:'slideBy',get:function get(){return this.options.slideByItemNumber||this.visibles;}/**
	 * Get ribbon width.
	 */},{key:'ribbonWidth',get:function get(){return this.$items.length*this.thumbWidth;}/** =================================================
	 * EVENTS
	 * ================================================ *//**
	 * Bind local events to this.$el.
	 */},{key:'events',get:function get(){return{'click {{this.options.prev}}':'showPrevElement','touchstart {{this.options.prev}}':'showPrevElement','click {{this.options.next}}':'showNextElement','touchstart {{this.options.next}}':'showNextElement','click {{this.paginationItemSel}}':'navigateToElement','touchstart {{this.paginationItemSel}}':'navigateToElement'};}/**
	 * Subscribe to global events of Veams or App namespace.
	 */},{key:'subscribe',get:function get(){return{'{{Veams.EVENTS.resize}}':'render'};}}],[{key:'info',get:function get(){return{version:'3.0.3',vc:true,mod:false};}}]);return Slider;}(_component2.default);exports.default=Slider;

},{"app":"app","veams/src/js/common/component":30,"veams/src/js/utils/helpers/transition-end-event":37}],52:[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _app=require('app');var _component=require('veams/src/js/common/component');var _component2=_interopRequireDefault(_component);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}/**
 * Represents a simple toggler with global event binding.
 *
 * @module Toggler
 * @version v3.0.3
 *
 * @author Andy Gutsche
 */// Global dependencies
var $=_app.Veams.$;var Helpers=_app.Veams.helpers;var Toggler=function(_VeamsComponent){_inherits(Toggler,_VeamsComponent);/**
	 * Constructor for our class
	 *
	 * @see module.js
	 *
	 * @param {Object} obj - Object which is passed to our class
	 * @param {Object} obj.el - element which will be saved in this.el
	 * @param {Object} obj.options - options which will be passed in as JSON object
	 */function Toggler(obj){_classCallCheck(this,Toggler);var options={a11yFocusKeyClass:'a11y-focus-key',calculatingClass:'is-calculating',closeClass:'is-closed',context:false,dataMaxAttr:'data-js-height',globalEvent:'',globalEventId:'',openClass:'is-open',setOverflow:false,toggleTabindexElems:''};return _possibleConstructorReturn(this,(Toggler.__proto__||Object.getPrototypeOf(Toggler)).call(this,obj,options));}/**
	 * Get module information
	 */_createClass(Toggler,[{key:'initialize',/**
	 * Initialize the view and merge options
	 *
	 */value:function initialize(){var _this2=this;var selfInit=this.$el.attr('data-js-module')&&this.$el.attr('data-js-module').indexOf('toggler')>-1;if(selfInit&&!this.options.globalEvent){console.info('Toggler: this.options.globalEvent not set.');}this.isOpen=this.$el.hasClass(this.options.openClass);this.calculateHeight().then(function(){if(!_this2.isOpen){_this2.setHeight(0);}});}/**
	 * Bind events
	 *
	 * Listen to open and close events
	 */},{key:'bindEvents',value:function bindEvents(){// Global events
if(this.options.globalEvent){this.registerEvent('{{this.options.globalEvent}}','toggle',true);}}/**
	 * handle on resize event
	 *
	 * close the toggler
	 *
	 */},{key:'onResize',value:function onResize(){var _this3=this;// give browser some tie to recalculate
setTimeout(function(){_this3.calculateHeight().then(function(){_this3.setHeight();});},200);}/**
	 * Enable calc mode.
	 *
	 * @private
	 */},{key:'enableCalcMode',value:function enableCalcMode(){if(!this.isOpen){this.$el.addClass(this.options.openClass);this.$el.removeClass(this.options.closeClass);}this.$el.addClass(this.options.calculatingClass);}/**
	 * Disable calc mode.
	 *
	 * @private
	 */},{key:'disableCalcMode',value:function disableCalcMode(){this.$el.removeClass(this.options.calculatingClass);if(!this.isOpen){this.$el.addClass(this.options.closeClass);this.$el.removeClass(this.options.openClass);}else{this.setHeight();}}/**
	 * Set height of current view element to given value or latest calculated value.
	 *
	 * @private
	 * @param {Number} [height] - height
	 */},{key:'setHeight',value:function setHeight(height){this.$el.css('height',typeof height==='number'?height+'px':this.$el.attr(this.options.dataMaxAttr)+'px');}/**
	 * Calc the height of current view element.
	 *
	 * @private
	 */},{key:'calcHeight',value:function calcHeight(){var _this4=this;return new Promise(function(resolve,reject){setTimeout(function(){var wantedHeight=_this4.$el.outerHeight();_this4.$el.attr(_this4.options.dataMaxAttr,wantedHeight);_this4.height=wantedHeight!==_this4.height?wantedHeight:_this4.height;resolve();},10);});}/**
	 * Save all styles from current view element
	 *
	 * @private
	 */},{key:'saveStyles',value:function saveStyles(){this.savedStyles=this.$el.attr('style');}/**
	 * Restore all styles from current view element
	 *
	 * @private
	 */},{key:'restoreStyles',value:function restoreStyles(){this.$el.attr('style',this.savedStyles);delete this.savedStyles;}/**
	 * Toggles content
	 *
	 * @public
	 *
	 * @param {Object} obj - the event data
	 * @param {Boolean} obj.isActive - indicates if panel should open or close itself
	 * @param {String} obj.options.setFocus - element to set focus on open
	 */},{key:'toggle',value:function toggle(obj){//console.log('obj', obj);
// if globalEventId is set on both (cta and toggler)
if(this.options.globalEventId&&obj.options&&obj.options.globalEventId){// stop here if global event id don't match
if(this.options.globalEventId!==obj.options.globalEventId){return;}}if(obj.isActive){this.open(obj);}else{this.close();}}/**
	 * Open current view element
	 *
	 * @public
	 *
	 * @param {Object} [obj] - the event object
	 * @param {Boolean} [obj.isActive] - indicates if panel should open or close itself
	 * @param {String} [obj.options.setFocus] - element to set focus on open
	 */},{key:'open',value:function open(obj){var _this5=this;this.$el.css('height',this.$el.attr(this.options.dataMaxAttr)+'px').attr('aria-hidden',false).removeClass(this.options.closeClass).addClass(this.options.openClass);if(obj&&obj.focusEl){this.$el.on(Helpers.transitionEndEvent(),function(){obj.focusEl.focus();_this5.$el.off(Helpers.transitionEndEvent());});}_app.Veams.Vent.trigger(_app.Veams.EVENTS.toggler.open,{context:this.options.context});if(this.options.setOverflow){this.$el.on(Helpers.transitionEndEvent(),function(){_this5.$el.css('overflow','visible');_this5.$el.off(Helpers.transitionEndEvent());});}if(this.options.toggleTabindexElems){$(this.options.toggleTabindexElems,this.el).attr('tabindex',0);}this.isOpen=true;}/**
	 * Close current view element
	 *
	 * @public
	 */},{key:'close',value:function close(){this.$el.css('height',0).removeAttr('style').attr('aria-hidden','true').removeClass(this.options.openClass).addClass(this.options.closeClass);if(this.options.setOverflow){this.$el.css('overflow','hidden');}if(this.options.toggleTabindexElems){$(this.options.toggleTabindexElems,this.el).attr('tabindex',-1);}this.isOpen=false;}/**
	 * calculateHeight class
	 */},{key:'calculateHeight',value:function calculateHeight(){var _this6=this;return new Promise(function(resolve,reject){if(_this6.el&&_this6.el.hasAttribute('style')){_this6.saveStyles();}_this6.enableCalcMode(true);_this6.calcHeight().then(function(){if(_this6.savedStyles){_this6.restoreStyles();}_this6.disableCalcMode();resolve();});});}},{key:'height',get:function get(){return this._height;},set:function set(height){this._height=height;}},{key:'isOpen',get:function get(){return this._isOpen;},set:function set(bool){this._isOpen=bool;}/**
	 * Get global events
	 *
	 */},{key:'subscribe',get:function get(){return{'{{Veams.EVENTS.resize}}':'onResize'};}}],[{key:'info',get:function get(){return{version:'3.0.3',vc:true,mod:false// set to true if source was modified in project
};}}]);return Toggler;}(_component2.default);exports.default=Toggler;

},{"app":"app","veams/src/js/common/component":30}],"app":[function(require,module,exports){
'use strict';Object.defineProperty(exports,"__esModule",{value:true});exports.Veams=exports.App=undefined;var _jquery=require('jquery');var _jquery2=_interopRequireDefault(_jquery);var _veams=require('veams');var _veams2=_interopRequireDefault(_veams);var _veamsPluginLogger=require('veams-plugin-logger');var _veamsPluginLogger2=_interopRequireDefault(_veamsPluginLogger);var _veamsPluginDom=require('veams-plugin-dom');var _veamsPluginDom2=_interopRequireDefault(_veamsPluginDom);var _veamsPluginVent=require('veams-plugin-vent');var _veamsPluginVent2=_interopRequireDefault(_veamsPluginVent);var _veamsPluginModules=require('veams-plugin-modules');var _veamsPluginModules2=_interopRequireDefault(_veamsPluginModules);var _veamsPluginMediaQueryHandler=require('veams-plugin-media-query-handler');var _veamsPluginMediaQueryHandler2=_interopRequireDefault(_veamsPluginMediaQueryHandler);var _veamsPluginTemplater=require('veams-plugin-templater');var _veamsPluginTemplater2=_interopRequireDefault(_veamsPluginTemplater);var _events=require('./events');var _events2=_interopRequireDefault(_events);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}// Global dependencies 
var Handlebars=require('handlebars/runtime');var Templates=require('./templates/templates');// import VeamsStore from 'veams-plugin-store';
// Trigger global resize event
window.onscroll=_veams2.default.helpers.throttle(function(e){_veams2.default.Vent.trigger(_veams2.default.EVENTS.scroll,e);},200);var App={};App.$=_jquery2.default;// Versioning
App.version="0.0.1";// Veams
_veams2.default.onInitialize(function(){/**
	* Veams Plugins
	*/// Dom Plugin
_veams2.default.use(_veamsPluginDom2.default,{DOM:_jquery2.default});// Vent Plugin
_veams2.default.use(_veamsPluginVent2.default,{furtherEvents:_events2.default});_veams2.default.use(_veamsPluginTemplater2.default,{templates:Templates,engine:Handlebars});// Logger Plugin for devmode and logger
_veams2.default.use(_veamsPluginLogger2.default);// Module System Plugin
_veams2.default.use(_veamsPluginModules2.default,{useMutationObserver:true,internalCacheOnly:false});// Store Plugin
// Veams.use(VeamsStore, {
// 	reducer: rootReducer,
// 	state: INITIAL_STATE,
// 	subjects: subjects
// });
// Media Query Handler Plugin
_veams2.default.use(_veamsPluginMediaQueryHandler2.default);});exports.App=App;exports.Veams=_veams2.default;

},{"./events":41,"./templates/templates":43,"handlebars/runtime":19,"jquery":"jquery","veams":28,"veams-plugin-dom":22,"veams-plugin-logger":23,"veams-plugin-media-query-handler":24,"veams-plugin-modules":25,"veams-plugin-templater":26,"veams-plugin-vent":27}]},{},[42])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy5ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2RlY29yYXRvcnMuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9kZWNvcmF0b3JzL2lubGluZS5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2V4Y2VwdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2Jsb2NrLWhlbHBlci1taXNzaW5nLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9lYWNoLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy9oZWxwZXItbWlzc2luZy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvaWYuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9oZWxwZXJzL2xvZy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL2hlbHBlcnMvbG9va3VwLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvaGVscGVycy93aXRoLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvbGliL2hhbmRsZWJhcnMvbG9nZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvZGlzdC9janMvaGFuZGxlYmFycy9ub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9uby1jb25mbGljdC5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvaGFuZGxlYmFycy9saWIvaGFuZGxlYmFycy9zYWZlLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy9oYW5kbGViYXJzL2xpYi9oYW5kbGViYXJzL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL2hhbmRsZWJhcnMvcnVudGltZS5qcyIsIm5vZGVfbW9kdWxlcy9tb21lbnQvbW9tZW50LmpzIiwibm9kZV9tb2R1bGVzL3Bpa2FkYXkvcGlrYWRheS5qcyIsIm5vZGVfbW9kdWxlcy92ZWFtcy1wbHVnaW4tZG9tL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWFtcy1wbHVnaW4tbG9nZ2VyL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWFtcy1wbHVnaW4tbWVkaWEtcXVlcnktaGFuZGxlci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmVhbXMtcGx1Z2luLW1vZHVsZXMvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlYW1zLXBsdWdpbi10ZW1wbGF0ZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZlYW1zLXBsdWdpbi12ZW50L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92ZWFtcy9saWIvdmVhbXMuanMiLCJub2RlX21vZHVsZXMvdmVhbXMvc3JjL2pzL2NvbW1vbi9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3ZlYW1zL3NyYy9qcy9jb21tb24vY29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3ZlYW1zL3NyYy9qcy91dGlscy9oZWxwZXJzL2RlZmF1bHRzLmpzIiwibm9kZV9tb2R1bGVzL3ZlYW1zL3NyYy9qcy91dGlscy9oZWxwZXJzL2V4dGVuZC5qcyIsIm5vZGVfbW9kdWxlcy92ZWFtcy9zcmMvanMvdXRpbHMvaGVscGVycy9pcy1pbi12aWV3cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy92ZWFtcy9zcmMvanMvdXRpbHMvaGVscGVycy9tYWtlLWlkLmpzIiwibm9kZV9tb2R1bGVzL3ZlYW1zL3NyYy9qcy91dGlscy9oZWxwZXJzL21ldGhvZC1leHRlbmQuanMiLCJub2RlX21vZHVsZXMvdmVhbXMvc3JjL2pzL3V0aWxzL2hlbHBlcnMvbWl4aW4uanMiLCJub2RlX21vZHVsZXMvdmVhbXMvc3JjL2pzL3V0aWxzL2hlbHBlcnMvdHJhbnNpdGlvbi1lbmQtZXZlbnQuanMiLCJub2RlX21vZHVsZXMvdmVhbXMvc3JjL2pzL3V0aWxzL2ludGVybmFsLWhlbHBlcnMvZ2V0LXN0cmluZy12YWx1ZS5qcyIsIm5vZGVfbW9kdWxlcy92ZWFtcy9zcmMvanMvdXRpbHMvaW50ZXJuYWwtaGVscGVycy9zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvdmVhbXMvc3JjL2pzL3V0aWxzL2ludGVybmFsLWhlbHBlcnMvdGVtcGxhdGUtZW5naW5lLmpzIiwicmVzb3VyY2VzL2pzL2V2ZW50cy5qcyIsInJlc291cmNlcy9qcy9tYWluLmpzIiwicmVzb3VyY2VzL2pzL3RlbXBsYXRlcy90ZW1wbGF0ZXMuanMiLCJyZXNvdXJjZXMvdGVtcGxhdGluZy9wYXJ0aWFscy9jb21wb25lbnRzL2FjY29yZGlvbi9qcy9hY2NvcmRpb24uanMiLCJyZXNvdXJjZXMvdGVtcGxhdGluZy9wYXJ0aWFscy9jb21wb25lbnRzL2NvbXBhcmVyL2pzL2NvbXBhcmVyLmpzIiwicmVzb3VyY2VzL3RlbXBsYXRpbmcvcGFydGlhbHMvY29tcG9uZW50cy9jdGEvanMvY3RhLmpzIiwicmVzb3VyY2VzL3RlbXBsYXRpbmcvcGFydGlhbHMvY29tcG9uZW50cy9mb3JtL2pzL2Zvcm0tYWpheC5qcyIsInJlc291cmNlcy90ZW1wbGF0aW5nL3BhcnRpYWxzL2NvbXBvbmVudHMvZm9ybS9qcy9mb3JtLWRhdGVwaWNrZXIuanMiLCJyZXNvdXJjZXMvdGVtcGxhdGluZy9wYXJ0aWFscy9jb21wb25lbnRzL292ZXJsYXkvanMvb3ZlcmxheS5qcyIsInJlc291cmNlcy90ZW1wbGF0aW5nL3BhcnRpYWxzL2NvbXBvbmVudHMvc2xpZGUtZm94L2pzL3NsaWRlLWZveC5qcyIsInJlc291cmNlcy90ZW1wbGF0aW5nL3BhcnRpYWxzL2NvbXBvbmVudHMvc2xpZGVyL2pzL3NsaWRlci5qcyIsInJlc291cmNlcy90ZW1wbGF0aW5nL3BhcnRpYWxzL2NvbXBvbmVudHMvdG9nZ2xlci9qcy90b2dnbGVyLmpzIiwicmVzb3VyY2VzL2pzL2FwcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7OzhCQ0FzQixtQkFBbUI7O0lBQTdCLElBQUk7Ozs7O29DQUlPLDBCQUEwQjs7OzttQ0FDM0Isd0JBQXdCOzs7OytCQUN2QixvQkFBb0I7O0lBQS9CLEtBQUs7O2lDQUNRLHNCQUFzQjs7SUFBbkMsT0FBTzs7b0NBRUksMEJBQTBCOzs7OztBQUdqRCxTQUFTLE1BQU0sR0FBRztBQUNoQixNQUFJLEVBQUUsR0FBRyxJQUFJLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDOztBQUUxQyxPQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUN2QixJQUFFLENBQUMsVUFBVSxvQ0FBYSxDQUFDO0FBQzNCLElBQUUsQ0FBQyxTQUFTLG1DQUFZLENBQUM7QUFDekIsSUFBRSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDakIsSUFBRSxDQUFDLGdCQUFnQixHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQzs7QUFFN0MsSUFBRSxDQUFDLEVBQUUsR0FBRyxPQUFPLENBQUM7QUFDaEIsSUFBRSxDQUFDLFFBQVEsR0FBRyxVQUFTLElBQUksRUFBRTtBQUMzQixXQUFPLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0dBQ25DLENBQUM7O0FBRUYsU0FBTyxFQUFFLENBQUM7Q0FDWDs7QUFFRCxJQUFJLElBQUksR0FBRyxNQUFNLEVBQUUsQ0FBQztB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O0NBQ2Y7O0FBRU0sU0FBUyxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsRUFBRSxFQUFFO0FBQ2pELFNBQU8sQ0FBQyxXQUFXLEdBQUcsV0FBVyxHQUFHLEdBQUcsR0FBRyxFQUFFLENBQUEsR0FBSSxFQUFFLENBQUM7Q0FDcEQ7Ozs7QUMzR0Q7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy8ySUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3B0Q0EsQ0FBQyxTQUFTLGdDQUFULENBQTBDLElBQTFDLEVBQWdELE9BQWhELEVBQXlEO0FBQ3pELEtBQUcsUUFBTyxPQUFQLHlDQUFPLE9BQVAsT0FBbUIsUUFBbkIsSUFBK0IsUUFBTyxNQUFQLHlDQUFPLE1BQVAsT0FBa0IsUUFBcEQs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LHlFQUNBLGdDLGdJQWRBO0FBSUEsR0FBTSxZQUFhLFFBQVEsb0JBQVIsQ0FBbkIsQ0FDQSxHQUFNLFdBQVksUUFBUSx1QkFBUixDQUFsQixDQU9BO0FBSUE7QUFDQSxPQUFPLFFBQVAsQ0FBa0IsZ0JBQU0sT0FBTixDQUFjLFFBQWQsQ0FBdUIsU0FBQyxDQUFELENBQU8sQ0FDNUMsZ0JBQU0sSUFBTixDQUFXLE9BQVgsQ0FBbUIsZ0JBQU0sTUFBTixDQUFhLE1BQWhDLENBQXdDLENBQXhDLEVBQ0gsQ0FGaUIsQ0FFZixHQUZlLENBQWxCLENBS0EsR0FBSSxLQUFNLEVBQVYsQ0FDQSxJQUFJLENBQUosa0JBRUE7QUFDQSxJQUFJLE9BQUosQ0FBYyxPQUFkLENBRUE7QUFDQSxnQkFBTSxZQUFOLENBQW1CLFVBQU0sQ0FDeEI7O0dBSUE7QUFDQSxnQkFBTSxHQUFOLDBCQUFvQixDQUNuQixvQkFEbUIsQ0FBcEIsRUFJQTtBQUNBLGdCQUFNLEdBQU4sMkJBQXFCLENBQ3BCLDhCQURvQixDQUFyQixFQUtHLGdCQUFNLEdBQU4sZ0NBQTBCLENBQ3RCLFVBQVcsU0FEVyxDQUV0QixPQUFRLFVBRmMsQ0FBMUIsRUFNQTtBQUNILGdCQUFNLEdBQU4sOEJBRUE7QUFDQSxnQkFBTSxHQUFOLDhCQUF3QixDQUN2QixvQkFBcUIsSUFERSxDQUV2QixrQkFBbUIsS0FGSSxDQUF4QixFQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0EsZ0JBQU0sR0FBTix5Q0FDQSxDQXhDRCxFLFFBMENRLEcsQ0FBQSxHLFNBQUssSyIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJpbXBvcnQgKiBhcyBiYXNlIGZyb20gJy4vaGFuZGxlYmFycy9iYXNlJztcblxuLy8gRWFjaCBvZiB0aGVzZSBhdWdtZW50IHRoZSBIYW5kbGViYXJzIG9iamVjdC4gTm8gbmVlZCB0byBzZXR1cCBoZXJlLlxuLy8gKFRoaXMgaXMgZG9uZSB0byBlYXNpbHkgc2hhcmUgY29kZSBiZXR3ZWVuIGNvbW1vbmpzIGFuZCBicm93c2UgZW52cylcbmltcG9ydCBTYWZlU3RyaW5nIGZyb20gJy4vaGFuZGxlYmFycy9zYWZlLXN0cmluZyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4vaGFuZGxlYmFycy9leGNlcHRpb24nO1xuaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi9oYW5kbGViYXJzL3V0aWxzJztcbmltcG9ydCAqIGFzIHJ1bnRpbWUgZnJvbSAnLi9oYW5kbGViYXJzL3J1bnRpbWUnO1xuXG5pbXBvcnQgbm9Db25mbGljdCBmcm9tICcuL2hhbmRsZWJhcnMvbm8tY29uZmxpY3QnO1xuXG4vLyBGb3IgY29tcGF0aWJpbGl0eSBhbmQgdXNhZ2Ugb3V0c2lkZSBvZiBtb2R1bGUgc3lzdGVtcywgbWFrZSB0aGUgSGFuZGxlYmFycyBvYmplY3QgYSBuYW1lc3BhY2VcbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgbGV0IGhiID0gbmV3IGJhc2UuSGFuZGxlYmFyc0Vudmlyb25tZW50KCk7XG5cbiAgVXRpbHMuZXh0ZW5kKGhiLCBiYXNlKTtcbiAgaGIuU2FmZVN0cmluZyA9IFNhZmVTdHJpbmc7XG4gIGhiLkV4Y2VwdGlvbiA9IEV4Y2VwdGlvbjtcbiAgaGIuVXRpbHMgPSBVdGlscztcbiAgaGIuZXNjYXBlRXhwcmVzc2lvbiA9IFV0aWxzLmVzY2FwZUV4cHJlc3Npb247XG5cbiAgaGIuVk0gPSBydW50aW1lO1xuICBoYi50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICByZXR1cm4gcnVudGltZS50ZW1wbGF0ZShzcGVjLCBoYik7XG4gIH07XG5cbiAgcmV0dXJuIGhiO1xufVxuXG5sZXQgaW5zdCA9IGNyZWF0ZSgpO1xuaW5zdC5jcmVhdGUgPSBjcmVhdGU7XG5cbm5vQ29uZmxpY3QoaW5zdCk7XG5cbmluc3RbJ2RlZmF1bHQnXSA9IGluc3Q7XG5cbmV4cG9ydCBkZWZhdWx0IGluc3Q7XG4iLCJpbXBvcnQge2NyZWF0ZUZyYW1lLCBleHRlbmQsIHRvU3RyaW5nfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi9leGNlcHRpb24nO1xuaW1wb3J0IHtyZWdpc3RlckRlZmF1bHRIZWxwZXJzfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHtyZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzfSBmcm9tICcuL2RlY29yYXRvcnMnO1xuaW1wb3J0IGxvZ2dlciBmcm9tICcuL2xvZ2dlcic7XG5cbmV4cG9ydCBjb25zdCBWRVJTSU9OID0gJzQuMC4xMCc7XG5leHBvcnQgY29uc3QgQ09NUElMRVJfUkVWSVNJT04gPSA3O1xuXG5leHBvcnQgY29uc3QgUkVWSVNJT05fQ0hBTkdFUyA9IHtcbiAgMTogJzw9IDEuMC5yYy4yJywgLy8gMS4wLnJjLjIgaXMgYWN0dWFsbHkgcmV2MiBidXQgZG9lc24ndCByZXBvcnQgaXRcbiAgMjogJz09IDEuMC4wLXJjLjMnLFxuICAzOiAnPT0gMS4wLjAtcmMuNCcsXG4gIDQ6ICc9PSAxLngueCcsXG4gIDU6ICc9PSAyLjAuMC1hbHBoYS54JyxcbiAgNjogJz49IDIuMC4wLWJldGEuMScsXG4gIDc6ICc+PSA0LjAuMCdcbn07XG5cbmNvbnN0IG9iamVjdFR5cGUgPSAnW29iamVjdCBPYmplY3RdJztcblxuZXhwb3J0IGZ1bmN0aW9uIEhhbmRsZWJhcnNFbnZpcm9ubWVudChoZWxwZXJzLCBwYXJ0aWFscywgZGVjb3JhdG9ycykge1xuICB0aGlzLmhlbHBlcnMgPSBoZWxwZXJzIHx8IHt9O1xuICB0aGlzLnBhcnRpYWxzID0gcGFydGlhbHMgfHwge307XG4gIHRoaXMuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnMgfHwge307XG5cbiAgcmVnaXN0ZXJEZWZhdWx0SGVscGVycyh0aGlzKTtcbiAgcmVnaXN0ZXJEZWZhdWx0RGVjb3JhdG9ycyh0aGlzKTtcbn1cblxuSGFuZGxlYmFyc0Vudmlyb25tZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEhhbmRsZWJhcnNFbnZpcm9ubWVudCxcblxuICBsb2dnZXI6IGxvZ2dlcixcbiAgbG9nOiBsb2dnZXIubG9nLFxuXG4gIHJlZ2lzdGVySGVscGVyOiBmdW5jdGlvbihuYW1lLCBmbikge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBpZiAoZm4pIHsgdGhyb3cgbmV3IEV4Y2VwdGlvbignQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBoZWxwZXJzJyk7IH1cbiAgICAgIGV4dGVuZCh0aGlzLmhlbHBlcnMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlbHBlcnNbbmFtZV0gPSBmbjtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJIZWxwZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5oZWxwZXJzW25hbWVdO1xuICB9LFxuXG4gIHJlZ2lzdGVyUGFydGlhbDogZnVuY3Rpb24obmFtZSwgcGFydGlhbCkge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBleHRlbmQodGhpcy5wYXJ0aWFscywgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgcGFydGlhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbihgQXR0ZW1wdGluZyB0byByZWdpc3RlciBhIHBhcnRpYWwgY2FsbGVkIFwiJHtuYW1lfVwiIGFzIHVuZGVmaW5lZGApO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJ0aWFsc1tuYW1lXSA9IHBhcnRpYWw7XG4gICAgfVxuICB9LFxuICB1bnJlZ2lzdGVyUGFydGlhbDogZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLnBhcnRpYWxzW25hbWVdO1xuICB9LFxuXG4gIHJlZ2lzdGVyRGVjb3JhdG9yOiBmdW5jdGlvbihuYW1lLCBmbikge1xuICAgIGlmICh0b1N0cmluZy5jYWxsKG5hbWUpID09PSBvYmplY3RUeXBlKSB7XG4gICAgICBpZiAoZm4pIHsgdGhyb3cgbmV3IEV4Y2VwdGlvbignQXJnIG5vdCBzdXBwb3J0ZWQgd2l0aCBtdWx0aXBsZSBkZWNvcmF0b3JzJyk7IH1cbiAgICAgIGV4dGVuZCh0aGlzLmRlY29yYXRvcnMsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlY29yYXRvcnNbbmFtZV0gPSBmbjtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXJEZWNvcmF0b3I6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5kZWNvcmF0b3JzW25hbWVdO1xuICB9XG59O1xuXG5leHBvcnQgbGV0IGxvZyA9IGxvZ2dlci5sb2c7XG5cbmV4cG9ydCB7Y3JlYXRlRnJhbWUsIGxvZ2dlcn07XG4iLCJpbXBvcnQgcmVnaXN0ZXJJbmxpbmUgZnJvbSAnLi9kZWNvcmF0b3JzL2lubGluZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHREZWNvcmF0b3JzKGluc3RhbmNlKSB7XG4gIHJlZ2lzdGVySW5saW5lKGluc3RhbmNlKTtcbn1cblxuIiwiaW1wb3J0IHtleHRlbmR9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJEZWNvcmF0b3IoJ2lubGluZScsIGZ1bmN0aW9uKGZuLCBwcm9wcywgY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgbGV0IHJldCA9IGZuO1xuICAgIGlmICghcHJvcHMucGFydGlhbHMpIHtcbiAgICAgIHByb3BzLnBhcnRpYWxzID0ge307XG4gICAgICByZXQgPSBmdW5jdGlvbihjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwYXJ0aWFscyBzdGFjayBmcmFtZSBwcmlvciB0byBleGVjLlxuICAgICAgICBsZXQgb3JpZ2luYWwgPSBjb250YWluZXIucGFydGlhbHM7XG4gICAgICAgIGNvbnRhaW5lci5wYXJ0aWFscyA9IGV4dGVuZCh7fSwgb3JpZ2luYWwsIHByb3BzLnBhcnRpYWxzKTtcbiAgICAgICAgbGV0IHJldCA9IGZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcmlnaW5hbDtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcHJvcHMucGFydGlhbHNbb3B0aW9ucy5hcmdzWzBdXSA9IG9wdGlvbnMuZm47XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cbiIsIlxuY29uc3QgZXJyb3JQcm9wcyA9IFsnZGVzY3JpcHRpb24nLCAnZmlsZU5hbWUnLCAnbGluZU51bWJlcicsICdtZXNzYWdlJywgJ25hbWUnLCAnbnVtYmVyJywgJ3N0YWNrJ107XG5cbmZ1bmN0aW9uIEV4Y2VwdGlvbihtZXNzYWdlLCBub2RlKSB7XG4gIGxldCBsb2MgPSBub2RlICYmIG5vZGUubG9jLFxuICAgICAgbGluZSxcbiAgICAgIGNvbHVtbjtcbiAgaWYgKGxvYykge1xuICAgIGxpbmUgPSBsb2Muc3RhcnQubGluZTtcbiAgICBjb2x1bW4gPSBsb2Muc3RhcnQuY29sdW1uO1xuXG4gICAgbWVzc2FnZSArPSAnIC0gJyArIGxpbmUgKyAnOicgKyBjb2x1bW47XG4gIH1cblxuICBsZXQgdG1wID0gRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cbiAgLy8gVW5mb3J0dW5hdGVseSBlcnJvcnMgYXJlIG5vdCBlbnVtZXJhYmxlIGluIENocm9tZSAoYXQgbGVhc3QpLCBzbyBgZm9yIHByb3AgaW4gdG1wYCBkb2Vzbid0IHdvcmsuXG4gIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGVycm9yUHJvcHMubGVuZ3RoOyBpZHgrKykge1xuICAgIHRoaXNbZXJyb3JQcm9wc1tpZHhdXSA9IHRtcFtlcnJvclByb3BzW2lkeF1dO1xuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgRXhjZXB0aW9uKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGxvYykge1xuICAgICAgdGhpcy5saW5lTnVtYmVyID0gbGluZTtcblxuICAgICAgLy8gV29yayBhcm91bmQgaXNzdWUgdW5kZXIgc2FmYXJpIHdoZXJlIHdlIGNhbid0IGRpcmVjdGx5IHNldCB0aGUgY29sdW1uIHZhbHVlXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvbHVtbicsIHtcbiAgICAgICAgICB2YWx1ZTogY29sdW1uLFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKG5vcCkge1xuICAgIC8qIElnbm9yZSBpZiB0aGUgYnJvd3NlciBpcyB2ZXJ5IHBhcnRpY3VsYXIgKi9cbiAgfVxufVxuXG5FeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbmV4cG9ydCBkZWZhdWx0IEV4Y2VwdGlvbjtcbiIsImltcG9ydCByZWdpc3RlckJsb2NrSGVscGVyTWlzc2luZyBmcm9tICcuL2hlbHBlcnMvYmxvY2staGVscGVyLW1pc3NpbmcnO1xuaW1wb3J0IHJlZ2lzdGVyRWFjaCBmcm9tICcuL2hlbHBlcnMvZWFjaCc7XG5pbXBvcnQgcmVnaXN0ZXJIZWxwZXJNaXNzaW5nIGZyb20gJy4vaGVscGVycy9oZWxwZXItbWlzc2luZyc7XG5pbXBvcnQgcmVnaXN0ZXJJZiBmcm9tICcuL2hlbHBlcnMvaWYnO1xuaW1wb3J0IHJlZ2lzdGVyTG9nIGZyb20gJy4vaGVscGVycy9sb2cnO1xuaW1wb3J0IHJlZ2lzdGVyTG9va3VwIGZyb20gJy4vaGVscGVycy9sb29rdXAnO1xuaW1wb3J0IHJlZ2lzdGVyV2l0aCBmcm9tICcuL2hlbHBlcnMvd2l0aCc7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHRIZWxwZXJzKGluc3RhbmNlKSB7XG4gIHJlZ2lzdGVyQmxvY2tIZWxwZXJNaXNzaW5nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJFYWNoKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJIZWxwZXJNaXNzaW5nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJJZihpbnN0YW5jZSk7XG4gIHJlZ2lzdGVyTG9nKGluc3RhbmNlKTtcbiAgcmVnaXN0ZXJMb29rdXAoaW5zdGFuY2UpO1xuICByZWdpc3RlcldpdGgoaW5zdGFuY2UpO1xufVxuIiwiaW1wb3J0IHthcHBlbmRDb250ZXh0UGF0aCwgY3JlYXRlRnJhbWUsIGlzQXJyYXl9IGZyb20gJy4uL3V0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2Jsb2NrSGVscGVyTWlzc2luZycsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBsZXQgaW52ZXJzZSA9IG9wdGlvbnMuaW52ZXJzZSxcbiAgICAgICAgZm4gPSBvcHRpb25zLmZuO1xuXG4gICAgaWYgKGNvbnRleHQgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBmbih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRleHQgPT09IGZhbHNlIHx8IGNvbnRleHQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGludmVyc2UodGhpcyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICBpZiAoY29udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmlkcykge1xuICAgICAgICAgIG9wdGlvbnMuaWRzID0gW29wdGlvbnMubmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5zdGFuY2UuaGVscGVycy5lYWNoKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGludmVyc2UodGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5pZHMpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgICBkYXRhLmNvbnRleHRQYXRoID0gYXBwZW5kQ29udGV4dFBhdGgob3B0aW9ucy5kYXRhLmNvbnRleHRQYXRoLCBvcHRpb25zLm5hbWUpO1xuICAgICAgICBvcHRpb25zID0ge2RhdGE6IGRhdGF9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbn1cbiIsImltcG9ydCB7YXBwZW5kQ29udGV4dFBhdGgsIGJsb2NrUGFyYW1zLCBjcmVhdGVGcmFtZSwgaXNBcnJheSwgaXNGdW5jdGlvbn0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IEV4Y2VwdGlvbiBmcm9tICcuLi9leGNlcHRpb24nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcignZWFjaCcsIGZ1bmN0aW9uKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ011c3QgcGFzcyBpdGVyYXRvciB0byAjZWFjaCcpO1xuICAgIH1cblxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm4sXG4gICAgICAgIGludmVyc2UgPSBvcHRpb25zLmludmVyc2UsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICByZXQgPSAnJyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgY29udGV4dFBhdGg7XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhICYmIG9wdGlvbnMuaWRzKSB7XG4gICAgICBjb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pICsgJy4nO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRleHQpKSB7IGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7IH1cblxuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4ZWNJdGVyYXRpb24oZmllbGQsIGluZGV4LCBsYXN0KSB7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBkYXRhLmtleSA9IGZpZWxkO1xuICAgICAgICBkYXRhLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIGRhdGEuZmlyc3QgPSBpbmRleCA9PT0gMDtcbiAgICAgICAgZGF0YS5sYXN0ID0gISFsYXN0O1xuXG4gICAgICAgIGlmIChjb250ZXh0UGF0aCkge1xuICAgICAgICAgIGRhdGEuY29udGV4dFBhdGggPSBjb250ZXh0UGF0aCArIGZpZWxkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldCA9IHJldCArIGZuKGNvbnRleHRbZmllbGRdLCB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGJsb2NrUGFyYW1zOiBibG9ja1BhcmFtcyhbY29udGV4dFtmaWVsZF0sIGZpZWxkXSwgW2NvbnRleHRQYXRoICsgZmllbGQsIG51bGxdKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAoaXNBcnJheShjb250ZXh0KSkge1xuICAgICAgICBmb3IgKGxldCBqID0gY29udGV4dC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICBpZiAoaSBpbiBjb250ZXh0KSB7XG4gICAgICAgICAgICBleGVjSXRlcmF0aW9uKGksIGksIGkgPT09IGNvbnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcHJpb3JLZXk7XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIGNvbnRleHQpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBydW5uaW5nIHRoZSBpdGVyYXRpb25zIG9uZSBzdGVwIG91dCBvZiBzeW5jIHNvIHdlIGNhbiBkZXRlY3RcbiAgICAgICAgICAgIC8vIHRoZSBsYXN0IGl0ZXJhdGlvbiB3aXRob3V0IGhhdmUgdG8gc2NhbiB0aGUgb2JqZWN0IHR3aWNlIGFuZCBjcmVhdGVcbiAgICAgICAgICAgIC8vIGFuIGl0ZXJtZWRpYXRlIGtleXMgYXJyYXkuXG4gICAgICAgICAgICBpZiAocHJpb3JLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmlvcktleSA9IGtleTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW9yS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBleGVjSXRlcmF0aW9uKHByaW9yS2V5LCBpIC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgcmV0ID0gaW52ZXJzZSh0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cbiIsImltcG9ydCBFeGNlcHRpb24gZnJvbSAnLi4vZXhjZXB0aW9uJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2hlbHBlck1pc3NpbmcnLCBmdW5jdGlvbigvKiBbYXJncywgXW9wdGlvbnMgKi8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gQSBtaXNzaW5nIGZpZWxkIGluIGEge3tmb299fSBjb25zdHJ1Y3QuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTb21lb25lIGlzIGFjdHVhbGx5IHRyeWluZyB0byBjYWxsIHNvbWV0aGluZywgYmxvdyB1cC5cbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ01pc3NpbmcgaGVscGVyOiBcIicgKyBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdLm5hbWUgKyAnXCInKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiaW1wb3J0IHtpc0VtcHR5LCBpc0Z1bmN0aW9ufSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCdpZicsIGZ1bmN0aW9uKGNvbmRpdGlvbmFsLCBvcHRpb25zKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oY29uZGl0aW9uYWwpKSB7IGNvbmRpdGlvbmFsID0gY29uZGl0aW9uYWwuY2FsbCh0aGlzKTsgfVxuXG4gICAgLy8gRGVmYXVsdCBiZWhhdmlvciBpcyB0byByZW5kZXIgdGhlIHBvc2l0aXZlIHBhdGggaWYgdGhlIHZhbHVlIGlzIHRydXRoeSBhbmQgbm90IGVtcHR5LlxuICAgIC8vIFRoZSBgaW5jbHVkZVplcm9gIG9wdGlvbiBtYXkgYmUgc2V0IHRvIHRyZWF0IHRoZSBjb25kdGlvbmFsIGFzIHB1cmVseSBub3QgZW1wdHkgYmFzZWQgb24gdGhlXG4gICAgLy8gYmVoYXZpb3Igb2YgaXNFbXB0eS4gRWZmZWN0aXZlbHkgdGhpcyBkZXRlcm1pbmVzIGlmIDAgaXMgaGFuZGxlZCBieSB0aGUgcG9zaXRpdmUgcGF0aCBvciBuZWdhdGl2ZS5cbiAgICBpZiAoKCFvcHRpb25zLmhhc2guaW5jbHVkZVplcm8gJiYgIWNvbmRpdGlvbmFsKSB8fCBpc0VtcHR5KGNvbmRpdGlvbmFsKSkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW52ZXJzZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuZm4odGhpcyk7XG4gICAgfVxuICB9KTtcblxuICBpbnN0YW5jZS5yZWdpc3RlckhlbHBlcigndW5sZXNzJywgZnVuY3Rpb24oY29uZGl0aW9uYWwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuaGVscGVyc1snaWYnXS5jYWxsKHRoaXMsIGNvbmRpdGlvbmFsLCB7Zm46IG9wdGlvbnMuaW52ZXJzZSwgaW52ZXJzZTogb3B0aW9ucy5mbiwgaGFzaDogb3B0aW9ucy5oYXNofSk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvZycsIGZ1bmN0aW9uKC8qIG1lc3NhZ2UsIG9wdGlvbnMgKi8pIHtcbiAgICBsZXQgYXJncyA9IFt1bmRlZmluZWRdLFxuICAgICAgICBvcHRpb25zID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIGxldCBsZXZlbCA9IDE7XG4gICAgaWYgKG9wdGlvbnMuaGFzaC5sZXZlbCAhPSBudWxsKSB7XG4gICAgICBsZXZlbCA9IG9wdGlvbnMuaGFzaC5sZXZlbDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmRhdGEubGV2ZWwgIT0gbnVsbCkge1xuICAgICAgbGV2ZWwgPSBvcHRpb25zLmRhdGEubGV2ZWw7XG4gICAgfVxuICAgIGFyZ3NbMF0gPSBsZXZlbDtcblxuICAgIGluc3RhbmNlLmxvZyguLi4gYXJncyk7XG4gIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucmVnaXN0ZXJIZWxwZXIoJ2xvb2t1cCcsIGZ1bmN0aW9uKG9iaiwgZmllbGQpIHtcbiAgICByZXR1cm4gb2JqICYmIG9ialtmaWVsZF07XG4gIH0pO1xufVxuIiwiaW1wb3J0IHthcHBlbmRDb250ZXh0UGF0aCwgYmxvY2tQYXJhbXMsIGNyZWF0ZUZyYW1lLCBpc0VtcHR5LCBpc0Z1bmN0aW9ufSBmcm9tICcuLi91dGlscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnJlZ2lzdGVySGVscGVyKCd3aXRoJywgZnVuY3Rpb24oY29udGV4dCwgb3B0aW9ucykge1xuICAgIGlmIChpc0Z1bmN0aW9uKGNvbnRleHQpKSB7IGNvbnRleHQgPSBjb250ZXh0LmNhbGwodGhpcyk7IH1cblxuICAgIGxldCBmbiA9IG9wdGlvbnMuZm47XG5cbiAgICBpZiAoIWlzRW1wdHkoY29udGV4dCkpIHtcbiAgICAgIGxldCBkYXRhID0gb3B0aW9ucy5kYXRhO1xuICAgICAgaWYgKG9wdGlvbnMuZGF0YSAmJiBvcHRpb25zLmlkcykge1xuICAgICAgICBkYXRhID0gY3JlYXRlRnJhbWUob3B0aW9ucy5kYXRhKTtcbiAgICAgICAgZGF0YS5jb250ZXh0UGF0aCA9IGFwcGVuZENvbnRleHRQYXRoKG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCwgb3B0aW9ucy5pZHNbMF0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm4oY29udGV4dCwge1xuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBibG9ja1BhcmFtczogYmxvY2tQYXJhbXMoW2NvbnRleHRdLCBbZGF0YSAmJiBkYXRhLmNvbnRleHRQYXRoXSlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbnZlcnNlKHRoaXMpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJpbXBvcnQge2luZGV4T2Z9IGZyb20gJy4vdXRpbHMnO1xuXG5sZXQgbG9nZ2VyID0ge1xuICBtZXRob2RNYXA6IFsnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJ10sXG4gIGxldmVsOiAnaW5mbycsXG5cbiAgLy8gTWFwcyBhIGdpdmVuIGxldmVsIHZhbHVlIHRvIHRoZSBgbWV0aG9kTWFwYCBpbmRleGVzIGFib3ZlLlxuICBsb29rdXBMZXZlbDogZnVuY3Rpb24obGV2ZWwpIHtcbiAgICBpZiAodHlwZW9mIGxldmVsID09PSAnc3RyaW5nJykge1xuICAgICAgbGV0IGxldmVsTWFwID0gaW5kZXhPZihsb2dnZXIubWV0aG9kTWFwLCBsZXZlbC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGlmIChsZXZlbE1hcCA+PSAwKSB7XG4gICAgICAgIGxldmVsID0gbGV2ZWxNYXA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXZlbCA9IHBhcnNlSW50KGxldmVsLCAxMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxldmVsO1xuICB9LFxuXG4gIC8vIENhbiBiZSBvdmVycmlkZGVuIGluIHRoZSBob3N0IGVudmlyb25tZW50XG4gIGxvZzogZnVuY3Rpb24obGV2ZWwsIC4uLm1lc3NhZ2UpIHtcbiAgICBsZXZlbCA9IGxvZ2dlci5sb29rdXBMZXZlbChsZXZlbCk7XG5cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGxvZ2dlci5sb29rdXBMZXZlbChsb2dnZXIubGV2ZWwpIDw9IGxldmVsKSB7XG4gICAgICBsZXQgbWV0aG9kID0gbG9nZ2VyLm1ldGhvZE1hcFtsZXZlbF07XG4gICAgICBpZiAoIWNvbnNvbGVbbWV0aG9kXSkgeyAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgICBtZXRob2QgPSAnbG9nJztcbiAgICAgIH1cbiAgICAgIGNvbnNvbGVbbWV0aG9kXSguLi5tZXNzYWdlKTsgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBsb2dnZXI7XG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihIYW5kbGViYXJzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGxldCByb290ID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB3aW5kb3csXG4gICAgICAkSGFuZGxlYmFycyA9IHJvb3QuSGFuZGxlYmFycztcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgSGFuZGxlYmFycy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHJvb3QuSGFuZGxlYmFycyA9PT0gSGFuZGxlYmFycykge1xuICAgICAgcm9vdC5IYW5kbGViYXJzID0gJEhhbmRsZWJhcnM7XG4gICAgfVxuICAgIHJldHVybiBIYW5kbGViYXJzO1xuICB9O1xufVxuIiwiaW1wb3J0ICogYXMgVXRpbHMgZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgRXhjZXB0aW9uIGZyb20gJy4vZXhjZXB0aW9uJztcbmltcG9ydCB7IENPTVBJTEVSX1JFVklTSU9OLCBSRVZJU0lPTl9DSEFOR0VTLCBjcmVhdGVGcmFtZSB9IGZyb20gJy4vYmFzZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1JldmlzaW9uKGNvbXBpbGVySW5mbykge1xuICBjb25zdCBjb21waWxlclJldmlzaW9uID0gY29tcGlsZXJJbmZvICYmIGNvbXBpbGVySW5mb1swXSB8fCAxLFxuICAgICAgICBjdXJyZW50UmV2aXNpb24gPSBDT01QSUxFUl9SRVZJU0lPTjtcblxuICBpZiAoY29tcGlsZXJSZXZpc2lvbiAhPT0gY3VycmVudFJldmlzaW9uKSB7XG4gICAgaWYgKGNvbXBpbGVyUmV2aXNpb24gPCBjdXJyZW50UmV2aXNpb24pIHtcbiAgICAgIGNvbnN0IHJ1bnRpbWVWZXJzaW9ucyA9IFJFVklTSU9OX0NIQU5HRVNbY3VycmVudFJldmlzaW9uXSxcbiAgICAgICAgICAgIGNvbXBpbGVyVmVyc2lvbnMgPSBSRVZJU0lPTl9DSEFOR0VTW2NvbXBpbGVyUmV2aXNpb25dO1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVGVtcGxhdGUgd2FzIHByZWNvbXBpbGVkIHdpdGggYW4gb2xkZXIgdmVyc2lvbiBvZiBIYW5kbGViYXJzIHRoYW4gdGhlIGN1cnJlbnQgcnVudGltZS4gJyArXG4gICAgICAgICAgICAnUGxlYXNlIHVwZGF0ZSB5b3VyIHByZWNvbXBpbGVyIHRvIGEgbmV3ZXIgdmVyc2lvbiAoJyArIHJ1bnRpbWVWZXJzaW9ucyArICcpIG9yIGRvd25ncmFkZSB5b3VyIHJ1bnRpbWUgdG8gYW4gb2xkZXIgdmVyc2lvbiAoJyArIGNvbXBpbGVyVmVyc2lvbnMgKyAnKS4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXNlIHRoZSBlbWJlZGRlZCB2ZXJzaW9uIGluZm8gc2luY2UgdGhlIHJ1bnRpbWUgZG9lc24ndCBrbm93IGFib3V0IHRoaXMgcmV2aXNpb24geWV0XG4gICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdUZW1wbGF0ZSB3YXMgcHJlY29tcGlsZWQgd2l0aCBhIG5ld2VyIHZlcnNpb24gb2YgSGFuZGxlYmFycyB0aGFuIHRoZSBjdXJyZW50IHJ1bnRpbWUuICcgK1xuICAgICAgICAgICAgJ1BsZWFzZSB1cGRhdGUgeW91ciBydW50aW1lIHRvIGEgbmV3ZXIgdmVyc2lvbiAoJyArIGNvbXBpbGVySW5mb1sxXSArICcpLicpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGUodGVtcGxhdGVTcGVjLCBlbnYpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKCFlbnYpIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdObyBlbnZpcm9ubWVudCBwYXNzZWQgdG8gdGVtcGxhdGUnKTtcbiAgfVxuICBpZiAoIXRlbXBsYXRlU3BlYyB8fCAhdGVtcGxhdGVTcGVjLm1haW4pIHtcbiAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdVbmtub3duIHRlbXBsYXRlIG9iamVjdDogJyArIHR5cGVvZiB0ZW1wbGF0ZVNwZWMpO1xuICB9XG5cbiAgdGVtcGxhdGVTcGVjLm1haW4uZGVjb3JhdG9yID0gdGVtcGxhdGVTcGVjLm1haW5fZDtcblxuICAvLyBOb3RlOiBVc2luZyBlbnYuVk0gcmVmZXJlbmNlcyByYXRoZXIgdGhhbiBsb2NhbCB2YXIgcmVmZXJlbmNlcyB0aHJvdWdob3V0IHRoaXMgc2VjdGlvbiB0byBhbGxvd1xuICAvLyBmb3IgZXh0ZXJuYWwgdXNlcnMgdG8gb3ZlcnJpZGUgdGhlc2UgYXMgcHN1ZWRvLXN1cHBvcnRlZCBBUElzLlxuICBlbnYuVk0uY2hlY2tSZXZpc2lvbih0ZW1wbGF0ZVNwZWMuY29tcGlsZXIpO1xuXG4gIGZ1bmN0aW9uIGludm9rZVBhcnRpYWxXcmFwcGVyKHBhcnRpYWwsIGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5oYXNoKSB7XG4gICAgICBjb250ZXh0ID0gVXRpbHMuZXh0ZW5kKHt9LCBjb250ZXh0LCBvcHRpb25zLmhhc2gpO1xuICAgICAgaWYgKG9wdGlvbnMuaWRzKSB7XG4gICAgICAgIG9wdGlvbnMuaWRzWzBdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJ0aWFsID0gZW52LlZNLnJlc29sdmVQYXJ0aWFsLmNhbGwodGhpcywgcGFydGlhbCwgY29udGV4dCwgb3B0aW9ucyk7XG4gICAgbGV0IHJlc3VsdCA9IGVudi5WTS5pbnZva2VQYXJ0aWFsLmNhbGwodGhpcywgcGFydGlhbCwgY29udGV4dCwgb3B0aW9ucyk7XG5cbiAgICBpZiAocmVzdWx0ID09IG51bGwgJiYgZW52LmNvbXBpbGUpIHtcbiAgICAgIG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXSA9IGVudi5jb21waWxlKHBhcnRpYWwsIHRlbXBsYXRlU3BlYy5jb21waWxlck9wdGlvbnMsIGVudik7XG4gICAgICByZXN1bHQgPSBvcHRpb25zLnBhcnRpYWxzW29wdGlvbnMubmFtZV0oY29udGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgaWYgKG9wdGlvbnMuaW5kZW50KSB7XG4gICAgICAgIGxldCBsaW5lcyA9IHJlc3VsdC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFsaW5lc1tpXSAmJiBpICsgMSA9PT0gbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGluZXNbaV0gPSBvcHRpb25zLmluZGVudCArIGxpbmVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignVGhlIHBhcnRpYWwgJyArIG9wdGlvbnMubmFtZSArICcgY291bGQgbm90IGJlIGNvbXBpbGVkIHdoZW4gcnVubmluZyBpbiBydW50aW1lLW9ubHkgbW9kZScpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEp1c3QgYWRkIHdhdGVyXG4gIGxldCBjb250YWluZXIgPSB7XG4gICAgc3RyaWN0OiBmdW5jdGlvbihvYmosIG5hbWUpIHtcbiAgICAgIGlmICghKG5hbWUgaW4gb2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXhjZXB0aW9uKCdcIicgKyBuYW1lICsgJ1wiIG5vdCBkZWZpbmVkIGluICcgKyBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialtuYW1lXTtcbiAgICB9LFxuICAgIGxvb2t1cDogZnVuY3Rpb24oZGVwdGhzLCBuYW1lKSB7XG4gICAgICBjb25zdCBsZW4gPSBkZXB0aHMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoZGVwdGhzW2ldICYmIGRlcHRoc1tpXVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGRlcHRoc1tpXVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbGFtYmRhOiBmdW5jdGlvbihjdXJyZW50LCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGN1cnJlbnQgPT09ICdmdW5jdGlvbicgPyBjdXJyZW50LmNhbGwoY29udGV4dCkgOiBjdXJyZW50O1xuICAgIH0sXG5cbiAgICBlc2NhcGVFeHByZXNzaW9uOiBVdGlscy5lc2NhcGVFeHByZXNzaW9uLFxuICAgIGludm9rZVBhcnRpYWw6IGludm9rZVBhcnRpYWxXcmFwcGVyLFxuXG4gICAgZm46IGZ1bmN0aW9uKGkpIHtcbiAgICAgIGxldCByZXQgPSB0ZW1wbGF0ZVNwZWNbaV07XG4gICAgICByZXQuZGVjb3JhdG9yID0gdGVtcGxhdGVTcGVjW2kgKyAnX2QnXTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIHByb2dyYW1zOiBbXSxcbiAgICBwcm9ncmFtOiBmdW5jdGlvbihpLCBkYXRhLCBkZWNsYXJlZEJsb2NrUGFyYW1zLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG4gICAgICBsZXQgcHJvZ3JhbVdyYXBwZXIgPSB0aGlzLnByb2dyYW1zW2ldLFxuICAgICAgICAgIGZuID0gdGhpcy5mbihpKTtcbiAgICAgIGlmIChkYXRhIHx8IGRlcHRocyB8fCBibG9ja1BhcmFtcyB8fCBkZWNsYXJlZEJsb2NrUGFyYW1zKSB7XG4gICAgICAgIHByb2dyYW1XcmFwcGVyID0gd3JhcFByb2dyYW0odGhpcywgaSwgZm4sIGRhdGEsIGRlY2xhcmVkQmxvY2tQYXJhbXMsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICAgICAgfSBlbHNlIGlmICghcHJvZ3JhbVdyYXBwZXIpIHtcbiAgICAgICAgcHJvZ3JhbVdyYXBwZXIgPSB0aGlzLnByb2dyYW1zW2ldID0gd3JhcFByb2dyYW0odGhpcywgaSwgZm4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb2dyYW1XcmFwcGVyO1xuICAgIH0sXG5cbiAgICBkYXRhOiBmdW5jdGlvbih2YWx1ZSwgZGVwdGgpIHtcbiAgICAgIHdoaWxlICh2YWx1ZSAmJiBkZXB0aC0tKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuX3BhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIG1lcmdlOiBmdW5jdGlvbihwYXJhbSwgY29tbW9uKSB7XG4gICAgICBsZXQgb2JqID0gcGFyYW0gfHwgY29tbW9uO1xuXG4gICAgICBpZiAocGFyYW0gJiYgY29tbW9uICYmIChwYXJhbSAhPT0gY29tbW9uKSkge1xuICAgICAgICBvYmogPSBVdGlscy5leHRlbmQoe30sIGNvbW1vbiwgcGFyYW0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgLy8gQW4gZW1wdHkgb2JqZWN0IHRvIHVzZSBhcyByZXBsYWNlbWVudCBmb3IgbnVsbC1jb250ZXh0c1xuICAgIG51bGxDb250ZXh0OiBPYmplY3Quc2VhbCh7fSksXG5cbiAgICBub29wOiBlbnYuVk0ubm9vcCxcbiAgICBjb21waWxlckluZm86IHRlbXBsYXRlU3BlYy5jb21waWxlclxuICB9O1xuXG4gIGZ1bmN0aW9uIHJldChjb250ZXh0LCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgZGF0YSA9IG9wdGlvbnMuZGF0YTtcblxuICAgIHJldC5fc2V0dXAob3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zLnBhcnRpYWwgJiYgdGVtcGxhdGVTcGVjLnVzZURhdGEpIHtcbiAgICAgIGRhdGEgPSBpbml0RGF0YShjb250ZXh0LCBkYXRhKTtcbiAgICB9XG4gICAgbGV0IGRlcHRocyxcbiAgICAgICAgYmxvY2tQYXJhbXMgPSB0ZW1wbGF0ZVNwZWMudXNlQmxvY2tQYXJhbXMgPyBbXSA6IHVuZGVmaW5lZDtcbiAgICBpZiAodGVtcGxhdGVTcGVjLnVzZURlcHRocykge1xuICAgICAgaWYgKG9wdGlvbnMuZGVwdGhzKSB7XG4gICAgICAgIGRlcHRocyA9IGNvbnRleHQgIT0gb3B0aW9ucy5kZXB0aHNbMF0gPyBbY29udGV4dF0uY29uY2F0KG9wdGlvbnMuZGVwdGhzKSA6IG9wdGlvbnMuZGVwdGhzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVwdGhzID0gW2NvbnRleHRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1haW4oY29udGV4dC8qLCBvcHRpb25zKi8pIHtcbiAgICAgIHJldHVybiAnJyArIHRlbXBsYXRlU3BlYy5tYWluKGNvbnRhaW5lciwgY29udGV4dCwgY29udGFpbmVyLmhlbHBlcnMsIGNvbnRhaW5lci5wYXJ0aWFscywgZGF0YSwgYmxvY2tQYXJhbXMsIGRlcHRocyk7XG4gICAgfVxuICAgIG1haW4gPSBleGVjdXRlRGVjb3JhdG9ycyh0ZW1wbGF0ZVNwZWMubWFpbiwgbWFpbiwgY29udGFpbmVyLCBvcHRpb25zLmRlcHRocyB8fCBbXSwgZGF0YSwgYmxvY2tQYXJhbXMpO1xuICAgIHJldHVybiBtYWluKGNvbnRleHQsIG9wdGlvbnMpO1xuICB9XG4gIHJldC5pc1RvcCA9IHRydWU7XG5cbiAgcmV0Ll9zZXR1cCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMucGFydGlhbCkge1xuICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5oZWxwZXJzLCBlbnYuaGVscGVycyk7XG5cbiAgICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlUGFydGlhbCkge1xuICAgICAgICBjb250YWluZXIucGFydGlhbHMgPSBjb250YWluZXIubWVyZ2Uob3B0aW9ucy5wYXJ0aWFscywgZW52LnBhcnRpYWxzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wbGF0ZVNwZWMudXNlUGFydGlhbCB8fCB0ZW1wbGF0ZVNwZWMudXNlRGVjb3JhdG9ycykge1xuICAgICAgICBjb250YWluZXIuZGVjb3JhdG9ycyA9IGNvbnRhaW5lci5tZXJnZShvcHRpb25zLmRlY29yYXRvcnMsIGVudi5kZWNvcmF0b3JzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udGFpbmVyLmhlbHBlcnMgPSBvcHRpb25zLmhlbHBlcnM7XG4gICAgICBjb250YWluZXIucGFydGlhbHMgPSBvcHRpb25zLnBhcnRpYWxzO1xuICAgICAgY29udGFpbmVyLmRlY29yYXRvcnMgPSBvcHRpb25zLmRlY29yYXRvcnM7XG4gICAgfVxuICB9O1xuXG4gIHJldC5fY2hpbGQgPSBmdW5jdGlvbihpLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKSB7XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VCbG9ja1BhcmFtcyAmJiAhYmxvY2tQYXJhbXMpIHtcbiAgICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ211c3QgcGFzcyBibG9jayBwYXJhbXMnKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlU3BlYy51c2VEZXB0aHMgJiYgIWRlcHRocykge1xuICAgICAgdGhyb3cgbmV3IEV4Y2VwdGlvbignbXVzdCBwYXNzIHBhcmVudCBkZXB0aHMnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcFByb2dyYW0oY29udGFpbmVyLCBpLCB0ZW1wbGF0ZVNwZWNbaV0sIGRhdGEsIDAsIGJsb2NrUGFyYW1zLCBkZXB0aHMpO1xuICB9O1xuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JhcFByb2dyYW0oY29udGFpbmVyLCBpLCBmbiwgZGF0YSwgZGVjbGFyZWRCbG9ja1BhcmFtcywgYmxvY2tQYXJhbXMsIGRlcHRocykge1xuICBmdW5jdGlvbiBwcm9nKGNvbnRleHQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGxldCBjdXJyZW50RGVwdGhzID0gZGVwdGhzO1xuICAgIGlmIChkZXB0aHMgJiYgY29udGV4dCAhPSBkZXB0aHNbMF0gJiYgIShjb250ZXh0ID09PSBjb250YWluZXIubnVsbENvbnRleHQgJiYgZGVwdGhzWzBdID09PSBudWxsKSkge1xuICAgICAgY3VycmVudERlcHRocyA9IFtjb250ZXh0XS5jb25jYXQoZGVwdGhzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm4oY29udGFpbmVyLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjb250YWluZXIuaGVscGVycywgY29udGFpbmVyLnBhcnRpYWxzLFxuICAgICAgICBvcHRpb25zLmRhdGEgfHwgZGF0YSxcbiAgICAgICAgYmxvY2tQYXJhbXMgJiYgW29wdGlvbnMuYmxvY2tQYXJhbXNdLmNvbmNhdChibG9ja1BhcmFtcyksXG4gICAgICAgIGN1cnJlbnREZXB0aHMpO1xuICB9XG5cbiAgcHJvZyA9IGV4ZWN1dGVEZWNvcmF0b3JzKGZuLCBwcm9nLCBjb250YWluZXIsIGRlcHRocywgZGF0YSwgYmxvY2tQYXJhbXMpO1xuXG4gIHByb2cucHJvZ3JhbSA9IGk7XG4gIHByb2cuZGVwdGggPSBkZXB0aHMgPyBkZXB0aHMubGVuZ3RoIDogMDtcbiAgcHJvZy5ibG9ja1BhcmFtcyA9IGRlY2xhcmVkQmxvY2tQYXJhbXMgfHwgMDtcbiAgcmV0dXJuIHByb2c7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUGFydGlhbChwYXJ0aWFsLCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIGlmICghcGFydGlhbCkge1xuICAgIGlmIChvcHRpb25zLm5hbWUgPT09ICdAcGFydGlhbC1ibG9jaycpIHtcbiAgICAgIHBhcnRpYWwgPSBvcHRpb25zLmRhdGFbJ3BhcnRpYWwtYmxvY2snXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydGlhbCA9IG9wdGlvbnMucGFydGlhbHNbb3B0aW9ucy5uYW1lXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIXBhcnRpYWwuY2FsbCAmJiAhb3B0aW9ucy5uYW1lKSB7XG4gICAgLy8gVGhpcyBpcyBhIGR5bmFtaWMgcGFydGlhbCB0aGF0IHJldHVybmVkIGEgc3RyaW5nXG4gICAgb3B0aW9ucy5uYW1lID0gcGFydGlhbDtcbiAgICBwYXJ0aWFsID0gb3B0aW9ucy5wYXJ0aWFsc1twYXJ0aWFsXTtcbiAgfVxuICByZXR1cm4gcGFydGlhbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGludm9rZVBhcnRpYWwocGFydGlhbCwgY29udGV4dCwgb3B0aW9ucykge1xuICAvLyBVc2UgdGhlIGN1cnJlbnQgY2xvc3VyZSBjb250ZXh0IHRvIHNhdmUgdGhlIHBhcnRpYWwtYmxvY2sgaWYgdGhpcyBwYXJ0aWFsXG4gIGNvbnN0IGN1cnJlbnRQYXJ0aWFsQmxvY2sgPSBvcHRpb25zLmRhdGEgJiYgb3B0aW9ucy5kYXRhWydwYXJ0aWFsLWJsb2NrJ107XG4gIG9wdGlvbnMucGFydGlhbCA9IHRydWU7XG4gIGlmIChvcHRpb25zLmlkcykge1xuICAgIG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aCA9IG9wdGlvbnMuaWRzWzBdIHx8IG9wdGlvbnMuZGF0YS5jb250ZXh0UGF0aDtcbiAgfVxuXG4gIGxldCBwYXJ0aWFsQmxvY2s7XG4gIGlmIChvcHRpb25zLmZuICYmIG9wdGlvbnMuZm4gIT09IG5vb3ApIHtcbiAgICBvcHRpb25zLmRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgIC8vIFdyYXBwZXIgZnVuY3Rpb24gdG8gZ2V0IGFjY2VzcyB0byBjdXJyZW50UGFydGlhbEJsb2NrIGZyb20gdGhlIGNsb3N1cmVcbiAgICBsZXQgZm4gPSBvcHRpb25zLmZuO1xuICAgIHBhcnRpYWxCbG9jayA9IG9wdGlvbnMuZGF0YVsncGFydGlhbC1ibG9jayddID0gZnVuY3Rpb24gcGFydGlhbEJsb2NrV3JhcHBlcihjb250ZXh0LCBvcHRpb25zID0ge30pIHtcblxuICAgICAgLy8gUmVzdG9yZSB0aGUgcGFydGlhbC1ibG9jayBmcm9tIHRoZSBjbG9zdXJlIGZvciB0aGUgZXhlY3V0aW9uIG9mIHRoZSBibG9ja1xuICAgICAgLy8gaS5lLiB0aGUgcGFydCBpbnNpZGUgdGhlIGJsb2NrIG9mIHRoZSBwYXJ0aWFsIGNhbGwuXG4gICAgICBvcHRpb25zLmRhdGEgPSBjcmVhdGVGcmFtZShvcHRpb25zLmRhdGEpO1xuICAgICAgb3B0aW9ucy5kYXRhWydwYXJ0aWFsLWJsb2NrJ10gPSBjdXJyZW50UGFydGlhbEJsb2NrO1xuICAgICAgcmV0dXJuIGZuKGNvbnRleHQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgaWYgKGZuLnBhcnRpYWxzKSB7XG4gICAgICBvcHRpb25zLnBhcnRpYWxzID0gVXRpbHMuZXh0ZW5kKHt9LCBvcHRpb25zLnBhcnRpYWxzLCBmbi5wYXJ0aWFscyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnRpYWwgPT09IHVuZGVmaW5lZCAmJiBwYXJ0aWFsQmxvY2spIHtcbiAgICBwYXJ0aWFsID0gcGFydGlhbEJsb2NrO1xuICB9XG5cbiAgaWYgKHBhcnRpYWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFeGNlcHRpb24oJ1RoZSBwYXJ0aWFsICcgKyBvcHRpb25zLm5hbWUgKyAnIGNvdWxkIG5vdCBiZSBmb3VuZCcpO1xuICB9IGVsc2UgaWYgKHBhcnRpYWwgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xuICAgIHJldHVybiBwYXJ0aWFsKGNvbnRleHQsIG9wdGlvbnMpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub29wKCkgeyByZXR1cm4gJyc7IH1cblxuZnVuY3Rpb24gaW5pdERhdGEoY29udGV4dCwgZGF0YSkge1xuICBpZiAoIWRhdGEgfHwgISgncm9vdCcgaW4gZGF0YSkpIHtcbiAgICBkYXRhID0gZGF0YSA/IGNyZWF0ZUZyYW1lKGRhdGEpIDoge307XG4gICAgZGF0YS5yb290ID0gY29udGV4dDtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZXhlY3V0ZURlY29yYXRvcnMoZm4sIHByb2csIGNvbnRhaW5lciwgZGVwdGhzLCBkYXRhLCBibG9ja1BhcmFtcykge1xuICBpZiAoZm4uZGVjb3JhdG9yKSB7XG4gICAgbGV0IHByb3BzID0ge307XG4gICAgcHJvZyA9IGZuLmRlY29yYXRvcihwcm9nLCBwcm9wcywgY29udGFpbmVyLCBkZXB0aHMgJiYgZGVwdGhzWzBdLCBkYXRhLCBibG9ja1BhcmFtcywgZGVwdGhzKTtcbiAgICBVdGlscy5leHRlbmQocHJvZywgcHJvcHMpO1xuICB9XG4gIHJldHVybiBwcm9nO1xufVxuIiwiLy8gQnVpbGQgb3V0IG91ciBiYXNpYyBTYWZlU3RyaW5nIHR5cGVcbmZ1bmN0aW9uIFNhZmVTdHJpbmcoc3RyaW5nKSB7XG4gIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xufVxuXG5TYWZlU3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IFNhZmVTdHJpbmcucHJvdG90eXBlLnRvSFRNTCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJycgKyB0aGlzLnN0cmluZztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNhZmVTdHJpbmc7XG4iLCJjb25zdCBlc2NhcGUgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmI3gyNzsnLFxuICAnYCc6ICcmI3g2MDsnLFxuICAnPSc6ICcmI3gzRDsnXG59O1xuXG5jb25zdCBiYWRDaGFycyA9IC9bJjw+XCInYD1dL2csXG4gICAgICBwb3NzaWJsZSA9IC9bJjw+XCInYD1dLztcblxuZnVuY3Rpb24gZXNjYXBlQ2hhcihjaHIpIHtcbiAgcmV0dXJuIGVzY2FwZVtjaHJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKG9iai8qICwgLi4uc291cmNlICovKSB7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQga2V5IGluIGFyZ3VtZW50c1tpXSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmd1bWVudHNbaV0sIGtleSkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBhcmd1bWVudHNbaV1ba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5leHBvcnQgbGV0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLy8gU291cmNlZCBmcm9tIGxvZGFzaFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL2xvZGFzaC9ibG9iL21hc3Rlci9MSUNFTlNFLnR4dFxuLyogZXNsaW50LWRpc2FibGUgZnVuYy1zdHlsZSAqL1xubGV0IGlzRnVuY3Rpb24gPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufTtcbi8vIGZhbGxiYWNrIGZvciBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmIChpc0Z1bmN0aW9uKC94LykpIHtcbiAgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgfTtcbn1cbmV4cG9ydCB7aXNGdW5jdGlvbn07XG4vKiBlc2xpbnQtZW5hYmxlIGZ1bmMtc3R5bGUgKi9cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpID8gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScgOiBmYWxzZTtcbn07XG5cbi8vIE9sZGVyIElFIHZlcnNpb25zIGRvIG5vdCBkaXJlY3RseSBzdXBwb3J0IGluZGV4T2Ygc28gd2UgbXVzdCBpbXBsZW1lbnQgb3VyIG93biwgc2FkbHkuXG5leHBvcnQgZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUpIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGFycmF5W2ldID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlRXhwcmVzc2lvbihzdHJpbmcpIHtcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZG9uJ3QgZXNjYXBlIFNhZmVTdHJpbmdzLCBzaW5jZSB0aGV5J3JlIGFscmVhZHkgc2FmZVxuICAgIGlmIChzdHJpbmcgJiYgc3RyaW5nLnRvSFRNTCkge1xuICAgICAgcmV0dXJuIHN0cmluZy50b0hUTUwoKTtcbiAgICB9IGVsc2UgaWYgKHN0cmluZyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIGlmICghc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nICsgJyc7XG4gICAgfVxuXG4gICAgLy8gRm9yY2UgYSBzdHJpbmcgY29udmVyc2lvbiBhcyB0aGlzIHdpbGwgYmUgZG9uZSBieSB0aGUgYXBwZW5kIHJlZ2FyZGxlc3MgYW5kXG4gICAgLy8gdGhlIHJlZ2V4IHRlc3Qgd2lsbCBkbyB0aGlzIHRyYW5zcGFyZW50bHkgYmVoaW5kIHRoZSBzY2VuZXMsIGNhdXNpbmcgaXNzdWVzIGlmXG4gICAgLy8gYW4gb2JqZWN0J3MgdG8gc3RyaW5nIGhhcyBlc2NhcGVkIGNoYXJhY3RlcnMgaW4gaXQuXG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG4gIH1cblxuICBpZiAoIXBvc3NpYmxlLnRlc3Qoc3RyaW5nKSkgeyByZXR1cm4gc3RyaW5nOyB9XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShiYWRDaGFycywgZXNjYXBlQ2hhcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZyYW1lKG9iamVjdCkge1xuICBsZXQgZnJhbWUgPSBleHRlbmQoe30sIG9iamVjdCk7XG4gIGZyYW1lLl9wYXJlbnQgPSBvYmplY3Q7XG4gIHJldHVybiBmcmFtZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJsb2NrUGFyYW1zKHBhcmFtcywgaWRzKSB7XG4gIHBhcmFtcy5wYXRoID0gaWRzO1xuICByZXR1cm4gcGFyYW1zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kQ29udGV4dFBhdGgoY29udGV4dFBhdGgsIGlkKSB7XG4gIHJldHVybiAoY29udGV4dFBhdGggPyBjb250ZXh0UGF0aCArICcuJyA6ICcnKSArIGlkO1xufVxuIiwiLy8gQ3JlYXRlIGEgc2ltcGxlIHBhdGggYWxpYXMgdG8gYWxsb3cgYnJvd3NlcmlmeSB0byByZXNvbHZlXG4vLyB0aGUgcnVudGltZSBvbiBhIHN1cHBvcnRlZCBwYXRoLlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2pzL2hhbmRsZWJhcnMucnVudGltZScpWydkZWZhdWx0J107XG4iLCIvLyEgbW9tZW50LmpzXG4vLyEgdmVyc2lvbiA6IDIuMTguMVxuLy8hIGF1dGhvcnMgOiBUaW0gV29vZCwgSXNrcmVuIENoZXJuZXYsIE1vbWVudC5qcyBjb250cmlidXRvcnNcbi8vISBsaWNlbnNlIDogTUlUXG4vLyEgbW9tZW50anMuY29tXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgaG9va0NhbGxiYWNrO1xuXG5mdW5jdGlvbiBob29rcyAoKSB7XG4gICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG4vLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG5mdW5jdGlvbiBzZXRIb29rQ2FsbGJhY2sgKGNhbGxiYWNrKSB7XG4gICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBBcnJheSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgIC8vIElFOCB3aWxsIHRyZWF0IHVuZGVmaW5lZCBhbmQgbnVsbCBhcyBvYmplY3QgaWYgaXQgd2Fzbid0IGZvclxuICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICB2YXIgaztcbiAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICAgIC8vIGV2ZW4gaWYgaXRzIG5vdCBvd24gcHJvcGVydHkgSSdkIHN0aWxsIGNhbGwgaXQgbm9uLWVtcHR5XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGlucHV0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59XG5cbmZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG5mdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVVRDIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICB1bnVzZWRJbnB1dCAgICAgOiBbXSxcbiAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgIG51bGxJbnB1dCAgICAgICA6IGZhbHNlLFxuICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXG4gICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcbiAgICAgICAgbWVyaWRpZW0gICAgICAgIDogbnVsbCxcbiAgICAgICAgcmZjMjgyMiAgICAgICAgIDogZmFsc2UsXG4gICAgICAgIHdlZWtkYXlNaXNtYXRjaCA6IGZhbHNlXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICBtLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcbiAgICB9XG4gICAgcmV0dXJuIG0uX3BmO1xufVxuXG52YXIgc29tZTtcbmlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgIHNvbWUgPSBBcnJheS5wcm90b3R5cGUuc29tZTtcbn0gZWxzZSB7XG4gICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXMsIHRbaV0sIGksIHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cblxudmFyIHNvbWUkMSA9IHNvbWU7XG5cbmZ1bmN0aW9uIGlzVmFsaWQobSkge1xuICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgdmFyIGZsYWdzID0gZ2V0UGFyc2luZ0ZsYWdzKG0pO1xuICAgICAgICB2YXIgcGFyc2VkUGFydHMgPSBzb21lJDEuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGlzTm93VmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICBmbGFncy5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgIWZsYWdzLmludmFsaWRXZWVrZGF5ICYmXG4gICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEZvcm1hdCAmJlxuICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZCAmJlxuICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICBpc05vd1ZhbGlkID0gaXNOb3dWYWxpZCAmJlxuICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgZmxhZ3MuYmlnSG91ciA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBpc05vd1ZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTm93VmFsaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcbiAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICBleHRlbmQoZ2V0UGFyc2luZ0ZsYWdzKG0pLCBmbGFncyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkudXNlckludmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbnZhciBtb21lbnRQcm9wZXJ0aWVzID0gaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdO1xuXG5mdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgdmFyIGksIHByb3AsIHZhbDtcblxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgfVxuICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICB9XG4gICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICB9XG5cbiAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0bztcbn1cblxudmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuLy8gTW9tZW50IHByb3RvdHlwZSBvYmplY3RcbmZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgdGhpcy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5fZCAhPSBudWxsID8gY29uZmlnLl9kLmdldFRpbWUoKSA6IE5hTik7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICB9XG4gICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgIC8vIG9iamVjdHMuXG4gICAgaWYgKHVwZGF0ZUluUHJvZ3Jlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgTW9tZW50IHx8IChvYmogIT0gbnVsbCAmJiBvYmouX2lzQU1vbWVudE9iamVjdCAhPSBudWxsKTtcbn1cblxuZnVuY3Rpb24gYWJzRmxvb3IgKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICB2YWx1ZSA9IDA7XG5cbiAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gY29tcGFyZSB0d28gYXJyYXlzLCByZXR1cm4gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlc1xuZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgIGxlbmd0aERpZmYgPSBNYXRoLmFicyhhcnJheTEubGVuZ3RoIC0gYXJyYXkyLmxlbmd0aCksXG4gICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSkpIHtcbiAgICAgICAgICAgIGRpZmZzKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcbn1cblxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICBpZiAoaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihudWxsLCBtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICB2YXIgYXJnO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmcgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMCwgLTIpOyAvLyBSZW1vdmUgdHJhaWxpbmcgY29tbWEgYW5kIHNwYWNlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdhcm4obXNnICsgJ1xcbkFyZ3VtZW50czogJyArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJycpICsgJ1xcbicgKyAobmV3IEVycm9yKCkpLnN0YWNrKTtcbiAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sIGZuKTtcbn1cblxudmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xuICAgIH1cbiAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xuICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgfVxufVxuXG5ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbmhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciA9IG51bGw7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG5mdW5jdGlvbiBzZXQgKGNvbmZpZykge1xuICAgIHZhciBwcm9wLCBpO1xuICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgIHRoaXNbaV0gPSBwcm9wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgIC8vIExlbmllbnQgb3JkaW5hbCBwYXJzaW5nIGFjY2VwdHMganVzdCBhIG51bWJlciBpbiBhZGRpdGlvbiB0b1xuICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX2RheU9mTW9udGhPcmRpbmFsUGFyc2UuXG4gICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgIHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgKHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2Uuc291cmNlIHx8IHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UpICtcbiAgICAgICAgICAgICd8JyArICgvXFxkezEsMn0vKS5zb3VyY2UpO1xufVxuXG5mdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xuICAgIHZhciByZXMgPSBleHRlbmQoe30sIHBhcmVudENvbmZpZyksIHByb3A7XG4gICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgZXh0ZW5kKHJlc1twcm9wXSwgcGFyZW50Q29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBjaGlsZENvbmZpZ1twcm9wXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHByb3AgaW4gcGFyZW50Q29uZmlnKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNldChjb25maWcpO1xuICAgIH1cbn1cblxudmFyIGtleXM7XG5cbmlmIChPYmplY3Qua2V5cykge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cztcbn0gZWxzZSB7XG4gICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGksIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGkpKSB7XG4gICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xufVxuXG52YXIga2V5cyQxID0ga2V5cztcblxudmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICBzYW1lRGF5IDogJ1tUb2RheSBhdF0gTFQnLFxuICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICBsYXN0RGF5IDogJ1tZZXN0ZXJkYXkgYXRdIExUJyxcbiAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICBzYW1lRWxzZSA6ICdMJ1xufTtcblxuZnVuY3Rpb24gY2FsZW5kYXIgKGtleSwgbW9tLCBub3cpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xufVxuXG52YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgIExUUyAgOiAnaDptbTpzcyBBJyxcbiAgICBMVCAgIDogJ2g6bW0gQScsXG4gICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICBMTCAgIDogJ01NTU0gRCwgWVlZWScsXG4gICAgTExMICA6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG59O1xuXG5mdW5jdGlvbiBsb25nRGF0ZUZvcm1hdCAoa2V5KSB7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgaWYgKGZvcm1hdCB8fCAhZm9ybWF0VXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gZm9ybWF0VXBwZXIucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldO1xufVxuXG52YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbmZ1bmN0aW9uIGludmFsaWREYXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG59XG5cbnZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCc7XG52YXIgZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG5mdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG59XG5cbnZhciBkZWZhdWx0UmVsYXRpdmVUaW1lID0ge1xuICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgcyAgOiAnYSBmZXcgc2Vjb25kcycsXG4gICAgc3MgOiAnJWQgc2Vjb25kcycsXG4gICAgbSAgOiAnYSBtaW51dGUnLFxuICAgIG1tIDogJyVkIG1pbnV0ZXMnLFxuICAgIGggIDogJ2FuIGhvdXInLFxuICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICBkICA6ICdhIGRheScsXG4gICAgZGQgOiAnJWQgZGF5cycsXG4gICAgTSAgOiAnYSBtb250aCcsXG4gICAgTU0gOiAnJWQgbW9udGhzJyxcbiAgICB5ICA6ICdhIHllYXInLFxuICAgIHl5IDogJyVkIHllYXJzJ1xufTtcblxuZnVuY3Rpb24gcmVsYXRpdmVUaW1lIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgcmV0dXJuIChpc0Z1bmN0aW9uKG91dHB1dCkpID9cbiAgICAgICAgb3V0cHV0KG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkgOlxuICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbn1cblxuZnVuY3Rpb24gcGFzdEZ1dHVyZSAoZGlmZiwgb3V0cHV0KSB7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbn1cblxudmFyIGFsaWFzZXMgPSB7fTtcblxuZnVuY3Rpb24gYWRkVW5pdEFsaWFzICh1bml0LCBzaG9ydGhhbmQpIHtcbiAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xuICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgIHByb3A7XG5cbiAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkUHJvcCA9IG5vcm1hbGl6ZVVuaXRzKHByb3ApO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRJbnB1dDtcbn1cblxudmFyIHByaW9yaXRpZXMgPSB7fTtcblxuZnVuY3Rpb24gYWRkVW5pdFByaW9yaXR5KHVuaXQsIHByaW9yaXR5KSB7XG4gICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xufVxuXG5mdW5jdGlvbiBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzT2JqKSB7XG4gICAgdmFyIHVuaXRzID0gW107XG4gICAgZm9yICh2YXIgdSBpbiB1bml0c09iaikge1xuICAgICAgICB1bml0cy5wdXNoKHt1bml0OiB1LCBwcmlvcml0eTogcHJpb3JpdGllc1t1XX0pO1xuICAgIH1cbiAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5pdHM7XG59XG5cbmZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldCAobW9tLCB1bml0KSB7XG4gICAgcmV0dXJuIG1vbS5pc1ZhbGlkKCkgP1xuICAgICAgICBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKSA6IE5hTjtcbn1cblxuZnVuY3Rpb24gc2V0JDEgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICBpZiAobW9tLmlzVmFsaWQoKSkge1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgIH1cbn1cblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBzdHJpbmdHZXQgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn1cblxuXG5mdW5jdGlvbiBzdHJpbmdTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplT2JqZWN0VW5pdHModW5pdHMpO1xuICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmlvcml0aXplZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10odmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG4gICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArIGFic051bWJlcjtcbn1cblxudmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xuXG52YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxudmFyIGZvcm1hdEZ1bmN0aW9ucyA9IHt9O1xuXG52YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuLy8gdG9rZW46ICAgICdNJ1xuLy8gcGFkZGVkOiAgIFsnTU0nLCAyXVxuLy8gb3JkaW5hbDogICdNbydcbi8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuZnVuY3Rpb24gYWRkRm9ybWF0VG9rZW4gKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0b2tlbikge1xuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgIH1cbiAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGlucHV0KSB7XG4gICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcbiAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSAnJywgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gaXNGdW5jdGlvbihhcnJheVtpXSkgPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn1cblxuLy8gZm9ybWF0IGRhdGUgdXNpbmcgbmF0aXZlIGRhdGUgb2JqZWN0XG5mdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gbS5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG5cbiAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gPSBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgdmFyIGkgPSA1O1xuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgIH1cblxuICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShsb2NhbEZvcm1hdHRpbmdUb2tlbnMsIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vucyk7XG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpIC09IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdDtcbn1cblxudmFyIG1hdGNoMSAgICAgICAgID0gL1xcZC87ICAgICAgICAgICAgLy8gICAgICAgMCAtIDlcbnZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbnZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbnZhciBtYXRjaDQgICAgICAgICA9IC9cXGR7NH0vOyAgICAgICAgIC8vICAgIDAwMDAgLSA5OTk5XG52YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG52YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG52YXIgbWF0Y2gzdG80ICAgICAgPSAvXFxkXFxkXFxkXFxkPy87ICAgICAvLyAgICAgOTk5IC0gOTk5OVxudmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XG52YXIgbWF0Y2gxdG8zICAgICAgPSAvXFxkezEsM30vOyAgICAgICAvLyAgICAgICAwIC0gOTk5XG52YXIgbWF0Y2gxdG80ICAgICAgPSAvXFxkezEsNH0vOyAgICAgICAvLyAgICAgICAwIC0gOTk5OVxudmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG52YXIgbWF0Y2hVbnNpZ25lZCAgPSAvXFxkKy87ICAgICAgICAgICAvLyAgICAgICAwIC0gaW5mXG52YXIgbWF0Y2hTaWduZWQgICAgPSAvWystXT9cXGQrLzsgICAgICAvLyAgICAtaW5mIC0gaW5mXG5cbnZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG52YXIgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpOyAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuXG52YXIgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vOyAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuXG4vLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbi8vIGluY2x1ZGVzIHNjb3R0aXNoIGdhZWxpYyB0d28gd29yZCBhbmQgaHlwaGVuYXRlZCBtb250aHNcbnZhciBtYXRjaFdvcmQgPSAvWzAtOV0qWydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK3xbXFx1MDYwMC1cXHUwNkZGXFwvXSsoXFxzKj9bXFx1MDYwMC1cXHUwNkZGXSspezEsMn0vaTtcblxuXG52YXIgcmVnZXhlcyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRSZWdleFRva2VuICh0b2tlbiwgcmVnZXgsIHN0cmljdFJlZ2V4KSB7XG4gICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgIHJldHVybiAoaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXgpID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4gKHRva2VuLCBjb25maWcpIHtcbiAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG59XG5cbi8vIENvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM1NjE0OTMvaXMtdGhlcmUtYS1yZWdleHAtZXNjYXBlLWZ1bmN0aW9uLWluLWphdmFzY3JpcHRcbmZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICByZXR1cm4gcmVnZXhFc2NhcGUocy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICB9KSk7XG59XG5cbmZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbn1cblxudmFyIHRva2VucyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRva2VuID0gW3Rva2VuXTtcbiAgICB9XG4gICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICB9XG59XG5cbnZhciBZRUFSID0gMDtcbnZhciBNT05USCA9IDE7XG52YXIgREFURSA9IDI7XG52YXIgSE9VUiA9IDM7XG52YXIgTUlOVVRFID0gNDtcbnZhciBTRUNPTkQgPSA1O1xudmFyIE1JTExJU0VDT05EID0gNjtcbnZhciBXRUVLID0gNztcbnZhciBXRUVLREFZID0gODtcblxudmFyIGluZGV4T2Y7XG5cbmlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbn0gZWxzZSB7XG4gICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIC8vIEkga25vd1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG59XG5cbnZhciBpbmRleE9mJDEgPSBpbmRleE9mO1xuXG5mdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCArIDEsIDApKS5nZXRVVENEYXRlKCk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbn0pO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ21vbnRoJywgOCk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdNTScsICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignTU1NJywgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG59KTtcblxuYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG59KTtcblxuYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICB9XG59KTtcblxuLy8gTE9DQUxFU1xuXG52YXIgTU9OVEhTX0lOX0ZPUk1BVCA9IC9EW29EXT8oXFxbW15cXFtcXF1dKlxcXXxcXHMpK01NTU0/LztcbnZhciBkZWZhdWx0TG9jYWxlTW9udGhzID0gJ0phbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXInLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVNb250aHMgKG0sIGZvcm1hdCkge1xuICAgIGlmICghbSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1snc3RhbmRhbG9uZSddO1xuICAgIH1cbiAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpID8gdGhpcy5fbW9udGhzW20ubW9udGgoKV0gOlxuICAgICAgICB0aGlzLl9tb250aHNbKHRoaXMuX21vbnRocy5pc0Zvcm1hdCB8fCBNT05USFNfSU5fRk9STUFUKS50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbn1cblxudmFyIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9ICdKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlYycuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0IChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpID8gdGhpcy5fbW9udGhzU2hvcnQgOlxuICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXSA6XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0W01PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAvLyB0aGlzIGlzIG5vdCB1c2VkXG4gICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbG9jYWxlTW9udGhzUGFyc2UgKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgIGlmICh0aGlzLl9tb250aHNQYXJzZUV4YWN0KSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgbW9udGggKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXJcbiAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIHNldE1vbnRoIChtb20sIHZhbHVlKSB7XG4gICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgIHJldHVybiBtb207XG59XG5cbmZ1bmN0aW9uIGdldFNldE1vbnRoICh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0KHRoaXMsICdNb250aCcpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF5c0luTW9udGggKCkge1xuICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbn1cblxudmFyIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkO1xuZnVuY3Rpb24gbW9udGhzU2hvcnRSZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICB9XG59XG5cbnZhciBkZWZhdWx0TW9udGhzUmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiBtb250aHNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZU1vbnRoc1BhcnNlICgpIHtcbiAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICBpLCBtb207XG4gICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICBsb25nUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICB9XG4gICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICByZXR1cm4geSA8PSA5OTk5ID8gJycgKyB5IDogJysnICsgeTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZJywgICA0XSwgICAgICAgMCwgJ3llYXInKTtcbmFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCAgNV0sICAgICAgIDAsICd5ZWFyJyk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbi8vIFBSSU9SSVRJRVNcblxuYWRkVW5pdFByaW9yaXR5KCd5ZWFyJywgMSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuYWRkUmVnZXhUb2tlbignWVknLCAgICAgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignWVlZWScsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuYWRkUmVnZXhUb2tlbignWVlZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG5hZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICBhcnJheVtZRUFSXSA9IGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbn0pO1xuYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG59XG5cbmZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xuICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbn1cblxuLy8gSE9PS1NcblxuaG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xufTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbmZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF0ZSAoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcbiAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG5cbiAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDAgJiYgaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgIHZhciBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG5cbiAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwICYmIGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGU7XG59XG5cbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgIGZ3ZCA9IDcgKyBkb3cgLSBkb3ksXG4gICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgcmV0dXJuIC1md2RsdyArIGZ3ZCAtIDE7XG59XG5cbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG5mdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICBkYXlPZlllYXIgPSAxICsgNyAqICh3ZWVrIC0gMSkgKyBsb2NhbFdlZWtkYXkgKyB3ZWVrT2Zmc2V0LFxuICAgICAgICByZXNZZWFyLCByZXNEYXlPZlllYXI7XG5cbiAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xuICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgd2VlayA9IE1hdGguZmxvb3IoKG1vbS5kYXlPZlllYXIoKSAtIHdlZWtPZmZzZXQgLSAxKSAvIDcpICsgMSxcbiAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgIGlmICh3ZWVrIDwgMSkge1xuICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgIH0gZWxzZSBpZiAod2VlayA+IHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KSkge1xuICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICB5ZWFyOiByZXNZZWFyXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG5hZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuLy8gUFJJT1JJVElFU1xuXG5hZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ3cnLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsndycsICd3dycsICdXJywgJ1dXJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbn0pO1xuXG4vLyBIRUxQRVJTXG5cbi8vIExPQ0FMRVNcblxuZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICBkb3cgOiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG59O1xuXG5mdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlayAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xufVxuXG5mdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xufVxuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbmFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbn0pO1xuXG5hZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbmFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXknLCAxMSk7XG5hZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG5hZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ0UnLCAgICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbn0pO1xuYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgIH1cbn0pO1xuXG5hZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgfVxuXG4gICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgfVxuICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG59XG5cbi8vIExPQ0FMRVNcblxudmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoJ18nKTtcbmZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtLCBmb3JtYXQpIHtcbiAgICBpZiAoIW0pIHtcbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXMgOlxuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNbJ3N0YW5kYWxvbmUnXTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fd2Vla2RheXMpID8gdGhpcy5fd2Vla2RheXNbbS5kYXkoKV0gOlxuICAgICAgICB0aGlzLl93ZWVrZGF5c1t0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5kYXkoKV07XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0IChtKSB7XG4gICAgcmV0dXJuIChtKSA/IHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xufVxuXG52YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluID0gJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpO1xuZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4gKG0pIHtcbiAgICByZXR1cm4gKG0pID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV0gOiB0aGlzLl93ZWVrZGF5c01pbjtcbn1cblxuZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlpID0gaW5kZXhPZiQxLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpaSA9IGluZGV4T2YkMS5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWkgPSBpbmRleE9mJDEuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlICh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlJDEuY2FsbCh0aGlzLCB3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlID0gW107XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcblxuICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZGRkJyAmJiB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZCcgJiYgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGQnICYmIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIE1PTUVOVFNcblxuZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgIH1cbiAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRheTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayAoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICB9XG4gICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG59XG5cbmZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayAoaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICB9XG5cbiAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgLy8gYXMgYSBnZXR0ZXIsIHJldHVybnMgNyBpbnN0ZWFkIG9mIDAgKDEtNyByYW5nZSBpbnN0ZWFkIG9mIDAtNilcbiAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgd2Vla2RheSA9IHBhcnNlSXNvV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRheSgpIHx8IDc7XG4gICAgfVxufVxuXG52YXIgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiB3ZWVrZGF5c1JlZ2V4IChpc1N0cmljdCkge1xuICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgIH1cbn1cblxudmFyIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQ7XG5mdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgIH1cbn1cblxudmFyIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuZnVuY3Rpb24gd2Vla2RheXNNaW5SZWdleCAoaXNTdHJpY3QpIHtcbiAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UgKCkge1xuICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgIH1cblxuICAgIHZhciBtaW5QaWVjZXMgPSBbXSwgc2hvcnRQaWVjZXMgPSBbXSwgbG9uZ1BpZWNlcyA9IFtdLCBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICBpLCBtb20sIG1pbnAsIHNob3J0cCwgbG9uZ3A7XG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICBtaW5wID0gdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgc2hvcnRwID0gdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpO1xuICAgICAgICBsb25ncCA9IHRoaXMud2Vla2RheXMobW9tLCAnJyk7XG4gICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgIG1peGVkUGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgfVxuICAgIC8vIFNvcnRpbmcgbWFrZXMgc3VyZSBpZiBvbmUgd2Vla2RheSAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xufVxuXG5mdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgIHJldHVybiB0aGlzLmhvdXJzKCkgfHwgMjQ7XG59XG5cbmFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuYWRkRm9ybWF0VG9rZW4oJ2gnLCBbJ2hoJywgMl0sIDAsIGhGb3JtYXQpO1xuYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG5hZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIGhGb3JtYXQuYXBwbHkodGhpcykgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMik7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbn0pO1xuXG5mdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBsb3dlcmNhc2UpO1xuICAgIH0pO1xufVxuXG5tZXJpZGllbSgnYScsIHRydWUpO1xubWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbi8vIEFMSUFTRVNcblxuYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuLy8gUFJJT1JJVFlcbmFkZFVuaXRQcmlvcml0eSgnaG91cicsIDEzKTtcblxuLy8gUEFSU0lOR1xuXG5mdW5jdGlvbiBtYXRjaE1lcmlkaWVtIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbn1cblxuYWRkUmVnZXhUb2tlbignYScsICBtYXRjaE1lcmlkaWVtKTtcbmFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG5hZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdoJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdrJywgIG1hdGNoMXRvMik7XG5hZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUmVnZXhUb2tlbigna2snLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbmFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG5hZGRSZWdleFRva2VuKCdobW1zcycsIG1hdGNoNXRvNik7XG5hZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG5hZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcbmFkZFBhcnNlVG9rZW4oWydrJywgJ2trJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgYXJyYXlbSE9VUl0gPSBrSW5wdXQgPT09IDI0ID8gMCA6IGtJbnB1dDtcbn0pO1xuYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG59KTtcbmFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xufSk7XG5hZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xufSk7XG5hZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xufSk7XG5hZGRQYXJzZVRva2VuKCdIbW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xufSk7XG5hZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNDtcbiAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xufSk7XG5cbi8vIExPQ0FMRVNcblxuZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG59XG5cbnZhciBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSA9IC9bYXBdXFwuP20/XFwuPy9pO1xuZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgIH1cbn1cblxuXG4vLyBNT01FTlRTXG5cbi8vIFNldHRpbmcgdGhlIGhvdXIgc2hvdWxkIGtlZXAgdGhlIHRpbWUsIGJlY2F1c2UgdGhlIHVzZXIgZXhwbGljaXRseVxuLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgaGUgd2FudHMuIFNvIHRyeWluZyB0byBtYWludGFpbiB0aGUgc2FtZSBob3VyIChpblxuLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4vLyB0aGlzIHJ1bGUuXG52YXIgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbi8vIG1vbnRoc1xuLy8gd2Vla1xuLy8gd2Vla2RheXNcbi8vIG1lcmlkaWVtXG52YXIgYmFzZUNvbmZpZyA9IHtcbiAgICBjYWxlbmRhcjogZGVmYXVsdENhbGVuZGFyLFxuICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICBvcmRpbmFsOiBkZWZhdWx0T3JkaW5hbCxcbiAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICBtb250aHM6IGRlZmF1bHRMb2NhbGVNb250aHMsXG4gICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgd2Vla2RheXM6IGRlZmF1bHRMb2NhbGVXZWVrZGF5cyxcbiAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgbWVyaWRpZW1QYXJzZTogZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2Vcbn07XG5cbi8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcbnZhciBsb2NhbGVzID0ge307XG52YXIgbG9jYWxlRmFtaWxpZXMgPSB7fTtcbnZhciBnbG9iYWxMb2NhbGU7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsZShrZXkpIHtcbiAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG59XG5cbi8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxuLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbi8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbmZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xuICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubGVuZ3RoID49IGogJiYgY29tcGFyZUFycmF5cyhzcGxpdCwgbmV4dCwgdHJ1ZSkgPj0gaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqLS07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICBpZiAoIWxvY2FsZXNbbmFtZV0gJiYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICByZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGRlZmluZUxvY2FsZSBjdXJyZW50bHkgYWxzbyBzZXRzIHRoZSBnbG9iYWwgbG9jYWxlLCB3ZVxuICAgICAgICAgICAgLy8gd2FudCB0byB1bmRvIHRoYXQgZm9yIGxhenkgbG9hZGVkIGxvY2FsZXNcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbi8vIGxvY2FsZSBrZXkuXG5mdW5jdGlvbiBnZXRTZXRHbG9iYWxMb2NhbGUgKGtleSwgdmFsdWVzKSB7XG4gICAgdmFyIGRhdGE7XG4gICAgaWYgKGtleSkge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWVzKSkge1xuICAgICAgICAgICAgZGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbn1cblxuZnVuY3Rpb24gZGVmaW5lTG9jYWxlIChuYW1lLCBjb25maWcpIHtcbiAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZSgnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICdhbiBleGlzdGluZyBsb2NhbGUuIG1vbWVudC5kZWZpbmVMb2NhbGUobG9jYWxlTmFtZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbbmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIGRlZmluZUxvY2FsZSh4Lm5hbWUsIHguY29uZmlnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgLy8gY3JlYXRlZCwgc28gd2Ugd29uJ3QgZW5kIHVwIHdpdGggdGhlIGNoaWxkIGxvY2FsZSBzZXQuXG4gICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuXG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBsb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgIC8vIE1FUkdFXG4gICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgfVxuICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICBsb2NhbGUgPSBuZXcgTG9jYWxlKGNvbmZpZyk7XG4gICAgICAgIGxvY2FsZS5wYXJlbnRMb2NhbGUgPSBsb2NhbGVzW25hbWVdO1xuICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuXG4gICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcGFzcyBudWxsIGZvciBjb25maWcgdG8gdW51cGRhdGUsIHVzZWZ1bCBmb3IgdGVzdHNcbiAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xufVxuXG4vLyByZXR1cm5zIGxvY2FsZSBkYXRhXG5mdW5jdGlvbiBnZXRMb2NhbGUgKGtleSkge1xuICAgIHZhciBsb2NhbGU7XG5cbiAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgIH1cblxuICAgIGlmICgha2V5KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xufVxuXG5mdW5jdGlvbiBsaXN0TG9jYWxlcygpIHtcbiAgICByZXR1cm4ga2V5cyQxKGxvY2FsZXMpO1xufVxuXG5mdW5jdGlvbiBjaGVja092ZXJmbG93IChtKSB7XG4gICAgdmFyIG92ZXJmbG93O1xuICAgIHZhciBhID0gbS5fYTtcblxuICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgYVtNT05USF0gICAgICAgPCAwIHx8IGFbTU9OVEhdICAgICAgID4gMTEgID8gTU9OVEggOlxuICAgICAgICAgICAgYVtEQVRFXSAgICAgICAgPCAxIHx8IGFbREFURV0gICAgICAgID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgYVtNSU5VVEVdICAgICAgPCAwIHx8IGFbTUlOVVRFXSAgICAgID4gNTkgID8gTUlOVVRFIDpcbiAgICAgICAgICAgIGFbU0VDT05EXSAgICAgIDwgMCB8fCBhW1NFQ09ORF0gICAgICA+IDU5ICA/IFNFQ09ORCA6XG4gICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAtMTtcblxuICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFS0RBWTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBpc28gODYwMSByZWdleFxuLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG52YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcbnZhciBiYXNpY0lzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZCkpKD86KFR8ICkoXFxkXFxkKD86XFxkXFxkKD86XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLztcblxudmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbnZhciBpc29EYXRlcyA9IFtcbiAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAvLyBZWVlZTU0gaXMgTk9UIGFsbG93ZWQgYnkgdGhlIHN0YW5kYXJkXG4gICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgIFsnWVlZWURERCcsIC9cXGR7N30vXVxuXTtcblxuLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xudmFyIGlzb1RpbWVzID0gW1xuICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgIFsnSEgnLCAvXFxkXFxkL11cbl07XG5cbnZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4vLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICB2YXIgaSwgbCxcbiAgICAgICAgc3RyaW5nID0gY29uZmlnLl9pLFxuICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMobWF0Y2hbMV0pKSB7XG4gICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvVGltZXNbaV1bMV0uZXhlYyhtYXRjaFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpbWVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaFs0XSkge1xuICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG52YXIgYmFzaWNSZmNSZWdleCA9IC9eKCg/Ok1vbnxUdWV8V2VkfFRodXxGcml8U2F0fFN1biksP1xccyk/KFxcZD9cXGRcXHMoPzpKYW58RmVifE1hcnxBcHJ8TWF5fEp1bnxKdWx8QXVnfFNlcHxPY3R8Tm92fERlYylcXHMoPzpcXGRcXGQpP1xcZFxcZFxccykoXFxkXFxkOlxcZFxcZCkoXFw6XFxkXFxkKT8oXFxzKD86VVR8R01UfFtFQ01QXVtTRF1UfFtBLUlLLVphLWlrLXpdfFsrLV1cXGR7NH0pKSQvO1xuXG4vLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG5mdW5jdGlvbiBjb25maWdGcm9tUkZDMjgyMihjb25maWcpIHtcbiAgICB2YXIgc3RyaW5nLCBtYXRjaCwgZGF5Rm9ybWF0LFxuICAgICAgICBkYXRlRm9ybWF0LCB0aW1lRm9ybWF0LCB0ekZvcm1hdDtcbiAgICB2YXIgdGltZXpvbmVzID0ge1xuICAgICAgICAnIEdNVCc6ICcgKzAwMDAnLFxuICAgICAgICAnIEVEVCc6ICcgLTA0MDAnLFxuICAgICAgICAnIEVTVCc6ICcgLTA1MDAnLFxuICAgICAgICAnIENEVCc6ICcgLTA1MDAnLFxuICAgICAgICAnIENTVCc6ICcgLTA2MDAnLFxuICAgICAgICAnIE1EVCc6ICcgLTA2MDAnLFxuICAgICAgICAnIE1TVCc6ICcgLTA3MDAnLFxuICAgICAgICAnIFBEVCc6ICcgLTA3MDAnLFxuICAgICAgICAnIFBTVCc6ICcgLTA4MDAnXG4gICAgfTtcbiAgICB2YXIgbWlsaXRhcnkgPSAnWVhXVlVUU1JRUE9OWkFCQ0RFRkdISUtMTSc7XG4gICAgdmFyIHRpbWV6b25lLCB0aW1lem9uZUluZGV4O1xuXG4gICAgc3RyaW5nID0gY29uZmlnLl9pXG4gICAgICAgIC5yZXBsYWNlKC9cXChbXlxcKV0qXFwpfFtcXG5cXHRdL2csICcgJykgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpIC8vIFJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgLnJlcGxhY2UoL15cXHN8XFxzJC9nLCAnJyk7IC8vIFJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXNcbiAgICBtYXRjaCA9IGJhc2ljUmZjUmVnZXguZXhlYyhzdHJpbmcpO1xuXG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGRheUZvcm1hdCA9IG1hdGNoWzFdID8gJ2RkZCcgKyAoKG1hdGNoWzFdLmxlbmd0aCA9PT0gNSkgPyAnLCAnIDogJyAnKSA6ICcnO1xuICAgICAgICBkYXRlRm9ybWF0ID0gJ0QgTU1NICcgKyAoKG1hdGNoWzJdLmxlbmd0aCA+IDEwKSA/ICdZWVlZICcgOiAnWVkgJyk7XG4gICAgICAgIHRpbWVGb3JtYXQgPSAnSEg6bW0nICsgKG1hdGNoWzRdID8gJzpzcycgOiAnJyk7XG5cbiAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW50ZW50IGRheS1vZi13ZWVrIGNoZWNrLlxuICAgICAgICBpZiAobWF0Y2hbMV0pIHsgLy8gZGF5IG9mIHdlZWsgZ2l2ZW5cbiAgICAgICAgICAgIHZhciBtb21lbnREYXRlID0gbmV3IERhdGUobWF0Y2hbMl0pO1xuICAgICAgICAgICAgdmFyIG1vbWVudERheSA9IFsnU3VuJywnTW9uJywnVHVlJywnV2VkJywnVGh1JywnRnJpJywnU2F0J11bbW9tZW50RGF0ZS5nZXREYXkoKV07XG5cbiAgICAgICAgICAgIGlmIChtYXRjaFsxXS5zdWJzdHIoMCwzKSAhPT0gbW9tZW50RGF5KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKG1hdGNoWzVdLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAyOiAvLyBtaWxpdGFyeVxuICAgICAgICAgICAgICAgIGlmICh0aW1lem9uZUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWV6b25lID0gJyArMDAwMCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXpvbmVJbmRleCA9IG1pbGl0YXJ5LmluZGV4T2YobWF0Y2hbNV1bMV0udG9VcHBlckNhc2UoKSkgLSAxMjtcbiAgICAgICAgICAgICAgICAgICAgdGltZXpvbmUgPSAoKHRpbWV6b25lSW5kZXggPCAwKSA/ICcgLScgOiAnICsnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoKCcnICsgdGltZXpvbmVJbmRleCkucmVwbGFjZSgvXi0/LywgJzAnKSkubWF0Y2goLy4uJC8pWzBdICsgJzAwJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6IC8vIFpvbmVcbiAgICAgICAgICAgICAgICB0aW1lem9uZSA9IHRpbWV6b25lc1ttYXRjaFs1XV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiAvLyBVVCBvciArLy05OTk5XG4gICAgICAgICAgICAgICAgdGltZXpvbmUgPSB0aW1lem9uZXNbJyBHTVQnXTtcbiAgICAgICAgfVxuICAgICAgICBtYXRjaFs1XSA9IHRpbWV6b25lO1xuICAgICAgICBjb25maWcuX2kgPSBtYXRjaC5zcGxpY2UoMSkuam9pbignJyk7XG4gICAgICAgIHR6Rm9ybWF0ID0gJyBaWic7XG4gICAgICAgIGNvbmZpZy5fZiA9IGRheUZvcm1hdCArIGRhdGVGb3JtYXQgKyB0aW1lRm9ybWF0ICsgdHpGb3JtYXQ7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucmZjMjgyMiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBkYXRlIGZyb20gaXNvIGZvcm1hdCBvciBmYWxsYmFja1xuZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xufVxuXG5ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAndmFsdWUgcHJvdmlkZWQgaXMgbm90IGluIGEgcmVjb2duaXplZCBSRkMyODIyIG9yIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xuICAgICd3aGljaCBpcyBub3QgcmVsaWFibGUgYWNyb3NzIGFsbCBicm93c2VycyBhbmQgdmVyc2lvbnMuIE5vbiBSRkMyODIyL0lTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xuICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIG1ham9yIHJlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAnaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgIH1cbik7XG5cbi8vIFBpY2sgdGhlIGZpcnN0IGRlZmluZWQgb2YgdHdvIG9yIHRocmVlIGFyZ3VtZW50cy5cbmZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICByZXR1cm4gYztcbn1cblxuZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgIHZhciBub3dWYWx1ZSA9IG5ldyBEYXRlKGhvb2tzLm5vdygpKTtcbiAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRVVENNb250aCgpLCBub3dWYWx1ZS5nZXRVVENEYXRlKCldO1xuICAgIH1cbiAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG59XG5cbi8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbi8vIG5vdGU6IGFsbCB2YWx1ZXMgcGFzdCB0aGUgeWVhciBhcmUgb3B0aW9uYWwgYW5kIHdpbGwgZGVmYXVsdCB0byB0aGUgbG93ZXN0IHBvc3NpYmxlIHZhbHVlLlxuLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG5mdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgIHZhciBpLCBkYXRlLCBpbnB1dCA9IFtdLCBjdXJyZW50RGF0ZSwgeWVhclRvVXNlO1xuXG4gICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgfVxuXG4gICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8IGNvbmZpZy5fZGF5T2ZZZWFyID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgIGNvbmZpZy5fYVtEQVRFXSA9IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcbiAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXG4gICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgIH1cblxuICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgIGNvbmZpZy5fYVtpXSA9IGlucHV0W2ldID0gKGNvbmZpZy5fYVtpXSA9PSBudWxsKSA/IChpID09PSAyID8gMSA6IDApIDogY29uZmlnLl9hW2ldO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICBpZiAoY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwKSB7XG4gICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgfVxuXG4gICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcbiAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAvLyB3aXRoIHBhcnNlWm9uZS5cbiAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93O1xuXG4gICAgdyA9IGNvbmZpZy5fdztcbiAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgIGRvdyA9IDE7XG4gICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5HRywgY29uZmlnLl9hW1lFQVJdLCB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXIpO1xuICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgIGlmICh3ZWVrZGF5IDwgMSB8fCB3ZWVrZGF5ID4gNykge1xuICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgIHZhciBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIGN1cldlZWsueWVhcik7XG5cbiAgICAgICAgLy8gRGVmYXVsdCB0byBjdXJyZW50IHdlZWsuXG4gICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcbiAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICBpZiAody5lIDwgMCB8fCB3LmUgPiA2KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAod2VlayA8IDEgfHwgd2VlayA+IHdlZWtzSW5ZZWFyKHdlZWtZZWFyLCBkb3csIGRveSkpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla2RheSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgfVxufVxuXG4vLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG5ob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4vLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgUkZDIDI4MjIgZm9ybVxuaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpIHtcbiAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLklTT184NjAxKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5SRkNfMjgyMikge1xuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDA7XG5cbiAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbicsIHRva2VuLCAncGFyc2VkSW5wdXQnLCBwYXJzZWRJbnB1dCxcbiAgICAgICAgLy8gICAgICAgICAncmVnZXgnLCBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpO1xuICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmNoYXJzTGVmdE92ZXIgPSBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgfVxuXG4gICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICBpZiAoY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPT09IHRydWUgJiZcbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5tZXJpZGllbSA9IGNvbmZpZy5fbWVyaWRpZW07XG4gICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xufVxuXG5cbmZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgIHZhciBpc1BtO1xuXG4gICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG4gICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XG4gICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XG4gICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBob3VyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxuICAgICAgICByZXR1cm4gaG91cjtcbiAgICB9XG59XG5cbi8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG5mdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgIGksXG4gICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAvL29yIHRva2Vuc1xuICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgIHNjb3JlVG9CZWF0ID0gY3VycmVudFNjb3JlO1xuICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xufVxuXG5mdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICBjb25maWcuX2EgPSBtYXAoW2kueWVhciwgaS5tb250aCwgaS5kYXkgfHwgaS5kYXRlLCBpLmhvdXIsIGkubWludXRlLCBpLnNlY29uZCwgaS5taWxsaXNlY29uZF0sIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiBwYXJzZUludChvYmosIDEwKTtcbiAgICB9KTtcblxuICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICB2YXIgcmVzID0gbmV3IE1vbWVudChjaGVja092ZXJmbG93KHByZXBhcmVDb25maWcoY29uZmlnKSkpO1xuICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgIHJlcy5hZGQoMSwgJ2QnKTtcbiAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mO1xuXG4gICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCh7bnVsbElucHV0OiB0cnVlfSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgfVxuXG4gICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICB9ICBlbHNlIHtcbiAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlnO1xufVxuXG5mdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgIGlmIChpc1VuZGVmaW5lZChpbnB1dCkpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dC52YWx1ZU9mKCkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGlucHV0KSkge1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgIHZhciBjID0ge307XG5cbiAgICBpZiAobG9jYWxlID09PSB0cnVlIHx8IGxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKSkge1xuICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgIGMuX3VzZVVUQyA9IGMuX2lzVVRDID0gaXNVVEM7XG4gICAgYy5fbCA9IGxvY2FsZTtcbiAgICBjLl9pID0gaW5wdXQ7XG4gICAgYy5fZiA9IGZvcm1hdDtcbiAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9jYWwgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbn1cblxudmFyIHByb3RvdHlwZU1pbiA9IGRlcHJlY2F0ZShcbiAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG52YXIgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5taW4gaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9taW4tbWF4LycsXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoKTtcbiAgICAgICAgfVxuICAgIH1cbik7XG5cbi8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4vLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4vL1xuLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbmZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xuICAgIHZhciByZXMsIGk7XG4gICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XG4gICAgfVxuICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKCk7XG4gICAgfVxuICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgZm9yIChpID0gMTsgaSA8IG1vbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG5mdW5jdGlvbiBtaW4gKCkge1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbn1cblxuZnVuY3Rpb24gbWF4ICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbn1cblxudmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3cgPyBEYXRlLm5vdygpIDogKyhuZXcgRGF0ZSgpKTtcbn07XG5cbnZhciBvcmRlcmluZyA9IFsneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCddO1xuXG5mdW5jdGlvbiBpc0R1cmF0aW9uVmFsaWQobSkge1xuICAgIGZvciAodmFyIGtleSBpbiBtKSB7XG4gICAgICAgIGlmICghKG9yZGVyaW5nLmluZGV4T2Yoa2V5KSAhPT0gLTEgJiYgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bml0SGFzRGVjaW1hbCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICBpZiAodW5pdEhhc0RlY2ltYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG9ubHkgYWxsb3cgbm9uLWludGVnZXJzIGZvciBzbWFsbGVzdCB1bml0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtW29yZGVyaW5nW2ldXSkgIT09IHRvSW50KG1bb3JkZXJpbmdbaV1dKSkge1xuICAgICAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkJDEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUludmFsaWQkMSgpIHtcbiAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbn1cblxuZnVuY3Rpb24gRHVyYXRpb24gKGR1cmF0aW9uKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IDAsXG4gICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXG4gICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgIC8vIGRheSB3aGVuIHdvcmtpbmcgYXJvdW5kIERTVCwgd2UgbmVlZCB0byBzdG9yZSB0aGVtIHNlcGFyYXRlbHlcbiAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICB3ZWVrcyAqIDc7XG4gICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArXG4gICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgIHllYXJzICogMTI7XG5cbiAgICB0aGlzLl9kYXRhID0ge307XG5cbiAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgIHRoaXMuX2J1YmJsZSgpO1xufVxuXG5mdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG59XG5cbmZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcbiAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChudW1iZXIpO1xuICAgIH1cbn1cblxuLy8gRk9STUFUVElOR1xuXG5mdW5jdGlvbiBvZmZzZXQgKHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy51dGNPZmZzZXQoKTtcbiAgICAgICAgdmFyIHNpZ24gPSAnKyc7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAtb2Zmc2V0O1xuICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lnbiArIHplcm9GaWxsKH5+KG9mZnNldCAvIDYwKSwgMikgKyBzZXBhcmF0b3IgKyB6ZXJvRmlsbCh+fihvZmZzZXQpICUgNjAsIDIpO1xuICAgIH0pO1xufVxuXG5vZmZzZXQoJ1onLCAnOicpO1xub2Zmc2V0KCdaWicsICcnKTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdaJywgIG1hdGNoU2hvcnRPZmZzZXQpO1xuYWRkUmVnZXhUb2tlbignWlonLCBtYXRjaFNob3J0T2Zmc2V0KTtcbmFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuLy8gdGltZXpvbmUgY2h1bmtlclxuLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4vLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbnZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpO1xuXG4gICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGNodW5rICAgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgIHZhciBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgIHJldHVybiBtaW51dGVzID09PSAwID9cbiAgICAgIDAgOlxuICAgICAgcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbn1cblxuLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbmZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICB2YXIgcmVzLCBkaWZmO1xuICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgZGlmZiA9IChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/IGlucHV0LnZhbHVlT2YoKSA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICByZXMuX2Quc2V0VGltZShyZXMuX2QudmFsdWVPZigpICsgZGlmZik7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXREYXRlT2Zmc2V0IChtKSB7XG4gICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICByZXR1cm4gLU1hdGgucm91bmQobS5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XG59XG5cbi8vIEhPT0tTXG5cbi8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbi8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbi8vIE1PTUVOVFNcblxuLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4vLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuLy9cbi8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4vLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4vLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2Vcbi8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG5mdW5jdGlvbiBnZXRTZXRPZmZzZXQgKGlucHV0LCBrZWVwTG9jYWxUaW1lLCBrZWVwTWludXRlcykge1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgfVxuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYgJiYgIWtlZXBNaW51dGVzKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc1VUQyAmJiBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKGxvY2FsQWRqdXN0LCAnbScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoIWtlZXBMb2NhbFRpbWUgfHwgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGNyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRTZXRab25lIChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IC1pbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbn1cblxuZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCAoKSB7XG4gICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQodFpvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0IChpbnB1dCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpbnB1dCA9IGlucHV0ID8gY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xufVxuXG5mdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSAoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICB0aGlzLnV0Y09mZnNldCgpID4gdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnV0Y09mZnNldCgpXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkICgpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHt9O1xuXG4gICAgY29weUNvbmZpZyhjLCB0aGlzKTtcbiAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgIGlmIChjLl9hKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lzRFNUU2hpZnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5faXNVVEMgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xufVxuXG4vLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbnZhciBhc3BOZXRSZWdleCA9IC9eKFxcLSk/KD86KFxcZCopWy4gXSk/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspKFxcLlxcZCopPyk/JC87XG5cbi8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4vLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4vLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XG52YXIgaXNvUmVnZXggPSAvXigtKT9QKD86KC0/WzAtOSwuXSopWSk/KD86KC0/WzAtOSwuXSopTSk/KD86KC0/WzAtOSwuXSopVyk/KD86KC0/WzAtOSwuXSopRCk/KD86VCg/OigtP1swLTksLl0qKUgpPyg/OigtP1swLTksLl0qKU0pPyg/OigtP1swLTksLl0qKVMpPyk/JC87XG5cbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uIChpbnB1dCwga2V5KSB7XG4gICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgcmV0LFxuICAgICAgICBkaWZmUmVzO1xuXG4gICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgbXMgOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgIE0gIDogaW5wdXQuX21vbnRoc1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHkgIDogMCxcbiAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIG0gIDogdG9JbnQobWF0Y2hbTUlOVVRFXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgIG1zIDogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICB3IDogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgZCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgcyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkgey8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xuICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKSk7XG5cbiAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgIH1cblxuICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5jcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xuXG5mdW5jdGlvbiBwYXJzZUlzbyAoaW5wLCBzaWduKSB7XG4gICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbn1cblxuZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgIHZhciByZXMgPSB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuXG4gICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgfVxuXG4gICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuICAgIH1cblxuICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbmZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJyk7XG4gICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICBkdXIgPSBjcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICB9XG4gICAgaWYgKGRheXMpIHtcbiAgICAgICAgc2V0JDEobW9tLCAnRGF0ZScsIGdldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgIH1cbiAgICBpZiAobW9udGhzKSB7XG4gICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgfVxuICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgIH1cbn1cblxudmFyIGFkZCAgICAgID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpO1xudmFyIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG5mdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgdmFyIGRpZmYgPSBteU1vbWVudC5kaWZmKG5vdywgJ2RheXMnLCB0cnVlKTtcbiAgICByZXR1cm4gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XG4gICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcbiAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcbiAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcbiAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG59XG5cbmZ1bmN0aW9uIGNhbGVuZGFyJDEgKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICBmb3JtYXQgPSBob29rcy5jYWxlbmRhckZvcm1hdCh0aGlzLCBzb2QpIHx8ICdzYW1lRWxzZSc7XG5cbiAgICB2YXIgb3V0cHV0ID0gZm9ybWF0cyAmJiAoaXNGdW5jdGlvbihmb3JtYXRzW2Zvcm1hdF0pID8gZm9ybWF0c1tmb3JtYXRdLmNhbGwodGhpcywgbm93KSA6IGZvcm1hdHNbZm9ybWF0XSk7XG5cbiAgICByZXR1cm4gdGhpcy5mb3JtYXQob3V0cHV0IHx8IHRoaXMubG9jYWxlRGF0YSgpLmNhbGVuZGFyKGZvcm1hdCwgdGhpcywgY3JlYXRlTG9jYWwobm93KSkpO1xufVxuXG5mdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBNb21lbnQodGhpcyk7XG59XG5cbmZ1bmN0aW9uIGlzQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyghaXNVbmRlZmluZWQodW5pdHMpID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcbiAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzQmVmb3JlIChpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHMoIWlzVW5kZWZpbmVkKHVuaXRzKSA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNCZXR3ZWVuIChmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgIHJldHVybiAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJyA/IHRoaXMuaXNBZnRlcihmcm9tLCB1bml0cykgOiAhdGhpcy5pc0JlZm9yZShmcm9tLCB1bml0cykpICYmXG4gICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknID8gdGhpcy5pc0JlZm9yZSh0bywgdW5pdHMpIDogIXRoaXMuaXNBZnRlcih0bywgdW5pdHMpKTtcbn1cblxuZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICBpbnB1dE1zO1xuICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMgfHwgJ21pbGxpc2Vjb25kJyk7XG4gICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA9PT0gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1NhbWVPckFmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsdW5pdHMpO1xufVxuXG5mdW5jdGlvbiBpc1NhbWVPckJlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0JlZm9yZShpbnB1dCx1bml0cyk7XG59XG5cbmZ1bmN0aW9uIGRpZmYgKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgIHZhciB0aGF0LFxuICAgICAgICB6b25lRGVsdGEsXG4gICAgICAgIGRlbHRhLCBvdXRwdXQ7XG5cbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgdGhhdCA9IGNsb25lV2l0aE9mZnNldChpbnB1dCwgdGhpcyk7XG5cbiAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBOYU47XG4gICAgfVxuXG4gICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgaWYgKHVuaXRzID09PSAneWVhcicgfHwgdW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3F1YXJ0ZXInKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAzO1xuICAgICAgICB9IGVsc2UgaWYgKHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IG91dHB1dCAvIDEyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGVsdGEgPSB0aGlzIC0gdGhhdDtcbiAgICAgICAgb3V0cHV0ID0gdW5pdHMgPT09ICdzZWNvbmQnID8gZGVsdGEgLyAxZTMgOiAvLyAxMDAwXG4gICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkZWx0YSAvIDZlNCA6IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgdW5pdHMgPT09ICdob3VyJyA/IGRlbHRhIC8gMzZlNSA6IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICB1bml0cyA9PT0gJ2RheScgPyAoZGVsdGEgLSB6b25lRGVsdGEpIC8gODY0ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICB1bml0cyA9PT0gJ3dlZWsnID8gKGRlbHRhIC0gem9uZURlbHRhKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBkZWx0YTtcbiAgICB9XG4gICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9ICgoYi55ZWFyKCkgLSBhLnllYXIoKSkgKiAxMikgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICBhbmNob3IyLCBhZGp1c3Q7XG5cbiAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgIC8vIGxpbmVhciBhY3Jvc3MgdGhlIG1vbnRoXG4gICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhbmNob3IyID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiArIDEsICdtb250aHMnKTtcbiAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgIH1cblxuICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbn1cblxuaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG5ob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG5mdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5sb2NhbGUoJ2VuJykuZm9ybWF0KCdkZGQgTU1NIEREIFlZWVkgSEg6bW06c3MgW0dNVF1aWicpO1xufVxuXG5mdW5jdGlvbiB0b0lTT1N0cmluZygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbSA9IHRoaXMuY2xvbmUoKS51dGMoKTtcbiAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgIC8vIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiBpcyB+NTB4IGZhc3RlciwgdXNlIGl0IHdoZW4gd2UgY2FuXG4gICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICogYWxzbyBiZSBldmFsdWF0ZWQgdG8gZ2V0IGEgbmV3IG1vbWVudCB3aGljaCBpcyB0aGUgc2FtZVxuICpcbiAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gKi9cbmZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcbiAgICB9XG4gICAgdmFyIGZ1bmMgPSAnbW9tZW50JztcbiAgICB2YXIgem9uZSA9ICcnO1xuICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgZnVuYyA9IHRoaXMudXRjT2Zmc2V0KCkgPT09IDAgPyAnbW9tZW50LnV0YycgOiAnbW9tZW50LnBhcnNlWm9uZSc7XG4gICAgICAgIHpvbmUgPSAnWic7XG4gICAgfVxuICAgIHZhciBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xuICAgIHZhciB5ZWFyID0gKDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSkgPyAnWVlZWScgOiAnWVlZWVlZJztcbiAgICB2YXIgZGF0ZXRpbWUgPSAnLU1NLUREW1RdSEg6bW06c3MuU1NTJztcbiAgICB2YXIgc3VmZml4ID0gem9uZSArICdbXCIpXSc7XG5cbiAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKCkgPyBob29rcy5kZWZhdWx0Rm9ybWF0VXRjIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICB9XG4gICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHxcbiAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7dG86IHRoaXMsIGZyb206IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG59XG5cbmZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHtmcm9tOiB0aGlzLCB0bzogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgIHJldHVybiB0aGlzLnRvKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xufVxuXG4vLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4vLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXG4vLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG5mdW5jdGlvbiBsb2NhbGUgKGtleSkge1xuICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmV3TG9jYWxlRGF0YSA9IGdldExvY2FsZShrZXkpO1xuICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxudmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuXG5mdW5jdGlvbiBsb2NhbGVEYXRhICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xufVxuXG5mdW5jdGlvbiBzdGFydE9mICh1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIC8vIHRoZSBmb2xsb3dpbmcgc3dpdGNoIGludGVudGlvbmFsbHkgb21pdHMgYnJlYWsga2V5d29yZHNcbiAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXG4gICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICB0aGlzLmRhdGUoMSk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICB0aGlzLmhvdXJzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgIHRoaXMubWludXRlcygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgIHRoaXMuc2Vjb25kcygwKTtcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRzKDApO1xuICAgIH1cblxuICAgIC8vIHdlZWtzIGFyZSBhIHNwZWNpYWwgY2FzZVxuICAgIGlmICh1bml0cyA9PT0gJ3dlZWsnKSB7XG4gICAgICAgIHRoaXMud2Vla2RheSgwKTtcbiAgICB9XG4gICAgaWYgKHVuaXRzID09PSAnaXNvV2VlaycpIHtcbiAgICAgICAgdGhpcy5pc29XZWVrZGF5KDEpO1xuICAgIH1cblxuICAgIC8vIHF1YXJ0ZXJzIGFyZSBhbHNvIHNwZWNpYWxcbiAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICB0aGlzLm1vbnRoKE1hdGguZmxvb3IodGhpcy5tb250aCgpIC8gMykgKiAzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZW5kT2YgKHVuaXRzKSB7XG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gJ2RhdGUnIGlzIGFuIGFsaWFzIGZvciAnZGF5Jywgc28gaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYXMgc3VjaC5cbiAgICBpZiAodW5pdHMgPT09ICdkYXRlJykge1xuICAgICAgICB1bml0cyA9ICdkYXknO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0YXJ0T2YodW5pdHMpLmFkZCgxLCAodW5pdHMgPT09ICdpc29XZWVrJyA/ICd3ZWVrJyA6IHVuaXRzKSkuc3VidHJhY3QoMSwgJ21zJyk7XG59XG5cbmZ1bmN0aW9uIHZhbHVlT2YgKCkge1xuICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xufVxuXG5mdW5jdGlvbiB1bml4ICgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xufVxuXG5mdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG59XG5cbmZ1bmN0aW9uIHRvQXJyYXkgKCkge1xuICAgIHZhciBtID0gdGhpcztcbiAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbn1cblxuZnVuY3Rpb24gdG9PYmplY3QgKCkge1xuICAgIHZhciBtID0gdGhpcztcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKClcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB0b0pTT04gKCkge1xuICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkJDIgKCkge1xuICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBwYXJzaW5nRmxhZ3MgKCkge1xuICAgIHJldHVybiBleHRlbmQoe30sIGdldFBhcnNpbmdGbGFncyh0aGlzKSk7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbn1cblxuZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0XG4gICAgfTtcbn1cblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG59KTtcblxuZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbiAodG9rZW4sIGdldHRlcikge1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbn1cblxuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICAgICAnd2Vla1llYXInKTtcbmFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG5hZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHJywgICdpc29XZWVrWWVhcicpO1xuYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG5hZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbmFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla1llYXInLCAxKTtcblxuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ0cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ2cnLCAgICAgIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ2dnJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbmFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbmFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbmFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbmFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbmFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG59KTtcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXRXZWVrWWVhciAoaW5wdXQpIHtcbiAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbCh0aGlzLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICB0aGlzLndlZWsoKSxcbiAgICAgICAgICAgIHRoaXMud2Vla2RheSgpLFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KTtcbn1cblxuZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgcmV0dXJuIGdldFNldFdlZWtZZWFySGVscGVyLmNhbGwodGhpcyxcbiAgICAgICAgICAgIGlucHV0LCB0aGlzLmlzb1dlZWsoKSwgdGhpcy5pc29XZWVrZGF5KCksIDEsIDQpO1xufVxuXG5mdW5jdGlvbiBnZXRJU09XZWVrc0luWWVhciAoKSB7XG4gICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcbn1cblxuZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIgKCkge1xuICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xufVxuXG5mdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgIHJldHVybiB0aGlzO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4vLyBQUklPUklUWVxuXG5hZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbmFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbn0pO1xuXG4vLyBNT01FTlRTXG5cbmZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIgKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xufVxuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbi8vIFBSSU9ST0lUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignRCcsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgIHJldHVybiBpc1N0cmljdCA/XG4gICAgICAobG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIHx8IGxvY2FsZS5fb3JkaW5hbFBhcnNlKSA6XG4gICAgICBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xufSk7XG5cbmFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbREFURV0gPSB0b0ludChpbnB1dC5tYXRjaChtYXRjaDF0bzIpWzBdLCAxMCk7XG59KTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnZGF5T2ZZZWFyJywgJ0RERCcpO1xuXG4vLyBQUklPUklUWVxuYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuLy8gUEFSU0lOR1xuXG5hZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcbmFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xufSk7XG5cbi8vIEhFTFBFUlNcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgdmFyIGRheU9mWWVhciA9IE1hdGgucm91bmQoKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTUpICsgMTtcbiAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XG59XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4vLyBQQVJTSU5HXG5cbmFkZFJlZ2V4VG9rZW4oJ20nLCAgbWF0Y2gxdG8yKTtcbmFkZFJlZ2V4VG9rZW4oJ21tJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0TWludXRlID0gbWFrZUdldFNldCgnTWludXRlcycsIGZhbHNlKTtcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4vLyBBTElBU0VTXG5cbmFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuLy8gUFJJT1JJVFlcblxuYWRkVW5pdFByaW9yaXR5KCdzZWNvbmQnLCAxNSk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xuYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5hZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4vLyBNT01FTlRTXG5cbnZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4vLyBGT1JNQVRUSU5HXG5cbmFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xufSk7XG5cbmFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG59KTtcblxuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwO1xufSk7XG5hZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDtcbn0pO1xuYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDAwO1xufSk7XG5cblxuLy8gQUxJQVNFU1xuXG5hZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbi8vIFBSSU9SSVRZXG5cbmFkZFVuaXRQcmlvcml0eSgnbWlsbGlzZWNvbmQnLCAxNik7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbmFkZFJlZ2V4VG9rZW4oJ1NTJywgICBtYXRjaDF0bzMsIG1hdGNoMik7XG5hZGRSZWdleFRva2VuKCdTU1MnLCAgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG52YXIgdG9rZW47XG5mb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbn1cblxuZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xufVxuLy8gTU9NRU5UU1xuXG52YXIgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbi8vIEZPUk1BVFRJTkdcblxuYWRkRm9ybWF0VG9rZW4oJ3onLCAgMCwgMCwgJ3pvbmVBYmJyJyk7XG5hZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuLy8gTU9NRU5UU1xuXG5mdW5jdGlvbiBnZXRab25lQWJiciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0Wm9uZU5hbWUgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbn1cblxudmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxucHJvdG8uYWRkICAgICAgICAgICAgICAgPSBhZGQ7XG5wcm90by5jYWxlbmRhciAgICAgICAgICA9IGNhbGVuZGFyJDE7XG5wcm90by5jbG9uZSAgICAgICAgICAgICA9IGNsb25lO1xucHJvdG8uZGlmZiAgICAgICAgICAgICAgPSBkaWZmO1xucHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcbnByb3RvLmZvcm1hdCAgICAgICAgICAgID0gZm9ybWF0O1xucHJvdG8uZnJvbSAgICAgICAgICAgICAgPSBmcm9tO1xucHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xucHJvdG8udG8gICAgICAgICAgICAgICAgPSB0bztcbnByb3RvLnRvTm93ICAgICAgICAgICAgID0gdG9Ob3c7XG5wcm90by5nZXQgICAgICAgICAgICAgICA9IHN0cmluZ0dldDtcbnByb3RvLmludmFsaWRBdCAgICAgICAgID0gaW52YWxpZEF0O1xucHJvdG8uaXNBZnRlciAgICAgICAgICAgPSBpc0FmdGVyO1xucHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcbnByb3RvLmlzQmV0d2VlbiAgICAgICAgID0gaXNCZXR3ZWVuO1xucHJvdG8uaXNTYW1lICAgICAgICAgICAgPSBpc1NhbWU7XG5wcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XG5wcm90by5pc1NhbWVPckJlZm9yZSAgICA9IGlzU2FtZU9yQmVmb3JlO1xucHJvdG8uaXNWYWxpZCAgICAgICAgICAgPSBpc1ZhbGlkJDI7XG5wcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XG5wcm90by5sb2NhbGUgICAgICAgICAgICA9IGxvY2FsZTtcbnByb3RvLmxvY2FsZURhdGEgICAgICAgID0gbG9jYWxlRGF0YTtcbnByb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xucHJvdG8ubWluICAgICAgICAgICAgICAgPSBwcm90b3R5cGVNaW47XG5wcm90by5wYXJzaW5nRmxhZ3MgICAgICA9IHBhcnNpbmdGbGFncztcbnByb3RvLnNldCAgICAgICAgICAgICAgID0gc3RyaW5nU2V0O1xucHJvdG8uc3RhcnRPZiAgICAgICAgICAgPSBzdGFydE9mO1xucHJvdG8uc3VidHJhY3QgICAgICAgICAgPSBzdWJ0cmFjdDtcbnByb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcbnByb3RvLnRvT2JqZWN0ICAgICAgICAgID0gdG9PYmplY3Q7XG5wcm90by50b0RhdGUgICAgICAgICAgICA9IHRvRGF0ZTtcbnByb3RvLnRvSVNPU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmc7XG5wcm90by5pbnNwZWN0ICAgICAgICAgICA9IGluc3BlY3Q7XG5wcm90by50b0pTT04gICAgICAgICAgICA9IHRvSlNPTjtcbnByb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XG5wcm90by51bml4ICAgICAgICAgICAgICA9IHVuaXg7XG5wcm90by52YWx1ZU9mICAgICAgICAgICA9IHZhbHVlT2Y7XG5wcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcblxuLy8gWWVhclxucHJvdG8ueWVhciAgICAgICA9IGdldFNldFllYXI7XG5wcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcblxuLy8gV2VlayBZZWFyXG5wcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xucHJvdG8uaXNvV2Vla1llYXIgPSBnZXRTZXRJU09XZWVrWWVhcjtcblxuLy8gUXVhcnRlclxucHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcblxuLy8gTW9udGhcbnByb3RvLm1vbnRoICAgICAgID0gZ2V0U2V0TW9udGg7XG5wcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuXG4vLyBXZWVrXG5wcm90by53ZWVrICAgICAgICAgICA9IHByb3RvLndlZWtzICAgICAgICA9IGdldFNldFdlZWs7XG5wcm90by5pc29XZWVrICAgICAgICA9IHByb3RvLmlzb1dlZWtzICAgICA9IGdldFNldElTT1dlZWs7XG5wcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xucHJvdG8uaXNvV2Vla3NJblllYXIgPSBnZXRJU09XZWVrc0luWWVhcjtcblxuLy8gRGF5XG5wcm90by5kYXRlICAgICAgID0gZ2V0U2V0RGF5T2ZNb250aDtcbnByb3RvLmRheSAgICAgICAgPSBwcm90by5kYXlzICAgICAgICAgICAgID0gZ2V0U2V0RGF5T2ZXZWVrO1xucHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbnByb3RvLmlzb1dlZWtkYXkgPSBnZXRTZXRJU09EYXlPZldlZWs7XG5wcm90by5kYXlPZlllYXIgID0gZ2V0U2V0RGF5T2ZZZWFyO1xuXG4vLyBIb3VyXG5wcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuXG4vLyBNaW51dGVcbnByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG5cbi8vIFNlY29uZFxucHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcblxuLy8gTWlsbGlzZWNvbmRcbnByb3RvLm1pbGxpc2Vjb25kID0gcHJvdG8ubWlsbGlzZWNvbmRzID0gZ2V0U2V0TWlsbGlzZWNvbmQ7XG5cbi8vIE9mZnNldFxucHJvdG8udXRjT2Zmc2V0ICAgICAgICAgICAgPSBnZXRTZXRPZmZzZXQ7XG5wcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xucHJvdG8ubG9jYWwgICAgICAgICAgICAgICAgPSBzZXRPZmZzZXRUb0xvY2FsO1xucHJvdG8ucGFyc2Vab25lICAgICAgICAgICAgPSBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldDtcbnByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG5wcm90by5pc0RTVCAgICAgICAgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xucHJvdG8uaXNMb2NhbCAgICAgICAgICAgICAgPSBpc0xvY2FsO1xucHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbnByb3RvLmlzVXRjICAgICAgICAgICAgICAgID0gaXNVdGM7XG5wcm90by5pc1VUQyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuXG4vLyBUaW1lem9uZVxucHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbnByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG5cbi8vIERlcHJlY2F0aW9uc1xucHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xucHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKCdtb250aHMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbnRoIGluc3RlYWQnLCBnZXRTZXRNb250aCk7XG5wcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbnByb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLCBnZXRTZXRab25lKTtcbnByb3RvLmlzRFNUU2hpZnRlZCA9IGRlcHJlY2F0ZSgnaXNEU1RTaGlmdGVkIGlzIGRlcHJlY2F0ZWQuIFNlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RzdC1zaGlmdGVkLyBmb3IgbW9yZSBpbmZvcm1hdGlvbicsIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluWm9uZSAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XG59XG5cbmZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZztcbn1cblxudmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG5wcm90byQxLmNhbGVuZGFyICAgICAgICA9IGNhbGVuZGFyO1xucHJvdG8kMS5sb25nRGF0ZUZvcm1hdCAgPSBsb25nRGF0ZUZvcm1hdDtcbnByb3RvJDEuaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG5wcm90byQxLm9yZGluYWwgICAgICAgICA9IG9yZGluYWw7XG5wcm90byQxLnByZXBhcnNlICAgICAgICA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbnByb3RvJDEucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xucHJvdG8kMS5yZWxhdGl2ZVRpbWUgICAgPSByZWxhdGl2ZVRpbWU7XG5wcm90byQxLnBhc3RGdXR1cmUgICAgICA9IHBhc3RGdXR1cmU7XG5wcm90byQxLnNldCAgICAgICAgICAgICA9IHNldDtcblxuLy8gTW9udGhcbnByb3RvJDEubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xucHJvdG8kMS5tb250aHNTaG9ydCAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNTaG9ydDtcbnByb3RvJDEubW9udGhzUGFyc2UgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzUGFyc2U7XG5wcm90byQxLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XG5wcm90byQxLm1vbnRoc1Nob3J0UmVnZXggID0gbW9udGhzU2hvcnRSZWdleDtcblxuLy8gV2Vla1xucHJvdG8kMS53ZWVrID0gbG9jYWxlV2VlaztcbnByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbnByb3RvJDEuZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuLy8gRGF5IG9mIFdlZWtcbnByb3RvJDEud2Vla2RheXMgICAgICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXM7XG5wcm90byQxLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xucHJvdG8kMS53ZWVrZGF5c1Nob3J0ICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1Nob3J0O1xucHJvdG8kMS53ZWVrZGF5c1BhcnNlICA9ICAgICAgICBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG5wcm90byQxLndlZWtkYXlzUmVnZXggICAgICAgPSAgICAgICAgd2Vla2RheXNSZWdleDtcbnByb3RvJDEud2Vla2RheXNTaG9ydFJlZ2V4ICA9ICAgICAgICB3ZWVrZGF5c1Nob3J0UmVnZXg7XG5wcm90byQxLndlZWtkYXlzTWluUmVnZXggICAgPSAgICAgICAgd2Vla2RheXNNaW5SZWdleDtcblxuLy8gSG91cnNcbnByb3RvJDEuaXNQTSA9IGxvY2FsZUlzUE07XG5wcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbmZ1bmN0aW9uIGdldCQxIChmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpO1xuICAgIHZhciB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xufVxuXG5mdW5jdGlvbiBsaXN0TW9udGhzSW1wbCAoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufVxuXG4vLyAoKVxuLy8gKDUpXG4vLyAoZm10LCA1KVxuLy8gKGZtdClcbi8vICh0cnVlKVxuLy8gKHRydWUsIDUpXG4vLyAodHJ1ZSwgZm10LCA1KVxuLy8gKHRydWUsIGZtdClcbmZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICBpZiAodHlwZW9mIGxvY2FsZVNvcnRlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICBsb2NhbGVTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgfVxuXG4gICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxuICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIChpICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gbGlzdE1vbnRocyAoZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG59XG5cbmZ1bmN0aW9uIGxpc3RNb250aHNTaG9ydCAoZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbn1cblxuZnVuY3Rpb24gbGlzdFdlZWtkYXlzIChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xufVxuXG5mdW5jdGlvbiBsaXN0V2Vla2RheXNTaG9ydCAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xufVxuXG5mdW5jdGlvbiBsaXN0V2Vla2RheXNNaW4gKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG59XG5cbmdldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgb3JkaW5hbCA6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgdmFyIGIgPSBudW1iZXIgJSAxMCxcbiAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAoYiA9PT0gMSkgPyAnc3QnIDpcbiAgICAgICAgICAgIChiID09PSAyKSA/ICduZCcgOlxuICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgfVxufSk7XG5cbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcbmhvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgZ2V0U2V0R2xvYmFsTG9jYWxlKTtcbmhvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJywgZ2V0TG9jYWxlKTtcblxudmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuZnVuY3Rpb24gYWJzICgpIHtcbiAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xuXG4gICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgIHRoaXMuX2RheXMgICAgICAgICA9IG1hdGhBYnModGhpcy5fZGF5cyk7XG4gICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgZGF0YS5zZWNvbmRzICAgICAgID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgIGRhdGEubW9udGhzICAgICAgICA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gYWRkU3VidHJhY3QkMSAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICBkdXJhdGlvbi5fZGF5cyAgICAgICAgICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgIHJldHVybiBkdXJhdGlvbi5fYnViYmxlKCk7XG59XG5cbi8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbmZ1bmN0aW9uIGFkZCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIDEpO1xufVxuXG4vLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuZnVuY3Rpb24gc3VidHJhY3QkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG59XG5cbmZ1bmN0aW9uIGFic0NlaWwgKG51bWJlcikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuICAgIHZhciBkYXlzICAgICAgICAgPSB0aGlzLl9kYXlzO1xuICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgdmFyIGRhdGEgICAgICAgICA9IHRoaXMuX2RhdGE7XG4gICAgdmFyIHNlY29uZHMsIG1pbnV0ZXMsIGhvdXJzLCB5ZWFycywgbW9udGhzRnJvbURheXM7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgaWYgKCEoKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgIGRheXMgPSAwO1xuICAgICAgICBtb250aHMgPSAwO1xuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgc2Vjb25kcyAgICAgICAgICAgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICBkYXRhLm1pbnV0ZXMgICAgICA9IG1pbnV0ZXMgJSA2MDtcblxuICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgIG1vbnRoc0Zyb21EYXlzID0gYWJzRmxvb3IoZGF5c1RvTW9udGhzKGRheXMpKTtcbiAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgIG1vbnRocyAlPSAxMjtcblxuICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxMiBtb250aHMgPT09IDQ4MDBcbiAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG59XG5cbmZ1bmN0aW9uIG1vbnRoc1RvRGF5cyAobW9udGhzKSB7XG4gICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgcmV0dXJuIG1vbnRocyAqIDE0NjA5NyAvIDQ4MDA7XG59XG5cbmZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgdmFyIGRheXM7XG4gICAgdmFyIG1vbnRocztcbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICBkYXlzICAgPSB0aGlzLl9kYXlzICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICByZXR1cm4gdW5pdHMgPT09ICdtb250aCcgPyBtb250aHMgOiBtb250aHMgLyAxMjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnICAgOiByZXR1cm4gZGF5cyAvIDcgICAgICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInICAgOiByZXR1cm4gZGF5cyAqIDI0ICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZScgOiByZXR1cm4gZGF5cyAqIDE0NDAgICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbmZ1bmN0aW9uIHZhbHVlT2YkMSAoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICk7XG59XG5cbmZ1bmN0aW9uIG1ha2VBcyAoYWxpYXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgfTtcbn1cblxudmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xudmFyIGFzU2Vjb25kcyAgICAgID0gbWFrZUFzKCdzJyk7XG52YXIgYXNNaW51dGVzICAgICAgPSBtYWtlQXMoJ20nKTtcbnZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xudmFyIGFzRGF5cyAgICAgICAgID0gbWFrZUFzKCdkJyk7XG52YXIgYXNXZWVrcyAgICAgICAgPSBtYWtlQXMoJ3cnKTtcbnZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xudmFyIGFzWWVhcnMgICAgICAgID0gbWFrZUFzKCd5Jyk7XG5cbmZ1bmN0aW9uIGdldCQyICh1bml0cykge1xuICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG59XG5cbmZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2RhdGFbbmFtZV0gOiBOYU47XG4gICAgfTtcbn1cblxudmFyIG1pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xudmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbnZhciBtaW51dGVzICAgICAgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyk7XG52YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbnZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG52YXIgbW9udGhzICAgICAgID0gbWFrZUdldHRlcignbW9udGhzJyk7XG52YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xufVxuXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIHRocmVzaG9sZHMgPSB7XG4gICAgc3M6IDQ0LCAgICAgICAgIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xuICAgIHMgOiA0NSwgICAgICAgICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgIG0gOiA0NSwgICAgICAgICAvLyBtaW51dGVzIHRvIGhvdXJcbiAgICBoIDogMjIsICAgICAgICAgLy8gaG91cnMgdG8gZGF5XG4gICAgZCA6IDI2LCAgICAgICAgIC8vIGRheXMgdG8gbW9udGhcbiAgICBNIDogMTEgICAgICAgICAgLy8gbW9udGhzIHRvIHllYXJcbn07XG5cbi8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG5mdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xufVxuXG5mdW5jdGlvbiByZWxhdGl2ZVRpbWUkMSAocG9zTmVnRHVyYXRpb24sIHdpdGhvdXRTdWZmaXgsIGxvY2FsZSkge1xuICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKTtcbiAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICB2YXIgaG91cnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKTtcbiAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICB2YXIgeWVhcnMgICAgPSByb3VuZChkdXJhdGlvbi5hcygneScpKTtcblxuICAgIHZhciBhID0gc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgc2Vjb25kcyA8IHRocmVzaG9sZHMucyAgICYmIFsnc3MnLCBzZWNvbmRzXSB8fFxuICAgICAgICAgICAgbWludXRlcyA8PSAxICAgICAgICAgICAgICYmIFsnbSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAgICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgaG91cnMgICA8PSAxICAgICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgaG91cnMgICA8IHRocmVzaG9sZHMuaCAgICYmIFsnaGgnLCBob3Vyc10gICB8fFxuICAgICAgICAgICAgZGF5cyAgICA8PSAxICAgICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgZGF5cyAgICA8IHRocmVzaG9sZHMuZCAgICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgbW9udGhzICA8PSAxICAgICAgICAgICAgICYmIFsnTSddICAgICAgICAgICB8fFxuICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAgICYmIFsnTU0nLCBtb250aHNdICB8fFxuICAgICAgICAgICAgeWVhcnMgICA8PSAxICAgICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgYVs0XSA9IGxvY2FsZTtcbiAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbmZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIChyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcm91bmQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Yocm91bmRpbmdGdW5jdGlvbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbmZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCAodGhyZXNob2xkLCBsaW1pdCkge1xuICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgfVxuICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgIGlmICh0aHJlc2hvbGQgPT09ICdzJykge1xuICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaHVtYW5pemUgKHdpdGhTdWZmaXgpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgIH1cblxuICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICB2YXIgb3V0cHV0ID0gcmVsYXRpdmVUaW1lJDEodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbn1cblxudmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbmZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XG4gICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAvLyAgKiBtaWxsaXNlY29uZHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIGhvdXJzXG4gICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlcmUgaXMgbm8gY29udGV4dC1mcmVlIGNvbnZlcnNpb24gYmV0d2VlbiBob3VycyBhbmQgZGF5c1xuICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgc2Vjb25kcyA9IGFicyQxKHRoaXMuX21pbGxpc2Vjb25kcykgLyAxMDAwO1xuICAgIHZhciBkYXlzICAgICAgICAgPSBhYnMkMSh0aGlzLl9kYXlzKTtcbiAgICB2YXIgbW9udGhzICAgICAgID0gYWJzJDEodGhpcy5fbW9udGhzKTtcbiAgICB2YXIgbWludXRlcywgaG91cnMsIHllYXJzO1xuXG4gICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgbWludXRlcyAgICAgICAgICAgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICBzZWNvbmRzICU9IDYwO1xuICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgIG1vbnRocyAlPSAxMjtcblxuXG4gICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcbiAgICB2YXIgWSA9IHllYXJzO1xuICAgIHZhciBNID0gbW9udGhzO1xuICAgIHZhciBEID0gZGF5cztcbiAgICB2YXIgaCA9IGhvdXJzO1xuICAgIHZhciBtID0gbWludXRlcztcbiAgICB2YXIgcyA9IHNlY29uZHM7XG4gICAgdmFyIHRvdGFsID0gdGhpcy5hc1NlY29uZHMoKTtcblxuICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAvLyBidXQgbm90IG90aGVyIEpTIChnb29nLmRhdGUpXG4gICAgICAgIHJldHVybiAnUDBEJztcbiAgICB9XG5cbiAgICByZXR1cm4gKHRvdGFsIDwgMCA/ICctJyA6ICcnKSArXG4gICAgICAgICdQJyArXG4gICAgICAgIChZID8gWSArICdZJyA6ICcnKSArXG4gICAgICAgIChNID8gTSArICdNJyA6ICcnKSArXG4gICAgICAgIChEID8gRCArICdEJyA6ICcnKSArXG4gICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgKGggPyBoICsgJ0gnIDogJycpICtcbiAgICAgICAgKG0gPyBtICsgJ00nIDogJycpICtcbiAgICAgICAgKHMgPyBzICsgJ1MnIDogJycpO1xufVxuXG52YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxucHJvdG8kMi5pc1ZhbGlkICAgICAgICA9IGlzVmFsaWQkMTtcbnByb3RvJDIuYWJzICAgICAgICAgICAgPSBhYnM7XG5wcm90byQyLmFkZCAgICAgICAgICAgID0gYWRkJDE7XG5wcm90byQyLnN1YnRyYWN0ICAgICAgID0gc3VidHJhY3QkMTtcbnByb3RvJDIuYXMgICAgICAgICAgICAgPSBhcztcbnByb3RvJDIuYXNNaWxsaXNlY29uZHMgPSBhc01pbGxpc2Vjb25kcztcbnByb3RvJDIuYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG5wcm90byQyLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xucHJvdG8kMi5hc0hvdXJzICAgICAgICA9IGFzSG91cnM7XG5wcm90byQyLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xucHJvdG8kMi5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XG5wcm90byQyLmFzTW9udGhzICAgICAgID0gYXNNb250aHM7XG5wcm90byQyLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbnByb3RvJDIudmFsdWVPZiAgICAgICAgPSB2YWx1ZU9mJDE7XG5wcm90byQyLl9idWJibGUgICAgICAgID0gYnViYmxlO1xucHJvdG8kMi5nZXQgICAgICAgICAgICA9IGdldCQyO1xucHJvdG8kMi5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbnByb3RvJDIuc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xucHJvdG8kMi5taW51dGVzICAgICAgICA9IG1pbnV0ZXM7XG5wcm90byQyLmhvdXJzICAgICAgICAgID0gaG91cnM7XG5wcm90byQyLmRheXMgICAgICAgICAgID0gZGF5cztcbnByb3RvJDIud2Vla3MgICAgICAgICAgPSB3ZWVrcztcbnByb3RvJDIubW9udGhzICAgICAgICAgPSBtb250aHM7XG5wcm90byQyLnllYXJzICAgICAgICAgID0geWVhcnM7XG5wcm90byQyLmh1bWFuaXplICAgICAgID0gaHVtYW5pemU7XG5wcm90byQyLnRvSVNPU3RyaW5nICAgID0gdG9JU09TdHJpbmckMTtcbnByb3RvJDIudG9TdHJpbmcgICAgICAgPSB0b0lTT1N0cmluZyQxO1xucHJvdG8kMi50b0pTT04gICAgICAgICA9IHRvSVNPU3RyaW5nJDE7XG5wcm90byQyLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xucHJvdG8kMi5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbi8vIERlcHJlY2F0aW9uc1xucHJvdG8kMi50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCB0b0lTT1N0cmluZyQxKTtcbnByb3RvJDIubGFuZyA9IGxhbmc7XG5cbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuLy8gRk9STUFUVElOR1xuXG5hZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG5hZGRGb3JtYXRUb2tlbigneCcsIDAsIDAsICd2YWx1ZU9mJyk7XG5cbi8vIFBBUlNJTkdcblxuYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbmFkZFJlZ2V4VG9rZW4oJ1gnLCBtYXRjaFRpbWVzdGFtcCk7XG5hZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCwgMTApICogMTAwMCk7XG59KTtcbmFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xufSk7XG5cbi8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG5ob29rcy52ZXJzaW9uID0gJzIuMTguMSc7XG5cbnNldEhvb2tDYWxsYmFjayhjcmVhdGVMb2NhbCk7XG5cbmhvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IHByb3RvO1xuaG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuaG9va3MubWF4ICAgICAgICAgICAgICAgICAgID0gbWF4O1xuaG9va3Mubm93ICAgICAgICAgICAgICAgICAgID0gbm93O1xuaG9va3MudXRjICAgICAgICAgICAgICAgICAgID0gY3JlYXRlVVRDO1xuaG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gY3JlYXRlVW5peDtcbmhvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RNb250aHM7XG5ob29rcy5pc0RhdGUgICAgICAgICAgICAgICAgPSBpc0RhdGU7XG5ob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBnZXRTZXRHbG9iYWxMb2NhbGU7XG5ob29rcy5pbnZhbGlkICAgICAgICAgICAgICAgPSBjcmVhdGVJbnZhbGlkO1xuaG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlRHVyYXRpb247XG5ob29rcy5pc01vbWVudCAgICAgICAgICAgICAgPSBpc01vbWVudDtcbmhvb2tzLndlZWtkYXlzICAgICAgICAgICAgICA9IGxpc3RXZWVrZGF5cztcbmhvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IGNyZWF0ZUluWm9uZTtcbmhvb2tzLmxvY2FsZURhdGEgICAgICAgICAgICA9IGdldExvY2FsZTtcbmhvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG5ob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0TW9udGhzU2hvcnQ7XG5ob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0V2Vla2RheXNNaW47XG5ob29rcy5kZWZpbmVMb2NhbGUgICAgICAgICAgPSBkZWZpbmVMb2NhbGU7XG5ob29rcy51cGRhdGVMb2NhbGUgICAgICAgICAgPSB1cGRhdGVMb2NhbGU7XG5ob29rcy5sb2NhbGVzICAgICAgICAgICAgICAgPSBsaXN0TG9jYWxlcztcbmhvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RXZWVrZGF5c1Nob3J0O1xuaG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG5ob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuaG9va3MucmVsYXRpdmVUaW1lVGhyZXNob2xkID0gZ2V0U2V0UmVsYXRpdmVUaW1lVGhyZXNob2xkO1xuaG9va3MuY2FsZW5kYXJGb3JtYXQgICAgICAgID0gZ2V0Q2FsZW5kYXJGb3JtYXQ7XG5ob29rcy5wcm90b3R5cGUgICAgICAgICAgICAgPSBwcm90bztcblxucmV0dXJuIGhvb2tzO1xuXG59KSkpO1xuIiwiLyohXG4gKiBQaWthZGF5XG4gKlxuICogQ29weXJpZ2h0IMKpIDIwMTQgRGF2aWQgQnVzaGVsbCB8IEJTRCAmIE1JVCBsaWNlbnNlIHwgaHR0cHM6Ly9naXRodWIuY29tL2RidXNoZWxsL1Bpa2FkYXlcbiAqL1xuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpXG57XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG1vbWVudDtcbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIENvbW1vbkpTIG1vZHVsZVxuICAgICAgICAvLyBMb2FkIG1vbWVudC5qcyBhcyBhbiBvcHRpb25hbCBkZXBlbmRlbmN5XG4gICAgICAgIHRyeSB7IG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpOyB9IGNhdGNoIChlKSB7fVxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkobW9tZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShmdW5jdGlvbiAocmVxKVxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBMb2FkIG1vbWVudC5qcyBhcyBhbiBvcHRpb25hbCBkZXBlbmRlbmN5XG4gICAgICAgICAgICB2YXIgaWQgPSAnbW9tZW50JztcbiAgICAgICAgICAgIHRyeSB7IG1vbWVudCA9IHJlcShpZCk7IH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeShtb21lbnQpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LlBpa2FkYXkgPSBmYWN0b3J5KHJvb3QubW9tZW50KTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIChtb21lbnQpXG57XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogZmVhdHVyZSBkZXRlY3Rpb24gYW5kIGhlbHBlciBmdW5jdGlvbnNcbiAgICAgKi9cbiAgICB2YXIgaGFzTW9tZW50ID0gdHlwZW9mIG1vbWVudCA9PT0gJ2Z1bmN0aW9uJyxcblxuICAgIGhhc0V2ZW50TGlzdGVuZXJzID0gISF3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcixcblxuICAgIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxuXG4gICAgc3RvID0gd2luZG93LnNldFRpbWVvdXQsXG5cbiAgICBhZGRFdmVudCA9IGZ1bmN0aW9uKGVsLCBlLCBjYWxsYmFjaywgY2FwdHVyZSlcbiAgICB7XG4gICAgICAgIGlmIChoYXNFdmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihlLCBjYWxsYmFjaywgISFjYXB0dXJlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVtb3ZlRXZlbnQgPSBmdW5jdGlvbihlbCwgZSwgY2FsbGJhY2ssIGNhcHR1cmUpXG4gICAge1xuICAgICAgICBpZiAoaGFzRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgY2FsbGJhY2ssICEhY2FwdHVyZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRyaW0gPSBmdW5jdGlvbihzdHIpXG4gICAge1xuICAgICAgICByZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csJycpO1xuICAgIH0sXG5cbiAgICBoYXNDbGFzcyA9IGZ1bmN0aW9uKGVsLCBjbilcbiAgICB7XG4gICAgICAgIHJldHVybiAoJyAnICsgZWwuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgJyArIGNuICsgJyAnKSAhPT0gLTE7XG4gICAgfSxcblxuICAgIGFkZENsYXNzID0gZnVuY3Rpb24oZWwsIGNuKVxuICAgIHtcbiAgICAgICAgaWYgKCFoYXNDbGFzcyhlbCwgY24pKSB7XG4gICAgICAgICAgICBlbC5jbGFzc05hbWUgPSAoZWwuY2xhc3NOYW1lID09PSAnJykgPyBjbiA6IGVsLmNsYXNzTmFtZSArICcgJyArIGNuO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbW92ZUNsYXNzID0gZnVuY3Rpb24oZWwsIGNuKVxuICAgIHtcbiAgICAgICAgZWwuY2xhc3NOYW1lID0gdHJpbSgoJyAnICsgZWwuY2xhc3NOYW1lICsgJyAnKS5yZXBsYWNlKCcgJyArIGNuICsgJyAnLCAnICcpKTtcbiAgICB9LFxuXG4gICAgaXNBcnJheSA9IGZ1bmN0aW9uKG9iailcbiAgICB7XG4gICAgICAgIHJldHVybiAoL0FycmF5LykudGVzdChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSk7XG4gICAgfSxcblxuICAgIGlzRGF0ZSA9IGZ1bmN0aW9uKG9iailcbiAgICB7XG4gICAgICAgIHJldHVybiAoL0RhdGUvKS50ZXN0KE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopKSAmJiAhaXNOYU4ob2JqLmdldFRpbWUoKSk7XG4gICAgfSxcblxuICAgIGlzV2Vla2VuZCA9IGZ1bmN0aW9uKGRhdGUpXG4gICAge1xuICAgICAgICB2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKTtcbiAgICAgICAgcmV0dXJuIGRheSA9PT0gMCB8fCBkYXkgPT09IDY7XG4gICAgfSxcblxuICAgIGlzTGVhcFllYXIgPSBmdW5jdGlvbih5ZWFyKVxuICAgIHtcbiAgICAgICAgLy8gc29sdXRpb24gYnkgTWF0dGkgVmlya2t1bmVuOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80ODgxOTUxXG4gICAgICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gICAgfSxcblxuICAgIGdldERheXNJbk1vbnRoID0gZnVuY3Rpb24oeWVhciwgbW9udGgpXG4gICAge1xuICAgICAgICByZXR1cm4gWzMxLCBpc0xlYXBZZWFyKHllYXIpID8gMjkgOiAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdW21vbnRoXTtcbiAgICB9LFxuXG4gICAgc2V0VG9TdGFydE9mRGF5ID0gZnVuY3Rpb24oZGF0ZSlcbiAgICB7XG4gICAgICAgIGlmIChpc0RhdGUoZGF0ZSkpIGRhdGUuc2V0SG91cnMoMCwwLDAsMCk7XG4gICAgfSxcblxuICAgIGNvbXBhcmVEYXRlcyA9IGZ1bmN0aW9uKGEsYilcbiAgICB7XG4gICAgICAgIC8vIHdlYWsgZGF0ZSBjb21wYXJpc29uICh1c2Ugc2V0VG9TdGFydE9mRGF5KGRhdGUpIHRvIGVuc3VyZSBjb3JyZWN0IHJlc3VsdClcbiAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKTtcbiAgICB9LFxuXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24odG8sIGZyb20sIG92ZXJ3cml0ZSlcbiAgICB7XG4gICAgICAgIHZhciBwcm9wLCBoYXNQcm9wO1xuICAgICAgICBmb3IgKHByb3AgaW4gZnJvbSkge1xuICAgICAgICAgICAgaGFzUHJvcCA9IHRvW3Byb3BdICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaGFzUHJvcCAmJiB0eXBlb2YgZnJvbVtwcm9wXSA9PT0gJ29iamVjdCcgJiYgZnJvbVtwcm9wXSAhPT0gbnVsbCAmJiBmcm9tW3Byb3BdLm5vZGVOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEYXRlKGZyb21bcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdmVyd3JpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gbmV3IERhdGUoZnJvbVtwcm9wXS5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXkoZnJvbVtwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSBmcm9tW3Byb3BdLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSBleHRlbmQoe30sIGZyb21bcHJvcF0sIG92ZXJ3cml0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVyd3JpdGUgfHwgIWhhc1Byb3ApIHtcbiAgICAgICAgICAgICAgICB0b1twcm9wXSA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH0sXG5cbiAgICBmaXJlRXZlbnQgPSBmdW5jdGlvbihlbCwgZXZlbnROYW1lLCBkYXRhKVxuICAgIHtcbiAgICAgICAgdmFyIGV2O1xuXG4gICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgZXYgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICAgICAgICAgICAgZXYuaW5pdEV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgZXYgPSBleHRlbmQoZXYsIGRhdGEpO1xuICAgICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChldik7XG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QpIHtcbiAgICAgICAgICAgIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTtcbiAgICAgICAgICAgIGV2ID0gZXh0ZW5kKGV2LCBkYXRhKTtcbiAgICAgICAgICAgIGVsLmZpcmVFdmVudCgnb24nICsgZXZlbnROYW1lLCBldik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYWRqdXN0Q2FsZW5kYXIgPSBmdW5jdGlvbihjYWxlbmRhcikge1xuICAgICAgICBpZiAoY2FsZW5kYXIubW9udGggPCAwKSB7XG4gICAgICAgICAgICBjYWxlbmRhci55ZWFyIC09IE1hdGguY2VpbChNYXRoLmFicyhjYWxlbmRhci5tb250aCkvMTIpO1xuICAgICAgICAgICAgY2FsZW5kYXIubW9udGggKz0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGVuZGFyLm1vbnRoID4gMTEpIHtcbiAgICAgICAgICAgIGNhbGVuZGFyLnllYXIgKz0gTWF0aC5mbG9vcihNYXRoLmFicyhjYWxlbmRhci5tb250aCkvMTIpO1xuICAgICAgICAgICAgY2FsZW5kYXIubW9udGggLT0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGVuZGFyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkZWZhdWx0cyBhbmQgbG9jYWxpc2F0aW9uXG4gICAgICovXG4gICAgZGVmYXVsdHMgPSB7XG5cbiAgICAgICAgLy8gYmluZCB0aGUgcGlja2VyIHRvIGEgZm9ybSBmaWVsZFxuICAgICAgICBmaWVsZDogbnVsbCxcblxuICAgICAgICAvLyBhdXRvbWF0aWNhbGx5IHNob3cvaGlkZSB0aGUgcGlja2VyIG9uIGBmaWVsZGAgZm9jdXMgKGRlZmF1bHQgYHRydWVgIGlmIGBmaWVsZGAgaXMgc2V0KVxuICAgICAgICBib3VuZDogdW5kZWZpbmVkLFxuXG4gICAgICAgIC8vIHBvc2l0aW9uIG9mIHRoZSBkYXRlcGlja2VyLCByZWxhdGl2ZSB0byB0aGUgZmllbGQgKGRlZmF1bHQgdG8gYm90dG9tICYgbGVmdClcbiAgICAgICAgLy8gKCdib3R0b20nICYgJ2xlZnQnIGtleXdvcmRzIGFyZSBub3QgdXNlZCwgJ3RvcCcgJiAncmlnaHQnIGFyZSBtb2RpZmllciBvbiB0aGUgYm90dG9tL2xlZnQgcG9zaXRpb24pXG4gICAgICAgIHBvc2l0aW9uOiAnYm90dG9tIGxlZnQnLFxuXG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgZml0IGluIHRoZSB2aWV3cG9ydCBldmVuIGlmIGl0IG1lYW5zIHJlcG9zaXRpb25pbmcgZnJvbSB0aGUgcG9zaXRpb24gb3B0aW9uXG4gICAgICAgIHJlcG9zaXRpb246IHRydWUsXG5cbiAgICAgICAgLy8gdGhlIGRlZmF1bHQgb3V0cHV0IGZvcm1hdCBmb3IgYC50b1N0cmluZygpYCBhbmQgYGZpZWxkYCB2YWx1ZVxuICAgICAgICBmb3JtYXQ6ICdZWVlZLU1NLUREJyxcblxuICAgICAgICAvLyB0aGUgdG9TdHJpbmcgZnVuY3Rpb24gd2hpY2ggZ2V0cyBwYXNzZWQgYSBjdXJyZW50IGRhdGUgb2JqZWN0IGFuZCBmb3JtYXRcbiAgICAgICAgLy8gYW5kIHJldHVybnMgYSBzdHJpbmdcbiAgICAgICAgdG9TdHJpbmc6IG51bGwsXG5cbiAgICAgICAgLy8gdXNlZCB0byBjcmVhdGUgZGF0ZSBvYmplY3QgZnJvbSBjdXJyZW50IGlucHV0IHN0cmluZ1xuICAgICAgICBwYXJzZTogbnVsbCxcblxuICAgICAgICAvLyB0aGUgaW5pdGlhbCBkYXRlIHRvIHZpZXcgd2hlbiBmaXJzdCBvcGVuZWRcbiAgICAgICAgZGVmYXVsdERhdGU6IG51bGwsXG5cbiAgICAgICAgLy8gbWFrZSB0aGUgYGRlZmF1bHREYXRlYCB0aGUgaW5pdGlhbCBzZWxlY3RlZCB2YWx1ZVxuICAgICAgICBzZXREZWZhdWx0RGF0ZTogZmFsc2UsXG5cbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHdlZWsgKDA6IFN1bmRheSwgMTogTW9uZGF5IGV0YylcbiAgICAgICAgZmlyc3REYXk6IDAsXG5cbiAgICAgICAgLy8gdGhlIGRlZmF1bHQgZmxhZyBmb3IgbW9tZW50J3Mgc3RyaWN0IGRhdGUgcGFyc2luZ1xuICAgICAgICBmb3JtYXRTdHJpY3Q6IGZhbHNlLFxuXG4gICAgICAgIC8vIHRoZSBtaW5pbXVtL2VhcmxpZXN0IGRhdGUgdGhhdCBjYW4gYmUgc2VsZWN0ZWRcbiAgICAgICAgbWluRGF0ZTogbnVsbCxcbiAgICAgICAgLy8gdGhlIG1heGltdW0vbGF0ZXN0IGRhdGUgdGhhdCBjYW4gYmUgc2VsZWN0ZWRcbiAgICAgICAgbWF4RGF0ZTogbnVsbCxcblxuICAgICAgICAvLyBudW1iZXIgb2YgeWVhcnMgZWl0aGVyIHNpZGUsIG9yIGFycmF5IG9mIHVwcGVyL2xvd2VyIHJhbmdlXG4gICAgICAgIHllYXJSYW5nZTogMTAsXG5cbiAgICAgICAgLy8gc2hvdyB3ZWVrIG51bWJlcnMgYXQgaGVhZCBvZiByb3dcbiAgICAgICAgc2hvd1dlZWtOdW1iZXI6IGZhbHNlLFxuXG4gICAgICAgIC8vIFdlZWsgcGlja2VyIG1vZGVcbiAgICAgICAgcGlja1dob2xlV2VlazogZmFsc2UsXG5cbiAgICAgICAgLy8gdXNlZCBpbnRlcm5hbGx5IChkb24ndCBjb25maWcgb3V0c2lkZSlcbiAgICAgICAgbWluWWVhcjogMCxcbiAgICAgICAgbWF4WWVhcjogOTk5OSxcbiAgICAgICAgbWluTW9udGg6IHVuZGVmaW5lZCxcbiAgICAgICAgbWF4TW9udGg6IHVuZGVmaW5lZCxcblxuICAgICAgICBzdGFydFJhbmdlOiBudWxsLFxuICAgICAgICBlbmRSYW5nZTogbnVsbCxcblxuICAgICAgICBpc1JUTDogZmFsc2UsXG5cbiAgICAgICAgLy8gQWRkaXRpb25hbCB0ZXh0IHRvIGFwcGVuZCB0byB0aGUgeWVhciBpbiB0aGUgY2FsZW5kYXIgdGl0bGVcbiAgICAgICAgeWVhclN1ZmZpeDogJycsXG5cbiAgICAgICAgLy8gUmVuZGVyIHRoZSBtb250aCBhZnRlciB5ZWFyIGluIHRoZSBjYWxlbmRhciB0aXRsZVxuICAgICAgICBzaG93TW9udGhBZnRlclllYXI6IGZhbHNlLFxuXG4gICAgICAgIC8vIFJlbmRlciBkYXlzIG9mIHRoZSBjYWxlbmRhciBncmlkIHRoYXQgZmFsbCBpbiB0aGUgbmV4dCBvciBwcmV2aW91cyBtb250aFxuICAgICAgICBzaG93RGF5c0luTmV4dEFuZFByZXZpb3VzTW9udGhzOiBmYWxzZSxcblxuICAgICAgICAvLyBBbGxvd3MgdXNlciB0byBzZWxlY3QgZGF5cyB0aGF0IGZhbGwgaW4gdGhlIG5leHQgb3IgcHJldmlvdXMgbW9udGhcbiAgICAgICAgZW5hYmxlU2VsZWN0aW9uRGF5c0luTmV4dEFuZFByZXZpb3VzTW9udGhzOiBmYWxzZSxcblxuICAgICAgICAvLyBob3cgbWFueSBtb250aHMgYXJlIHZpc2libGVcbiAgICAgICAgbnVtYmVyT2ZNb250aHM6IDEsXG5cbiAgICAgICAgLy8gd2hlbiBudW1iZXJPZk1vbnRocyBpcyB1c2VkLCB0aGlzIHdpbGwgaGVscCB5b3UgdG8gY2hvb3NlIHdoZXJlIHRoZSBtYWluIGNhbGVuZGFyIHdpbGwgYmUgKGRlZmF1bHQgYGxlZnRgLCBjYW4gYmUgc2V0IHRvIGByaWdodGApXG4gICAgICAgIC8vIG9ubHkgdXNlZCBmb3IgdGhlIGZpcnN0IGRpc3BsYXkgb3Igd2hlbiBhIHNlbGVjdGVkIGRhdGUgaXMgbm90IHZpc2libGVcbiAgICAgICAgbWFpbkNhbGVuZGFyOiAnbGVmdCcsXG5cbiAgICAgICAgLy8gU3BlY2lmeSBhIERPTSBlbGVtZW50IHRvIHJlbmRlciB0aGUgY2FsZW5kYXIgaW5cbiAgICAgICAgY29udGFpbmVyOiB1bmRlZmluZWQsXG5cbiAgICAgICAgLy8gQmx1ciBmaWVsZCB3aGVuIGRhdGUgaXMgc2VsZWN0ZWRcbiAgICAgICAgYmx1ckZpZWxkT25TZWxlY3QgOiB0cnVlLFxuXG4gICAgICAgIC8vIGludGVybmF0aW9uYWxpemF0aW9uXG4gICAgICAgIGkxOG46IHtcbiAgICAgICAgICAgIHByZXZpb3VzTW9udGggOiAnUHJldmlvdXMgTW9udGgnLFxuICAgICAgICAgICAgbmV4dE1vbnRoICAgICA6ICdOZXh0IE1vbnRoJyxcbiAgICAgICAgICAgIG1vbnRocyAgICAgICAgOiBbJ0phbnVhcnknLCdGZWJydWFyeScsJ01hcmNoJywnQXByaWwnLCdNYXknLCdKdW5lJywnSnVseScsJ0F1Z3VzdCcsJ1NlcHRlbWJlcicsJ09jdG9iZXInLCdOb3ZlbWJlcicsJ0RlY2VtYmVyJ10sXG4gICAgICAgICAgICB3ZWVrZGF5cyAgICAgIDogWydTdW5kYXknLCdNb25kYXknLCdUdWVzZGF5JywnV2VkbmVzZGF5JywnVGh1cnNkYXknLCdGcmlkYXknLCdTYXR1cmRheSddLFxuICAgICAgICAgICAgd2Vla2RheXNTaG9ydCA6IFsnU3VuJywnTW9uJywnVHVlJywnV2VkJywnVGh1JywnRnJpJywnU2F0J11cbiAgICAgICAgfSxcblxuICAgICAgICAvLyBUaGVtZSBDbGFzc25hbWVcbiAgICAgICAgdGhlbWU6IG51bGwsXG5cbiAgICAgICAgLy8gZXZlbnRzIGFycmF5XG4gICAgICAgIGV2ZW50czogW10sXG5cbiAgICAgICAgLy8gY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgb25TZWxlY3Q6IG51bGwsXG4gICAgICAgIG9uT3BlbjogbnVsbCxcbiAgICAgICAgb25DbG9zZTogbnVsbCxcbiAgICAgICAgb25EcmF3OiBudWxsXG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogdGVtcGxhdGluZyBmdW5jdGlvbnMgdG8gYWJzdHJhY3QgSFRNTCByZW5kZXJpbmdcbiAgICAgKi9cbiAgICByZW5kZXJEYXlOYW1lID0gZnVuY3Rpb24ob3B0cywgZGF5LCBhYmJyKVxuICAgIHtcbiAgICAgICAgZGF5ICs9IG9wdHMuZmlyc3REYXk7XG4gICAgICAgIHdoaWxlIChkYXkgPj0gNykge1xuICAgICAgICAgICAgZGF5IC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFiYnIgPyBvcHRzLmkxOG4ud2Vla2RheXNTaG9ydFtkYXldIDogb3B0cy5pMThuLndlZWtkYXlzW2RheV07XG4gICAgfSxcblxuICAgIHJlbmRlckRheSA9IGZ1bmN0aW9uKG9wdHMpXG4gICAge1xuICAgICAgICB2YXIgYXJyID0gW107XG4gICAgICAgIHZhciBhcmlhU2VsZWN0ZWQgPSAnZmFsc2UnO1xuICAgICAgICBpZiAob3B0cy5pc0VtcHR5KSB7XG4gICAgICAgICAgICBpZiAob3B0cy5zaG93RGF5c0luTmV4dEFuZFByZXZpb3VzTW9udGhzKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goJ2lzLW91dHNpZGUtY3VycmVudC1tb250aCcpO1xuXG4gICAgICAgICAgICAgICAgaWYoIW9wdHMuZW5hYmxlU2VsZWN0aW9uRGF5c0luTmV4dEFuZFByZXZpb3VzTW9udGhzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKCdpcy1zZWxlY3Rpb24tZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJpcy1lbXB0eVwiPjwvdGQ+JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICBhcnIucHVzaCgnaXMtZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5pc1RvZGF5KSB7XG4gICAgICAgICAgICBhcnIucHVzaCgnaXMtdG9kYXknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICBhcnIucHVzaCgnaXMtc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgIGFyaWFTZWxlY3RlZCA9ICd0cnVlJztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5oYXNFdmVudCkge1xuICAgICAgICAgICAgYXJyLnB1c2goJ2hhcy1ldmVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmlzSW5SYW5nZSkge1xuICAgICAgICAgICAgYXJyLnB1c2goJ2lzLWlucmFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5pc1N0YXJ0UmFuZ2UpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKCdpcy1zdGFydHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuaXNFbmRSYW5nZSkge1xuICAgICAgICAgICAgYXJyLnB1c2goJ2lzLWVuZHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICc8dGQgZGF0YS1kYXk9XCInICsgb3B0cy5kYXkgKyAnXCIgY2xhc3M9XCInICsgYXJyLmpvaW4oJyAnKSArICdcIiBhcmlhLXNlbGVjdGVkPVwiJyArIGFyaWFTZWxlY3RlZCArICdcIj4nICtcbiAgICAgICAgICAgICAgICAgJzxidXR0b24gY2xhc3M9XCJwaWthLWJ1dHRvbiBwaWthLWRheVwiIHR5cGU9XCJidXR0b25cIiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2RhdGEtcGlrYS15ZWFyPVwiJyArIG9wdHMueWVhciArICdcIiBkYXRhLXBpa2EtbW9udGg9XCInICsgb3B0cy5tb250aCArICdcIiBkYXRhLXBpa2EtZGF5PVwiJyArIG9wdHMuZGF5ICsgJ1wiPicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5kYXkgK1xuICAgICAgICAgICAgICAgICAnPC9idXR0b24+JyArXG4gICAgICAgICAgICAgICAnPC90ZD4nO1xuICAgIH0sXG5cbiAgICByZW5kZXJXZWVrID0gZnVuY3Rpb24gKGQsIG0sIHkpIHtcbiAgICAgICAgLy8gTGlmdGVkIGZyb20gaHR0cDovL2phdmFzY3JpcHQuYWJvdXQuY29tL2xpYnJhcnkvYmx3ZWVreWVhci5odG0sIGxpZ2h0bHkgbW9kaWZpZWQuXG4gICAgICAgIHZhciBvbmVqYW4gPSBuZXcgRGF0ZSh5LCAwLCAxKSxcbiAgICAgICAgICAgIHdlZWtOdW0gPSBNYXRoLmNlaWwoKCgobmV3IERhdGUoeSwgbSwgZCkgLSBvbmVqYW4pIC8gODY0MDAwMDApICsgb25lamFuLmdldERheSgpKzEpLzcpO1xuICAgICAgICByZXR1cm4gJzx0ZCBjbGFzcz1cInBpa2Etd2Vla1wiPicgKyB3ZWVrTnVtICsgJzwvdGQ+JztcbiAgICB9LFxuXG4gICAgcmVuZGVyUm93ID0gZnVuY3Rpb24oZGF5cywgaXNSVEwsIHBpY2tXaG9sZVdlZWssIGlzUm93U2VsZWN0ZWQpXG4gICAge1xuICAgICAgICByZXR1cm4gJzx0ciBjbGFzcz1cInBpa2Etcm93JyArIChwaWNrV2hvbGVXZWVrID8gJyBwaWNrLXdob2xlLXdlZWsnIDogJycpICsgKGlzUm93U2VsZWN0ZWQgPyAnIGlzLXNlbGVjdGVkJyA6ICcnKSArICdcIj4nICsgKGlzUlRMID8gZGF5cy5yZXZlcnNlKCkgOiBkYXlzKS5qb2luKCcnKSArICc8L3RyPic7XG4gICAgfSxcblxuICAgIHJlbmRlckJvZHkgPSBmdW5jdGlvbihyb3dzKVxuICAgIHtcbiAgICAgICAgcmV0dXJuICc8dGJvZHk+JyArIHJvd3Muam9pbignJykgKyAnPC90Ym9keT4nO1xuICAgIH0sXG5cbiAgICByZW5kZXJIZWFkID0gZnVuY3Rpb24ob3B0cylcbiAgICB7XG4gICAgICAgIHZhciBpLCBhcnIgPSBbXTtcbiAgICAgICAgaWYgKG9wdHMuc2hvd1dlZWtOdW1iZXIpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKCc8dGg+PC90aD4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBhcnIucHVzaCgnPHRoIHNjb3BlPVwiY29sXCI+PGFiYnIgdGl0bGU9XCInICsgcmVuZGVyRGF5TmFtZShvcHRzLCBpKSArICdcIj4nICsgcmVuZGVyRGF5TmFtZShvcHRzLCBpLCB0cnVlKSArICc8L2FiYnI+PC90aD4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzx0aGVhZD48dHI+JyArIChvcHRzLmlzUlRMID8gYXJyLnJldmVyc2UoKSA6IGFycikuam9pbignJykgKyAnPC90cj48L3RoZWFkPic7XG4gICAgfSxcblxuICAgIHJlbmRlclRpdGxlID0gZnVuY3Rpb24oaW5zdGFuY2UsIGMsIHllYXIsIG1vbnRoLCByZWZZZWFyLCByYW5kSWQpXG4gICAge1xuICAgICAgICB2YXIgaSwgaiwgYXJyLFxuICAgICAgICAgICAgb3B0cyA9IGluc3RhbmNlLl9vLFxuICAgICAgICAgICAgaXNNaW5ZZWFyID0geWVhciA9PT0gb3B0cy5taW5ZZWFyLFxuICAgICAgICAgICAgaXNNYXhZZWFyID0geWVhciA9PT0gb3B0cy5tYXhZZWFyLFxuICAgICAgICAgICAgaHRtbCA9ICc8ZGl2IGlkPVwiJyArIHJhbmRJZCArICdcIiBjbGFzcz1cInBpa2EtdGl0bGVcIiByb2xlPVwiaGVhZGluZ1wiIGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiPicsXG4gICAgICAgICAgICBtb250aEh0bWwsXG4gICAgICAgICAgICB5ZWFySHRtbCxcbiAgICAgICAgICAgIHByZXYgPSB0cnVlLFxuICAgICAgICAgICAgbmV4dCA9IHRydWU7XG5cbiAgICAgICAgZm9yIChhcnIgPSBbXSwgaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBhcnIucHVzaCgnPG9wdGlvbiB2YWx1ZT1cIicgKyAoeWVhciA9PT0gcmVmWWVhciA/IGkgLSBjIDogMTIgKyBpIC0gYykgKyAnXCInICtcbiAgICAgICAgICAgICAgICAoaSA9PT0gbW9udGggPyAnIHNlbGVjdGVkPVwic2VsZWN0ZWRcIic6ICcnKSArXG4gICAgICAgICAgICAgICAgKChpc01pblllYXIgJiYgaSA8IG9wdHMubWluTW9udGgpIHx8IChpc01heFllYXIgJiYgaSA+IG9wdHMubWF4TW9udGgpID8gJ2Rpc2FibGVkPVwiZGlzYWJsZWRcIicgOiAnJykgKyAnPicgK1xuICAgICAgICAgICAgICAgIG9wdHMuaTE4bi5tb250aHNbaV0gKyAnPC9vcHRpb24+Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBtb250aEh0bWwgPSAnPGRpdiBjbGFzcz1cInBpa2EtbGFiZWxcIj4nICsgb3B0cy5pMThuLm1vbnRoc1ttb250aF0gKyAnPHNlbGVjdCBjbGFzcz1cInBpa2Etc2VsZWN0IHBpa2Etc2VsZWN0LW1vbnRoXCIgdGFiaW5kZXg9XCItMVwiPicgKyBhcnIuam9pbignJykgKyAnPC9zZWxlY3Q+PC9kaXY+JztcblxuICAgICAgICBpZiAoaXNBcnJheShvcHRzLnllYXJSYW5nZSkpIHtcbiAgICAgICAgICAgIGkgPSBvcHRzLnllYXJSYW5nZVswXTtcbiAgICAgICAgICAgIGogPSBvcHRzLnllYXJSYW5nZVsxXSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpID0geWVhciAtIG9wdHMueWVhclJhbmdlO1xuICAgICAgICAgICAgaiA9IDEgKyB5ZWFyICsgb3B0cy55ZWFyUmFuZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGFyciA9IFtdOyBpIDwgaiAmJiBpIDw9IG9wdHMubWF4WWVhcjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBvcHRzLm1pblllYXIpIHtcbiAgICAgICAgICAgICAgICBhcnIucHVzaCgnPG9wdGlvbiB2YWx1ZT1cIicgKyBpICsgJ1wiJyArIChpID09PSB5ZWFyID8gJyBzZWxlY3RlZD1cInNlbGVjdGVkXCInOiAnJykgKyAnPicgKyAoaSkgKyAnPC9vcHRpb24+Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWVhckh0bWwgPSAnPGRpdiBjbGFzcz1cInBpa2EtbGFiZWxcIj4nICsgeWVhciArIG9wdHMueWVhclN1ZmZpeCArICc8c2VsZWN0IGNsYXNzPVwicGlrYS1zZWxlY3QgcGlrYS1zZWxlY3QteWVhclwiIHRhYmluZGV4PVwiLTFcIj4nICsgYXJyLmpvaW4oJycpICsgJzwvc2VsZWN0PjwvZGl2Pic7XG5cbiAgICAgICAgaWYgKG9wdHMuc2hvd01vbnRoQWZ0ZXJZZWFyKSB7XG4gICAgICAgICAgICBodG1sICs9IHllYXJIdG1sICsgbW9udGhIdG1sO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHRtbCArPSBtb250aEh0bWwgKyB5ZWFySHRtbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01pblllYXIgJiYgKG1vbnRoID09PSAwIHx8IG9wdHMubWluTW9udGggPj0gbW9udGgpKSB7XG4gICAgICAgICAgICBwcmV2ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNYXhZZWFyICYmIChtb250aCA9PT0gMTEgfHwgb3B0cy5tYXhNb250aCA8PSBtb250aCkpIHtcbiAgICAgICAgICAgIG5leHQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjID09PSAwKSB7XG4gICAgICAgICAgICBodG1sICs9ICc8YnV0dG9uIGNsYXNzPVwicGlrYS1wcmV2JyArIChwcmV2ID8gJycgOiAnIGlzLWRpc2FibGVkJykgKyAnXCIgdHlwZT1cImJ1dHRvblwiPicgKyBvcHRzLmkxOG4ucHJldmlvdXNNb250aCArICc8L2J1dHRvbj4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjID09PSAoaW5zdGFuY2UuX28ubnVtYmVyT2ZNb250aHMgLSAxKSApIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJzxidXR0b24gY2xhc3M9XCJwaWthLW5leHQnICsgKG5leHQgPyAnJyA6ICcgaXMtZGlzYWJsZWQnKSArICdcIiB0eXBlPVwiYnV0dG9uXCI+JyArIG9wdHMuaTE4bi5uZXh0TW9udGggKyAnPC9idXR0b24+JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBodG1sICs9ICc8L2Rpdj4nO1xuICAgIH0sXG5cbiAgICByZW5kZXJUYWJsZSA9IGZ1bmN0aW9uKG9wdHMsIGRhdGEsIHJhbmRJZClcbiAgICB7XG4gICAgICAgIHJldHVybiAnPHRhYmxlIGNlbGxwYWRkaW5nPVwiMFwiIGNlbGxzcGFjaW5nPVwiMFwiIGNsYXNzPVwicGlrYS10YWJsZVwiIHJvbGU9XCJncmlkXCIgYXJpYS1sYWJlbGxlZGJ5PVwiJyArIHJhbmRJZCArICdcIj4nICsgcmVuZGVySGVhZChvcHRzKSArIHJlbmRlckJvZHkoZGF0YSkgKyAnPC90YWJsZT4nO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFBpa2FkYXkgY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBQaWthZGF5ID0gZnVuY3Rpb24ob3B0aW9ucylcbiAgICB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIG9wdHMgPSBzZWxmLmNvbmZpZyhvcHRpb25zKTtcblxuICAgICAgICBzZWxmLl9vbk1vdXNlRG93biA9IGZ1bmN0aW9uKGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5fdikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFoYXNDbGFzcyh0YXJnZXQsICdpcy1kaXNhYmxlZCcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKHRhcmdldCwgJ3Bpa2EtYnV0dG9uJykgJiYgIWhhc0NsYXNzKHRhcmdldCwgJ2lzLWVtcHR5JykgJiYgIWhhc0NsYXNzKHRhcmdldC5wYXJlbnROb2RlLCAnaXMtZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldERhdGUobmV3IERhdGUodGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1waWthLXllYXInKSwgdGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1waWthLW1vbnRoJyksIHRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGlrYS1kYXknKSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5ib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmJsdXJGaWVsZE9uU2VsZWN0ICYmIG9wdHMuZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5maWVsZC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNDbGFzcyh0YXJnZXQsICdwaWthLXByZXYnKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnByZXZNb250aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNDbGFzcyh0YXJnZXQsICdwaWthLW5leHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm5leHRNb250aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzQ2xhc3ModGFyZ2V0LCAncGlrYS1zZWxlY3QnKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgdG91Y2ggZXZlbnQgcHJldmVudCBtb3VzZSBldmVudHMgZW11bGF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5fb25DaGFuZ2UgPSBmdW5jdGlvbihlKVxuICAgICAgICB7XG4gICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzQ2xhc3ModGFyZ2V0LCAncGlrYS1zZWxlY3QtbW9udGgnKSkge1xuICAgICAgICAgICAgICAgIHNlbGYuZ290b01vbnRoKHRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoYXNDbGFzcyh0YXJnZXQsICdwaWthLXNlbGVjdC15ZWFyJykpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmdvdG9ZZWFyKHRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5fb25LZXlDaGFuZ2UgPSBmdW5jdGlvbihlKVxuICAgICAgICB7XG4gICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgICAgICAgIGlmIChzZWxmLmlzVmlzaWJsZSgpKSB7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2goZS5rZXlDb2RlKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5maWVsZC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuYWRqdXN0RGF0ZSgnc3VidHJhY3QnLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGp1c3REYXRlKCdzdWJ0cmFjdCcsIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkanVzdERhdGUoJ2FkZCcsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFkanVzdERhdGUoJ2FkZCcsIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuX29uSW5wdXRDaGFuZ2UgPSBmdW5jdGlvbihlKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZGF0ZTtcblxuICAgICAgICAgICAgaWYgKGUuZmlyZWRCeSA9PT0gc2VsZikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLnBhcnNlKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG9wdHMucGFyc2Uob3B0cy5maWVsZC52YWx1ZSwgb3B0cy5mb3JtYXQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNNb21lbnQpIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbW9tZW50KG9wdHMuZmllbGQudmFsdWUsIG9wdHMuZm9ybWF0LCBvcHRzLmZvcm1hdFN0cmljdCk7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IChkYXRlICYmIGRhdGUuaXNWYWxpZCgpKSA/IGRhdGUudG9EYXRlKCkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUucGFyc2Uob3B0cy5maWVsZC52YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGF0ZShkYXRlKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldERhdGUoZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNlbGYuX3YpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBzZWxmLl9vbklucHV0Rm9jdXMgPSBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNlbGYuc2hvdygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuX29uSW5wdXRDbGljayA9IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgc2VsZi5zaG93KCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VsZi5fb25JbnB1dEJsdXIgPSBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIElFIGFsbG93cyBwaWthIGRpdiB0byBnYWluIGZvY3VzOyBjYXRjaCBibHVyIHRoZSBpbnB1dCBmaWVsZFxuICAgICAgICAgICAgdmFyIHBFbCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0NsYXNzKHBFbCwgJ3Bpa2Etc2luZ2xlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICgocEVsID0gcEVsLnBhcmVudE5vZGUpKTtcblxuICAgICAgICAgICAgaWYgKCFzZWxmLl9jKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fYiA9IHN0byhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5oaWRlKCk7XG4gICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5fYyA9IGZhbHNlO1xuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuX29uQ2xpY2sgPSBmdW5jdGlvbihlKVxuICAgICAgICB7XG4gICAgICAgICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50LFxuICAgICAgICAgICAgICAgIHBFbCA9IHRhcmdldDtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNFdmVudExpc3RlbmVycyAmJiBoYXNDbGFzcyh0YXJnZXQsICdwaWthLXNlbGVjdCcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQub25jaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZSgnb25jaGFuZ2UnLCAncmV0dXJuOycpO1xuICAgICAgICAgICAgICAgICAgICBhZGRFdmVudCh0YXJnZXQsICdjaGFuZ2UnLCBzZWxmLl9vbkNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChoYXNDbGFzcyhwRWwsICdwaWthLXNpbmdsZScpIHx8IHBFbCA9PT0gb3B0cy50cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoKHBFbCA9IHBFbC5wYXJlbnROb2RlKSk7XG4gICAgICAgICAgICBpZiAoc2VsZi5fdiAmJiB0YXJnZXQgIT09IG9wdHMudHJpZ2dlciAmJiBwRWwgIT09IG9wdHMudHJpZ2dlcikge1xuICAgICAgICAgICAgICAgIHNlbGYuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHNlbGYuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc2VsZi5lbC5jbGFzc05hbWUgPSAncGlrYS1zaW5nbGUnICsgKG9wdHMuaXNSVEwgPyAnIGlzLXJ0bCcgOiAnJykgKyAob3B0cy50aGVtZSA/ICcgJyArIG9wdHMudGhlbWUgOiAnJyk7XG5cbiAgICAgICAgYWRkRXZlbnQoc2VsZi5lbCwgJ21vdXNlZG93bicsIHNlbGYuX29uTW91c2VEb3duLCB0cnVlKTtcbiAgICAgICAgYWRkRXZlbnQoc2VsZi5lbCwgJ3RvdWNoZW5kJywgc2VsZi5fb25Nb3VzZURvd24sIHRydWUpO1xuICAgICAgICBhZGRFdmVudChzZWxmLmVsLCAnY2hhbmdlJywgc2VsZi5fb25DaGFuZ2UpO1xuICAgICAgICBhZGRFdmVudChkb2N1bWVudCwgJ2tleWRvd24nLCBzZWxmLl9vbktleUNoYW5nZSk7XG5cbiAgICAgICAgaWYgKG9wdHMuZmllbGQpIHtcbiAgICAgICAgICAgIGlmIChvcHRzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIG9wdHMuY29udGFpbmVyLmFwcGVuZENoaWxkKHNlbGYuZWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRzLmJvdW5kKSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzZWxmLmVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0cy5maWVsZC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzZWxmLmVsLCBvcHRzLmZpZWxkLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZEV2ZW50KG9wdHMuZmllbGQsICdjaGFuZ2UnLCBzZWxmLl9vbklucHV0Q2hhbmdlKTtcblxuICAgICAgICAgICAgaWYgKCFvcHRzLmRlZmF1bHREYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc01vbWVudCAmJiBvcHRzLmZpZWxkLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuZGVmYXVsdERhdGUgPSBtb21lbnQob3B0cy5maWVsZC52YWx1ZSwgb3B0cy5mb3JtYXQpLnRvRGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuZGVmYXVsdERhdGUgPSBuZXcgRGF0ZShEYXRlLnBhcnNlKG9wdHMuZmllbGQudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0cy5zZXREZWZhdWx0RGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGVmRGF0ZSA9IG9wdHMuZGVmYXVsdERhdGU7XG5cbiAgICAgICAgaWYgKGlzRGF0ZShkZWZEYXRlKSkge1xuICAgICAgICAgICAgaWYgKG9wdHMuc2V0RGVmYXVsdERhdGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldERhdGUoZGVmRGF0ZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGYuZ290b0RhdGUoZGVmRGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmdvdG9EYXRlKG5ldyBEYXRlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdHMuYm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgc2VsZi5lbC5jbGFzc05hbWUgKz0gJyBpcy1ib3VuZCc7XG4gICAgICAgICAgICBhZGRFdmVudChvcHRzLnRyaWdnZXIsICdjbGljaycsIHNlbGYuX29uSW5wdXRDbGljayk7XG4gICAgICAgICAgICBhZGRFdmVudChvcHRzLnRyaWdnZXIsICdmb2N1cycsIHNlbGYuX29uSW5wdXRGb2N1cyk7XG4gICAgICAgICAgICBhZGRFdmVudChvcHRzLnRyaWdnZXIsICdibHVyJywgc2VsZi5fb25JbnB1dEJsdXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBwdWJsaWMgUGlrYWRheSBBUElcbiAgICAgKi9cbiAgICBQaWthZGF5LnByb3RvdHlwZSA9IHtcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb25maWd1cmUgZnVuY3Rpb25hbGl0eVxuICAgICAgICAgKi9cbiAgICAgICAgY29uZmlnOiBmdW5jdGlvbihvcHRpb25zKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX28pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vID0gZXh0ZW5kKHt9LCBkZWZhdWx0cywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvcHRzID0gZXh0ZW5kKHRoaXMuX28sIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgICAgICBvcHRzLmlzUlRMID0gISFvcHRzLmlzUlRMO1xuXG4gICAgICAgICAgICBvcHRzLmZpZWxkID0gKG9wdHMuZmllbGQgJiYgb3B0cy5maWVsZC5ub2RlTmFtZSkgPyBvcHRzLmZpZWxkIDogbnVsbDtcblxuICAgICAgICAgICAgb3B0cy50aGVtZSA9ICh0eXBlb2Ygb3B0cy50aGVtZSkgPT09ICdzdHJpbmcnICYmIG9wdHMudGhlbWUgPyBvcHRzLnRoZW1lIDogbnVsbDtcblxuICAgICAgICAgICAgb3B0cy5ib3VuZCA9ICEhKG9wdHMuYm91bmQgIT09IHVuZGVmaW5lZCA/IG9wdHMuZmllbGQgJiYgb3B0cy5ib3VuZCA6IG9wdHMuZmllbGQpO1xuXG4gICAgICAgICAgICBvcHRzLnRyaWdnZXIgPSAob3B0cy50cmlnZ2VyICYmIG9wdHMudHJpZ2dlci5ub2RlTmFtZSkgPyBvcHRzLnRyaWdnZXIgOiBvcHRzLmZpZWxkO1xuXG4gICAgICAgICAgICBvcHRzLmRpc2FibGVXZWVrZW5kcyA9ICEhb3B0cy5kaXNhYmxlV2Vla2VuZHM7XG5cbiAgICAgICAgICAgIG9wdHMuZGlzYWJsZURheUZuID0gKHR5cGVvZiBvcHRzLmRpc2FibGVEYXlGbikgPT09ICdmdW5jdGlvbicgPyBvcHRzLmRpc2FibGVEYXlGbiA6IG51bGw7XG5cbiAgICAgICAgICAgIHZhciBub20gPSBwYXJzZUludChvcHRzLm51bWJlck9mTW9udGhzLCAxMCkgfHwgMTtcbiAgICAgICAgICAgIG9wdHMubnVtYmVyT2ZNb250aHMgPSBub20gPiA0ID8gNCA6IG5vbTtcblxuICAgICAgICAgICAgaWYgKCFpc0RhdGUob3B0cy5taW5EYXRlKSkge1xuICAgICAgICAgICAgICAgIG9wdHMubWluRGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0RhdGUob3B0cy5tYXhEYXRlKSkge1xuICAgICAgICAgICAgICAgIG9wdHMubWF4RGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChvcHRzLm1pbkRhdGUgJiYgb3B0cy5tYXhEYXRlKSAmJiBvcHRzLm1heERhdGUgPCBvcHRzLm1pbkRhdGUpIHtcbiAgICAgICAgICAgICAgICBvcHRzLm1heERhdGUgPSBvcHRzLm1pbkRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLm1pbkRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE1pbkRhdGUob3B0cy5taW5EYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLm1heERhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE1heERhdGUob3B0cy5tYXhEYXRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzQXJyYXkob3B0cy55ZWFyUmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZhbGxiYWNrID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpIC0gMTA7XG4gICAgICAgICAgICAgICAgb3B0cy55ZWFyUmFuZ2VbMF0gPSBwYXJzZUludChvcHRzLnllYXJSYW5nZVswXSwgMTApIHx8IGZhbGxiYWNrO1xuICAgICAgICAgICAgICAgIG9wdHMueWVhclJhbmdlWzFdID0gcGFyc2VJbnQob3B0cy55ZWFyUmFuZ2VbMV0sIDEwKSB8fCBmYWxsYmFjaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0cy55ZWFyUmFuZ2UgPSBNYXRoLmFicyhwYXJzZUludChvcHRzLnllYXJSYW5nZSwgMTApKSB8fCBkZWZhdWx0cy55ZWFyUmFuZ2U7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMueWVhclJhbmdlID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMueWVhclJhbmdlID0gMTAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybiBhIGZvcm1hdHRlZCBzdHJpbmcgb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uICh1c2luZyBNb21lbnQuanMgaWYgYXZhaWxhYmxlKVxuICAgICAgICAgKi9cbiAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uKGZvcm1hdClcbiAgICAgICAge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8IHRoaXMuX28uZm9ybWF0O1xuICAgICAgICAgICAgaWYgKCFpc0RhdGUodGhpcy5fZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fby50b1N0cmluZykge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fby50b1N0cmluZyh0aGlzLl9kLCBmb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc01vbWVudCkge1xuICAgICAgICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMuX2QpLmZvcm1hdChmb3JtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2QudG9EYXRlU3RyaW5nKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybiBhIE1vbWVudC5qcyBvYmplY3Qgb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIChpZiBhdmFpbGFibGUpXG4gICAgICAgICAqL1xuICAgICAgICBnZXRNb21lbnQ6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGhhc01vbWVudCA/IG1vbWVudCh0aGlzLl9kKSA6IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCB0aGUgY3VycmVudCBzZWxlY3Rpb24gZnJvbSBhIE1vbWVudC5qcyBvYmplY3QgKGlmIGF2YWlsYWJsZSlcbiAgICAgICAgICovXG4gICAgICAgIHNldE1vbWVudDogZnVuY3Rpb24oZGF0ZSwgcHJldmVudE9uU2VsZWN0KVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaGFzTW9tZW50ICYmIG1vbWVudC5pc01vbWVudChkYXRlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RGF0ZShkYXRlLnRvRGF0ZSgpLCBwcmV2ZW50T25TZWxlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXR1cm4gYSBEYXRlIG9iamVjdCBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIGdldERhdGU6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIGlzRGF0ZSh0aGlzLl9kKSA/IG5ldyBEYXRlKHRoaXMuX2QuZ2V0VGltZSgpKSA6IG51bGw7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIHNldERhdGU6IGZ1bmN0aW9uKGRhdGUsIHByZXZlbnRPblNlbGVjdClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fby5maWVsZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vLmZpZWxkLnZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGZpcmVFdmVudCh0aGlzLl9vLmZpZWxkLCAnY2hhbmdlJywgeyBmaXJlZEJ5OiB0aGlzIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5wYXJzZShkYXRlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzRGF0ZShkYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1pbiA9IHRoaXMuX28ubWluRGF0ZSxcbiAgICAgICAgICAgICAgICBtYXggPSB0aGlzLl9vLm1heERhdGU7XG5cbiAgICAgICAgICAgIGlmIChpc0RhdGUobWluKSAmJiBkYXRlIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG1pbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKG1heCkgJiYgZGF0ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgIGRhdGUgPSBtYXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7XG4gICAgICAgICAgICBzZXRUb1N0YXJ0T2ZEYXkodGhpcy5fZCk7XG4gICAgICAgICAgICB0aGlzLmdvdG9EYXRlKHRoaXMuX2QpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fby5maWVsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX28uZmllbGQudmFsdWUgPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgZmlyZUV2ZW50KHRoaXMuX28uZmllbGQsICdjaGFuZ2UnLCB7IGZpcmVkQnk6IHRoaXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXByZXZlbnRPblNlbGVjdCAmJiB0eXBlb2YgdGhpcy5fby5vblNlbGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX28ub25TZWxlY3QuY2FsbCh0aGlzLCB0aGlzLmdldERhdGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoYW5nZSB2aWV3IHRvIGEgc3BlY2lmaWMgZGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZ290b0RhdGU6IGZ1bmN0aW9uKGRhdGUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBuZXdDYWxlbmRhciA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICghaXNEYXRlKGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5jYWxlbmRhcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RWaXNpYmxlRGF0ZSA9IG5ldyBEYXRlKHRoaXMuY2FsZW5kYXJzWzBdLnllYXIsIHRoaXMuY2FsZW5kYXJzWzBdLm1vbnRoLCAxKSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdFZpc2libGVEYXRlID0gbmV3IERhdGUodGhpcy5jYWxlbmRhcnNbdGhpcy5jYWxlbmRhcnMubGVuZ3RoLTFdLnllYXIsIHRoaXMuY2FsZW5kYXJzW3RoaXMuY2FsZW5kYXJzLmxlbmd0aC0xXS5tb250aCwgMSksXG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVEYXRlID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBlbmQgb2YgdGhlIG1vbnRoXG4gICAgICAgICAgICAgICAgbGFzdFZpc2libGVEYXRlLnNldE1vbnRoKGxhc3RWaXNpYmxlRGF0ZS5nZXRNb250aCgpKzEpO1xuICAgICAgICAgICAgICAgIGxhc3RWaXNpYmxlRGF0ZS5zZXREYXRlKGxhc3RWaXNpYmxlRGF0ZS5nZXREYXRlKCktMSk7XG4gICAgICAgICAgICAgICAgbmV3Q2FsZW5kYXIgPSAodmlzaWJsZURhdGUgPCBmaXJzdFZpc2libGVEYXRlLmdldFRpbWUoKSB8fCBsYXN0VmlzaWJsZURhdGUuZ2V0VGltZSgpIDwgdmlzaWJsZURhdGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV3Q2FsZW5kYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGVuZGFycyA9IFt7XG4gICAgICAgICAgICAgICAgICAgIG1vbnRoOiBkYXRlLmdldE1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgIHllYXI6IGRhdGUuZ2V0RnVsbFllYXIoKVxuICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vLm1haW5DYWxlbmRhciA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGVuZGFyc1swXS5tb250aCArPSAxIC0gdGhpcy5fby5udW1iZXJPZk1vbnRocztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYWRqdXN0Q2FsZW5kYXJzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRqdXN0RGF0ZTogZnVuY3Rpb24oc2lnbiwgZGF5cykge1xuXG4gICAgICAgICAgICB2YXIgZGF5ID0gdGhpcy5nZXREYXRlKCkgfHwgbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHZhciBkaWZmZXJlbmNlID0gcGFyc2VJbnQoZGF5cykqMjQqNjAqNjAqMTAwMDtcblxuICAgICAgICAgICAgdmFyIG5ld0RheTtcblxuICAgICAgICAgICAgaWYgKHNpZ24gPT09ICdhZGQnKSB7XG4gICAgICAgICAgICAgICAgbmV3RGF5ID0gbmV3IERhdGUoZGF5LnZhbHVlT2YoKSArIGRpZmZlcmVuY2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzaWduID09PSAnc3VidHJhY3QnKSB7XG4gICAgICAgICAgICAgICAgbmV3RGF5ID0gbmV3IERhdGUoZGF5LnZhbHVlT2YoKSAtIGRpZmZlcmVuY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldERhdGUobmV3RGF5KTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGp1c3RDYWxlbmRhcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhcnNbMF0gPSBhZGp1c3RDYWxlbmRhcih0aGlzLmNhbGVuZGFyc1swXSk7XG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMTsgYyA8IHRoaXMuX28ubnVtYmVyT2ZNb250aHM7IGMrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJzW2NdID0gYWRqdXN0Q2FsZW5kYXIoe1xuICAgICAgICAgICAgICAgICAgICBtb250aDogdGhpcy5jYWxlbmRhcnNbMF0ubW9udGggKyBjLFxuICAgICAgICAgICAgICAgICAgICB5ZWFyOiB0aGlzLmNhbGVuZGFyc1swXS55ZWFyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRyYXcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnb3RvVG9kYXk6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5nb3RvRGF0ZShuZXcgRGF0ZSgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hhbmdlIHZpZXcgdG8gYSBzcGVjaWZpYyBtb250aCAoemVyby1pbmRleCwgZS5nLiAwOiBKYW51YXJ5KVxuICAgICAgICAgKi9cbiAgICAgICAgZ290b01vbnRoOiBmdW5jdGlvbihtb250aClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCFpc05hTihtb250aCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGVuZGFyc1swXS5tb250aCA9IHBhcnNlSW50KG1vbnRoLCAxMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGp1c3RDYWxlbmRhcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBuZXh0TW9udGg6IGZ1bmN0aW9uKClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhcnNbMF0ubW9udGgrKztcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0Q2FsZW5kYXJzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcHJldk1vbnRoOiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuY2FsZW5kYXJzWzBdLm1vbnRoLS07XG4gICAgICAgICAgICB0aGlzLmFkanVzdENhbGVuZGFycygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFuZ2UgdmlldyB0byBhIHNwZWNpZmljIGZ1bGwgeWVhciAoZS5nLiBcIjIwMTJcIilcbiAgICAgICAgICovXG4gICAgICAgIGdvdG9ZZWFyOiBmdW5jdGlvbih5ZWFyKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHllYXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxlbmRhcnNbMF0ueWVhciA9IHBhcnNlSW50KHllYXIsIDEwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkanVzdENhbGVuZGFycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGFuZ2UgdGhlIG1pbkRhdGVcbiAgICAgICAgICovXG4gICAgICAgIHNldE1pbkRhdGU6IGZ1bmN0aW9uKHZhbHVlKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZih2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICBzZXRUb1N0YXJ0T2ZEYXkodmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX28ubWluRGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX28ubWluWWVhciAgPSB2YWx1ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX28ubWluTW9udGggPSB2YWx1ZS5nZXRNb250aCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vLm1pbkRhdGUgPSBkZWZhdWx0cy5taW5EYXRlO1xuICAgICAgICAgICAgICAgIHRoaXMuX28ubWluWWVhciAgPSBkZWZhdWx0cy5taW5ZZWFyO1xuICAgICAgICAgICAgICAgIHRoaXMuX28ubWluTW9udGggPSBkZWZhdWx0cy5taW5Nb250aDtcbiAgICAgICAgICAgICAgICB0aGlzLl9vLnN0YXJ0UmFuZ2UgPSBkZWZhdWx0cy5zdGFydFJhbmdlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRyYXcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hhbmdlIHRoZSBtYXhEYXRlXG4gICAgICAgICAqL1xuICAgICAgICBzZXRNYXhEYXRlOiBmdW5jdGlvbih2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgc2V0VG9TdGFydE9mRGF5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vLm1heERhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9vLm1heFllYXIgPSB2YWx1ZS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX28ubWF4TW9udGggPSB2YWx1ZS5nZXRNb250aCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vLm1heERhdGUgPSBkZWZhdWx0cy5tYXhEYXRlO1xuICAgICAgICAgICAgICAgIHRoaXMuX28ubWF4WWVhciA9IGRlZmF1bHRzLm1heFllYXI7XG4gICAgICAgICAgICAgICAgdGhpcy5fby5tYXhNb250aCA9IGRlZmF1bHRzLm1heE1vbnRoO1xuICAgICAgICAgICAgICAgIHRoaXMuX28uZW5kUmFuZ2UgPSBkZWZhdWx0cy5lbmRSYW5nZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kcmF3KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0U3RhcnRSYW5nZTogZnVuY3Rpb24odmFsdWUpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX28uc3RhcnRSYW5nZSA9IHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldEVuZFJhbmdlOiBmdW5jdGlvbih2YWx1ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fby5lbmRSYW5nZSA9IHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZWZyZXNoIHRoZSBIVE1MXG4gICAgICAgICAqL1xuICAgICAgICBkcmF3OiBmdW5jdGlvbihmb3JjZSlcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl92ICYmICFmb3JjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5fbyxcbiAgICAgICAgICAgICAgICBtaW5ZZWFyID0gb3B0cy5taW5ZZWFyLFxuICAgICAgICAgICAgICAgIG1heFllYXIgPSBvcHRzLm1heFllYXIsXG4gICAgICAgICAgICAgICAgbWluTW9udGggPSBvcHRzLm1pbk1vbnRoLFxuICAgICAgICAgICAgICAgIG1heE1vbnRoID0gb3B0cy5tYXhNb250aCxcbiAgICAgICAgICAgICAgICBodG1sID0gJycsXG4gICAgICAgICAgICAgICAgcmFuZElkO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5feSA8PSBtaW5ZZWFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IG1pblllYXI7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihtaW5Nb250aCkgJiYgdGhpcy5fbSA8IG1pbk1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX20gPSBtaW5Nb250aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5feSA+PSBtYXhZZWFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feSA9IG1heFllYXI7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihtYXhNb250aCkgJiYgdGhpcy5fbSA+IG1heE1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX20gPSBtYXhNb250aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJhbmRJZCA9ICdwaWthLXRpdGxlLScgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5yZXBsYWNlKC9bXmEtel0rL2csICcnKS5zdWJzdHIoMCwgMik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgb3B0cy5udW1iZXJPZk1vbnRoczsgYysrKSB7XG4gICAgICAgICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cInBpa2EtbGVuZGFyXCI+JyArIHJlbmRlclRpdGxlKHRoaXMsIGMsIHRoaXMuY2FsZW5kYXJzW2NdLnllYXIsIHRoaXMuY2FsZW5kYXJzW2NdLm1vbnRoLCB0aGlzLmNhbGVuZGFyc1swXS55ZWFyLCByYW5kSWQpICsgdGhpcy5yZW5kZXIodGhpcy5jYWxlbmRhcnNbY10ueWVhciwgdGhpcy5jYWxlbmRhcnNbY10ubW9udGgsIHJhbmRJZCkgKyAnPC9kaXY+JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lbC5pbm5lckhUTUwgPSBodG1sO1xuXG4gICAgICAgICAgICBpZiAob3B0cy5ib3VuZCkge1xuICAgICAgICAgICAgICAgIGlmKG9wdHMuZmllbGQudHlwZSAhPT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy50cmlnZ2VyLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vLm9uRHJhdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX28ub25EcmF3KHRoaXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0cy5ib3VuZCkge1xuICAgICAgICAgICAgICAgIC8vIGxldCB0aGUgc2NyZWVuIHJlYWRlciB1c2VyIGtub3cgdG8gdXNlIGFycm93IGtleXNcbiAgICAgICAgICAgICAgICBvcHRzLmZpZWxkLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsICdVc2UgdGhlIGFycm93IGtleXMgdG8gcGljayBhIGRhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZGp1c3RQb3NpdGlvbjogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZmllbGQsIHBFbCwgd2lkdGgsIGhlaWdodCwgdmlld3BvcnRXaWR0aCwgdmlld3BvcnRIZWlnaHQsIHNjcm9sbFRvcCwgbGVmdCwgdG9wLCBjbGllbnRSZWN0O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fby5jb250YWluZXIpIHJldHVybjtcblxuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgICAgICAgICAgIGZpZWxkID0gdGhpcy5fby50cmlnZ2VyO1xuICAgICAgICAgICAgcEVsID0gZmllbGQ7XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuZWwub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmVsLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIHZpZXdwb3J0V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICB2aWV3cG9ydEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2xpZW50UmVjdCA9IGZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBjbGllbnRSZWN0LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgICAgICAgICAgICAgdG9wID0gY2xpZW50UmVjdC5ib3R0b20gKyB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBwRWwub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICB0b3AgID0gcEVsLm9mZnNldFRvcCArIHBFbC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgd2hpbGUoKHBFbCA9IHBFbC5vZmZzZXRQYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgKz0gcEVsLm9mZnNldExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHRvcCAgKz0gcEVsLm9mZnNldFRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRlZmF1bHQgcG9zaXRpb24gaXMgYm90dG9tICYgbGVmdFxuICAgICAgICAgICAgaWYgKCh0aGlzLl9vLnJlcG9zaXRpb24gJiYgbGVmdCArIHdpZHRoID4gdmlld3BvcnRXaWR0aCkgfHxcbiAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX28ucG9zaXRpb24uaW5kZXhPZigncmlnaHQnKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgLSB3aWR0aCArIGZpZWxkLm9mZnNldFdpZHRoID4gMFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0IC0gd2lkdGggKyBmaWVsZC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGhpcy5fby5yZXBvc2l0aW9uICYmIHRvcCArIGhlaWdodCA+IHZpZXdwb3J0SGVpZ2h0ICsgc2Nyb2xsVG9wKSB8fFxuICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fby5wb3NpdGlvbi5pbmRleE9mKCd0b3AnKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgICAgIHRvcCAtIGhlaWdodCAtIGZpZWxkLm9mZnNldEhlaWdodCA+IDBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0b3AgPSB0b3AgLSBoZWlnaHQgLSBmaWVsZC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZW5kZXIgSFRNTCBmb3IgYSBwYXJ0aWN1bGFyIG1vbnRoXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKHllYXIsIG1vbnRoLCByYW5kSWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvcHRzICAgPSB0aGlzLl9vLFxuICAgICAgICAgICAgICAgIG5vdyAgICA9IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgZGF5cyAgID0gZ2V0RGF5c0luTW9udGgoeWVhciwgbW9udGgpLFxuICAgICAgICAgICAgICAgIGJlZm9yZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKS5nZXREYXkoKSxcbiAgICAgICAgICAgICAgICBkYXRhICAgPSBbXSxcbiAgICAgICAgICAgICAgICByb3cgICAgPSBbXTtcbiAgICAgICAgICAgIHNldFRvU3RhcnRPZkRheShub3cpO1xuICAgICAgICAgICAgaWYgKG9wdHMuZmlyc3REYXkgPiAwKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlIC09IG9wdHMuZmlyc3REYXk7XG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlICs9IDc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZXZpb3VzTW9udGggPSBtb250aCA9PT0gMCA/IDExIDogbW9udGggLSAxLFxuICAgICAgICAgICAgICAgIG5leHRNb250aCA9IG1vbnRoID09PSAxMSA/IDAgOiBtb250aCArIDEsXG4gICAgICAgICAgICAgICAgeWVhck9mUHJldmlvdXNNb250aCA9IG1vbnRoID09PSAwID8geWVhciAtIDEgOiB5ZWFyLFxuICAgICAgICAgICAgICAgIHllYXJPZk5leHRNb250aCA9IG1vbnRoID09PSAxMSA/IHllYXIgKyAxIDogeWVhcixcbiAgICAgICAgICAgICAgICBkYXlzSW5QcmV2aW91c01vbnRoID0gZ2V0RGF5c0luTW9udGgoeWVhck9mUHJldmlvdXNNb250aCwgcHJldmlvdXNNb250aCk7XG4gICAgICAgICAgICB2YXIgY2VsbHMgPSBkYXlzICsgYmVmb3JlLFxuICAgICAgICAgICAgICAgIGFmdGVyID0gY2VsbHM7XG4gICAgICAgICAgICB3aGlsZShhZnRlciA+IDcpIHtcbiAgICAgICAgICAgICAgICBhZnRlciAtPSA3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VsbHMgKz0gNyAtIGFmdGVyO1xuICAgICAgICAgICAgdmFyIGlzV2Vla1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgciA9IDA7IGkgPCBjZWxsczsgaSsrKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBkYXkgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSArIChpIC0gYmVmb3JlKSksXG4gICAgICAgICAgICAgICAgICAgIGlzU2VsZWN0ZWQgPSBpc0RhdGUodGhpcy5fZCkgPyBjb21wYXJlRGF0ZXMoZGF5LCB0aGlzLl9kKSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpc1RvZGF5ID0gY29tcGFyZURhdGVzKGRheSwgbm93KSxcbiAgICAgICAgICAgICAgICAgICAgaGFzRXZlbnQgPSBvcHRzLmV2ZW50cy5pbmRleE9mKGRheS50b0RhdGVTdHJpbmcoKSkgIT09IC0xID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpc0VtcHR5ID0gaSA8IGJlZm9yZSB8fCBpID49IChkYXlzICsgYmVmb3JlKSxcbiAgICAgICAgICAgICAgICAgICAgZGF5TnVtYmVyID0gMSArIChpIC0gYmVmb3JlKSxcbiAgICAgICAgICAgICAgICAgICAgbW9udGhOdW1iZXIgPSBtb250aCxcbiAgICAgICAgICAgICAgICAgICAgeWVhck51bWJlciA9IHllYXIsXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnRSYW5nZSA9IG9wdHMuc3RhcnRSYW5nZSAmJiBjb21wYXJlRGF0ZXMob3B0cy5zdGFydFJhbmdlLCBkYXkpLFxuICAgICAgICAgICAgICAgICAgICBpc0VuZFJhbmdlID0gb3B0cy5lbmRSYW5nZSAmJiBjb21wYXJlRGF0ZXMob3B0cy5lbmRSYW5nZSwgZGF5KSxcbiAgICAgICAgICAgICAgICAgICAgaXNJblJhbmdlID0gb3B0cy5zdGFydFJhbmdlICYmIG9wdHMuZW5kUmFuZ2UgJiYgb3B0cy5zdGFydFJhbmdlIDwgZGF5ICYmIGRheSA8IG9wdHMuZW5kUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIGlzRGlzYWJsZWQgPSAob3B0cy5taW5EYXRlICYmIGRheSA8IG9wdHMubWluRGF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvcHRzLm1heERhdGUgJiYgZGF5ID4gb3B0cy5tYXhEYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wdHMuZGlzYWJsZVdlZWtlbmRzICYmIGlzV2Vla2VuZChkYXkpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9wdHMuZGlzYWJsZURheUZuICYmIG9wdHMuZGlzYWJsZURheUZuKGRheSkpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBiZWZvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheU51bWJlciA9IGRheXNJblByZXZpb3VzTW9udGggKyBkYXlOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aE51bWJlciA9IHByZXZpb3VzTW9udGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ZWFyTnVtYmVyID0geWVhck9mUHJldmlvdXNNb250aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheU51bWJlciA9IGRheU51bWJlciAtIGRheXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aE51bWJlciA9IG5leHRNb250aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHllYXJOdW1iZXIgPSB5ZWFyT2ZOZXh0TW9udGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZGF5Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF5OiBkYXlOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb250aDogbW9udGhOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB5ZWFyOiB5ZWFyTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXZlbnQ6IGhhc0V2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTZWxlY3RlZDogaXNTZWxlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVG9kYXk6IGlzVG9kYXksXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Rpc2FibGVkOiBpc0Rpc2FibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFbXB0eTogaXNFbXB0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RhcnRSYW5nZTogaXNTdGFydFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFbmRSYW5nZTogaXNFbmRSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzSW5SYW5nZTogaXNJblJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0RheXNJbk5leHRBbmRQcmV2aW91c01vbnRoczogb3B0cy5zaG93RGF5c0luTmV4dEFuZFByZXZpb3VzTW9udGhzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlU2VsZWN0aW9uRGF5c0luTmV4dEFuZFByZXZpb3VzTW9udGhzOiBvcHRzLmVuYWJsZVNlbGVjdGlvbkRheXNJbk5leHRBbmRQcmV2aW91c01vbnRoc1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdHMucGlja1dob2xlV2VlayAmJiBpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzV2Vla1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByb3cucHVzaChyZW5kZXJEYXkoZGF5Q29uZmlnKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKytyID09PSA3KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLnNob3dXZWVrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cudW5zaGlmdChyZW5kZXJXZWVrKGkgLSBiZWZvcmUsIG1vbnRoLCB5ZWFyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wdXNoKHJlbmRlclJvdyhyb3csIG9wdHMuaXNSVEwsIG9wdHMucGlja1dob2xlV2VlaywgaXNXZWVrU2VsZWN0ZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpc1dlZWtTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW5kZXJUYWJsZShvcHRzLCBkYXRhLCByYW5kSWQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGlzVmlzaWJsZTogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdjtcbiAgICAgICAgfSxcblxuICAgICAgICBzaG93OiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1Zpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3YgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHRoaXMuZWwsICdpcy1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fby5ib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRFdmVudChkb2N1bWVudCwgJ2NsaWNrJywgdGhpcy5fb25DbGljayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRqdXN0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vLm9uT3BlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vLm9uT3Blbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBoaWRlOiBmdW5jdGlvbigpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZhciB2ID0gdGhpcy5fdjtcbiAgICAgICAgICAgIGlmICh2ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vLmJvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50KGRvY3VtZW50LCAnY2xpY2snLCB0aGlzLl9vbkNsaWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5zdHlsZS5wb3NpdGlvbiA9ICdzdGF0aWMnOyAvLyByZXNldFxuICAgICAgICAgICAgICAgIHRoaXMuZWwuc3R5bGUubGVmdCA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICB0aGlzLmVsLnN0eWxlLnRvcCA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyh0aGlzLmVsLCAnaXMtaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHRoaXMuX28ub25DbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdBTUUgT1ZFUlxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50KHRoaXMuZWwsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICByZW1vdmVFdmVudCh0aGlzLmVsLCAndG91Y2hlbmQnLCB0aGlzLl9vbk1vdXNlRG93biwgdHJ1ZSk7XG4gICAgICAgICAgICByZW1vdmVFdmVudCh0aGlzLmVsLCAnY2hhbmdlJywgdGhpcy5fb25DaGFuZ2UpO1xuICAgICAgICAgICAgcmVtb3ZlRXZlbnQoZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlDaGFuZ2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX28uZmllbGQpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudCh0aGlzLl9vLmZpZWxkLCAnY2hhbmdlJywgdGhpcy5fb25JbnB1dENoYW5nZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX28uYm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnQodGhpcy5fby50cmlnZ2VyLCAnY2xpY2snLCB0aGlzLl9vbklucHV0Q2xpY2spO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudCh0aGlzLl9vLnRyaWdnZXIsICdmb2N1cycsIHRoaXMuX29uSW5wdXRGb2N1cyk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50KHRoaXMuX28udHJpZ2dlciwgJ2JsdXInLCB0aGlzLl9vbklucHV0Qmx1cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHJldHVybiBQaWthZGF5O1xuXG59KSk7XG4iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcImluZGV4XCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImluZGV4XCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImluZGV4XCJdID0gcm9vdFtcImluZGV4XCJdIHx8IHt9LCByb290W1wiaW5kZXhcIl1bXCJpbmRleFwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9LFxuLyoqKioqKi8gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bG9hZGVkOiBmYWxzZVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0dmFsdWU6IHRydWVcblx0fSk7XG5cdHZhciBWZWFtc0RPTSA9IHtcblx0XHRvcHRpb25zOiB7XG5cdFx0XHRET006IGZhbHNlXG5cdFx0fSxcblx0XHRwbHVnaW5OYW1lOiAnJCcsXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShWZWFtcywgX3JlZikge1xuXHRcdFx0dmFyIERPTSA9IF9yZWYuRE9NO1xuXHRcblx0XHRcdGlmICghRE9NKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1ZlYW1zRE9NIDo6IFlvdSBuZWVkIHRvIHBhc3MgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBhIERPTSBoYW5kbGVyOiBvcHRpb25zLkRPTSEnKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKFZlYW1zLiQpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coJ1ZlYW1zRE9NIDo6IEl0IHNlZW1zIHRoYXQgeW91IGhhdmUgYWxyZWFkeSBkZWZpbmVkIGEgRE9NIGhhbmRsZXIuIEkgYW0gb3ZlcndyaXRpbmcgaXQgbm93IGZvciB5b3UgOyknKTtcblx0XHRcdH1cblx0XG5cdFx0XHRWZWFtcy4kID0gdGhpcy5vcHRpb25zLkRPTSA9IERPTTtcblx0XHR9XG5cdH07XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBWZWFtc0RPTTtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiaW5kZXhcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiaW5kZXhcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiaW5kZXhcIl0gPSByb290W1wiaW5kZXhcIl0gfHwge30sIHJvb3RbXCJpbmRleFwiXVtcImluZGV4XCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHR2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblx0XG5cdHZhciBWZWFtc0xvZ2dlciA9IHtcblx0XHRwbHVnaW5OYW1lOiAnTG9nZ2VyJyxcblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKFZlYW1zKSB7XG5cdFx0XHQvKipcblx0ICAgKiBEZXZtb2RlIGFuZCBsb2dnZXJcblx0ICAgKi9cblx0XHRcdFZlYW1zLmRldm1vZGUgPSBmYWxzZTtcblx0XHRcdFZlYW1zLmxvZ2dlciA9IGZhbHNlO1xuXHRcblx0XHRcdGlmIChkb2N1bWVudC5sb2NhdGlvbi5zZWFyY2guaW5kZXhPZignZGV2bW9kZScpID4gLTEgfHwgd2luZG93LnNlc3Npb25TdG9yYWdlICYmIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ2Rldm1vZGVFbmFibGVkJykpIHtcblx0XHRcdFx0VmVhbXMuZGV2bW9kZSA9IHRydWU7XG5cdFxuXHRcdFx0XHRpZiAod2luZG93LnNlc3Npb25TdG9yYWdlICYmICFzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdkZXZtb2RlRW5hYmxlZCcpKSB7XG5cdFx0XHRcdFx0c2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnZGV2bW9kZUVuYWJsZWQnLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdGlmIChkb2N1bWVudC5sb2NhdGlvbi5zZWFyY2guaW5kZXhPZignbG9nZ2VyJykgPiAtMSkge1xuXHRcdFx0XHRWZWFtcy5sb2dnZXIgPSB0cnVlO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIGhpZGUgYWxsIHdhcm5pbmdzIGFuZCBsb2dzIGlmIG5vdCBpbiBkZXZtb2RlXG5cdFx0XHRpZiAoIVZlYW1zLmRldm1vZGUpIHtcblx0XHRcdFx0Y29uc29sZS5sb2cgPSBjb25zb2xlLndhcm4gPSBmdW5jdGlvbiAoKSB7fTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyBhZGQgY29uc29sZSBvdXRwdXQgZWxlbWVudCAodHJpZ2dlcmVkIGJ5IHBhcmFtZXRlciAnZGV2bW9kZScgYW5kICdsb2dnZXInIGluIHVybClcblx0XHRcdGlmIChWZWFtcy5kZXZtb2RlICYmIFZlYW1zLmxvZ2dlcikge1xuXHRcdFx0XHR2YXIgbG9nZ2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncHJlJyk7XG5cdFxuXHRcdFx0XHRsb2dnZXIuc2V0QXR0cmlidXRlKCdpZCcsICdsb2dnZXInKTtcblx0XHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsb2dnZXIpO1xuXHRcblx0XHRcdFx0Y29uc29sZS53cml0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKF90eXBlb2YoYXJndW1lbnRzW2ldKSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRcdFx0bG9nZ2VyLmlubmVySFRNTCArPSAoSlNPTiAmJiBKU09OLnN0cmluZ2lmeSA/IEpTT04uc3RyaW5naWZ5KGFyZ3VtZW50c1tpXSwgdW5kZWZpbmVkLCAyKSA6IGFyZ3VtZW50c1tpXSkgKyAnPGJyIC8+Jztcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxvZ2dlci5pbm5lckhUTUwgKz0gYXJndW1lbnRzW2ldICsgJzxiciAvPic7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRsb2dnZXIuaW5uZXJIVE1MICs9ICc8YnIgLz4nO1xuXHRcdFx0XHRcdGxvZ2dlci5zY3JvbGxUb3AgPSBsb2dnZXIuc2Nyb2xsSGVpZ2h0O1xuXHRcdFx0XHR9O1xuXHRcblx0XHRcdFx0Y29uc29sZS5lcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRsb2dnZXIuaW5uZXJIVE1MICs9ICdbRXJyb3JdPGJyIC8+Jztcblx0XHRcdFx0XHRjb25zb2xlLndyaXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH07XG5cdFxuXHRcdFx0XHRjb25zb2xlLndhcm4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bG9nZ2VyLmlubmVySFRNTCArPSAnW1dhcm5dPGJyIC8+Jztcblx0XHRcdFx0XHRjb25zb2xlLndyaXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH07XG5cdFxuXHRcdFx0XHRjb25zb2xlLmxvZyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRsb2dnZXIuaW5uZXJIVE1MICs9ICdbTG9nXTxiciAvPic7XG5cdFx0XHRcdFx0Y29uc29sZS53cml0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IFZlYW1zTG9nZ2VyO1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJpbmRleFwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJpbmRleFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJpbmRleFwiXSA9IHJvb3RbXCJpbmRleFwiXSB8fCB7fSwgcm9vdFtcImluZGV4XCJdW1wiaW5kZXhcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBJbXBvcnRzXG5cdCAqL1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0dmFsdWU6IHRydWVcblx0fSk7XG5cdHZhciBWZWFtc01lZGlhUXVlcnlIYW5kbGVyID0ge1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdG1lZGlhUXVlcnlQcm9wOiAnZm9udC1mYW1pbHknLFxuXHRcdFx0ZGVsYXk6IDMwMFxuXHRcdH0sXG5cdFx0cGx1Z2luTmFtZTogJ01lZGlhUXVlcnlIYW5kbGVyJyxcblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKFZlYW1zLCBvcHRzKSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXHRcblx0XHRcdC8vIE1lZGlhIFF1ZXJ5XG5cdFx0XHR2YXIgaGVhZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2hlYWQnKTtcblx0XG5cdFx0XHRpZiAob3B0cykge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMgPSBWZWFtcy5oZWxwZXJzLmV4dGVuZCh0aGlzLm9wdGlvbnMsIG9wdHMgfHwge30pO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8qKlxuXHQgICAqIEFkZCBjdXJyZW50IG1lZGlhIHF1ZXJ5IHRvIFZlYW1zXG5cdCAgICovXG5cdFx0XHRWZWFtcy5jdXJyZW50TWVkaWEgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShoZWFkWzBdLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKHRoaXMub3B0aW9ucy5tZWRpYVF1ZXJ5UHJvcCk7XG5cdFxuXHRcdFx0aWYgKCFWZWFtcy5WZW50KSB7XG5cdFx0XHRcdGNvbnNvbGUuaW5mbygnVmVhbXNNZWRpYVF1ZXJ5SGFuZGxlciA6OiBJbiBvcmRlciB0byB3b3JrIHByb3Blcmx5IHdpdGggdGhlIFZlYW1zTWVkaWFRdWVyeUhhbmRsZXIgcGx1Z2luIHlvdSBzaG91bGQgYWRkIHRoZSBWZWFtc1ZlbnQgcGx1Z2luIScpO1xuXHRcdFx0fVxuXHRcblx0XHRcdC8vIFRyaWdnZXIgZ2xvYmFsIHJlc2l6ZSBldmVudFxuXHRcdFx0d2luZG93Lm9ucmVzaXplID0gVmVhbXMuaGVscGVycy50aHJvdHRsZShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHR2YXIgY3VycmVudE1lZGlhID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaGVhZFswXSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShfdGhpcy5vcHRpb25zLm1lZGlhUXVlcnlQcm9wKTtcblx0XHRcdFx0dmFyIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG5cdFxuXHRcdFx0XHRpZiAoY3VycmVudE1lZGlhICE9PSBWZWFtcy5jdXJyZW50TWVkaWEpIHtcblx0XHRcdFx0XHR2YXIgb2xkTWVkaWEgPSBWZWFtcy5jdXJyZW50TWVkaWE7XG5cdFxuXHRcdFx0XHRcdFZlYW1zLmN1cnJlbnRNZWRpYSA9IGN1cnJlbnRNZWRpYTtcblx0XG5cdFx0XHRcdFx0Y29uc29sZS5pbmZvKCdWZWFtc01lZGlhUXVlcnlIYW5kbGVyIDo6IEN1cnJlbnQgbWVkaWEgaXMgJyArIFZlYW1zLmN1cnJlbnRNZWRpYSk7XG5cdFxuXHRcdFx0XHRcdGlmIChWZWFtcy5WZW50KSB7XG5cdFx0XHRcdFx0XHRWZWFtcy5WZW50LnRyaWdnZXIoVmVhbXMuRVZFTlRTLm1lZGlhY2hhbmdlLCB7XG5cdFx0XHRcdFx0XHRcdHR5cGU6IFZlYW1zLkVWRU5UUy5tZWRpYWNoYW5nZSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudE1lZGlhOiBjdXJyZW50TWVkaWEsXG5cdFx0XHRcdFx0XHRcdG9sZE1lZGlhOiBvbGRNZWRpYVxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRWZWFtcy5kZXRlY3Rpb25zLndpZHRoID0gd2lkdGg7XG5cdFx0XHRcdFZlYW1zLlZlbnQudHJpZ2dlcihWZWFtcy5FVkVOVFMucmVzaXplLCBlKTtcblx0XHRcdH0sIHRoaXMub3B0aW9ucy5kZWxheSk7XG5cdFx0fVxuXHR9O1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gVmVhbXNNZWRpYVF1ZXJ5SGFuZGxlcjtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwiaW5kZXhcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiaW5kZXhcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiaW5kZXhcIl0gPSByb290W1wiaW5kZXhcIl0gfHwge30sIHJvb3RbXCJpbmRleFwiXVtcImluZGV4XCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHR2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0XG5cdHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cdFxuXHRmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXHRcblx0dmFyIFZlYW1zID0ge307XG5cdHZhciBfX2NhY2hlID0gW107XG5cdHZhciBfX3JlZ2lzdGVyID0ge1xuXHRcdG1vZHVsZXNJblJlZ2lzdGVyOiBbXSxcblx0XHRtb2R1bGVzT25Db25kaXRpb25zOiBbXSxcblx0XHRtb2R1bGVzT25Jbml0OiBbXSxcblx0XHRtb2R1bGVzSW5Db250ZXh0OiBbXVxuXHR9O1xuXHRcblx0LyoqXG5cdCAqIFRPRE86IENsZWFuIHVwIG11dGF0aW9uIG9ic2VydmVyXG5cdCAqL1xuXHRcblx0LyoqXG5cdCAqIC0gR2V0IG1vZHVsZXMgaW4gRE9NXG5cdCAqIC0gR2V0IGNsYXNzZXMgYW5kIG9wdGlvbnMgZnJvbSBpbml0IHByb2Nlc3Ncblx0ICogLSBTcGxpdCB1cCBjb25kaXRpb25hbCBtb2R1bGVzIGZyb20gaW5pdGlhbCBtb2R1bGVzXG5cdCAqIC0gSW5pdCBvdGhlciBtb2R1bGVzXG5cdCAqIC0gQmluZCBldmVudHMgd2hlbiBhdmFpbGFibGUgZnJvbSBjb25kaXRpb25hbCBtb2R1bGVzXG5cdCAqIC1cblx0ICovXG5cdFxuXHR2YXIgTW9kdWxlcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBNb2R1bGVzKCkge1xuXHRcdFx0dmFyIFZFQU1TID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB3aW5kb3cuVmVhbXM7XG5cdFx0XHR2YXIgb3B0cyA9IGFyZ3VtZW50c1sxXTtcblx0XG5cdFx0XHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9kdWxlcyk7XG5cdFxuXHRcdFx0VmVhbXMgPSBWRUFNUztcblx0XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBvcHRzO1xuXHRcblx0XHRcdGlmICghdGhpcy5vcHRpb25zLmludGVybmFsQ2FjaGVPbmx5KSB7XG5cdFx0XHRcdHRoaXMuX2NhY2hlID0gX19jYWNoZTsgLy8gTW9kdWxlIGxpc3Rcblx0XHRcdH1cblx0XG5cdFx0XHRpZiAoIXRoaXMub3B0aW9ucy5pbnRlcm5hbFJlZ2lzdGVyT25seSkge1xuXHRcdFx0XHR0aGlzLl9yZWdpc3RlciA9IF9fcmVnaXN0ZXI7XG5cdFx0XHR9XG5cdFxuXHRcdFx0dGhpcy5pbml0aWFsaXplKCk7XG5cdFx0fVxuXHRcblx0XHRfY3JlYXRlQ2xhc3MoTW9kdWxlcywgW3tcblx0XHRcdGtleTogJ2luaXRpYWxpemUnLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG5cdFx0XHRcdHRoaXMucXVlcnlTdHJpbmcgPSAnWycgKyB0aGlzLm9wdGlvbnMuYXR0clByZWZpeCArICctJyArIHRoaXMub3B0aW9ucy5hdHRyTmFtZSArICddJztcblx0XHRcdFx0X19yZWdpc3Rlci5tb2R1bGVzSW5Db250ZXh0ID0gVmVhbXMuaGVscGVycy5xdWVyeVNlbGVjdG9yQXJyYXkodGhpcy5xdWVyeVN0cmluZyk7XG5cdFxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLnVzZU11dGF0aW9uT2JzZXJ2ZXIpIHtcblx0XHRcdFx0XHR0aGlzLm9ic2VydmUoZG9jdW1lbnQuYm9keSk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHRoaXMuYmluZEV2ZW50cygpO1xuXHRcdFx0fVxuXHRcdH0sIHtcblx0XHRcdGtleTogJ2JpbmRFdmVudHMnLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudHMoKSB7XG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXM7XG5cdFxuXHRcdFx0XHRpZiAoIVZlYW1zLlZlbnQgJiYgdGhpcy5vcHRpb25zLnVzZU11dGF0aW9uT2JzZXJ2ZXIgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5pbmZvKCdWZWFtc01vZHVsZXMgOjogSW4gb3JkZXIgdG8gd29yayB3aXRoIHRoZSB0aGUgYWpheCBoYW5kbGluZyBpbiBWZWFtc01vZHVsZXNIYW5kbGVyICcgKyAneW91IG5lZWQgdG8gZGVmaW5lIFwidXNlTXV0YXRpb25PYnNlcnZlclwiIG9yIHVzZSB0aGUgVmVhbXNWZW50IHBsdWdpbiEnKTtcblx0XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRpZiAoVmVhbXMuVmVudCAmJiB0aGlzLm9wdGlvbnMudXNlTXV0YXRpb25PYnNlcnZlciA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRWZWFtcy5WZW50Lm9uKFZlYW1zLkVWRU5UUy5ET01jaGFuZ2VkLCBmdW5jdGlvbiAoZSwgY29udGV4dCkge1xuXHRcdFx0XHRcdFx0X19yZWdpc3Rlci5tb2R1bGVzSW5Db250ZXh0ID0gX3RoaXMuZ2V0TW9kdWxlc0luQ29udGV4dChjb250ZXh0KTtcblx0XG5cdFx0XHRcdFx0XHRpZiAoX3RoaXMub3B0aW9ucy5sb2dzKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuaW5mbygnVmVhbXNNb2R1bGVzIDo6IFJlY29yZGluZyBuZXcgY29udGV4dC4gV2hlbiBhdmFpbGFibGUgbmV3IG1vZHVsZXMgd2lsbCBiZSBpbml0aWFsaXNlZCBpbjogJywgY29udGV4dCk7XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0X3RoaXMucmVnaXN0ZXJBbGwoKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdFx0Ly8gU1RBVElDIENBQ0hFIEhBTkRMRVJcblx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcblx0XHRcdC8qKlxuXHQgICAqIFNhdmUgdGhlIG1vZHVsZSBpbiBfX2NhY2hlLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IG1vZHVsZSAtIG1vZHVsZSBtZXRhZGF0YSBvYmplY3QgKEBzZWUgVmVhbXNDb21wb25lbnQubWV0YURhdGEoKSlcblx0ICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIG1vZHVsZSBlbGVtZW50ICh0aGlzLmVsKVxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZSAtIG1vZHVsZSBpbnN0YW5jZVxuXHQgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgLSBtb2R1bGUgbmFtZXNwYWNlXG5cdCAgICovXG5cdFxuXHRcdH0sIHtcblx0XHRcdGtleTogJ2JpbmRDb25kaXRpb25zJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiBiaW5kQ29uZGl0aW9ucygpIHtcblx0XHRcdFx0dmFyIF90aGlzMiA9IHRoaXM7XG5cdFxuXHRcdFx0XHRfX3JlZ2lzdGVyLm1vZHVsZXNPbkNvbmRpdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlKSB7XG5cdFx0XHRcdFx0aWYgKG1vZHVsZS5jb25kaXRpb25zTGlzdGVuT24gJiYgbW9kdWxlLmNvbmRpdGlvbnNMaXN0ZW5Pbi5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdF90aGlzMi5iaW5kQ29uZGl0aW9uKG1vZHVsZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdiaW5kQ29uZGl0aW9uJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiBiaW5kQ29uZGl0aW9uKG1vZHVsZSkge1xuXHRcdFx0XHR2YXIgX3RoaXMzID0gdGhpcztcblx0XG5cdFx0XHRcdHZhciBnbG9iYWxFdnRzID0gbW9kdWxlLmNvbmRpdGlvbnNMaXN0ZW5Pbi5qb2luKCcgJyk7XG5cdFxuXHRcdFx0XHRpZiAoVmVhbXMuVmVudCkge1xuXHRcdFx0XHRcdFZlYW1zLlZlbnQuc3Vic2NyaWJlKGdsb2JhbEV2dHMsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdF90aGlzMy5yZWdpc3RlckNvbmRpdGlvbmFsTW9kdWxlKG1vZHVsZSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHRcdC8vIFVOL1JFR0lTVEVSIEhBTkRMRVJcblx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcblx0XHRcdC8qKlxuXHQgICAqIFNwbGl0IHVwIG1vZHVsZXMgZGVwZW5kaW5nIG9uIGNvbmRpdGlvbiBjaGVja1xuXHQgICAqL1xuXHRcblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdzcGxpdFVwTW9kdWxlcycsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gc3BsaXRVcE1vZHVsZXMoKSB7XG5cdFx0XHRcdHZhciBfdGhpczQgPSB0aGlzO1xuXHRcblx0XHRcdFx0X19yZWdpc3Rlci5tb2R1bGVzSW5SZWdpc3Rlci5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0XHRpZiAoX3RoaXM0LmNvbnN0cnVjdG9yLmlzQ29uZGl0aW9uKG9iaikpIHtcblx0XHRcdFx0XHRcdF9fcmVnaXN0ZXIubW9kdWxlc09uQ29uZGl0aW9ucy5wdXNoKG9iaik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdF9fcmVnaXN0ZXIubW9kdWxlc09uSW5pdC5wdXNoKG9iaik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XG5cdFx0XHQvKipcblx0ICAgKiBSZWdpc3RlciBtdWx0aXBsZSBtb2R1bGVzLlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtBcnJheX0gYXJyIC0gQXJyYXkgd2hpY2ggY29udGFpbnMgdGhlIG1vZHVsZXMgYXMgb2JqZWN0LlxuXHQgICAqXG5cdCAgICogQHB1YmxpY1xuXHQgICAqL1xuXHRcblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdyZWdpc3RlcicsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIoYXJyKSB7XG5cdFx0XHRcdGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdWZWFtc01vZHVsZXMgOjogWW91IG5lZWQgdG8gcGFzcyBhbiBhcnJheSB0byByZWdpc3RlcigpIScpO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRfX3JlZ2lzdGVyLm1vZHVsZXNJblJlZ2lzdGVyID0gX19yZWdpc3Rlci5tb2R1bGVzSW5SZWdpc3Rlci5jb25jYXQoYXJyKTtcblx0XG5cdFx0XHRcdHRoaXMuc3BsaXRVcE1vZHVsZXMoKTtcblx0XHRcdFx0dGhpcy5iaW5kQ29uZGl0aW9ucygpO1xuXHRcdFx0XHR0aGlzLnJlZ2lzdGVyQWxsKCk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyoqXG5cdCAgICogUmVnaXN0ZXIgYWxsIG1vZHVsZXNcblx0ICAgKi9cblx0XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAncmVnaXN0ZXJBbGwnLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyQWxsKCkge1xuXHRcdFx0XHRpZiAoIV9fcmVnaXN0ZXIubW9kdWxlc0luUmVnaXN0ZXIpIHJldHVybjtcblx0XG5cdFx0XHRcdHRoaXMucmVnaXN0ZXJJbml0aWFsTW9kdWxlcygpO1xuXHRcdFx0XHR0aGlzLnJlZ2lzdGVyQ29uZGl0aW9uYWxNb2R1bGVzKCk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyoqXG5cdCAgICogUmVnaXN0ZXIgYWxsIGluaXRpYWwgbW9kdWxlc1xuXHQgICAqL1xuXHRcblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdyZWdpc3RlckluaXRpYWxNb2R1bGVzJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlckluaXRpYWxNb2R1bGVzKCkge1xuXHRcdFx0XHR2YXIgX3RoaXM1ID0gdGhpcztcblx0XG5cdFx0XHRcdF9fcmVnaXN0ZXIubW9kdWxlc09uSW5pdC5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0XHRfdGhpczUucmVnaXN0ZXJPbmUob2JqKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyoqXG5cdCAgICogUmVnaXN0ZXIgY29uZGl0aW9uYWwgbW9kdWxlc1xuXHQgICAqXG5cdCAgICogVGhlcmVmb3JlIHdlIGNoZWNrIHRoZSBjb25kaXRpb24gYW5kXG5cdCAgICogd2hlbiB0cnVlIHJlZ2lzdGVyIHRoZSBzcGVjaWZpYyBtb2R1bGVcblx0ICAgKiB3aGVuIGZhbHNlIHVucmVnaXN0ZXIgdGhlIHNwZWNpZmljIG1vZHVsZVxuXHQgICAqL1xuXHRcblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdyZWdpc3RlckNvbmRpdGlvbmFsTW9kdWxlcycsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJDb25kaXRpb25hbE1vZHVsZXMoKSB7XG5cdFx0XHRcdHZhciBfdGhpczYgPSB0aGlzO1xuXHRcblx0XHRcdFx0X19yZWdpc3Rlci5tb2R1bGVzT25Db25kaXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuXHRcdFx0XHRcdF90aGlzNi5yZWdpc3RlckNvbmRpdGlvbmFsTW9kdWxlKG9iaik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0sIHtcblx0XHRcdGtleTogJ3JlZ2lzdGVyQ29uZGl0aW9uYWxNb2R1bGUnLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyQ29uZGl0aW9uYWxNb2R1bGUob2JqKSB7XG5cdFx0XHRcdGlmICh0aGlzLmNvbnN0cnVjdG9yLm1ha2VDb25kaXRpb25DaGVjayhvYmopKSB7XG5cdFx0XHRcdFx0dGhpcy5yZWdpc3Rlck9uZShvYmopO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudW5yZWdpc3Rlck9uZShvYmopO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyoqXG5cdCAgICogUmVnaXN0ZXIgb25lIG1vZHVsZSBhbmQgaW5pdCB0aGUgZWxlbWVudHMgaW4gdGhlIHNwZWNpZmljIGNvbnRleHRcblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgLSBSZXF1aXJlZDogZWxlbWVudCBuYW1lIGluIERPTVxuXHQgICAqIEBwYXJhbSB7U3RyaW5nfSBkb21OYW1lIC0gUmVxdWlyZWQ6IGVsZW1lbnQgbmFtZSBpbiBET01cblx0ICAgKiBAcGFyYW0ge09iamVjdH0gbW9kdWxlIC0gUmVxdWlyZWQ6IGNsYXNzIHdoaWNoIHdpbGwgYmUgdXNlZCB0byByZW5kZXIgeW91ciBtb2R1bGVcblx0ICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW5kZXI9dHJ1ZV0gLSBPcHRpb25hbDogcmVuZGVyIHRoZSBjbGFzcywgaWYgZmFsc2UgdGhlIGNsYXNzIHdpbGwgb25seSBiZSBpbml0aWFsaXplZFxuXHQgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYl0gLSBPcHRpb25hbDogcHJvdmlkZSBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgaW5pdGlhbGlzYXRpb25cblx0ICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uYWw6IFlvdSBjYW4gcGFzcyBvcHRpb25zIHRvIHRoZSBtb2R1bGUgdmlhIEpTIChVc2VmdWwgZm9yIERPTUNoYW5nZWQpXG5cdCAgICpcblx0ICAgKi9cblx0XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAncmVnaXN0ZXJPbmUnLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyT25lKF9yZWYpIHtcblx0XHRcdFx0dmFyIG5hbWVzcGFjZSA9IF9yZWYubmFtZXNwYWNlLFxuXHRcdFx0XHQgICAgZG9tTmFtZSA9IF9yZWYuZG9tTmFtZSxcblx0XHRcdFx0ICAgIG1vZHVsZSA9IF9yZWYubW9kdWxlLFxuXHRcdFx0XHQgICAgcmVuZGVyID0gX3JlZi5yZW5kZXIsXG5cdFx0XHRcdCAgICBjYiA9IF9yZWYuY2IsXG5cdFx0XHRcdCAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuXHRcblx0XHRcdFx0dmFyIG5hbWVTcGFjZSA9IG5hbWVzcGFjZSA/IG5hbWVzcGFjZSA6IGRvbU5hbWU7XG5cdFxuXHRcdFx0XHRpZiAoIW1vZHVsZSkgdGhyb3cgbmV3IEVycm9yKCdWZWFtc01vZHVsZXMgOjogSW4gb3JkZXIgdG8gd29yayB3aXRoIHJlZ2lzdGVyKCkgeW91IG5lZWQgdG8gZGVmaW5lIGEgbW9kdWxlIScpO1xuXHRcdFx0XHRpZiAoIW5hbWVTcGFjZSkgdGhyb3cgbmV3IEVycm9yKCdWZWFtc01vZHVsZXMgOjogSW4gb3JkZXIgdG8gd29yayB3aXRoIHJlZ2lzdGVyKCkgeW91IG5lZWQgdG8gZGVmaW5lIGEgbW9kdWxlIScpO1xuXHRcblx0XHRcdFx0dGhpcy5pbml0TW9kdWxlcyh7XG5cdFx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lU3BhY2UsXG5cdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGUsXG5cdFx0XHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHRcdFx0Y2I6IGNiLFxuXHRcdFx0XHRcdG9wdGlvbnM6IG9wdGlvbnNcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAndW5yZWdpc3Rlck9uZScsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gdW5yZWdpc3Rlck9uZShfcmVmMikge1xuXHRcdFx0XHR2YXIgbmFtZXNwYWNlID0gX3JlZjIubmFtZXNwYWNlO1xuXHRcblx0XHRcdFx0aWYgKHRoaXMuY29uc3RydWN0b3IuY2hlY2tNb2R1bGVJbkNhY2hlKG5hbWVzcGFjZSwgJ25hbWVzcGFjZScpID09PSB0cnVlKSB7XG5cdFx0XHRcdFx0dGhpcy5jb25zdHJ1Y3Rvci5yZW1vdmVGcm9tQ2FjaGVCeUtleShuYW1lc3BhY2UsICduYW1lc3BhY2UnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcblx0XHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdFx0Ly8gSU5JVCBIQU5ETEVSXG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XG5cdFx0XHQvKipcblx0ICAgKiBJbml0aWFsaXplIGEgbW9kdWxlIGFuZCByZW5kZXIgaXQgYW5kL29yIHByb3ZpZGUgYSBjYWxsYmFjayBmdW5jdGlvblxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVzcGFjZSAtIFJlcXVpcmVkOiBkb20gbmFtZSBvZiB0aGUgZWxlbWVudFxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2R1bGUgLSBSZXF1aXJlZDogY2xhc3Mgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIHJlbmRlciB5b3VyIG1vZHVsZVxuXHQgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbmRlcj10cnVlXSAtIE9wdGlvbmFsOiByZW5kZXIgdGhlIGNsYXNzLCBpZiBmYWxzZSB0aGUgY2xhc3Mgd2lsbCBvbmx5IGJlIGluaXRpYWxpemVkXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsOiBZb3UgY2FuIHBhc3Mgb3B0aW9ucyB0byB0aGUgbW9kdWxlIHZpYSBKUyAoVXNlZnVsIGZvciBET01DaGFuZ2VkKVxuXHQgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYl0gLSBPcHRpb25hbDogcHJvdmlkZSBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgaW5pdGlhbGlzYXRpb25cblx0ICAgKlxuXHQgICAqL1xuXHRcblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdpbml0TW9kdWxlcycsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gaW5pdE1vZHVsZXMoX3JlZjMpIHtcblx0XHRcdFx0dmFyIF90aGlzNyA9IHRoaXM7XG5cdFxuXHRcdFx0XHR2YXIgbmFtZXNwYWNlID0gX3JlZjMubmFtZXNwYWNlLFxuXHRcdFx0XHQgICAgbW9kdWxlID0gX3JlZjMubW9kdWxlLFxuXHRcdFx0XHQgICAgcmVuZGVyID0gX3JlZjMucmVuZGVyLFxuXHRcdFx0XHQgICAgb3B0aW9ucyA9IF9yZWYzLm9wdGlvbnMsXG5cdFx0XHRcdCAgICBjYiA9IF9yZWYzLmNiO1xuXHRcblx0XHRcdFx0VmVhbXMuaGVscGVycy5mb3JFYWNoKF9fcmVnaXN0ZXIubW9kdWxlc0luQ29udGV4dCwgZnVuY3Rpb24gKGksIGVsKSB7XG5cdFx0XHRcdFx0X3RoaXM3LmluaXRNb2R1bGUoe1xuXHRcdFx0XHRcdFx0ZWw6IGVsLFxuXHRcdFx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UsXG5cdFx0XHRcdFx0XHRvcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGUsXG5cdFx0XHRcdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdFx0XHRcdGNiOiBjYlxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdpbml0TW9kdWxlJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiBpbml0TW9kdWxlKF9yZWY0KSB7XG5cdFx0XHRcdHZhciBlbCA9IF9yZWY0LmVsLFxuXHRcdFx0XHQgICAgbmFtZXNwYWNlID0gX3JlZjQubmFtZXNwYWNlLFxuXHRcdFx0XHQgICAgb3B0aW9ucyA9IF9yZWY0Lm9wdGlvbnMsXG5cdFx0XHRcdCAgICBtb2R1bGUgPSBfcmVmNC5tb2R1bGUsXG5cdFx0XHRcdCAgICByZW5kZXIgPSBfcmVmNC5yZW5kZXIsXG5cdFx0XHRcdCAgICBjYiA9IF9yZWY0LmNiO1xuXHRcblx0XHRcdFx0dmFyIG5vUmVuZGVyID0gZWwuZ2V0QXR0cmlidXRlKHRoaXMub3B0aW9ucy5hdHRyUHJlZml4ICsgJy1uby1yZW5kZXInKSB8fCByZW5kZXIgPT09IGZhbHNlIHx8IGZhbHNlO1xuXHRcdFx0XHR2YXIgZGF0YU1vZHVsZXMgPSBlbC5nZXRBdHRyaWJ1dGUodGhpcy5vcHRpb25zLmF0dHJQcmVmaXggKyAnLScgKyB0aGlzLm9wdGlvbnMuYXR0ck5hbWUpLnNwbGl0KCcgJyk7XG5cdFxuXHRcdFx0XHRpZiAoZGF0YU1vZHVsZXMuaW5kZXhPZihuYW1lc3BhY2UpICE9PSAtMSkge1xuXHRcdFx0XHRcdC8vIENoZWNrIGluaXQgc3RhdGVcblx0XHRcdFx0XHRpZiAodGhpcy5jb25zdHJ1Y3Rvci5jaGVja01vZHVsZUluQ2FjaGUoZWwsICdlbGVtZW50JywgbmFtZXNwYWNlKSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5pbmZvKCdWZWFtc01vZHVsZXMgOjogRWxlbWVudCBpcyBhbHJlYWR5IGluIGNhY2hlIGFuZCBpbml0aWFsaXplZDogJyk7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhlbCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHQvLyBHbyBhaGVhZCB3aGVuIGNvbmRpdGlvbiBpcyB0cnVlXG5cdFx0XHRcdFx0dmFyIGF0dHJzID0gZWwuZ2V0QXR0cmlidXRlKHRoaXMub3B0aW9ucy5hdHRyUHJlZml4ICsgJy0nICsgdGhpcy5vcHRpb25zLmF0dHJPcHRpb25zKTtcblx0XHRcdFx0XHR2YXIgbWVyZ2VkT3B0aW9ucyA9IFZlYW1zLmhlbHBlcnMuZXh0ZW5kKEpTT04ucGFyc2UoYXR0cnMpLCBvcHRpb25zIHx8IHt9KTtcblx0XHRcdFx0XHR2YXIgTW9kdWxlID0gbW9kdWxlO1xuXHRcdFx0XHRcdHZhciBpbnN0YW5jZSA9IG5ldyBNb2R1bGUoe1xuXHRcdFx0XHRcdFx0ZWw6IGVsLFxuXHRcdFx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2UsXG5cdFx0XHRcdFx0XHRvcHRpb25zOiBtZXJnZWRPcHRpb25zLFxuXHRcdFx0XHRcdFx0YXBwSW5zdGFuY2U6IFZlYW1zXG5cdFx0XHRcdFx0fSk7XG5cdFxuXHRcdFx0XHRcdHRoaXMuY29uc3RydWN0b3IuYWRkVG9DYWNoZSh7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiBlbCxcblx0XHRcdFx0XHRcdG1vZHVsZTogbW9kdWxlLFxuXHRcdFx0XHRcdFx0aW5zdGFuY2U6IGluc3RhbmNlLFxuXHRcdFx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2Vcblx0XHRcdFx0XHR9KTtcblx0XG5cdFx0XHRcdFx0Ly8gTW91bnQgcHJvY2Vzc1xuXHRcdFx0XHRcdGlmIChpbnN0YW5jZS53aWxsTW91bnQpIGluc3RhbmNlLndpbGxNb3VudCgpO1xuXHRcblx0XHRcdFx0XHQvLyBSZW5kZXIgYWZ0ZXIgaW5pdGlhbCBtb2R1bGUgbG9hZGluZ1xuXHRcdFx0XHRcdGlmICghbm9SZW5kZXIpIGluc3RhbmNlLnJlbmRlcigpO1xuXHRcblx0XHRcdFx0XHQvLyBQcm92aWRlIGNhbGxiYWNrIGZ1bmN0aW9uIGluIHdoaWNoIHlvdSBjYW4gdXNlIG1vZHVsZSBhbmQgb3B0aW9uc1xuXHRcdFx0XHRcdGlmIChjYiAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIGNiKG1vZHVsZSwgbWVyZ2VkT3B0aW9ucyk7XG5cdFxuXHRcdFx0XHRcdC8vIE1vdW50IHByb2Nlc3Ncblx0XHRcdFx0XHRpZiAoaW5zdGFuY2UuZGlkTW91bnQpIGluc3RhbmNlLmRpZE1vdW50KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XG5cdFx0XHQvKipcblx0ICAgKiBBZGQgbXV0YXRpb24gb2JzZXJ2ZXIgdG8gb2JzZXJ2ZSBuZXcgbW9kdWxlcy5cblx0ICAgKlxuXHQgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IC0gQ29udGV4dCBmb3IgdGhlIG11dGF0aW9uIG9ic2VydmVyXG5cdCAgICpcblx0ICAgKiBUT0RPOiBJbXByb3ZlIGZvciBsb29wc1xuXHQgICAqL1xuXHRcblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdvYnNlcnZlJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiBvYnNlcnZlKGNvbnRleHQpIHtcblx0XHRcdFx0dmFyIF90aGlzOCA9IHRoaXM7XG5cdFxuXHRcdFx0XHR2YXIgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7XG5cdFx0XHRcdFx0Ly8gbG9vayB0aHJvdWdoIGFsbCBtdXRhdGlvbnMgdGhhdCBqdXN0IG9jY3VyZWRcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHRcdFx0Ly8gbG9vayB0aHJvdWdoIGFsbCBhZGRlZCBub2RlcyBvZiB0aGlzIG11dGF0aW9uXG5cdFxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBtdXRhdGlvbnNbaV0uYWRkZWROb2Rlcy5sZW5ndGg7ICsraikge1xuXHRcdFx0XHRcdFx0XHR2YXIgYWRkZWROb2RlID0gbXV0YXRpb25zW2ldLmFkZGVkTm9kZXNbal07XG5cdFxuXHRcdFx0XHRcdFx0XHRpZiAoYWRkZWROb2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoYWRkZWROb2RlLmdldEF0dHJpYnV0ZShfdGhpczgub3B0aW9ucy5hdHRyUHJlZml4ICsgJy0nICsgX3RoaXM4Lm9wdGlvbnMuYXR0ck5hbWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgbmFtZXNwYWNlID0gYWRkZWROb2RlLmdldEF0dHJpYnV0ZShfdGhpczgub3B0aW9ucy5hdHRyUHJlZml4ICsgJy0nICsgX3RoaXM4Lm9wdGlvbnMuYXR0ck5hbWUpO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChfdGhpczgub3B0aW9ucy5sb2dzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUuaW5mbygnVmVhbXNNb2R1bGVzIDo6IFJlY29yZGluZyBhIG5ldyBtb2R1bGUgd2l0aCB0aGUgbmFtZXNwYWNlICcgKyBuYW1lc3BhY2UgKyAnIGF0OiAnLCBhZGRlZE5vZGUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZvciAodmFyIF9pdGVyYXRvciA9IF9fcmVnaXN0ZXIubW9kdWxlc0luUmVnaXN0ZXJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIG1vZHVsZSA9IF9zdGVwLnZhbHVlO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAobW9kdWxlLm5hbWVzcGFjZSA9PT0gbmFtZXNwYWNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRfdGhpczguaW5pdE1vZHVsZSh7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGVsOiBhZGRlZE5vZGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZTogbW9kdWxlLm1vZHVsZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmFtZXNwYWNlOiBtb2R1bGUubmFtZXNwYWNlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF9pdGVyYXRvckVycm9yID0gZXJyO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0X2l0ZXJhdG9yLnJldHVybigpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRocm93IF9pdGVyYXRvckVycm9yO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRcdFx0aWYgKF90aGlzOC5nZXRNb2R1bGVzSW5Db250ZXh0KGFkZGVkTm9kZSkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRfX3JlZ2lzdGVyLm1vZHVsZXNJbkNvbnRleHQgPSBfdGhpczguZ2V0TW9kdWxlc0luQ29udGV4dChhZGRlZE5vZGUpO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChfdGhpczgub3B0aW9ucy5sb2dzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUuaW5mbygnVmVhbXNNb2R1bGVzIDo6IFJlY29yZGluZyBuZXcgY29udGV4dC4gV2hlbiBhdmFpbGFibGUgbmV3IG1vZHVsZXMgd2lsbCBiZSBpbml0aWFsaXNlZCBpbjogJywgYWRkZWROb2RlKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRfdGhpczgucmVnaXN0ZXJBbGwoKTtcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRfX3JlZ2lzdGVyLm1vZHVsZXNJbkNvbnRleHQgPSBfdGhpczguZ2V0TW9kdWxlc0luQ29udGV4dChkb2N1bWVudCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0Zm9yICh2YXIgX2ogPSAwOyBfaiA8IG11dGF0aW9uc1tpXS5yZW1vdmVkTm9kZXMubGVuZ3RoOyArK19qKSB7XG5cdFx0XHRcdFx0XHRcdHZhciByZW1vdmVkTm9kZSA9IG11dGF0aW9uc1tpXS5yZW1vdmVkTm9kZXNbX2pdO1xuXHRcblx0XHRcdFx0XHRcdFx0aWYgKHJlbW92ZWROb2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAocmVtb3ZlZE5vZGUuZ2V0QXR0cmlidXRlKF90aGlzOC5vcHRpb25zLmF0dHJQcmVmaXggKyAnLScgKyBfdGhpczgub3B0aW9ucy5hdHRyTmFtZSkpIHtcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoX3RoaXM4Lm9wdGlvbnMubG9ncykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb25zb2xlLmluZm8oJ1ZlYW1zTW9kdWxlcyA6OiBSZWNvcmRpbmcgZGVsZXRpb24gb2YgbW9kdWxlOiAnLCByZW1vdmVkTm9kZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0XHRcdFx0X3RoaXM4LmNvbnN0cnVjdG9yLnJlbW92ZUZyb21DYWNoZUJ5S2V5KHJlbW92ZWROb2RlKTtcblx0XG5cdFx0XHRcdFx0XHRcdFx0XHRfX3JlZ2lzdGVyLm1vZHVsZXNJbkNvbnRleHQgPSBfdGhpczguZ2V0TW9kdWxlc0luQ29udGV4dChkb2N1bWVudCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0XHRpZiAoX3RoaXM4LmdldE1vZHVsZXNJbkNvbnRleHQocmVtb3ZlZE5vZGUpLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0X19yZWdpc3Rlci5tb2R1bGVzSW5Db250ZXh0ID0gX3RoaXM4LmdldE1vZHVsZXNJbkNvbnRleHQocmVtb3ZlZE5vZGUpO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChfdGhpczgub3B0aW9ucy5sb2dzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnNvbGUuaW5mbygnVmVhbXNNb2R1bGVzIDo6IFJlY29yZGluZyBkZWxldGlvbiBvZiBET00gZWxlbWVudC4gV2hlbiBhdmFpbGFibGUgbW9kdWxlcyB3aWxsIGJlIHVuYm91bmQgaW4gJywgcmVtb3ZlZE5vZGUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcblx0XHRcdFx0XHRcdFx0XHRcdF9fcmVnaXN0ZXIubW9kdWxlc0luQ29udGV4dC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdF90aGlzOC5jb25zdHJ1Y3Rvci5yZW1vdmVGcm9tQ2FjaGVCeUtleShub2RlKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcblx0XHRcdFx0XHRcdFx0XHRcdF9fcmVnaXN0ZXIubW9kdWxlc0luQ29udGV4dCA9IF90aGlzOC5nZXRNb2R1bGVzSW5Db250ZXh0KGRvY3VtZW50KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcblx0XHRcdFx0b2JzZXJ2ZXIub2JzZXJ2ZShjb250ZXh0LCB7XG5cdFx0XHRcdFx0Y2hpbGRMaXN0OiB0cnVlLFxuXHRcdFx0XHRcdHN1YnRyZWU6IHRydWVcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFxuXHRcdFx0LyoqXG5cdCAgICogR2V0IE1vZHVsZXMgaW4gYSBzcGVjaWZpYyBjb250ZXh0LlxuXHQgICAqXG5cdCAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgLSBDb250ZXh0IGZvciBxdWVyeSBzcGVjaWZpYyBzdHJpbmdcblx0ICAgKi9cblx0XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAnZ2V0TW9kdWxlc0luQ29udGV4dCcsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gZ2V0TW9kdWxlc0luQ29udGV4dChjb250ZXh0KSB7XG5cdFx0XHRcdHJldHVybiBWZWFtcy5oZWxwZXJzLnF1ZXJ5U2VsZWN0b3JBcnJheSh0aGlzLnF1ZXJ5U3RyaW5nLCBjb250ZXh0KTtcblx0XHRcdH1cblx0XHR9XSwgW3tcblx0XHRcdGtleTogJ2FkZFRvQ2FjaGUnLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIGFkZFRvQ2FjaGUoX3JlZjUpIHtcblx0XHRcdFx0dmFyIG1vZHVsZSA9IF9yZWY1Lm1vZHVsZSxcblx0XHRcdFx0ICAgIGVsZW1lbnQgPSBfcmVmNS5lbGVtZW50LFxuXHRcdFx0XHQgICAgaW5zdGFuY2UgPSBfcmVmNS5pbnN0YW5jZSxcblx0XHRcdFx0ICAgIG5hbWVzcGFjZSA9IF9yZWY1Lm5hbWVzcGFjZTtcblx0XG5cdFx0XHRcdF9fY2FjaGUucHVzaCh7XG5cdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGUsXG5cdFx0XHRcdFx0ZWxlbWVudDogZWxlbWVudCxcblx0XHRcdFx0XHRpbnN0YW5jZTogaW5zdGFuY2UsXG5cdFx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2Vcblx0XHRcdFx0fSk7XG5cdFxuXHRcdFx0XHRpZiAoVmVhbXMuVmVudCAmJiBWZWFtcy5FVkVOVFMubW9kdWxlQ2FjaGVkKSB7XG5cdFx0XHRcdFx0VmVhbXMuVmVudC50cmlnZ2VyKFZlYW1zLkVWRU5UUy5tb2R1bGVDYWNoZWQsIHtcblx0XHRcdFx0XHRcdG1vZHVsZTogbW9kdWxlLFxuXHRcdFx0XHRcdFx0ZWxlbWVudDogZWxlbWVudFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAncmVtb3ZlRnJvbUNhY2hlQnlLZXknLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUZyb21DYWNoZUJ5S2V5KG9iaikge1xuXHRcdFx0XHR2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnZWxlbWVudCc7XG5cdFxuXHRcdFx0XHR2YXIgZGVsZXRlSW5kZXggPSB2b2lkIDA7XG5cdFxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IF9fY2FjaGUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgY2FjaGVJdGVtID0gX19jYWNoZVtpXTtcblx0XG5cdFx0XHRcdFx0aWYgKGNhY2hlSXRlbVtrZXldID09PSBvYmopIHtcblx0XHRcdFx0XHRcdGlmIChjYWNoZUl0ZW0uaW5zdGFuY2Uud2lsbFVubW91bnQpIGNhY2hlSXRlbS5pbnN0YW5jZS53aWxsVW5tb3VudCgpO1xuXHRcdFx0XHRcdFx0aWYgKGNhY2hlSXRlbS5pbnN0YW5jZS51bnJlZ2lzdGVyRXZlbnRzKSBjYWNoZUl0ZW0uaW5zdGFuY2UudW5yZWdpc3RlckV2ZW50cygpO1xuXHRcdFx0XHRcdFx0aWYgKGNhY2hlSXRlbS5pbnN0YW5jZS5kaWRVbm1vdW50KSBjYWNoZUl0ZW0uaW5zdGFuY2UuZGlkVW5tb3VudCgpO1xuXHRcblx0XHRcdFx0XHRcdGRlbGV0ZUluZGV4ID0gaTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGlmIChkZWxldGVJbmRleCkgX19jYWNoZS5zcGxpY2UoZGVsZXRlSW5kZXgsIDEpO1xuXHRcdFx0fVxuXHRcdH0sIHtcblx0XHRcdGtleTogJ2NoZWNrTW9kdWxlSW5DYWNoZScsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gY2hlY2tNb2R1bGVJbkNhY2hlKG9iaikge1xuXHRcdFx0XHR2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnZWxlbWVudCc7XG5cdFx0XHRcdHZhciBuYW1lc3BhY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcblx0XG5cdFx0XHRcdHZhciBzdGF0ZSA9IGZhbHNlO1xuXHRcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBfX2NhY2hlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlSXRlbSA9IF9fY2FjaGVbaV07XG5cdFxuXHRcdFx0XHRcdHN0YXRlID0gbmFtZXNwYWNlICE9PSB1bmRlZmluZWQgPyBjYWNoZUl0ZW1ba2V5XSA9PT0gb2JqICYmIGNhY2hlSXRlbS5uYW1lc3BhY2UgPT09IG5hbWVzcGFjZSA6IGNhY2hlSXRlbVtrZXldID09PSBvYmo7XG5cdFxuXHRcdFx0XHRcdGlmIChzdGF0ZSkgYnJlYWs7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdH1cblx0XG5cdFx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHRcdC8vIENPTkRJVElPTlMgSEFORExFUlxuXHRcdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFxuXHRcdH0sIHtcblx0XHRcdGtleTogJ2lzQ29uZGl0aW9uJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiBpc0NvbmRpdGlvbihfcmVmNikge1xuXHRcdFx0XHR2YXIgY29uZGl0aW9ucyA9IF9yZWY2LmNvbmRpdGlvbnM7XG5cdFxuXHRcdFx0XHRyZXR1cm4gY29uZGl0aW9ucyAmJiB0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ2Z1bmN0aW9uJztcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdtYWtlQ29uZGl0aW9uQ2hlY2snLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIG1ha2VDb25kaXRpb25DaGVjayhfcmVmNykge1xuXHRcdFx0XHR2YXIgY29uZGl0aW9ucyA9IF9yZWY3LmNvbmRpdGlvbnM7XG5cdFxuXHRcdFx0XHRpZiAoY29uZGl0aW9ucyAmJiB0eXBlb2YgY29uZGl0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdHJldHVybiBjb25kaXRpb25zKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XSk7XG5cdFxuXHRcdHJldHVybiBNb2R1bGVzO1xuXHR9KCk7XG5cdFxuXHQvKipcblx0ICogUGx1Z2luIG9iamVjdFxuXHQgKi9cblx0XG5cdFxuXHR2YXIgVmVhbXNNb2R1bGVzID0ge1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdERFQlVHOiBmYWxzZSxcblx0XHRcdGF0dHJQcmVmaXg6ICdkYXRhLWpzJyxcblx0XHRcdGF0dHJOYW1lOiAnbW9kdWxlJyxcblx0XHRcdGF0dHJPcHRpb25zOiAnb3B0aW9ucycsXG5cdFx0XHRsb2dzOiBmYWxzZSxcblx0XHRcdGludGVybmFsQ2FjaGVPbmx5OiB0cnVlLFxuXHRcdFx0aW50ZXJuYWxSZWdpc3Rlck9ubHk6IGZhbHNlLFxuXHRcdFx0dXNlTXV0YXRpb25PYnNlcnZlcjogZmFsc2Vcblx0XHR9LFxuXHRcdHBsdWdpbk5hbWU6ICdNb2R1bGVzSGFuZGxlcicsXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShWZWFtcywgb3B0cykge1xuXHRcdFx0dGhpcy5vcHRpb25zID0gVmVhbXMuaGVscGVycy5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRzIHx8IHt9KTtcblx0XHRcdFZlYW1zLm1vZHVsZXMgPSBWZWFtcy5tb2R1bGVzIHx8IG5ldyBNb2R1bGVzKFZlYW1zLCB0aGlzLm9wdGlvbnMpO1xuXHRcdH1cblx0fTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IFZlYW1zTW9kdWxlcztcblx0ZXhwb3J0cy5Nb2R1bGVzID0gTW9kdWxlcztcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJpbmRleFwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJpbmRleFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJpbmRleFwiXSA9IHJvb3RbXCJpbmRleFwiXSB8fCB7fSwgcm9vdFtcImluZGV4XCJdW1wiaW5kZXhcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0LyoqXG5cdCAqIFJlcHJlc2VudHMgdGhlIFRlbXBsYXRlciBjbGFzcyB3aGljaCB3aWxsIGJlIHVzZWQgaW4gVmVhbXNUZW1wbGF0ZXIgcGx1Z2luLlxuXHQgKiBAbW9kdWxlIFRlbXBsYXRlclxuXHQgKlxuXHQgKiBAYXV0aG9yIFNlYmFzdGlhbiBGaXR6bmVyXG5cdCAqL1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0dmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHR2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdHZhciBWZWFtcyA9IHt9O1xuXHRcblx0dmFyIFRlbXBsYXRlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRmdW5jdGlvbiBUZW1wbGF0ZXIoKSB7XG5cdFx0XHR2YXIgVkVBTVMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHdpbmRvdy5WZWFtcztcblx0XHRcdHZhciBfcmVmID0gYXJndW1lbnRzWzFdO1xuXHRcdFx0dmFyIGVuZ2luZSA9IF9yZWYuZW5naW5lLFxuXHRcdFx0ICAgIHRlbXBsYXRlcyA9IF9yZWYudGVtcGxhdGVzLFxuXHRcdFx0ICAgIHBhcnRpYWxzID0gX3JlZi5wYXJ0aWFscyxcblx0XHRcdCAgICBoZWxwZXJzID0gX3JlZi5oZWxwZXJzO1xuXHRcblx0XHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZW1wbGF0ZXIpO1xuXHRcblx0XHRcdFZlYW1zID0gVkVBTVM7XG5cdFxuXHRcdFx0aWYgKCF0ZW1wbGF0ZXMpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVmVhbXNUZW1wbGF0ZXIgOjogWW91IG5lZWQgdG8gcGFzcyBhbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgeW91ciB0ZW1wbGF0ZXMgKG9iai50ZW1wbGF0ZXMpIScpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFxuXHRcdFx0aWYgKCFlbmdpbmUpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignVmVhbXNUZW1wbGF0ZXIgOjogWW91IG5lZWQgdG8gcGFzcyBhIGhhbmRsZWJhcnMgaW5zdGFuY2UgYnkgcHJvdmlkaW5nIG9iai5lbmdpbmUhJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSB7XG5cdFx0XHRcdG5hbWVzcGFjZTogVmVhbXMub3B0aW9ucy5uYW1lc3BhY2UsXG5cdFx0XHRcdGVuZ2luZTogZW5naW5lLFxuXHRcdFx0XHR0ZW1wbGF0ZXM6IHRlbXBsYXRlcyxcblx0XHRcdFx0cGFydGlhbHM6IHBhcnRpYWxzLFxuXHRcdFx0XHRoZWxwZXJzOiBoZWxwZXJzXG5cdFx0XHR9O1xuXHRcblx0XHRcdHRoaXMuaW5pdGlhbGl6ZSgpO1xuXHRcdH1cblx0XG5cdFx0X2NyZWF0ZUNsYXNzKFRlbXBsYXRlciwgW3tcblx0XHRcdGtleTogJ2luaXRpYWxpemUnLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG5cdFx0XHRcdGlmICh0aGlzLm9wdGlvbnMuaGVscGVycykge1xuXHRcdFx0XHRcdHRoaXMucmVnaXN0ZXJIZWxwZXJzKCk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdHRoaXMuYWRkVGVtcGxhdGVyKCk7XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAncmVnaXN0ZXJIZWxwZXJzJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlckhlbHBlcnMoKSB7XG5cdFx0XHRcdGlmICghQXJyYXkuaXNBcnJheSh0aGlzLm9wdGlvbnMuaGVscGVycykpIHtcblx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdWZWFtc1RlbXBsYXRlciA6OiBZb3UgbmVlZCB0byBwYXNzIHRoZSBoZWxwZXJzIGFzIGFuIGFycmF5IScpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMuaGVscGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHZhciBoZWxwZXIgPSB0aGlzLm9wdGlvbnMuaGVscGVyc1tpXTtcblx0XG5cdFx0XHRcdFx0aWYgKGhlbHBlci5yZWdpc3Rlcikge1xuXHRcdFx0XHRcdFx0dGhpcy5vcHRpb25zLmVuZ2luZS5yZWdpc3RlckhlbHBlcihoZWxwZXIucmVnaXN0ZXIodGhpcy5vcHRpb25zLmVuZ2luZSkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdWZWFtc1RlbXBsYXRlciA6OiBZb3VyIGhlbHBlciBkb2VzIG5vdCBoYXZlIGEgcmVnaXN0ZXIgZnVuY3Rpb24sIHNlZTogJyArIGhlbHBlcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAnYWRkVGVtcGxhdGVyJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiBhZGRUZW1wbGF0ZXIoKSB7XG5cdFx0XHRcdGlmIChWZWFtcy50ZW1wbGF0ZXIpIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ0l0IHNlZW1zIHRoYXQgeW91IGFyZSBhbHJlYWR5IHVzaW5nIFZlYW1zLnRlbXBsYXRlciEgVmVhbXMgaXMgb3ZlcnJpZGluZyBpdCBub3chJyk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdFZlYW1zLnRlbXBsYXRlciA9IHtcblx0XHRcdFx0XHRlbmdpbmU6IHRoaXMub3B0aW9ucy5lbmdpbmUsXG5cdFx0XHRcdFx0dGVtcGxhdGVzOiB0aGlzLm9wdGlvbnMudGVtcGxhdGVzKHRoaXMub3B0aW9ucy5lbmdpbmUpLFxuXHRcdFx0XHRcdHBhcnRpYWxzOiB0aGlzLm9wdGlvbnMucGFydGlhbHMgPyB0aGlzLm9wdGlvbnMucGFydGlhbHModGhpcy5vcHRpb25zLmVuZ2luZSkgOiB7fSxcblx0XHRcdFx0XHRoZWxwZXJzOiB0aGlzLm9wdGlvbnMuaGVscGVycyxcblx0XHRcdFx0XHRyZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcih0cGxOYW1lLCBkYXRhKSB7XG5cdFx0XHRcdFx0XHRpZiAoIWRhdGEgJiYgVmVhbXMudGVtcGxhdGVyLnRlbXBsYXRlc1t0cGxOYW1lXSkge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdWZWFtc1RlbXBsYXRlciA6OiBZb3UgbmVlZCB0byBwcm92aWRlIHNvbWUgZGF0YSBmb3IgJyArIHRwbE5hbWUgKyAnLicpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFxuXHRcdFx0XHRcdFx0aWYgKCFWZWFtcy50ZW1wbGF0ZXIudGVtcGxhdGVzW3RwbE5hbWVdKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ1ZlYW1zVGVtcGxhdGVyIDo6IFRlbXBsYXRlICcgKyB0cGxOYW1lICsgJyBub3QgZm91bmQuJyk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0XHRyZXR1cm4gVmVhbXMudGVtcGxhdGVyLnRlbXBsYXRlc1t0cGxOYW1lXShkYXRhKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fV0pO1xuXHRcblx0XHRyZXR1cm4gVGVtcGxhdGVyO1xuXHR9KCk7XG5cdFxuXHQvKipcblx0ICogUmVwcmVzZW50cyBhIHRlbXBsYXRlciBwbHVnaW4gd2hpY2ggeW91IGNhbiB1c2UgdG8gcmVuZGVyIHlvdXIgcHJlY29tcGlsZWQgaGFuZGxlYmFycyB0ZW1wbGF0ZXMuXG5cdCAqIFlvdSBjYW4gYWxzbyByZWdpc3RlciBjdXN0b20gaGVscGVycyBieSBwcm92aWRpbmcgdGhlbSBpbiBhbiBhcnJheSFcblx0ICpcblx0ICogQG1vZHVsZSBWZWFtc1RlbXBsYXRlclxuXHQgKlxuXHQgKiBAYXV0aG9yIFNlYmFzdGlhbiBGaXR6bmVyXG5cdCAqL1xuXHRcblx0XG5cdHZhciBWZWFtc1RlbXBsYXRlciA9IHtcblx0XHRvcHRpb25zOiB7XG5cdFx0XHRlbmdpbmU6IGZ1bmN0aW9uIGVuZ2luZSgpIHt9LFxuXHRcdFx0dGVtcGxhdGVzOiBmdW5jdGlvbiB0ZW1wbGF0ZXMoKSB7fSxcblx0XHRcdHBhcnRpYWxzOiBmdW5jdGlvbiBwYXJ0aWFscygpIHt9LFxuXHRcdFx0aGVscGVyczogW11cblx0XHR9LFxuXHRcdHBsdWdpbk5hbWU6ICdUZW1wbGF0ZXInLFxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUoVmVhbXMsIF9yZWYyKSB7XG5cdFx0XHR2YXIgZW5naW5lID0gX3JlZjIuZW5naW5lLFxuXHRcdFx0ICAgIHRlbXBsYXRlcyA9IF9yZWYyLnRlbXBsYXRlcyxcblx0XHRcdCAgICBwYXJ0aWFscyA9IF9yZWYyLnBhcnRpYWxzLFxuXHRcdFx0ICAgIGhlbHBlcnMgPSBfcmVmMi5oZWxwZXJzO1xuXHRcblx0XHRcdG5ldyBUZW1wbGF0ZXIoVmVhbXMsIHtcblx0XHRcdFx0ZW5naW5lOiBlbmdpbmUsXG5cdFx0XHRcdHRlbXBsYXRlczogdGVtcGxhdGVzLFxuXHRcdFx0XHRwYXJ0aWFsczogcGFydGlhbHMsXG5cdFx0XHRcdGhlbHBlcnM6IGhlbHBlcnNcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IFZlYW1zVGVtcGxhdGVyO1xuXHRleHBvcnRzLlRlbXBsYXRlciA9IFRlbXBsYXRlcjtcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJpbmRleFwiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJpbmRleFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJpbmRleFwiXSA9IHJvb3RbXCJpbmRleFwiXSB8fCB7fSwgcm9vdFtcImluZGV4XCJdW1wiaW5kZXhcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBSZXByZXNlbnRzIGEgVmVudCBwbHVnaW4gd2hpY2ggY3JlYXRlcyBhbiBlbXB0eSBvYmplY3QuXG5cdCAqIFRoZSBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIHB1Ymxpc2gvc3Vic2NyaWJlIHBsdWdpbi5cblx0ICpcblx0ICogVGhlIG1vZHVsZSBleHRlbmRzIHRoZSBkZWZhdWx0IEVWRU5UUyBvYmplY3Qgb2YgVmVhbXNcblx0ICogd2hlbiB5b3UgcGFzcyB0aGUgb3B0aW9uIGNhbGxlZCAnZnVydGhlckV2ZW50cycuXG5cdCAqXG5cdCAqIEBtb2R1bGUgVmVhbXNWZW50XG5cdCAqXG5cdCAqIEBhdXRob3IgU2ViYXN0aWFuIEZpdHpuZXJcblx0ICovXG5cdFxuXHQvKipcblx0ICogQG1vZHVsZSBFdmVudHNIYW5kbGVyXG5cdCAqXG5cdCAqIFB1Yi9TdWIgc3lzdGVtIGZvciBMb29zZWx5IENvdXBsZWQgbG9naWMuXG5cdCAqIEJhc2VkIG9uIFBldGVyIEhpZ2dpbnMnIHBvcnQgZnJvbSBEb2pvIHRvIGpRdWVyeVxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vcGhpZ2dpbnM0Mi9ibG9vZHktanF1ZXJ5LXBsdWdpbnMvYmxvYi9tYXN0ZXIvcHVic3ViLmpzXG5cdCAqIGFkb3B0ZWQgaHR0cHM6Ly9naXRodWIuY29tL3BoaWdnaW5zNDIvYmxvb2R5LWpxdWVyeS1wbHVnaW5zL2Jsb2IvNTVlNDFkZjliZjA4ZjQyMzc4YmIwOGI5M2VmY2IyODU1NWI2MWFlYi9wdWJzdWIuanNcblx0ICpcblx0ICogbW9kaWZpZWQgYnkgU2ViYXN0aWFuIEZpdHpuZXJcblx0ICpcblx0ICovXG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0XHR2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0dmFyIEV2ZW50c0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNhY2hlID0ge30sXG5cdFxuXHRcdC8qKlxuXHQgICogICAgRXZlbnRzLnB1Ymxpc2hcblx0ICAqICAgIGUuZy46IEV2ZW50cy5wdWJsaXNoKFwiL0FydGljbGUvYWRkZWRcIiwge2FydGljbGU6IGFydGljbGV9LCB0aGlzKTtcblx0ICAqXG5cdCAgKiAgICBAY2xhc3MgRXZlbnRzXG5cdCAgKiAgICBAbWV0aG9kIHB1Ymxpc2hcblx0ICAqICAgIEBwYXJhbSB0b3BpYyB7U3RyaW5nfVxuXHQgICogICAgQHBhcmFtIGFyZ3MgICAge09iamVjdH1cblx0ICAqICAgIEBwYXJhbSBzY29wZSB7T2JqZWN0fSBPcHRpb25hbFxuXHQgICovXG5cdFx0cHVibGlzaCA9IGZ1bmN0aW9uIHB1Ymxpc2godG9waWMsIGFyZ3MsIHNjb3BlKSB7XG5cdFx0XHRpZiAoY2FjaGVbdG9waWNdKSB7XG5cdFx0XHRcdHZhciB0aGlzVG9waWMgPSBjYWNoZVt0b3BpY107XG5cdFx0XHRcdHZhciBpID0gdGhpc1RvcGljLmxlbmd0aCAtIDE7XG5cdFxuXHRcdFx0XHRmb3IgKGk7IGkgPj0gMDsgaSAtPSAxKSB7XG5cdFx0XHRcdFx0dGhpc1RvcGljW2ldLmNhbGwoc2NvcGUgfHwgdGhpcywgYXJncyB8fCB7fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcblx0XHQvKipcblx0ICAqICAgIEV2ZW50cy5zdWJzY3JpYmVcblx0ICAqICAgIGUuZy46IEV2ZW50cy5zdWJzY3JpYmUoXCIvQXJ0aWNsZS9hZGRlZFwiLCBBcnRpY2xlcy52YWxpZGF0ZSlcblx0ICAqXG5cdCAgKiAgICBAY2xhc3MgRXZlbnRzXG5cdCAgKiAgICBAbWV0aG9kIHN1YnNjcmliZVxuXHQgICogICAgQHBhcmFtIHRvcGljIHtTdHJpbmd9XG5cdCAgKiAgICBAcGFyYW0gY2FsbGJhY2sge0Z1bmN0aW9ufVxuXHQgICogICAgQHJldHVybiBFdmVudCBoYW5kbGVyIHtBcnJheX1cblx0ICAqL1xuXHRcdHN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZSh0b3BpYywgY2FsbGJhY2spIHtcblx0XHRcdHZhciB0b3BpY3MgPSB0b3BpYy5zcGxpdCgnICcpO1xuXHRcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdG9waWNzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHZhciBfdG9waWMgPSB0b3BpY3NbaV07XG5cdFxuXHRcdFx0XHRpZiAoIWNhY2hlW190b3BpY10pIHtcblx0XHRcdFx0XHRjYWNoZVtfdG9waWNdID0gW107XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGNhY2hlW190b3BpY10ucHVzaChjYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XG5cdFxuXHRcdC8qKlxuXHQgICogICAgRXZlbnRzLnVuc3Vic2NyaWJlXG5cdCAgKiAgICBlLmcuOiB2YXIgaGFuZGxlID0gRXZlbnRzLnN1YnNjcmliZShcIi9BcnRpY2xlL2FkZGVkXCIsIEFydGljbGVzLnZhbGlkYXRlKTtcblx0ICAqICAgICAgICBFdmVudHMudW5zdWJzY3JpYmUoXCIvQXJ0aWNsZS9hZGRlZFwiLCBBcnRpY2xlcy52YWxpZGF0ZSk7XG5cdCAgKlxuXHQgICogICAgQGNsYXNzIEV2ZW50c1xuXHQgICogICAgQG1ldGhvZCB1bnN1YnNjcmliZVxuXHQgICogICAgQHBhcmFtIHRvcGljIHtTdHJpbmd9XG5cdCAgKiAgICBAcGFyYW0gaGFuZGxlIHtGdW5jdGlvbn1cblx0ICAqICAgIEBwYXJhbSBjb21wbGV0bHkge0Jvb2xlYW59XG5cdCAgKi9cblx0XHR1bnN1YnNjcmliZSA9IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKHRvcGljLCBoYW5kbGUpIHtcblx0XHRcdHZhciBjb21wbGV0bHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXHRcblx0XHRcdHZhciBpID0gY2FjaGVbdG9waWNdLmxlbmd0aCAtIDE7XG5cdFxuXHRcdFx0aWYgKGNhY2hlW3RvcGljXSkge1xuXHRcdFx0XHRmb3IgKGk7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0aWYgKGNhY2hlW3RvcGljXVtpXSA9PT0gaGFuZGxlKSB7XG5cdFx0XHRcdFx0XHRjYWNoZVt0b3BpY10uc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdFx0aWYgKGNvbXBsZXRseSkge1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgY2FjaGVbdG9waWNdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFxuXHRcdHJldHVybiB7XG5cdFx0XHRwdWJsaXNoOiBwdWJsaXNoLFxuXHRcdFx0c3Vic2NyaWJlOiBzdWJzY3JpYmUsXG5cdFx0XHR1bnN1YnNjcmliZTogdW5zdWJzY3JpYmUsXG5cdFx0XHR0cmlnZ2VyOiBwdWJsaXNoLFxuXHRcdFx0b246IHN1YnNjcmliZSxcblx0XHRcdG9mZjogdW5zdWJzY3JpYmVcblx0XHR9O1xuXHR9KCk7XG5cdFxuXHR2YXIgVmVhbXNWZW50ID0ge1xuXHRcdG9wdGlvbnM6IHtcblx0XHRcdGZ1cnRoZXJFdmVudHM6IHt9XG5cdFx0fSxcblx0XHRwbHVnaW5OYW1lOiAnVmVudCcsXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShWZWFtcywgb3B0cykge1xuXHRcdFx0aWYgKG9wdHMpIHtcblx0XHRcdFx0dGhpcy5vcHRpb25zID0gVmVhbXMuaGVscGVycy5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRzIHx8IHt9KTtcblx0XHRcdH1cblx0XG5cdFx0XHRWZWFtcy5WZW50ID0gRXZlbnRzSGFuZGxlcjtcblx0XHRcdFZlYW1zLkVWRU5UUyA9IFZlYW1zLmhlbHBlcnMuZXh0ZW5kKFZlYW1zLkVWRU5UUywgdGhpcy5vcHRpb25zLmZ1cnRoZXJFdmVudHMpO1xuXHRcdH1cblx0fTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IFZlYW1zVmVudDtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwidmVhbXNcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1widmVhbXNcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1widmVhbXNcIl0gPSByb290W1widmVhbXNcIl0gfHwge30sIHJvb3RbXCJ2ZWFtc1wiXVtcInZlYW1zXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogSW1wb3J0c1xuXHQgKi9cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9zdGFydGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cdFxuXHR2YXIgX3N0YXJ0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3RhcnRlcik7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0LyoqXG5cdCAqIFZhcmlhYmxlc1xuXHQgKi9cblxuXHRleHBvcnRzLmRlZmF1bHQgPSBfc3RhcnRlcjIuZGVmYXVsdDtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH0sXG4vKiAxICovLFxuLyogMiAqLyxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBtaXhpbjtcblx0XG5cdHZhciBfZGVmYXVsdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXHRcblx0dmFyIF9kZWZhdWx0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZhdWx0cyk7XG5cdFxuXHR2YXIgX21ldGhvZEV4dGVuZCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFxuXHR2YXIgX21ldGhvZEV4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZXRob2RFeHRlbmQpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdC8qKlxuXHQgKiBNZXJnZSBtZXRob2QgZnVuY3Rpb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZnJvbSAtIE1peGluIG9iamVjdCB3aGljaCB3aWxsIGJlIG1lcmdlZCB2aWEgSGVscGVycy5kZWZhdWx0cyB3aXRoIHRoZSBtZXRob2RzIG9mIG91ciBjbGFzc1xuXHQgKiBAcGFyYW0ge0FycmF5fSBtZXRob2RzIC0gQXJyYXkgb2YgbWV0aG9kIG5hbWVzIHdoaWNoIHdpbGwgYmUgZXh0ZW5kZWQuXG5cdCAqL1xuXHRmdW5jdGlvbiBtaXhpbihmcm9tKSB7XG5cdFx0dmFyIG1ldGhvZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFsnaW5pdGlhbGl6ZScsICdyZW5kZXInXTtcblx0XG5cdFx0aWYgKGZyb20gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y29uc29sZS5lcnJvcignVmVhbXNIZWxwZXJzIDogTWl4aW4gOjogTWl4aW4gbm90IGZvdW5kIScpO1xuXHRcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFxuXHRcdHZhciB0byA9IHRoaXMucHJvdG90eXBlO1xuXHRcblx0XHQvKiogQWRkIHRob3NlIG1ldGhvZHMgd2hpY2ggZXhpc3RzIG9uIGBmcm9tYCBidXQgbm90IG9uIGB0b2AgdG8gdGhlIGxhdHRlciAqL1xuXHRcdCgwLCBfZGVmYXVsdHMyLmRlZmF1bHQpKHRvLCBmcm9tKTtcblx0XG5cdFx0LyoqIHdlIGRvIHRoZSBzYW1lIGZvciBldmVudHMgKi9cblx0XHRpZiAodG8uZXZlbnRzKSB7XG5cdFx0XHQoMCwgX2RlZmF1bHRzMi5kZWZhdWx0KSh0by5ldmVudHMsIGZyb20uZXZlbnRzKTtcblx0XHR9XG5cdFxuXHRcdC8vIEV4dGVuZCB0bydzIG1ldGhvZHNcblx0XHRtZXRob2RzLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuXHRcdFx0KDAsIF9tZXRob2RFeHRlbmQyLmRlZmF1bHQpKHRvLCBmcm9tLCBtZXRob2QpO1xuXHRcdH0pO1xuXHR9O1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBTaW1wbGUgZXh0ZW5kIG1ldGhvZCwgd2hpY2ggZXh0ZW5kcyBhbiBvYmplY3QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBvYmplY3Qgd2hpY2ggd2lsbCBiZSBleHRlbmRlZFxuXHQgKlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IG9iaiAtIGV4dGVuZGVkIG9iamVjdFxuXHQgKi9cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0c0hlbHBlcjtcblx0ZnVuY3Rpb24gZGVmYXVsdHNIZWxwZXIob2JqKSB7XG5cdCAgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcblx0ICAgIGZvciAodmFyIGtleSBpbiBpdGVtKSB7XG5cdCAgICAgIGlmIChvYmpba2V5XSA9PT0gdW5kZWZpbmVkKSBvYmpba2V5XSA9IGl0ZW1ba2V5XTtcblx0ICAgIH1cblx0ICB9KTtcblx0ICByZXR1cm4gb2JqO1xuXHR9O1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBIZWxwZXIgbWV0aG9kIHRvIGV4dGVuZCBhbiBhbHJlYWR5IGV4aXN0aW5nIG1ldGhvZC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHRvIC0gdmlldyB3aGljaCB3aWxsIGJlIGV4dGVuZGVkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tIC0gbWV0aG9kcyB3aGljaCBjb21lcyBmcm9tIG1peGluXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIC0gZnVuY3Rpb24gbmFtZVxuXHQgKi9cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBtZXRob2RFeHRlbmQ7XG5cdGZ1bmN0aW9uIG1ldGhvZEV4dGVuZCh0bywgZnJvbSwgbWV0aG9kTmFtZSkge1xuXHRcdGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcblx0XHR9XG5cdFxuXHRcdGlmIChmcm9tID09PSB1bmRlZmluZWQpIHJldHVybjtcblx0XG5cdFx0Ly8gaWYgdGhlIG1ldGhvZCBpcyBkZWZpbmVkIG9uIGZyb20gLi4uXG5cdFx0aWYgKCFpc1VuZGVmaW5lZChmcm9tW21ldGhvZE5hbWVdKSkge1xuXHRcdFx0dmFyIG9sZCA9IHRvW21ldGhvZE5hbWVdO1xuXHRcblx0XHRcdC8vIC4uLiB3ZSBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb24gdG9cblx0XHRcdHRvW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkge1xuXHRcblx0XHRcdFx0Ly8gd2hlcmVpbiB3ZSBmaXJzdCBjYWxsIHRoZSBtZXRob2Qgd2hpY2ggZXhpc3RzIG9uIGB0b2Bcblx0XHRcdFx0dmFyIG9sZFJldHVybiA9IG9sZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcblx0XHRcdFx0Ly8gYW5kIHRoZW4gY2FsbCB0aGUgbWV0aG9kIG9uIGBmcm9tYFxuXHRcdFx0XHRmcm9tW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFxuXHRcdFx0XHQvLyBhbmQgdGhlbiByZXR1cm4gdGhlIGV4cGVjdGVkIHJlc3VsdCxcblx0XHRcdFx0Ly8gaS5lLiB3aGF0IHRoZSBtZXRob2Qgb24gYHRvYCByZXR1cm5zXG5cdFx0XHRcdHJldHVybiBvbGRSZXR1cm47XG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogU2ltcGxlIGV4dGVuZCBtZXRob2QgdG8gZXh0ZW5kIHRoZSBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIG9iamVjdCB3aGljaCB3aWxsIGJlIGV4dGVuZGVkXG5cdCAqXG5cdCAqIEByZXR1cm4ge09iamVjdH0gb2JqIC0gZXh0ZW5kZWQgb2JqZWN0XG5cdCAqL1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGV4dGVuZDtcblx0ZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuXHQgIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICBmb3IgKHZhciBrZXkgaW4gaXRlbSkge1xuXHQgICAgICBvYmpba2V5XSA9IGl0ZW1ba2V5XTtcblx0ICAgIH1cblx0ICB9KTtcblx0ICByZXR1cm4gb2JqO1xuXHR9O1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgbnVtZXJpYyBpZC5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtzZWdtZW50cz0xXSAtIG51bWJlciBvZiBzZWdtZW50cyBvZiBnZW5lcmF0ZWQgaWQgKHNlZ21lbnRzIGNvbnNpc3Qgb2YgMTAgZGlnaXRzLCBzZXBhcmF0ZWQgYnkgJy0nKS5cblx0ICpcblx0ICogQHJldHVybiB7U3RyaW5nfSAtIGdlbmVyYXRlZCBpZFxuXHQgKi9cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBtYWtlSWQ7XG5cdGZ1bmN0aW9uIG1ha2VJZCgpIHtcblx0XHR2YXIgc2VnbWVudHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG5cdFxuXHRcdHZhciBjcnlwdG8gPSB3aW5kb3cuY3J5cHRvIHx8IHdpbmRvdy5tc0NyeXB0bztcblx0XHR2YXIgYXJyYXkgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShzZWdtZW50cykpO1xuXHRcdHZhciBpZCA9ICcnO1xuXHRcdHZhciBpID0gMDtcblx0XG5cdFx0Zm9yICg7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWQgKz0gYXJyYXlbaV0gKyAnLSc7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gaWQuc2xpY2UoMCwgLTEpO1xuXHR9O1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSxcbi8qIDggKi8sXG4vKiA5ICovLFxuLyogMTAgKi8sXG4vKiAxMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0LyoqXG5cdCAqIFBvbHlmaWxsc1xuXHQgKi9cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdFxuXHR2YXIgX2NvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblx0XG5cdHZhciBfY29yZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb3JlKTtcblx0XG5cdGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cdFxuXHR2YXIgVmVhbXMgPSB7fTtcblx0XG5cdC8qKlxuXHQgKiBJbXBvcnRzXG5cdCAqL1xuXHRcblx0XG5cdChmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG5cdFx0J3VzZSBzdHJpY3QnO1xuXHRcblx0XHRWZWFtcyA9IG5ldyBfY29yZTIuZGVmYXVsdCh7XG5cdFx0XHRuYW1lc3BhY2U6ICdWZWFtcycsXG5cdFx0XHRhZGRUb0dsb2JhbDogdHJ1ZVxuXHRcdH0pO1xuXHRcblx0XHRWZWFtcy5pbml0aWFsaXplKCk7XG5cdH0pKHdpbmRvdywgZG9jdW1lbnQpO1xuXHRcblx0ZXhwb3J0cy5kZWZhdWx0ID0gVmVhbXM7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9LFxuLyogMTIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8vIFBvbHlmaWxsIGZvciBjdXN0b20gZXZlbnRzXG5cdChmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHJldHVybiBmYWxzZTtcblx0XG5cdFx0ZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuXHRcdFx0dmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuXHRcblx0XHRcdHBhcmFtcyA9IHBhcmFtcyB8fCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB1bmRlZmluZWQgfTtcblx0XG5cdFx0XHRldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuXHRcdFx0cmV0dXJuIGV2dDtcblx0XHR9XG5cdFxuXHRcdEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG5cdFxuXHRcdHdpbmRvdy5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50O1xuXHR9KSgpO1xuXG4vKioqLyB9LFxuLyogMTMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTsgLyoqXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBSZXByZXNlbnRzIFZlYW1zQ29yZS5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEBtb2R1bGUgVmVhbXNDb3JlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogQGF1dGhvciBTZWJhc3RpYW4gRml0em5lclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cdFxuXHRcblx0X193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cdFxuXHR2YXIgX3VzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXHRcblx0dmFyIF91c2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlKTtcblx0XG5cdHZhciBfZXZlbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cdFxuXHR2YXIgX2V2ZW50czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ldmVudHMpO1xuXHRcblx0dmFyIF9oZWxwZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cdFxuXHR2YXIgX2hlbHBlcnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGVscGVycyk7XG5cdFxuXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXHRcblx0ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblx0XG5cdHZhciBpbml0U3RhdGUgPSBmYWxzZTtcblx0XG5cdHZhciBWZWFtc0NvcmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0ZnVuY3Rpb24gVmVhbXNDb3JlKG9wdHMpIHtcblx0XHRcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWZWFtc0NvcmUpO1xuXHRcblx0XHRcdHRoaXMuX29wdGlvbnMgPSB7XG5cdFx0XHRcdG5hbWVzcGFjZTogJ1ZlYW1zJyxcblx0XHRcdFx0YWRkVG9HbG9iYWw6IGZhbHNlXG5cdFx0XHR9O1xuXHRcblx0XHRcdHRoaXMuYmFzZSA9IHtcblx0XHRcdFx0bmFtZTogJ1ZlYW1zJyxcblx0XHRcdFx0dmVyc2lvbjogJzUuMC4xJ1xuXHRcdFx0fTtcblx0XG5cdFx0XHR0aGlzLnVzZSA9IF91c2UyLmRlZmF1bHQuYmluZCh0aGlzKTtcblx0XHRcdHRoaXMuUGx1Z2lucyA9IHt9O1xuXHRcdFx0dGhpcy5FVkVOVFMgPSBfZXZlbnRzMi5kZWZhdWx0O1xuXHRcdFx0dGhpcy5oZWxwZXJzID0ge307XG5cdFx0XHR0aGlzLmRldGVjdGlvbnMgPSB7XG5cdFx0XHRcdHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcblx0XHRcdFx0aGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcblx0XHRcdH07XG5cdFxuXHRcdFx0aW5pdFN0YXRlID0gZmFsc2U7XG5cdFxuXHRcdFx0dGhpcy5zZXR1cChvcHRzKTtcblx0XHR9XG5cdFxuXHRcdF9jcmVhdGVDbGFzcyhWZWFtc0NvcmUsIFt7XG5cdFx0XHRrZXk6ICdzZXR1cCcsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gc2V0dXAob3B0cykge1xuXHRcdFx0XHR0aGlzLnVzZShfaGVscGVyczIuZGVmYXVsdCk7XG5cdFxuXHRcdFx0XHR0aGlzLmRldGVjdGlvbnMgPSB0aGlzLmhlbHBlcnMuZXh0ZW5kKHtcblx0XHRcdFx0XHR0b3VjaDogdGhpcy5oZWxwZXJzLmlzVG91Y2goKVxuXHRcdFx0XHR9LCB0aGlzLmRldGVjdGlvbnMpO1xuXHRcblx0XHRcdFx0dGhpcy5vcHRpb25zID0gb3B0cztcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdpbml0aWFsaXplJyxcblx0XHRcdHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplKG9wdHMpIHtcblx0XHRcdFx0aWYgKGluaXRTdGF0ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHRcdHJldHVybiBjb25zb2xlLmluZm8oJ1ZlYW1zIDo6IFlvdSBhbHJlYWR5IGluaXRpYWxpemVkIFZlYW1zIScpO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHQvKipcblx0ICAgICogU2V0IGdsb2JhbCBvcHRpb25zIG9uIGluaXRpYWxpemVcblx0ICAgICovXG5cdFx0XHRcdHRoaXMub3B0aW9ucyA9IG9wdHM7XG5cdFxuXHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLmFkZFRvR2xvYmFsKSB7XG5cdFx0XHRcdFx0aWYgKHdpbmRvdyAmJiAhd2luZG93W3RoaXMub3B0aW9ucy5uYW1lc3BhY2VdKSB7XG5cdFx0XHRcdFx0XHR3aW5kb3dbdGhpcy5vcHRpb25zLm5hbWVzcGFjZV0gPSB0aGlzIHx8IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcblx0XHRcdFx0aW5pdFN0YXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdvbkluaXRpYWxpemUnLFxuXHRcdFx0dmFsdWU6IGZ1bmN0aW9uIG9uSW5pdGlhbGl6ZShjYikge1xuXHRcdFx0XHRpZiAoIWNiIHx8IHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdWZWFtcyA6OiBDYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbiEnKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGlmIChpbml0U3RhdGUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0dGhpcy5pbml0aWFsaXplKCk7XG5cdFx0XHRcdH1cblx0XG5cdFx0XHRcdGNiKCk7XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAnb25ET01SZWFkeScsXG5cdFx0XHR2YWx1ZTogZnVuY3Rpb24gb25ET01SZWFkeShjYikge1xuXHRcdFx0XHRpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ1ZlYW1zIDo6IENhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2IpO1xuXHRcdFx0fVxuXHRcdH0sIHtcblx0XHRcdGtleTogJ3ZlcnNpb24nLFxuXHRcdFx0c2V0OiBmdW5jdGlvbiBzZXQodmVyc2lvbikge1xuXHRcdFx0XHR0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcblx0XHRcdH0sXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3ZlcnNpb247XG5cdFx0XHR9XG5cdFx0fSwge1xuXHRcdFx0a2V5OiAnaW5pdGlhbGl6ZWQnLFxuXHRcdFx0c2V0OiBmdW5jdGlvbiBzZXQoYm9vbCkge1xuXHRcdFx0XHR0aGlzLl9pbml0aWFsaXplZCA9IGJvb2w7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0OiBmdW5jdGlvbiBnZXQoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9pbml0aWFsaXplZDtcblx0XHRcdH1cblx0XHR9LCB7XG5cdFx0XHRrZXk6ICdvcHRpb25zJyxcblx0XHRcdHNldDogZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5fb3B0aW9ucyA9IHRoaXMuaGVscGVycy5leHRlbmQodGhpcy5vcHRpb25zLCBvcHRpb25zIHx8IHt9KTtcblx0XHRcdH0sXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX29wdGlvbnM7XG5cdFx0XHR9XG5cdFx0fV0pO1xuXHRcblx0XHRyZXR1cm4gVmVhbXNDb3JlO1xuXHR9KCk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBWZWFtc0NvcmU7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9LFxuLyogMTQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBSZXByZXNlbnRzIGEgc2ltcGxlIHBsdWdpbiBzeXN0ZW0gaW4gd2hpY2ggYHRoaXNgIGlzIFZlYW1zLlxuXHQgKiBAbW9kdWxlIHBsdWdpblxuXHQgKlxuXHQgKiBAYXV0aG9yIFNlYmFzdGlhbiBGaXR6bmVyXG5cdCAqL1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG5cdCAgaWYgKHBsdWdpbi5wbHVnaW5OYW1lKSB7XG5cdCAgICB0aGlzLlBsdWdpbnNbcGx1Z2luLnBsdWdpbk5hbWVdID0gcGx1Z2luO1xuXHQgIH1cblx0XG5cdCAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG5cdCAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcblx0ICB9XG5cdFxuXHQgIHBsdWdpbi5pbml0aWFsaXplLmFwcGx5KHBsdWdpbiwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG5cdH07XG5cdFxuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSxcbi8qIDE1ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogQ29uc3QgZm9yIGV2ZW50cyAocHViL3N1Yilcblx0ICpcblx0ICogQGF1dGhvcjogU2ViYXN0aWFuIEZpdHpuZXJcblx0ICovXG5cdFxuXHQvKipcblx0ICogRXZlbnRzIEdsb2JhbFxuXHQgKi9cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHR2YXIgRVZFTlRTID0ge1xuXHRcdGJsdXI6ICdibHVyJyxcblx0XHRjaGFuZ2U6ICdjaGFuZ2UnLFxuXHRcdGNsaWNrOiAnY2xpY2snLFxuXHRcdGRibGNsaWNrOiAnZGJsY2xpY2snLFxuXHRcdERPTWNoYW5nZWQ6ICdkb206Y2hhbmdlZCcsXG5cdFx0RE9NcmVkaXJlY3Q6ICdkb206cmVkaXJlY3QnLFxuXHRcdGhhc2hjaGFuZ2U6ICdoYXNoY2hhbmdlJyxcblx0XHRpbnB1dDogJ2lucHV0Jyxcblx0XHRrZXlkb3duOiAna2V5ZG93bicsXG5cdFx0a2V5cHJlc3M6ICdrZXlwcmVzcycsXG5cdFx0a2V5dXA6ICdrZXl1cCcsXG5cdFx0bWVkaWFjaGFuZ2U6ICdtZWRpYWNoYW5nZScsXG5cdFx0bW9kdWxlQ2FjaGVkOiAnbW9kdWxlOmNhY2hlZCcsXG5cdFx0bW91c2Vkb3duOiAnbW91c2Vkb3duJyxcblx0XHRtb3VzZWVudGVyOiAnbW91c2VlbnRlcicsXG5cdFx0bW91c2VsZWF2ZTogJ21vdXNlbGVhdmUnLFxuXHRcdG1vdXNlb3V0OiAnbW91c2VvdXQnLFxuXHRcdG1vdXNlb3ZlcjogJ21vdXNlb3ZlcicsXG5cdFx0bW91c2V1cDogJ21vdXNldXAnLFxuXHRcdHJlc2V0OiAncmVzZXQnLFxuXHRcdHJlc2l6ZTogJ3Jlc2l6ZScsXG5cdFx0c2Nyb2xsOiAnc2Nyb2xsJyxcblx0XHRzdWJtaXQ6ICdzdWJtaXQnLFxuXHRcdHN3aXBlOiAnc3dpcGUnXG5cdH07XG5cdFxuXHRleHBvcnRzLmRlZmF1bHQgPSBFVkVOVFM7XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9LFxuLyogMTYgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHRcdHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRcblx0dmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXHRcblx0dmFyIF9leHRlbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXHRcblx0dmFyIF9leHRlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXh0ZW5kKTtcblx0XG5cdHZhciBfbWl4aW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXHRcblx0dmFyIF9taXhpbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9taXhpbik7XG5cdFxuXHR2YXIgX21ldGhvZEV4dGVuZCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cdFxuXHR2YXIgX21ldGhvZEV4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tZXRob2RFeHRlbmQpO1xuXHRcblx0dmFyIF9pc1RvdWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cdFxuXHR2YXIgX2lzVG91Y2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNUb3VjaCk7XG5cdFxuXHR2YXIgX3Rocm90dGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cdFxuXHR2YXIgX3Rocm90dGxlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Rocm90dGxlKTtcblx0XG5cdHZhciBfcXVlcnlTZWxlY3RvckFycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cdFxuXHR2YXIgX3F1ZXJ5U2VsZWN0b3JBcnJheTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9xdWVyeVNlbGVjdG9yQXJyYXkpO1xuXHRcblx0dmFyIF9mb3JFYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cdFxuXHR2YXIgX2ZvckVhY2gyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZm9yRWFjaCk7XG5cdFxuXHR2YXIgX21ha2VJZCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cdFxuXHR2YXIgX21ha2VJZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYWtlSWQpO1xuXHRcblx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblx0XG5cdHZhciBWZWFtc0hlbHBlcnMgPSB7XG5cdFx0cGx1Z2luTmFtZTogJ0hlbHBlcnMnLFxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUoVmVhbXMpIHtcblx0XHRcdFZlYW1zLmFkZEhlbHBlciA9IGZ1bmN0aW9uIGFkZEhlbHBlcigpIHtcblx0XHRcdFx0Zm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcblx0XHRcdFx0XHRhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuXHRcdFx0XHR9XG5cdFxuXHRcdFx0XHR2YXIgcGFyYW1zID0gW10uY29uY2F0KGFyZ3MpO1xuXHRcblx0XHRcdFx0aWYgKHBhcmFtcy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0XHRpZiAoX3R5cGVvZihwYXJhbXNbMF0pICE9PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdFx0Y29uc29sZS5lcnJvcignVmVhbXNIZWxwZXJzIDo6IFlvdSBuZWVkIHRvIHBhc3MgYW4gb2JqZWN0IScpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHBhcmFtc1swXSkge1xuXHRcdFx0XHRcdFx0aWYgKHBhcmFtc1swXS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghVmVhbXMuaGVscGVyc1trZXldKSB7XG5cdFx0XHRcdFx0XHRcdFx0VmVhbXMuaGVscGVyc1trZXldID0gcGFyYW1zWzBdW2tleV07XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc29sZS5pbmZvKCdWZWFtc0hlbHBlcnMgOjogVGhlIGhlbHBlciAnICsga2V5ICsgJyBpcyBhbHJlYWR5IGRlZmluZWQhIFBsZWFzZSBkZWZpbmUgYSBuZXcgbmFtZSBmb3I6ICcsIHBhcmFtc1swXVtrZXldKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChwYXJhbXMubGVuZ3RoID09PSAyKSB7XG5cdFxuXHRcdFx0XHRcdGlmICghVmVhbXMuaGVscGVyc1twYXJhbXNbMF1dKSB7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHBhcmFtc1swXSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHBhcmFtc1sxXSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKCdWZWFtc0hlbHBlcnMgOjogWW91IG5lZWQgdG8gcGFzcyBhIHN0cmluZyBhcyBmaXJzdCBhcmd1bWVudCBhbmQgdGhlIGhlbHBlciBmdW5jdGlvbiBhcyBzZWNvbmQgb25lLicpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRWZWFtcy5oZWxwZXJzW3BhcmFtc1swXV0gPSBwYXJhbXNbMV07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUuaW5mbygnVmVhbXNIZWxwZXJzIDo6IFRoZSBoZWxwZXIgJyArIHBhcmFtc1swXSArICcgaXMgYWxyZWFkeSBkZWZpbmVkISBQbGVhc2UgZGVmaW5lIGEgbmV3IG5hbWUgZm9yOiAnLCBwYXJhbXNbMV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XG5cdFx0XHR0aGlzLmFkZERlZmF1bHRIZWxwZXJzKFZlYW1zKTtcblx0XHR9LFxuXHRcblx0XHRhZGREZWZhdWx0SGVscGVyczogZnVuY3Rpb24gYWRkRGVmYXVsdEhlbHBlcnMoVmVhbXMpIHtcblx0XHRcdFZlYW1zLmFkZEhlbHBlcigncXVlcnlTZWxlY3RvckFycmF5JywgX3F1ZXJ5U2VsZWN0b3JBcnJheTIuZGVmYXVsdCk7XG5cdFx0XHRWZWFtcy5hZGRIZWxwZXIoJ2V4dGVuZCcsIF9leHRlbmQyLmRlZmF1bHQpO1xuXHRcdFx0VmVhbXMuYWRkSGVscGVyKCdpc1RvdWNoJywgX2lzVG91Y2gyLmRlZmF1bHQpO1xuXHRcdFx0VmVhbXMuYWRkSGVscGVyKCdtaXhpbicsIF9taXhpbjIuZGVmYXVsdCk7XG5cdFx0XHRWZWFtcy5hZGRIZWxwZXIoJ21ldGhvZEV4dGVuZCcsIF9tZXRob2RFeHRlbmQyLmRlZmF1bHQpO1xuXHRcdFx0VmVhbXMuYWRkSGVscGVyKCd0aHJvdHRsZScsIF90aHJvdHRsZTIuZGVmYXVsdCk7XG5cdFx0XHRWZWFtcy5hZGRIZWxwZXIoJ2ZvckVhY2gnLCBfZm9yRWFjaDIuZGVmYXVsdCk7XG5cdFx0XHRWZWFtcy5hZGRIZWxwZXIoJ21ha2VJZCcsIF9tYWtlSWQyLmRlZmF1bHQpO1xuXHRcdH1cblx0fTtcblx0XG5cdGV4cG9ydHMuZGVmYXVsdCA9IFZlYW1zSGVscGVycztcblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cbi8qKiovIH0sXG4vKiAxNyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHRcblx0LyoqXG5cdCAqIFRvdWNoIERldGVjdGlvblxuXHQgKi9cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuXHQgIHZhbHVlOiB0cnVlXG5cdH0pO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBpc1RvdWNoO1xuXHRmdW5jdGlvbiBpc1RvdWNoKCkge1xuXHQgIHJldHVybiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG5cdH07XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9LFxuLyogMTggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBUaHJvdHRsZSBtZXRob2QgZm9yIHJlc2l6ZSBldmVudHMgYW5kIG1vcmVcblx0ICpcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IC0gbnVtYmVyIHRvIHdhaXQgaW4gbWlsbGlzZWNvbmRzLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGltbWVkaWF0ZSAtIGV4ZWN1dGUgZnVuY3Rpb24gaW1tZWRpYXRlbHkuXG5cdCAqL1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdFx0dmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IHRocm90dGxlO1xuXHRmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcblx0XHR2YXIgdGltZW91dCA9IHZvaWQgMDtcblx0XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBjb250ZXh0ID0gdGhpcztcblx0XHRcdHZhciBhcmdzID0gYXJndW1lbnRzO1xuXHRcdFx0dmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG5cdFx0XHR2YXIgbGF0ZXIgPSBmdW5jdGlvbiBsYXRlcigpIHtcblx0XHRcdFx0dGltZW91dCA9IG51bGw7XG5cdFx0XHRcdGlmICghaW1tZWRpYXRlKSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXHRcdFx0fTtcblx0XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFxuXHRcdFx0dGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuXHRcblx0XHRcdGlmIChjYWxsTm93KSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXHRcdH07XG5cdH07XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9LFxuLyogMTkgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdCd1c2Ugc3RyaWN0Jztcblx0XG5cdC8qKlxuXHQgKiBHZXQgZG9tIGVsZW1lbnRzIGluIGFuIGFycmF5XG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBlbGVtIC0gUmVxdWlyZWQ6IHNlbGVjdG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF0gLSBPcHRpb25hbDogY29udGV4dFxuXHQgKlxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICovXG5cdFxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICB2YWx1ZTogdHJ1ZVxuXHR9KTtcblx0ZXhwb3J0cy5kZWZhdWx0ID0gcXVlcnlTZWxlY3RvckFycmF5O1xuXHRmdW5jdGlvbiBxdWVyeVNlbGVjdG9yQXJyYXkoZWxlbSwgY29udGV4dCkge1xuXHQgIGlmICghZWxlbSkgdGhyb3cgbmV3IEVycm9yKCdJbiBvcmRlciB0byB3b3JrIHdpdGggcXVlcnlTZWxlY3RvckFycmF5IHlvdSBuZWVkIHRvIGRlZmluZSBhbiBlbGVtZW50IGFzIHN0cmluZyEnKTtcblx0ICB2YXIgZWwgPSBlbGVtO1xuXHQgIHZhciBjdXN0b21Db250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblx0XG5cdCAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1c3RvbUNvbnRleHQucXVlcnlTZWxlY3RvckFsbChlbCkpO1xuXHR9O1xuXHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuLyoqKi8gfSxcbi8qIDIwICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHQndXNlIHN0cmljdCc7XG5cdFxuXHQvKipcblx0ICogU2ltcGxlIGZvckVhY2ggbWV0aG9kXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gYXJyYXkgb2Ygb2JqZWN0c1xuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGNhbGxiYWNrIGZ1bmN0aW9uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZSAtIHNjb3BlIG9mIGZ1bmN0aW9uXG5cdCAqL1xuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG5cdCAgdmFsdWU6IHRydWVcblx0fSk7XG5cdGV4cG9ydHMuZGVmYXVsdCA9IGZvckVhY2g7XG5cdGZ1bmN0aW9uIGZvckVhY2goYXJyYXksIGNhbGxiYWNrLCBzY29wZSkge1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcblx0ICAgIGNhbGxiYWNrLmNhbGwoc2NvcGUsIGksIGFycmF5W2ldKTtcblx0ICB9XG5cdH07XG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG4vKioqLyB9XG4vKioqKioqLyBdKVxufSk7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZWFtcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBiYXNlIGNvbnN0cnVjdG9yIHdoaWNoIHN1cHBvcnRzXG4gKiBvcHRpb25zIG1lcmdpbmcgYW5kXG4gKiBzYXZpbmcgb2Ygc3RhbmRhcmQgc3R1ZmYuXG4gKlxuICogQG1vZHVsZSBWZWFtc0Jhc2VcbiAqIEBhdXRob3IgU2ViYXN0aWFuIEZpdHpuZXJcbiAqL1xuXG4vKipcbiAqIEltcG9ydHNcbiAqL1xuaW1wb3J0IHN0cmluZ0hlbHBlcnMgZnJvbSAnLi4vdXRpbHMvaW50ZXJuYWwtaGVscGVycy9zdHJpbmcnO1xuaW1wb3J0IG1peGluSGVscGVyIGZyb20gJy4uL3V0aWxzL2hlbHBlcnMvbWl4aW4nO1xuaW1wb3J0IGV4dGVuZEhlbHBlciBmcm9tICcuLi91dGlscy9oZWxwZXJzL2V4dGVuZCc7XG5pbXBvcnQgbWFrZUlkSGVscGVyIGZyb20gJy4uL3V0aWxzL2hlbHBlcnMvbWFrZS1pZCc7XG5cbmNsYXNzIFZlYW1zQmFzZSB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RvclxuXHQgKlxuXHQgKiB0byBzYXZlIHN0YW5kYXJkIGVsZW1lbnRzIGxpa2UgZWwgYW5kIG9wdGlvbnMgYW5kXG5cdCAqIGV4ZWN1dGUgaW5pdGlhbGl6ZSBhcyBkZWZhdWx0IG1ldGhvZC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSAtIEFkZCBjdXN0b20gbmFtZXNwYWNlIHRvIHlvdXIgY2xhc3MuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBlbCAtIFNhdmUgZWxlbWVudCBpbiBjbGFzcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIHBhc3NlZCBieSBpbml0IHByb2Nlc3MuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIFt7fV0gLSBPYmplY3Qgd2hpY2ggY29udGFpbnMgb3B0aW9ucyBvZiB0aGUgZXh0ZW5kZWQgY2xhc3MuXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih7bmFtZXNwYWNlLCBlbCwgb3B0aW9uc30sIG9wdHMgPSB7fSkge1xuXHRcdHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlIHx8ICdiYXNlJztcblx0XHR0aGlzLmluc3RhbmNlSWQgPSB0aGlzLm5hbWVzcGFjZTtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRzO1xuXHRcdHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuXG5cdFx0aWYgKGVsKSB7XG5cdFx0XHR0aGlzLmVsID0gZWw7XG5cdFx0fVxuXHR9XG5cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyBHRVRURVIgJiBTRVRURVJTXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXHRzZXQgbmFtZXNwYWNlKG5hbWVzcGFjZSkge1xuXHRcdHRoaXMuX25hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0fVxuXG5cdGdldCBuYW1lc3BhY2UoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX25hbWVzcGFjZTtcblx0fVxuXG5cdGdldCBpbnN0YW5jZUlkKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbnN0YW5jZUlkO1xuXHR9XG5cblx0c2V0IGluc3RhbmNlSWQoaWQpIHtcblx0XHR0aGlzLl9pbnN0YW5jZUlkID0gYCR7aWR9X2AgKyBEYXRlLm5vdygpICsgJ18nICsgbWFrZUlkSGVscGVyKCk7XG5cdH1cblxuXHRnZXQgX29wdGlvbnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucztcblx0fVxuXG5cdHNldCBfb3B0aW9ucyhvcHRpb25zKSB7XG5cdFx0dGhpcy5vcHRpb25zID0gZXh0ZW5kSGVscGVyKHRoaXMub3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG5cdH1cblxuXHRzZXQgZWwoZWxlbWVudCkge1xuXHRcdHRoaXMuX2VsID0gZWxlbWVudDtcblx0fVxuXG5cdGdldCBlbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZWw7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IG1vZHVsZSBpbmZvcm1hdGlvblxuXHQgKi9cblx0Z2V0IG1ldGFEYXRhKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRuYW1lOiB0eXBlb2YgdGhpcy5uYW1lc3BhY2UgPT09ICdzdHJpbmcnID8gc3RyaW5nSGVscGVycy5jYXBpdGFsaXplRmlyc3RMZXR0ZXIoc3RyaW5nSGVscGVycy50b0NhbWVsQ2FzZSh0aGlzLm5hbWVzcGFjZSkpIDogJydcblx0XHR9O1xuXHR9XG59XG5cbi8qKlxuICogQWRkIG1peGluIGZ1bmN0aW9uYWxpdHkgdG8gZXh0ZW5kIG1vZHVsZSBjbGFzcyBieSB1c2luZyBzaW1wbGUgb2JqZWN0c1xuICovXG5WZWFtc0Jhc2UubWl4aW4gPSBtaXhpbkhlbHBlcjtcblxuZXhwb3J0IGRlZmF1bHQgVmVhbXNCYXNlOyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29tcG9uZW50IGNvbnN0cnVjdG9yIHdoaWNoIHN1cHBvcnRzXG4gKiBvcHRpb25zIG1lcmdpbmcsXG4gKiBiaW5kaW5nIGFuZCB1bmJpbmRpbmcgb2YgZXZlbnRzIGFuZCBzdWJzY3JpcHRpb25zIHdpdGggdGVtcGxhdGUgc3RyaW5ncyxcbiAqIHJlbmRlcmluZyBvZiB0ZW1wbGF0ZXNcbiAqIGFuZCBhIGRlc3Ryb3kgYmVoYXZpb3VyLlxuICpcbiAqIEtlZXAgaW4gbWluZCwgdGhhdCB0aGlzIGNsYXNzIGlzIGEgZGVwZW5kZW50IG9mIFZlYW1zLlxuICpcbiAqIFRPRE86IE1ha2UgYSBuYXRpdmUgb25lIHdoaWNoIGRvZXMgbm90IG5lZWQgYW55IFZlYW1zIHNwZWNpZmljIHN0dWZmLlxuICpcbiAqIEBtb2R1bGUgVmVhbXNDb21wb25lbnRcbiAqIEBhdXRob3IgU2ViYXN0aWFuIEZpdHpuZXJcbiAqL1xuXG4vKipcbiAqIEltcG9ydHNcbiAqL1xuaW1wb3J0IFZlYW1zQmFzZSBmcm9tICcuL2Jhc2UnO1xuaW1wb3J0IGdldFN0cmluZ1ZhbHVlIGZyb20gJy4uL3V0aWxzL2ludGVybmFsLWhlbHBlcnMvZ2V0LXN0cmluZy12YWx1ZSc7XG5pbXBvcnQgdHBsRW5naW5lIGZyb20gJy4uL3V0aWxzL2ludGVybmFsLWhlbHBlcnMvdGVtcGxhdGUtZW5naW5lJztcblxuLyoqXG4gKiBDdXN0b20gRnVuY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRXZ0SWQoZXZ0S2V5QXJyLCBmbk5hbWUpIHtcblx0cmV0dXJuIGV2dEtleUFyci5qb2luKCdfJykgKyAnXycgKyBmbk5hbWU7XG59XG5cbmNsYXNzIFZlYW1zQ29tcG9uZW50IGV4dGVuZHMgVmVhbXNCYXNlIHtcblxuXHQvKipcblx0ICogQ29uc3RydWN0b3Jcblx0ICpcblx0ICogdG8gc2F2ZSBzdGFuZGFyZCBlbGVtZW50cyBsaWtlIGVsIGFuZCBvcHRpb25zIGFuZFxuXHQgKiBleGVjdXRlIGluaXRpYWxpemUgYXMgZGVmYXVsdCBtZXRob2QuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogW3t9XSAtIE9iamVjdCB3aGljaCBjb250YWlucyBlbCwgb3B0aW9ucyBmcm9tIHRoZSBET00gYW5kIG5hbWVzcGFjZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgW3t9XSAtIE9iamVjdCB3aGljaCBjb250YWlucyBvcHRpb25zIG9mIHRoZSBleHRlbmRlZCBjbGFzcy5cblx0ICovXG5cdGNvbnN0cnVjdG9yKG9iaiA9IHt9LCBvcHRpb25zID0ge30pIHtcblx0XHRzdXBlcihvYmosIG9wdGlvbnMpO1xuXHRcdHRoaXMuYXBwSW5zdGFuY2UgPSBvYmouYXBwSW5zdGFuY2UgfHwgd2luZG93LlZlYW1zO1xuXG5cdFx0aWYgKCF0aGlzLmFwcEluc3RhbmNlKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1ZlYW1zQ29tcG9uZW50IDo6IFBsZWFzZSBwcm92aWRlIHlvdXIgYXBwIGluc3RhbmNlIScpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5hcHBJbnN0YW5jZS4kKSB7XG5cdFx0XHRjb25zb2xlLmluZm8oJ1ZlYW1zQ29tcG9uZW50IDo6IFBsZWFzZSBhZGQgYSBET00gaGFuZGxlciBsaWtlIGpRdWVyeSB0byB0aGUgYXBwIGluc3RhbmNlIScpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmFwcEluc3RhbmNlLiQpIHtcblx0XHRcdHRoaXMuJGVsID0gdGhpcy5hcHBJbnN0YW5jZS4kKG9iai5lbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5pbml0aWFsaXplKG9iaiwgb3B0aW9ucyk7XG5cdFx0dGhpcy5fY3JlYXRlKCk7XG5cdH1cblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vIEdFVFRFUiAmIFNFVFRFUlNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBldmVudHMgb2JqZWN0XG5cdCAqL1xuXHRzZXQgZXZlbnRzKG9iaikge1xuXHRcdHRoaXMuX2V2ZW50cyA9IG9iajtcblx0fVxuXG5cdGdldCBldmVudHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2V2ZW50cztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBzdWJzY3JpYmUgb2JqZWN0XG5cdCAqL1xuXHRzZXQgc3Vic2NyaWJlKG9iaikge1xuXHRcdHRoaXMuX3N1YnNjcmliZSA9IG9iajtcblx0fVxuXG5cdGdldCBzdWJzY3JpYmUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N1YnNjcmliZTtcblx0fVxuXG5cdHNldCBfc3Vic2NyaWJlcnMob2JqKSB7XG5cdFx0aWYgKCF0aGlzLl9fc3Vic2NyaWJlcnMpIHtcblx0XHRcdHRoaXMuX19zdWJzY3JpYmVycyA9IHt9O1xuXHRcdH1cblxuXHRcdHRoaXMuX19zdWJzY3JpYmVyc1tvYmouaWRdID0ge1xuXHRcdFx0ZGVsZWdhdGU6IG9iai5kZWxlZ2F0ZSxcblx0XHRcdHR5cGU6IG9iai50eXBlLFxuXHRcdFx0ZXZlbnQ6IG9iai5ldmVudCxcblx0XHRcdGhhbmRsZXI6IG9iai5oYW5kbGVyXG5cdFx0fTtcblx0fVxuXG5cdGdldCBfc3Vic2NyaWJlcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX19zdWJzY3JpYmVycztcblx0fVxuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gU1RBTkRBUkQgTUVUSE9EU1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdGluaXRpYWxpemUoKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUHJpdmF0ZSBtZXRob2QgdG8gY3JlYXRlIGFsbCBuZWNlc3NhcnkgZWxlbWVudHMgYW5kIGJpbmRpbmdzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2NyZWF0ZSgpIHtcblx0XHR0aGlzLnByZVJlbmRlcigpO1xuXHRcdHRoaXMucmVnaXN0ZXJFdmVudHModGhpcy5ldmVudHMsIGZhbHNlKTtcblx0XHR0aGlzLnJlZ2lzdGVyRXZlbnRzKHRoaXMuc3Vic2NyaWJlLCB0cnVlKTtcblx0XHR0aGlzLmJpbmRFdmVudHMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kIGxvY2FsIGFuZCBnbG9iYWwgZXZlbnRzXG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdGJpbmRFdmVudHMoKSB7XG5cdH1cblxuXHQvKipcblx0ICogVW5iaW5kIGV2ZW50c1xuXHQgKlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHR1bmJpbmRFdmVudHMoKSB7XG5cdH1cblxuXHQvKipcblx0ICogUHJlLVJlbmRlciB0ZW1wbGF0ZXNcblx0ICogd2hpY2ggY2FuIGJlIHVzZWQgdG8gcmVuZGVyIGNvbnRlbnQgaW50byBpdFxuXHQgKlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRwcmVSZW5kZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVyIHlvdXIgbW9kdWxlXG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdHJlbmRlcigpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXN0cm95IGNvbXBvbmVudCBieSB1bmJpbmRpbmcgZXZlbnRzIGFuZFxuXHQgKiByZW1vdmluZyBlbGVtZW50IGZyb20gRE9NXG5cdCAqL1xuXHRkZXN0cm95KCkge1xuXHRcdHRoaXMudW5yZWdpc3RlckV2ZW50cygpO1xuXHRcdHRoaXMudW5iaW5kRXZlbnRzKCk7XG5cdFx0dGhpcy4kZWwucmVtb3ZlKCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVyIHRlbXBsYXRlIHdpdGggZGF0YVxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHBsTmFtZSAtIFRlbXBsYXRlIG5hbWUgd2hpY2ggZ2V0cyByZXR1cm5lZCBhcyByZW5kZXJlZCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIERhdGEgd2hpY2ggZ2V0cyBoYW5kbGVkIGJ5IHRoZSB0ZW1wbGF0ZS5cblx0ICovXG5cdHJlbmRlclRlbXBsYXRlKHRwbE5hbWUsIGRhdGEpIHtcblx0XHRpZiAoIXRoaXMuYXBwSW5zdGFuY2UudGVtcGxhdGVyKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKGBcblx0XHRcdFx0VmVhbXNDb21wb25lbnQgOjogSXQgc2VlbXMgdGhhdCB5b3UgaGF2ZW5cXCd0IGFkZGVkIHRoZSBWZWFtc1RlbXBsYXRlciBwbHVnaW4uIEluIG9yZGVyIHRvIHdvcmsgd2l0aCAncmVuZGVyVGVtcGxhdGUoKScgeW91IG5lZWQgdG8gYWRkIGl0IVxuXHRcdFx0YCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLmFwcEluc3RhbmNlLnRlbXBsYXRlci5yZW5kZXIodHBsTmFtZSwgZGF0YSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyBNT1VOVCBQUk9DRVNTIE1FVEhPRFNcblx0Ly8gTW91bnQgcHJvY2VzcyBtZXRob2RzIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgVmVhbXNNb2R1bGVzIHBsdWdpblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgaW5pdGlhbGlzZVxuXHQgKi9cblx0d2lsbE1vdW50KCkge1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgZXhlY3V0ZWQgYmVmb3JlIHVucmVnaXN0ZXJpbmcgZXZlbnRzXG5cdCAqL1xuXHR3aWxsVW5tb3VudCgpIHtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIGV4ZWN1dGVkIGFmdGVyIHJlbmRlclxuXHQgKi9cblx0ZGlkTW91bnQoKSB7XG5cdH1cblxuXHQvKipcblx0ICogVGhpcyBtZXRob2Qgd2lsbCBiZSBleGVjdXRlZCBhZnRlciB1bnJlZ2lzdGVyaW5nIGV2ZW50c1xuXHQgKi9cblx0ZGlkVW5tb3VudCgpIHtcblx0fVxuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gRVZFTlRTIE1FVEhPRFNcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBtdWx0aXBsZSBldmVudHMgd2hpY2ggYXJlIHNhdmVkIGluIGFuIG9iamVjdC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2dHMgLSBFdmVudHMgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGFuIG9iamVjdCB3aXRoIGV2ZW50cyBhcyBrZXkgYW5kIGZ1bmN0aW9ucyBhcyB2YWx1ZS5cblx0ICogQHBhcmFtIHtCb29sZWFufSBnbG9iYWwgLSBGbGFnIHRvIHN3aXRjaCBiZXR3ZWVuIGdsb2JhbCBhbmQgbG9jYWwgZXZlbnRzLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0cmVnaXN0ZXJFdmVudHMoZXZ0cywgZ2xvYmFsID0gZmFsc2UpIHtcblx0XHRpZiAoZXZ0cykge1xuXHRcdFx0T2JqZWN0LmtleXMoZXZ0cykuZm9yRWFjaCgoa2V5KSA9PiB7XG5cdFx0XHRcdHRoaXMucmVnaXN0ZXJFdmVudChrZXksIGV2dHNba2V5XSwgZ2xvYmFsKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlciBhbiBldmVudCBieSB1c2luZyBhIHNpbXBsZSB0ZW1wbGF0ZSBlbmdpbmUgYW5kXG5cdCAqIGEga2V5L3ZhbHVlIHBhaXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldnRLZXkgLSBFdmVudCBrZXkgd2hpY2ggY29udGFpbnMgZXZlbnQgYW5kIGFkZGl0aW9uYWxseSBhIGRlbGVnYXRlZCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZm4gLSBGdW5jdGlvbiBkZWZpbmVkIGFzIHN0cmluZyB3aGljaCB3aWxsIGJlIGJvdW5kIHRvIHRoaXMuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZ2xvYmFsIC0gRmxhZyBpZiBnbG9iYWwgb3IgbG9jYWwgZXZlbnQgLlxuXHQgKlxuXHQgKiBAcHVibGljXG5cdCAqXG5cdCAqIEBleGFtcGxlXG5cdCAqIHRoaXMucmVnaXN0ZXJFdmVudCgnY2xpY2sgLmJ0bicsICdyZW5kZXInKTtcblx0ICogdGhpcy5yZWdpc3RlckV2ZW50KCdjbGljayB7e3RoaXMub3B0aW9ucy5idG59fScsICdyZW5kZXInKTtcblx0ICogdGhpcy5yZWdpc3RlckV2ZW50KCd7e0FwcC5FVkVOVFMuY3VzdG9tLmV2ZW50JywgJ3JlbmRlcicpO1xuXHQgKiB0aGlzLnJlZ2lzdGVyRXZlbnQoJ3t7QXBwLkVWRU5UUy5yZXNpemUnLCAncmVuZGVyJywgdHJ1ZSk7XG5cdCAqL1xuXHRyZWdpc3RlckV2ZW50KGV2dEtleSwgZm4sIGdsb2JhbCA9IGZhbHNlKSB7XG5cdFx0aWYgKHR5cGVvZiBldnRLZXkgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKCdWZWFtc0NvbXBvbmVudCA6OiBZb3VyIGV2ZW50IGlzIG5vdCBhIHN0cmluZyEnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIGZuICE9PSAnc3RyaW5nJykge1xuXHRcdFx0Y29uc29sZS5lcnJvcignVmVhbXNDb21wb25lbnQgOjogWW91ciBldmVudCBoYW5kbGVyIGZ1bmN0aW9uIGlzIG5vdCBhIHN0cmluZyEnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgZXZ0S2V5QXJyID0gZXZ0S2V5LnNwbGl0KCcgJyk7XG5cdFx0bGV0IGFycmxlbiA9IGV2dEtleUFyci5sZW5ndGg7XG5cdFx0bGV0IGV2dFR5cGUgPSBnZXRTdHJpbmdWYWx1ZS5hcHBseSh0aGlzLCBbdHBsRW5naW5lKGV2dEtleUFyclswXSksIHRoaXMuYXBwSW5zdGFuY2VdKTtcblx0XHRsZXQgYmluZEZuID0gdGhpc1tmbl0uYmluZCh0aGlzKTtcblx0XHRsZXQgaWQgPSBidWlsZEV2dElkKGV2dEtleUFyciwgZm4pO1xuXG5cdFx0aWYgKGFycmxlbiA+IDIpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSXQgc2VlbXMgbGlrZSB5b3UgaGF2ZSBtb3JlIHRoYW4gdHdvIHN0cmluZ3MgaW4geW91ciBldmVudHMgb2JqZWN0IScpO1xuXHRcdH1cblxuXHRcdC8vIEJpbmQgb24gdGhpcy4kZWxcblx0XHRpZiAoYXJybGVuID09PSAxICYmICFnbG9iYWwpIHtcblx0XHRcdHRoaXMuJGVsLm9uKGV2dFR5cGUsIGJpbmRGbik7XG5cblx0XHRcdHRoaXMuX3N1YnNjcmliZXJzID0ge1xuXHRcdFx0XHR0eXBlOiAnZXZlbnQnLFxuXHRcdFx0XHRpZDogaWQsXG5cdFx0XHRcdGV2ZW50OiBldnRUeXBlLFxuXHRcdFx0XHRoYW5kbGVyOiBiaW5kRm5cblx0XHRcdH07XG5cblx0XHR9IGVsc2UgaWYgKGFycmxlbiA9PT0gMSAmJiBnbG9iYWwpIHtcblx0XHRcdHRoaXMuYXBwSW5zdGFuY2UuVmVudC5zdWJzY3JpYmUoZXZ0VHlwZSwgYmluZEZuKTtcblxuXHRcdFx0dGhpcy5fc3Vic2NyaWJlcnMgPSB7XG5cdFx0XHRcdHR5cGU6ICdnbG9iYWxFdmVudCcsXG5cdFx0XHRcdGlkOiBpZCxcblx0XHRcdFx0ZXZlbnQ6IGV2dFR5cGUsXG5cdFx0XHRcdGhhbmRsZXI6IGJpbmRGblxuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGV0IGRlbGVnYXRlID0gZ2V0U3RyaW5nVmFsdWUuYXBwbHkodGhpcywgW3RwbEVuZ2luZShldnRLZXlBcnJbMV0pXSk7XG5cblx0XHRcdHRoaXMuJGVsLm9uKGV2dFR5cGUsIGRlbGVnYXRlLCBiaW5kRm4pO1xuXG5cdFx0XHR0aGlzLl9zdWJzY3JpYmVycyA9IHtcblx0XHRcdFx0dHlwZTogJ2RlbGVnYXRlZEV2ZW50Jyxcblx0XHRcdFx0ZGVsZWdhdGU6IGRlbGVnYXRlLFxuXHRcdFx0XHRpZDogaWQsXG5cdFx0XHRcdGV2ZW50OiBldnRUeXBlLFxuXHRcdFx0XHRoYW5kbGVyOiBiaW5kRm5cblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIERlbGV0ZSBhbGwgcmVnaXN0ZXJlZCBldmVudHMuXG5cdCAqL1xuXHR1bnJlZ2lzdGVyRXZlbnRzKCkge1xuXHRcdGZvciAobGV0IGtleSBpbiB0aGlzLl9zdWJzY3JpYmVycykge1xuXHRcdFx0aWYgKHRoaXMuX3N1YnNjcmliZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0bGV0IG9iaiA9IHRoaXMuX3N1YnNjcmliZXJzW2tleV07XG5cblx0XHRcdFx0aWYgKG9iai50eXBlID09PSAnZ2xvYmFsRXZlbnQnKSB7XG5cdFx0XHRcdFx0dGhpcy5hcHBJbnN0YW5jZS5WZW50LnVuc3Vic2NyaWJlKG9iai5ldmVudCwgb2JqLmhhbmRsZXIpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG9iai50eXBlID09PSAnZGVsZWdhdGVkRXZlbnQnKSB7XG5cdFx0XHRcdFx0dGhpcy4kZWwub2ZmKG9iai5ldmVudCwgb2JqLmRlbGVnYXRlLCBvYmouaGFuZGxlcik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy4kZWwub2ZmKG9iai5ldmVudCwgb2JqLmhhbmRsZXIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFVucmVnaXN0ZXIgYW4gZXZlbnQgYnkgdXNpbmcgdGhlIHNhdmVkIHN1YnNjcmliZXJzIGFuZFxuXHQgKiBhIGtleS92YWx1ZSBwYWlyLlxuXHQgKlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZ0S2V5IC0gRXZlbnQga2V5IHdoaWNoIGNvbnRhaW5zIGV2ZW50IGFuZCBhZGRpdGlvbmFsbHkgYSBkZWxlZ2F0ZWQgZWxlbWVudC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGZuIC0gRnVuY3Rpb24gZGVmaW5lZCBhcyBzdHJpbmcgd2hpY2ggd2lsbCBiZSB1bmJvdW5kIHRvIHRoaXMuXG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICpcblx0ICogQGV4YW1wbGVcblx0ICogdGhpcy51bnJlZ2lzdGVyRXZlbnQoJ2NsaWNrIC5idG4nLCAncmVuZGVyJyk7XG5cdCAqIHRoaXMudW5yZWdpc3RlckV2ZW50KCdjbGljayB7e3RoaXMub3B0aW9ucy5idG59fScsICdyZW5kZXInKTtcblx0ICogdGhpcy51bnJlZ2lzdGVyRXZlbnQoJ3t7QXBwLkVWRU5UUy5jdXN0b20uZXZlbnQnLCAncmVuZGVyJyk7XG5cdCAqIHRoaXMudW5yZWdpc3RlckV2ZW50KCd7e0FwcC5FVkVOVFMucmVzaXplJywgJ3JlbmRlcicpO1xuXHQgKi9cblx0dW5yZWdpc3RlckV2ZW50KGV2dEtleSwgZm4pIHtcblx0XHRsZXQgZXZ0S2V5QXJyID0gZXZ0S2V5LnNwbGl0KCcgJyk7XG5cdFx0bGV0IGlkID0gYnVpbGRFdnRJZChldnRLZXlBcnIsIGZuKTtcblxuXHRcdGlmICh0aGlzLl9zdWJzY3JpYmVyc1tpZF0pIHtcblx0XHRcdGxldCBvYmogPSB0aGlzLl9zdWJzY3JpYmVyc1tpZF07XG5cblx0XHRcdGlmIChvYmoudHlwZSA9PT0gJ2dsb2JhbEV2ZW50Jykge1xuXHRcdFx0XHR0aGlzLmFwcEluc3RhbmNlLlZlbnQudW5zdWJzY3JpYmUob2JqLmV2ZW50LCBvYmouaGFuZGxlcik7XG5cdFx0XHR9IGVsc2UgaWYgKG9iai50eXBlID09PSAnZGVsZWdhdGVkRXZlbnQnKSB7XG5cdFx0XHRcdHRoaXMuJGVsLm9mZihvYmouZXZlbnQsIG9iai5kZWxlZ2F0ZSwgb2JqLmhhbmRsZXIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy4kZWwub2ZmKG9iai5ldmVudCwgb2JqLmhhbmRsZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBWZWFtc0NvbXBvbmVudDsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU2ltcGxlIGV4dGVuZCBtZXRob2QsIHdoaWNoIGV4dGVuZHMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBvYmplY3Qgd2hpY2ggd2lsbCBiZSBleHRlbmRlZFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gb2JqIC0gZXh0ZW5kZWQgb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlZmF1bHRzSGVscGVyKG9iaikge1xuXHRcdFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKS5mb3JFYWNoKChpdGVtKSA9PiB7XG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gaXRlbSkge1xuXHRcdFx0XHRpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZCkgb2JqW2tleV0gPSBpdGVtW2tleV07XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIG9iajtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbXBsZSBleHRlbmQgbWV0aG9kIHRvIGV4dGVuZCB0aGUgcHJvcGVydGllcyBvZiBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIG9iamVjdCB3aGljaCB3aWxsIGJlIGV4dGVuZGVkXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBvYmogLSBleHRlbmRlZCBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuXHRbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuXHRcdGZvciAobGV0IGtleSBpbiBpdGVtKSBvYmpba2V5XSA9IGl0ZW1ba2V5XTtcblx0fSk7XG5cdHJldHVybiBvYmo7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiBlbGVtZW50IGlzIGluIHZpZXdwb3J0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVsZW0gLSBPYmplY3QsIHdoaWNoIHdlIHdhbnQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlQm91bmRzIC0gaWYgdHJ1ZSwgd2hvbGUgZWxlbWVudCBtdXN0IGJlIHZpc2libGVcbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0luVmlld3BvcnQoZWxlbSwgdXNlQm91bmRzKSB7XG5cdGxldCBlbCA9IGVsZW07XG5cdGxldCB0b3AgPSBlbC5vZmZzZXRUb3A7XG5cdGxldCBsZWZ0ID0gZWwub2Zmc2V0TGVmdDtcblx0bGV0IHdpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG5cdGxldCBoZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQ7XG5cdGxldCBjb25kID0gZmFsc2U7XG5cblx0d2hpbGUgKGVsLm9mZnNldFBhcmVudCkge1xuXHRcdGVsID0gZWwub2Zmc2V0UGFyZW50O1xuXHRcdHRvcCArPSBlbC5vZmZzZXRUb3A7XG5cdFx0bGVmdCArPSBlbC5vZmZzZXRMZWZ0O1xuXHR9XG5cblx0aWYgKHVzZUJvdW5kcykge1xuXHRcdGNvbmQgPSB0b3AgPj0gd2luZG93LnBhZ2VZT2Zmc2V0ICYmIGxlZnQgPj0gd2luZG93LnBhZ2VYT2Zmc2V0ICYmICh0b3AgKyBoZWlnaHQpIDw9ICh3aW5kb3cucGFnZVlPZmZzZXQgKyB3aW5kb3cuaW5uZXJIZWlnaHQpICYmIChsZWZ0ICsgd2lkdGgpIDw9ICh3aW5kb3cucGFnZVhPZmZzZXQgKyB3aW5kb3cuaW5uZXJXaWR0aCk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uZCA9IHRvcCA8ICh3aW5kb3cucGFnZVlPZmZzZXQgKyB3aW5kb3cuaW5uZXJIZWlnaHQpICYmIGxlZnQgPCAod2luZG93LnBhZ2VYT2Zmc2V0ICsgd2luZG93LmlubmVyV2lkdGgpICYmICh0b3AgKyBoZWlnaHQpID4gd2luZG93LnBhZ2VZT2Zmc2V0ICYmIChsZWZ0ICsgd2lkdGgpID4gd2luZG93LnBhZ2VYT2Zmc2V0O1xuXHR9XG5cblx0cmV0dXJuIGNvbmQ7XG59OyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZW5lcmF0ZXMgbnVtZXJpYyBpZC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW3NlZ21lbnRzPTFdIC0gbnVtYmVyIG9mIHNlZ21lbnRzIG9mIGdlbmVyYXRlZCBpZCAoc2VnbWVudHMgY29uc2lzdCBvZiAxMCBkaWdpdHMsIHNlcGFyYXRlZCBieSAnLScpLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gLSBnZW5lcmF0ZWQgaWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWFrZUlkKHNlZ21lbnRzID0gMSkge1xuXHRsZXQgY3J5cHRvID0gd2luZG93LmNyeXB0byB8fCB3aW5kb3cubXNDcnlwdG87XG5cdGxldCBhcnJheSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KHNlZ21lbnRzKSk7XG5cdGxldCBpZCA9ICcnO1xuXHRsZXQgaSA9IDA7XG5cblx0Zm9yICg7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdGlkICs9IGFycmF5W2ldICsgJy0nO1xuXHR9XG5cblx0cmV0dXJuIGlkLnNsaWNlKDAsIC0xKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEhlbHBlciBtZXRob2QgdG8gZXh0ZW5kIGFuIGFscmVhZHkgZXhpc3RpbmcgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0byAtIHZpZXcgd2hpY2ggd2lsbCBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGZyb20gLSBtZXRob2RzIHdoaWNoIGNvbWVzIGZyb20gbWl4aW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIC0gZnVuY3Rpb24gbmFtZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXRob2RFeHRlbmQodG8sIGZyb20sIG1ldGhvZE5hbWUpIHtcblx0ZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcblx0fVxuXG5cdGlmIChmcm9tID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuXHQvLyBpZiB0aGUgbWV0aG9kIGlzIGRlZmluZWQgb24gZnJvbSAuLi5cblx0aWYgKCFpc1VuZGVmaW5lZChmcm9tW21ldGhvZE5hbWVdKSkge1xuXHRcdGxldCBvbGQgPSB0b1ttZXRob2ROYW1lXTtcblxuXHRcdC8vIC4uLiB3ZSBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb24gdG9cblx0XHR0b1ttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0Ly8gd2hlcmVpbiB3ZSBmaXJzdCBjYWxsIHRoZSBtZXRob2Qgd2hpY2ggZXhpc3RzIG9uIGB0b2Bcblx0XHRcdGxldCBvbGRSZXR1cm4gPSBvbGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdFx0Ly8gYW5kIHRoZW4gY2FsbCB0aGUgbWV0aG9kIG9uIGBmcm9tYFxuXHRcdFx0ZnJvbVttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0XHQvLyBhbmQgdGhlbiByZXR1cm4gdGhlIGV4cGVjdGVkIHJlc3VsdCxcblx0XHRcdC8vIGkuZS4gd2hhdCB0aGUgbWV0aG9kIG9uIGB0b2AgcmV0dXJuc1xuXHRcdFx0cmV0dXJuIG9sZFJldHVybjtcblx0XHR9O1xuXHR9XG59OyIsIid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGRlZmF1bHRzSGVscGVyIGZyb20gJy4vZGVmYXVsdHMnO1xuaW1wb3J0IG1ldGhvZEV4dGVuZEhlbHBlciBmcm9tICcuL21ldGhvZC1leHRlbmQnO1xuXG4vKipcbiAqIE1lcmdlIG1ldGhvZCBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZyb20gLSBNaXhpbiBvYmplY3Qgd2hpY2ggd2lsbCBiZSBtZXJnZWQgdmlhIEhlbHBlcnMuZGVmYXVsdHMgd2l0aCB0aGUgbWV0aG9kcyBvZiBvdXIgY2xhc3NcbiAqIEBwYXJhbSB7QXJyYXl9IG1ldGhvZHMgLSBBcnJheSBvZiBtZXRob2QgbmFtZXMgd2hpY2ggd2lsbCBiZSBleHRlbmRlZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWl4aW4oZnJvbSwgbWV0aG9kcyA9IFsnaW5pdGlhbGl6ZScsICdyZW5kZXInXSkge1xuXHRpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y29uc29sZS5lcnJvcihgVmVhbXNIZWxwZXJzIDogTWl4aW4gOjogTWl4aW4gbm90IGZvdW5kIWApO1xuXG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0bGV0IHRvID0gdGhpcy5wcm90b3R5cGU7XG5cblx0LyoqIEFkZCB0aG9zZSBtZXRob2RzIHdoaWNoIGV4aXN0cyBvbiBgZnJvbWAgYnV0IG5vdCBvbiBgdG9gIHRvIHRoZSBsYXR0ZXIgKi9cblx0ZGVmYXVsdHNIZWxwZXIodG8sIGZyb20pO1xuXG5cdC8qKiB3ZSBkbyB0aGUgc2FtZSBmb3IgZXZlbnRzICovXG5cdGlmICh0by5ldmVudHMpIHtcblx0XHRkZWZhdWx0c0hlbHBlcih0by5ldmVudHMsIGZyb20uZXZlbnRzKTtcblx0fVxuXG5cdC8vIEV4dGVuZCB0bydzIG1ldGhvZHNcblx0bWV0aG9kcy5mb3JFYWNoKChtZXRob2QpID0+IHtcblx0XHRtZXRob2RFeHRlbmRIZWxwZXIodG8sIGZyb20sIG1ldGhvZCk7XG5cdH0pO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZWN0IHRyYW5zaXRpb25lbmQgZXZlbnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRyYW5zaXRpb25FbmRFdmVudCgpIHtcblx0bGV0IHQ7XG5cdGxldCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zha2VlbGVtZW50Jyk7XG5cdGxldCB0cmFuc2l0aW9ucyA9IHtcblx0XHQndHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcblx0XHQnT1RyYW5zaXRpb24nOiAnb1RyYW5zaXRpb25FbmQnLFxuXHRcdCdNb3pUcmFuc2l0aW9uJzogJ3RyYW5zaXRpb25lbmQnLFxuXHRcdCdXZWJraXRUcmFuc2l0aW9uJzogJ3dlYmtpdFRyYW5zaXRpb25FbmQnXG5cdH07XG5cblx0Zm9yICh0IGluIHRyYW5zaXRpb25zKSB7XG5cdFx0aWYgKGVsLnN0eWxlW3RdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiB0cmFuc2l0aW9uc1t0XTtcblx0XHR9XG5cdH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldCB2YWx1ZSBvdXQgb2YgdmFyaWFibGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBTdHJpbmcgd2hpY2ggaXMgYSByZWZlcmVuY2UgdG8gYSB2YXIuXG4gKlxuICogQHJldHVybiBTdHJpbmdcbiAqL1xuY29uc3QgZ2V0U3RyaW5nVmFsdWUgPSBmdW5jdGlvbiBnZXRTdHJpbmdWYWx1ZShzdHIsIGluc3RhbmNlT2JqZWN0KSB7XG5cdGlmIChzdHIuaW5kZXhPZignLicpID09PSAtMSkgcmV0dXJuIHN0cjtcblx0bGV0IGFyciA9IHN0ci5zcGxpdCgnLicpO1xuXHRsZXQgY29udGV4dCA9IGFyclswXTtcblx0bGV0IGZpbmFsU3RyID0gY29udGV4dCA9PT0gJ3RoaXMnID8gdGhpcyA6IGluc3RhbmNlT2JqZWN0ID8gaW5zdGFuY2VPYmplY3QgOiB3aW5kb3dbY29udGV4dF07XG5cblx0bGV0IHN0clJlcGxhY2VyID0gKGVsLCBwcmV2KSA9PiB7XG5cdFx0cmV0dXJuIHByZXZbZWxdO1xuXHR9O1xuXG5cdGFyci5zaGlmdCgpO1xuXHRhcnIuZm9yRWFjaCgoaXRlbSkgPT4ge1xuXHRcdGZpbmFsU3RyID0gc3RyUmVwbGFjZXIoaXRlbSwgZmluYWxTdHIpO1xuXHRcdHJldHVybiBmaW5hbFN0cjtcblx0fSk7XG5cblx0aWYgKHR5cGVvZiBmaW5hbFN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXN1bHRpbmcgdmFyaWFibGUgb3V0IG9mIHlvdXIgZXZlbnRzIG9iamVjdCBtdXN0IGJlIGEgc3RyaW5nIScpO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBmaW5hbFN0cjtcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgZ2V0U3RyaW5nVmFsdWU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzdHJpbmdIZWxwZXJzID0ge307XG5cbi8qKlxuICogQ2FtZWxDYXNlIHN0cmluZ3MgYnkgcmVwbGFjaW5nIGh5cGhlbnMsIHdoaXRlIHNwYWNlIGFuZCBwb2ludHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIFN0cmluZyB3aGljaCB3aWxsIGJlIGNhbWVsY2FzZWRcbiAqL1xuc3RyaW5nSGVscGVycy50b0NhbWVsQ2FzZSA9IGZ1bmN0aW9uIChzdHIpIHtcblx0Ly8gTG93ZXIgY2FzZXMgdGhlIHN0cmluZ1xuXHRyZXR1cm4gc3RyLnRvTG93ZXJDYXNlKClcblx0Ly8gUmVwbGFjZXMgYW55IC0gb3IgXyBjaGFyYWN0ZXJzIHdpdGggYSBzcGFjZVxuXHRcdC5yZXBsYWNlKC9bLV9dKy9nLCAnICcpXG5cdFx0Ly8gUmVtb3ZlcyBhbnkgbm9uIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzXG5cdFx0LnJlcGxhY2UoL1teXFx3XFxzXS9nLCAnJylcblx0XHQvLyBVcHBlcmNhc2VzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gZWFjaCBncm91cCBpbW1lZGlhdGVseSBmb2xsb3dpbmcgYSBzcGFjZVxuXHRcdC8vIChkZWxpbWl0ZWQgYnkgc3BhY2VzKVxuXHRcdC5yZXBsYWNlKC8gKC4pL2csIGZ1bmN0aW9uICgkMSkge1xuXHRcdFx0cmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSlcblx0XHQvLyBSZW1vdmVzIHNwYWNlc1xuXHRcdC5yZXBsYWNlKC8gL2csICcnKTtcbn07XG5cbi8qKlxuICogU3RyaW5nIHdoaWNoIHdpbGwgYmUgaHlwaGVuYXRlZCBieSByZXBsYWNpbmcgd2hpdGUgc3BhY2UgYW5kIGxvd2VyIGNhc2UgdGhlIGNoYXJhY3RlcnMuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIC0gU3RyaW5nXG4gKi9cbnN0cmluZ0hlbHBlcnMuaHlwaGVuYXRlID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gc3RyLnJlcGxhY2UoL1xccy9nLCAnLScpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG4vKipcbiAqIFN0cmluZy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgLSBTdHJpbmcgd2hlcmUgZmlyc3QgY2hhciBpcyB1cHBlciBjYXNlZFxuICovXG5zdHJpbmdIZWxwZXJzLmNhcGl0YWxpemVGaXJzdExldHRlciA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ0hlbHBlcnM7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbXBsZSB0ZW1wbGF0ZSBlbmdpbmUgZm9yIGV2ZW50IHN5c3RlbS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHBsU3RyIC0gVGVtcGxhdGUgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4gU3RyaW5nXG4gKi9cbmNvbnN0IHRlbXBsYXRlRW5naW5lID0gZnVuY3Rpb24gdGVtcGxhdGVFbmdpbmUodHBsU3RyKSB7XG5cdGxldCByZWcgPSBuZXcgUmVnRXhwKCcoXFx7XFx7XFxzPykoLispKFxccz9cXH1cXH0pJyk7XG5cdGxldCBtYXRjaCA9IHJlZy5leGVjKHRwbFN0cik7XG5cdGxldCByZXR1cm5WYWwgPSAnJztcblxuXHRpZiAobWF0Y2gpIHtcblx0XHRyZXR1cm5WYWwgPSBtYXRjaFsyXTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm5WYWwgPSB0cGxTdHI7XG5cdH1cblxuXHRyZXR1cm4gcmV0dXJuVmFsO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGVFbmdpbmU7IiwiLyoqXG4gKiBDb25zdCBmb3IgZXZlbnRzIChwdWIvc3ViKVxuICpcbiAqIEBhdXRob3I6IFNlYmFzdGlhbiBGaXR6bmVyXG4gKi9cblxuLyoqXG4gKiBFdmVudHMgR2xvYmFsXG4gKi9cblxuY29uc3QgRVZFTlRTID0ge307XG5cblxuXG4vKipcbiAqIEV2ZW50cyBmb3IgU2xpZGVyXG4gKi9cbkVWRU5UUy5zbGlkZXIgPSB7XG5cdHNsaWRlU3RhcnQ6ICdzbGlkZTpzdGFydCdcbn07XG5cblxuLyoqXG4gKiBFdmVudHMgQWNjb3JkaW9uXG4gKi9cbkVWRU5UUy5hY2NvcmRpb24gPSB7XG5cdG9wZW5BbGw6ICdhY2NvcmRpb246b3BlbkFsbCcsXG5cdGNsb3NlQWxsOiAnYWNjb3JkaW9uOmNsb3NlQWxsJ1xufTtcblxuXG4vKipcbiAqIEV2ZW50cyBmb3IgVG9nZ2xlclxuICovXG5FVkVOVFMudG9nZ2xlciA9IHtcblx0ZXZlbnROYW1lOiAndG9nZ2xlcjpldmVudE5hbWUnXG59O1xuXG5cbi8qKlxuICogRXZlbnRzIEZvcm1cbiAqL1xuRVZFTlRTLmZvcm0gPSB7XG5cdGNvbXBsZXRlOiAnZm9ybTpjb21wbGV0ZScsXG5cdHJlc2V0OiAnZm9ybTpyZXNldCdcbn07XG5cblxuLyoqXG4gKiBFdmVudHMgT3ZlcmxheVxuICovXG5FVkVOVFMub3ZlcmxheSA9IHtcblx0b3BlbjogJ292ZXJsYXk6b3Blbidcbn07XG5cbi8vIEBJTlNFUlRQT0lOVCA6OiBAcmVmOiBqcy1ldmVudHNcblxuZXhwb3J0IGRlZmF1bHQgRVZFTlRTOyIsIi8vIEdsb2JhbCBkZXBlbmRlbmNpZXNcbmltcG9ydCB7QXBwLCBWZWFtc30gZnJvbSAnLi9hcHAnO1xuXG5jb25zb2xlLmxvZygnSlMgaW5pdGlhbGl6ZWQgaW4gdmVyc2lvbjonLCBBcHAudmVyc2lvbik7XG5jb25zb2xlLmxvZygnVmVhbXMgaW5pdGlhbGl6ZWQgaW4gdmVyc2lvbjonLCBWZWFtcy5iYXNlLnZlcnNpb24pO1xuXG4vLyBJbXBvcnRzXG5cbmltcG9ydCBTbGlkZXIgZnJvbSAnLi4vdGVtcGxhdGluZy9wYXJ0aWFscy9jb21wb25lbnRzL3NsaWRlci9qcy9zbGlkZXInO1xuaW1wb3J0IEFjY29yZGlvbiBmcm9tICcuLi90ZW1wbGF0aW5nL3BhcnRpYWxzL2NvbXBvbmVudHMvYWNjb3JkaW9uL2pzL2FjY29yZGlvbic7XG5cbmltcG9ydCBUb2dnbGVyIGZyb20gJy4uL3RlbXBsYXRpbmcvcGFydGlhbHMvY29tcG9uZW50cy90b2dnbGVyL2pzL3RvZ2dsZXInO1xuXG5cbmltcG9ydCBDVEEgZnJvbSAnLi4vdGVtcGxhdGluZy9wYXJ0aWFscy9jb21wb25lbnRzL2N0YS9qcy9jdGEnO1xuXG5cbmltcG9ydCBGb3JtQWpheCBmcm9tICcuLi90ZW1wbGF0aW5nL3BhcnRpYWxzL2NvbXBvbmVudHMvZm9ybS9qcy9mb3JtLWFqYXgnO1xuaW1wb3J0IEZvcm1EYXRlcGlja2VyIGZyb20gJy4uL3RlbXBsYXRpbmcvcGFydGlhbHMvY29tcG9uZW50cy9mb3JtL2pzL2Zvcm0tZGF0ZXBpY2tlcic7XG5cblxuaW1wb3J0IENvbXBhcmVyIGZyb20gJy4uL3RlbXBsYXRpbmcvcGFydGlhbHMvY29tcG9uZW50cy9jb21wYXJlci9qcy9jb21wYXJlcic7XG5cblxuaW1wb3J0IE92ZXJsYXkgZnJvbSAnLi4vdGVtcGxhdGluZy9wYXJ0aWFscy9jb21wb25lbnRzL292ZXJsYXkvanMvb3ZlcmxheSc7XG5cblxuaW1wb3J0IFNsaWRlRm94IGZyb20gJy4uL3RlbXBsYXRpbmcvcGFydGlhbHMvY29tcG9uZW50cy9zbGlkZS1mb3gvanMvc2xpZGUtZm94JztcblxuLy8gQElOU0VSVFBPSU5UIDo6IEByZWY6IGpzLXNlbGYtY29udGFpbmVkLWltcG9ydCwgQGtlZXA6IHRydWUgLy9cblxuLy8gSW5pdGlhbGl6ZSBtb2R1bGVzIHdpdGggVmVhbXNcblZlYW1zLm1vZHVsZXMucmVnaXN0ZXIoW1xuICAgIC8qKlxuICAgICAqIEluaXQgU2xpZGVyXG4gICAgICovXG4gICAge1xuICAgICAgICBuYW1lc3BhY2U6ICdzbGlkZXInLFxuICAgICAgICBtb2R1bGU6IFNsaWRlclxuICAgIH0sXG4gXHQvLyBJbml0IEFjY29yZGlvblxuIFx0e1xuIFx0XHRuYW1lc3BhY2U6ICdhY2NvcmRpb24nLFxuIFx0XHRtb2R1bGU6IEFjY29yZGlvblxuIFx0fSxcblx0Ly8gSW5pdCBUb2dnbGVyIC8vXG5cdHtcblx0XHRkb21OYW1lOiAndG9nZ2xlcicsXG5cdFx0bW9kdWxlOiBUb2dnbGVyLFxuXHR9LFxuIFx0Ly8gSW5pdCBDYWxsLVRvLUFjdGlvblxuIFx0e1xuIFx0XHRuYW1lc3BhY2U6ICdjdGEnLFxuIFx0XHRtb2R1bGU6IENUQVxuIFx0fVxuICAgICxcbiAgICAvKipcbiAgICAgKiBJbml0IEFKQVggRm9ybVxuICAgICAqL1xuICAgIHtcbiAgICAgICAgbmFtZXNwYWNlOiAnZm9ybS1hamF4JyxcbiAgICAgICAgbW9kdWxlOiBGb3JtQWpheFxuICAgIH1cbiAgICAsXG4gICAgLyoqXG4gICAgICogSW5pdCBGb3JtIERhdGVwaWNrZXJcbiAgICAgKi9cbiAgICB7XG5cdCAgICBuYW1lc3BhY2U6ICdmb3JtLWRhdGVwaWNrZXInLFxuXHQgICAgbW9kdWxlOiBGb3JtRGF0ZXBpY2tlclxuICAgIH1cblxuIFx0LFxuIFx0Ly8gSW5pdCBDb21wYXJlclxuIFx0e1xuIFx0XHRuYW1lc3BhY2U6ICdjb21wYXJlcicsXG4gXHRcdG1vZHVsZTogQ29tcGFyZXJcbiBcdH1cblxuXG5cblxuICAgICxcbiAgICAvKipcbiAgICAgKiBJbml0IFNsaWRlRm94XG4gICAgICovXG4gICAge1xuICAgICAgICBuYW1lc3BhY2U6ICdzbGlkZS1mb3gnLFxuICAgICAgICBtb2R1bGU6IFNsaWRlRm94XG4gICAgfVxuXG4gICAgLy8gQElOU0VSVFBPSU5UIDo6IEByZWY6IGpzLWluaXQtdjUsIEBrZWVwOiB0cnVlIC8vXG5dKTtcblxuXG5cbi8qKlxuICogSW5pdCBPdmVybGF5XG4gKi9cbm5ldyBPdmVybGF5KHtcbiAgICBhcHBJbnN0YW5jZTogVmVhbXNcbn0pO1xuXG4vLyBASU5TRVJUUE9JTlQgOjogQHJlZjoganMtaW5pdC1vbmNlLXY1LCBAa2VlcDogdHJ1ZSAvL1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihIYW5kbGViYXJzKSB7XG5cbndpbmRvd1tcIkFwcFwiXSA9IHdpbmRvd1tcIkFwcFwiXSB8fCB7fTtcbndpbmRvd1tcIkFwcFwiXVtcIlRlbXBsYXRlc1wiXSA9IHdpbmRvd1tcIkFwcFwiXVtcIlRlbXBsYXRlc1wiXSB8fCB7fTtcblxud2luZG93W1wiQXBwXCJdW1wiVGVtcGxhdGVzXCJdW1wiT1ZFUkxBWVwiXSA9IEhhbmRsZWJhcnMudGVtcGxhdGUoe1wiY29tcGlsZXJcIjpbNyxcIj49IDQuMC4wXCJdLFwibWFpblwiOmZ1bmN0aW9uKGNvbnRhaW5lcixkZXB0aDAsaGVscGVycyxwYXJ0aWFscyxkYXRhKSB7XG4gICAgcmV0dXJuIFwiPGRpdiBjbGFzcz1cXFwiYy1vdmVybGF5LS1kZWZhdWx0XFxcIiBkYXRhLWNzcz1cXFwiYy1vdmVybGF5XFxcIiBkYXRhLWpzLWl0ZW09XFxcIm92ZXJsYXlcXFwiPlxcblx0PGRpdiBjbGFzcz1cXFwib3ZlcmxheV9fd3JhcHBlclxcXCI+XFxuXHRcdDxidXR0b24gY2xhc3M9XFxcIm92ZXJsYXlfX2Nsb3NlXFxcIiBkYXRhLWpzLWl0ZW09XFxcIm92ZXJsYXktY2xvc2VcXFwiPjwvYnV0dG9uPlxcblx0XHQ8ZGl2IGNsYXNzPVxcXCJvdmVybGF5X19jb250ZW50XFxcIj5cXG5cdFx0XHQ8ZGl2IGNsYXNzPVxcXCJvdmVybGF5X19pbm5lclxcXCIgZGF0YS1qcy1pdGVtPVxcXCJvdmVybGF5LWNvbnRlbnRcXFwiPlxcblxcblx0XHRcdDwvZGl2Plxcblx0XHQ8L2Rpdj5cXG5cdDwvZGl2Plxcblx0PGRpdiBjbGFzcz1cXFwib3ZlcmxheV9fbWFza1xcXCIgZGF0YS1qcy1pdGVtPVxcXCJvdmVybGF5LW1hc2tcXFwiPjwvZGl2PlxcbjwvZGl2PlwiO1xufSxcInVzZURhdGFcIjp0cnVlfSk7XG5cbnJldHVybiB3aW5kb3dbXCJBcHBcIl1bXCJUZW1wbGF0ZXNcIl07XG5cbn07IiwiLyoqXG4gKiBSZXByZXNlbnRzIGEgc2ltcGxlIGFjY29yZGlvbiB3aXRoIHRyYW5zaXRpb25zIGFuZCBtYXgtaGVpZ2h0LlxuICpcbiAqIEBtb2R1bGUgQWNjb3JkaW9uXG4gKiBAdmVyc2lvbiB2My4wLjJcbiAqXG4gKiBAYXV0aG9yIFNlYmFzdGlhbiBGaXR6bmVyXG4gKiBAYXV0aG9yIEFuZHkgR3V0c2NoZVxuICovXG5cbi8qKlxuICogUmVxdWlyZW1lbnRzXG4gKi9cbmltcG9ydCB7IFZlYW1zIH0gZnJvbSAnYXBwJztcbmltcG9ydCBWZWFtc0NvbXBvbmVudCBmcm9tICd2ZWFtcy9zcmMvanMvY29tbW9uL2NvbXBvbmVudCc7XG5cbmNvbnN0ICQgPSBWZWFtcy4kO1xuY29uc3QgSGVscGVycyA9IFZlYW1zLmhlbHBlcnM7XG5cbi8qKlxuICogQ2xhc3MgQWNjb3JkaW9uXG4gKi9cbmNsYXNzIEFjY29yZGlvbiBleHRlbmRzIFZlYW1zQ29tcG9uZW50IHtcblx0Y29uc3RydWN0b3Iob2JqKSB7XG5cdFx0bGV0IG9wdGlvbnMgPSB7XG5cdFx0XHRhY3RpdmVDbGFzczogJ2lzLWFjdGl2ZScsXG5cdFx0XHRhY2NvcmRpb25CdG46ICdbZGF0YS1qcy1pdGVtPVwiYWNjb3JkaW9uLWJ0blwiXScsXG5cdFx0XHRhY2NvcmRpb25Db250ZW50OiAnW2RhdGEtanMtaXRlbT1cImFjY29yZGlvbi1jb250ZW50XCJdJyxcblx0XHRcdGNhbGN1bGF0aW5nQ2xhc3M6ICdpcy1jYWxjdWxhdGluZycsXG5cdFx0XHRjbGlja0hhbmRsZXI6ICdjbGljaycsXG5cdFx0XHRjbG9zZUNsYXNzOiAnaXMtY2xvc2VkJyxcblx0XHRcdGRhdGFNYXhBdHRyOiAnZGF0YS1qcy1oZWlnaHQnLFxuXHRcdFx0b3BlbkFsbE9uSW5pdDogZmFsc2UsXG5cdFx0XHRvcGVuQnlIYXNoOiBmYWxzZSxcblx0XHRcdG9wZW5DbGFzczogJ2lzLW9wZW4nLFxuXHRcdFx0b3BlbkluZGV4OiBudWxsLFxuXHRcdFx0b3Blbk9uVmlld3BvcnRzOiBbXG5cdFx0XHRcdCd0YWJsZXQtc21hbGwnLFxuXHRcdFx0XHQndGFibGV0LWxhcmdlJyxcblx0XHRcdFx0J2Rlc2t0b3AnXG5cdFx0XHRdLCAvLyBhcnJheTogdmlld3BvcnQgbmFtZXMgLSBlZy46IFsnbW9iaWxlJywgJ3RhYmxldCcsICdkZXNrdG9wLXNtYWxsJywgJ2Rlc2t0b3AnXVxuXHRcdFx0cmVtb3ZlU3R5bGVzOiBmYWxzZSwgLy8gVE9ET1xuXHRcdFx0c2luZ2xlT3BlbjogZmFsc2UsXG5cdFx0XHR0YWJNb2RlOiBmYWxzZSxcblx0XHRcdHVucmVzb2x2ZWRDbGFzczogJ2lzLXVucmVzb2x2ZWQnXG5cdFx0fTtcblxuXHRcdHN1cGVyKG9iaiwgb3B0aW9ucyk7XG5cdH1cblxuXHQvKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBHRVRURVIgJiBTRVRURVJcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblx0LyoqXG5cdCAqIEdldCBtb2R1bGUgaW5mb3JtYXRpb25cblx0ICovXG5cdHN0YXRpYyBnZXQgaW5mbygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogJ0FjY29yZGlvbicsXG5cdFx0XHR2ZXJzaW9uOiAnMy4wLjInLFxuXHRcdFx0dmM6IHRydWUsXG5cdFx0XHRtb2Q6IGZhbHNlIC8vIHNldCB0byB0cnVlIGlmIHNvdXJjZSB3YXMgbW9kaWZpZWQgaW4gcHJvamVjdFxuXHRcdH07XG5cdH1cblxuXHRzZXQgJGFjY29yZGlvbkNvbnRlbnRzKGl0ZW1zKSB7XG5cdFx0dGhpcy5fJGFjY29yZGlvbkNvbnRlbnRzID0gaXRlbXM7XG5cdH1cblxuXHRnZXQgJGFjY29yZGlvbkNvbnRlbnRzKCkge1xuXHRcdHJldHVybiB0aGlzLl8kYWNjb3JkaW9uQ29udGVudHM7XG5cdH1cblxuXHRzZXQgJGFjY29yZGlvbkJ0bnMoaXRlbXMpIHtcblx0XHR0aGlzLl8kYWNjb3JkaW9uQnRucyA9IGl0ZW1zO1xuXHR9XG5cblx0Z2V0ICRhY2NvcmRpb25CdG5zKCkge1xuXHRcdHJldHVybiB0aGlzLl8kYWNjb3JkaW9uQnRucztcblx0fVxuXG5cdHNldCAkdGFyZ2V0KGl0ZW0pIHtcblx0XHR0aGlzLl8kdGFyZ2V0ID0gaXRlbTtcblx0fVxuXG5cdGdldCAkdGFyZ2V0KCkge1xuXHRcdHJldHVybiB0aGlzLl8kdGFyZ2V0O1xuXHR9XG5cblx0c2V0ICRidG4oaXRlbSkge1xuXHRcdHRoaXMuXyRidG4gPSBpdGVtO1xuXHR9XG5cblx0Z2V0ICRidG4oKSB7XG5cdFx0cmV0dXJuIHRoaXMuXyRidG47XG5cdH1cblxuXHQvKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBFVkVOVFNcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cdGdldCBldmVudHMoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdCd7e3RoaXMub3B0aW9ucy5jbGlja0hhbmRsZXJ9fSB7e3RoaXMub3B0aW9ucy5hY2NvcmRpb25CdG59fSc6ICdoYW5kbGVDbGljaydcblx0XHR9XG5cdH1cblxuXHRnZXQgc3Vic2NyaWJlKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHQne3tWZWFtcy5FVkVOVFMucmVzaXplfX0nOiAncmVuZGVyJyxcblx0XHRcdCd7e1ZlYW1zLkVWRU5UUy5hY2NvcmRpb24uY2xvc2VBbGx9fSc6ICdjbG9zZUFsbCcsXG5cdFx0XHQne3tWZWFtcy5FVkVOVFMuYWNjb3JkaW9uLm9wZW5BbGx9fSc6ICdvcGVuQWxsJ1xuXHRcdH1cblx0fVxuXG5cdC8qKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIFNUQU5EQVJEIE1FVEhPRFNcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cdC8qKlxuXHQgKiBJbml0IG1ldGhvZCB0byBzYXZlIGFsbCBuZWNlc3NhcnkgcmVmZXJlbmNlcy5cblx0ICovXG5cdGluaXRpYWxpemUoKSB7XG5cdFx0dGhpcy4kYWNjb3JkaW9uQ29udGVudHMgPSAkKHRoaXMub3B0aW9ucy5hY2NvcmRpb25Db250ZW50LCB0aGlzLiRlbCk7XG5cdFx0dGhpcy4kYWNjb3JkaW9uQnRucyA9ICQodGhpcy5vcHRpb25zLmFjY29yZGlvbkJ0biwgdGhpcy4kZWwpO1xuXHRcdHRoaXMuJHRhcmdldCA9IG51bGw7XG5cdFx0dGhpcy4kYnRuID0gbnVsbDtcblx0XHR0aGlzLm9wZW5JbmRleCA9IHRoaXMub3B0aW9ucy5vcGVuSW5kZXg7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLm9wZW5CeUhhc2gpIHtcblx0XHRcdGxldCBpZHggPSB0aGlzLmdldEluZGV4QnlIYXNoKCk7XG5cblx0XHRcdHRoaXMub3BlbkluZGV4ID0gdHlwZW9mIGlkeCA9PT0gJ251bWJlcicgPyBpZHggOiB0aGlzLm9wdGlvbnMub3BlbkluZGV4O1xuXHRcdH1cblx0XHRlbHNlIGlmICh0aGlzLm9wdGlvbnMudGFiTW9kZSAmJiAhdGhpcy5vcHRpb25zLm9wZW5JbmRleCkge1xuXHRcdFx0dGhpcy5vcGVuSW5kZXggPSAwO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kIGFsbCBldmVudHNcblx0ICovXG5cdGJpbmRFdmVudHMoKSB7XG5cdFx0bGV0IGZuT25IYXNoQ2hhbmdlID0gdGhpcy5vbkhhc2hDaGFuZ2UuYmluZCh0aGlzKTtcblxuXHRcdC8vIEdsb2JhbCBldmVudHNcblx0XHRpZiAodGhpcy5vcHRpb25zLm9wZW5CeUhhc2gpIHtcblx0XHRcdCQod2luZG93KS5vbihWZWFtcy5FVkVOVFMuaGFzaGNoYW5nZSwgZm5Pbkhhc2hDaGFuZ2UpO1xuXHRcdH1cblx0fVxuXG5cdHJlbmRlcigpIHtcblx0XHRpZiAoIVZlYW1zLmN1cnJlbnRNZWRpYSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdBY2NvcmRpb246IFZlYW1zLmN1cnJlbnRNZWRpYSBpcyBuZWNlc3NhcnkgdG8gc3VwcG9ydCB0aGUgc2xpZGVyIG1vZHVsZSEnKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnJlbW92ZVN0eWxlcygpO1xuXHRcdHRoaXMuc2F2ZUhlaWdodHModGhpcy4kYWNjb3JkaW9uQ29udGVudHMpO1xuXHRcdHRoaXMuY2xvc2VBbGwoKTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMub3BlbkFsbE9uSW5pdCkge1xuXHRcdFx0dGhpcy5vcGVuQWxsKCk7XG5cdFx0fVxuXG5cdFx0Ly8gT3BlbiBvbiBpbmRleCBpZiBzZXQgaW4gb3B0aW9uc1xuXHRcdGlmICh0eXBlb2YgdGhpcy5vcGVuSW5kZXggPT09ICdudW1iZXInKSB7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnRhYk1vZGUgfHwgdGhpcy5vcHRpb25zLm9wZW5PblZpZXdwb3J0cy5pbmRleE9mKFZlYW1zLmN1cnJlbnRNZWRpYSkgIT09IC0xKSB7XG5cdFx0XHRcdHRoaXMuYWN0aXZhdGVCdG4odGhpcy4kYWNjb3JkaW9uQnRucy5lcSh0aGlzLm9wZW5JbmRleCkpO1xuXHRcdFx0XHR0aGlzLnNsaWRlRG93bih0aGlzLiRhY2NvcmRpb25Db250ZW50cy5lcSh0aGlzLm9wZW5JbmRleCkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLiRlbC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMudW5yZXNvbHZlZENsYXNzKSkge1xuXHRcdFx0dGhpcy4kZWwucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnVucmVzb2x2ZWRDbGFzcyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogQ1VTVE9NIEFDQ09SRElPTiBNRVRIT0RTXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXHQvKipcblx0ICogR2V0IGluZGV4IG9mIGFjY29yZGlvbiBjb250ZW50IHJlZmVyZW5jZWQgYnkgaGFzaFxuXHQgKlxuXHQgKiBAcmV0dXJuIHtudW1iZXJ8Ym9vbGVhbn0gLSBpbmRleCBvZiBlbGVtZW50IG9yIGZhbHNlIGlmIG5vIG1hdGNoXG5cdCAqL1xuXHRnZXRJbmRleEJ5SGFzaCgpIHtcblx0XHRsZXQgaGFzaCA9IGRvY3VtZW50LmxvY2F0aW9uLmhhc2guc3BsaXQoJyMnKTtcblx0XHRsZXQgcmV0VmFsID0gZmFsc2U7XG5cdFx0bGV0IGkgPSAwO1xuXG5cdFx0aWYgKGhhc2ggPCAyKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yIChpOyBpIDwgdGhpcy4kYWNjb3JkaW9uQ29udGVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLiRhY2NvcmRpb25Db250ZW50c1tpXS5pZCA9PT0gaGFzaFsxXSkge1xuXHRcdFx0XHRyZXRWYWwgPSBpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0VmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIE9wZW4gYWNjb3JkaW9uIGNvbnRlbnQgcmVmZXJlbmNlZCBieSBoYXNoXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBlIC0gZXZlbnQgb2JqZWN0XG5cdCAqL1xuXHRvbkhhc2hDaGFuZ2UoZSkge1xuXHRcdGxldCBpZHggPSB0aGlzLmdldEluZGV4QnlIYXNoKCk7XG5cblx0XHRpZiAodHlwZW9mIGlkeCA9PT0gJ251bWJlcicpIHtcblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zaW5nbGVPcGVuKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2VBbGwoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hY3RpdmF0ZUJ0bih0aGlzLiRhY2NvcmRpb25CdG5zLmVxKGlkeCkpO1xuXHRcdFx0dGhpcy5zbGlkZURvd24odGhpcy4kYWNjb3JkaW9uQ29udGVudHMuZXEoaWR4KSk7XG5cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU2F2ZSBoZWlnaHRzIG9mIGFsbCBhY2NvcmRpb24gY29udGVudHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zIC0gYXJyYXkgb2YgaXRlbXNcblx0ICovXG5cdHNhdmVIZWlnaHRzKGl0ZW1zKSB7XG5cdFx0SGVscGVycy5mb3JFYWNoKGl0ZW1zLCAoaWR4LCBpdGVtKSA9PiB7XG5cdFx0XHR0aGlzLnNhdmVIZWlnaHQoaXRlbSk7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogU2F2ZSB0aGUgaGVpZ2h0IG9mIHRoZSBub2RlIGl0ZW0uXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIC0gaXRlbSB0byBjYWxjdWxhdGUgdGhlIGhlaWdodFxuXHQgKi9cblx0c2F2ZUhlaWdodChpdGVtKSB7XG5cdFx0bGV0ICRlbCA9ICQoaXRlbSk7XG5cblx0XHQvLyB0aGUgZWwgaXMgaGlkZGVuIHNvOlxuXHRcdC8vIG1ha2luZyB0aGUgZWwgYmxvY2sgc28gd2UgY2FuIG1lYXN1cmUgaXRzIGhlaWdodCBidXQgc3RpbGwgYmUgaGlkZGVuXG5cdFx0JGVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jYWxjdWxhdGluZ0NsYXNzKTtcblxuXHRcdGxldCB3YW50ZWRIZWlnaHQgPSAkZWwub3V0ZXJIZWlnaHQoKTtcblxuXHRcdC8vIHJldmVydGluZyB0byB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0JGVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jYWxjdWxhdGluZ0NsYXNzKTtcblxuXHRcdC8vIHNhdmUgaGVpZ2h0IGluIGRhdGEgYXR0cmlidXRlXG5cdFx0JGVsLmF0dHIodGhpcy5vcHRpb25zLmRhdGFNYXhBdHRyLCB3YW50ZWRIZWlnaHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEhhbmRsZSB0aGUgY2xpY2ssXG5cdCAqIGdldCB0aGUgaWQgb2YgdGhlIGNsaWNrZWQgYnV0dG9uIGFuZFxuXHQgKiBleGVjdXRlIHRoZSB0b2dnbGVDb250ZW50IG1ldGhvZC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGUgLSBldmVudCBvYmplY3Rcblx0ICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRUYXJnZXQgLSBUYXJnZXQgdG8gd2hpY2ggbGlzdGVuZXIgd2FzIGF0dGFjaGVkLlxuXHQgKi9cblx0aGFuZGxlQ2xpY2soZSwgY3VycmVudFRhcmdldCkge1xuXHRcdHRoaXMuJGJ0biA9IGN1cnJlbnRUYXJnZXQgPyAkKGN1cnJlbnRUYXJnZXQpIDogJChlLmN1cnJlbnRUYXJnZXQpO1xuXHRcdGxldCB0YXJnZXRJZCA9IHRoaXMuJGJ0bi5hdHRyKCdocmVmJyk7XG5cblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLnRhYk1vZGUgJiYgdGhpcy4kYnRuLmhhc0NsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnRvZ2dsZUNvbnRlbnQodGFyZ2V0SWQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRvZ2dsZSB0aGUgYWNjb3JkaW9uIGNvbnRlbnQgYnkgdXNpbmcgdGhlIGlkIG9mIHRoZSBhY2NvcmRpb24gYnV0dG9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBpZCBvZiB0aGUgdGFyZ2V0XG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdHRvZ2dsZUNvbnRlbnQoaWQpIHtcblx0XHR0aGlzLiR0YXJnZXQgPSB0aGlzLiRlbC5maW5kKGlkKTtcblxuXHRcdGlmICh0aGlzLiR0YXJnZXQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLm9wZW5DbGFzcykpIHtcblx0XHRcdHRoaXMuc2xpZGVVcCh0aGlzLiR0YXJnZXQpO1xuXHRcdFx0dGhpcy5kZWFjdGl2YXRlQnRuKHRoaXMuJGJ0bik7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zaW5nbGVPcGVuIHx8IHRoaXMub3B0aW9ucy50YWJNb2RlKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2VBbGwoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hY3RpdmF0ZUJ0bih0aGlzLiRidG4pO1xuXHRcdFx0dGhpcy5zbGlkZURvd24odGhpcy4kdGFyZ2V0KTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTWltaWNzIHRoZSBzbGlkZVVwIGZ1bmN0aW9uYWxpdHkgb2YgalF1ZXJ5IGJ5IHVzaW5nIGhlaWdodCBhbmQgdHJhbnNpdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9ICRpdGVtIC0galF1ZXJ5IG9iamVjdCBvZiBpdGVtXG5cdCAqL1xuXHRzbGlkZVVwKCRpdGVtKSB7XG5cdFx0JGl0ZW1cblx0XHRcdC5jc3MoJ2hlaWdodCcsIDApXG5cdFx0XHQucmVtb3ZlQXR0cignc3R5bGUnKVxuXHRcdFx0LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKVxuXHRcdFx0LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5vcGVuQ2xhc3MpXG5cdFx0XHQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNsb3NlQ2xhc3MpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1pbWljcyB0aGUgc2xpZGVEb3duIGZ1bmN0aW9uYWxpdHkgb2YgalF1ZXJ5IGJ5IHVzaW5nIGhlaWdodCBhbmQgdHJhbnNpdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9ICRpdGVtIC0galF1ZXJ5IG9iamVjdCBvZiBpdGVtXG5cdCAqL1xuXHRzbGlkZURvd24oJGl0ZW0pIHtcblx0XHQkaXRlbVxuXHRcdFx0LmNzcygnaGVpZ2h0JywgJGl0ZW0uYXR0cignZGF0YS1qcy1oZWlnaHQnKSArICdweCcpXG5cdFx0XHQuYXR0cignYXJpYS1leHBhbmRlZCcsICd0cnVlJylcblx0XHRcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuY2xvc2VDbGFzcylcblx0XHRcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMub3BlbkNsYXNzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGRzIGFjdGl2ZSBjbGFzcyB0byB0aGUgY2xpY2tlZCBidXR0b24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSAkaXRlbSAtIGpRdWVyeSBvYmplY3Qgb2YgYnV0dG9uXG5cdCAqL1xuXHRhY3RpdmF0ZUJ0bigkaXRlbSkge1xuXHRcdCRpdGVtLmFkZENsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhY3RpdmUgY2xhc3MgZnJvbSB0aGUgYnV0dG9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gJGl0ZW0gLSBqUXVlcnkgb2JqZWN0IG9mIGJ1dHRvblxuXHQgKi9cblx0ZGVhY3RpdmF0ZUJ0bigkaXRlbSkge1xuXHRcdCRpdGVtLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcyk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlIGFsbCBzdHlsZXMgb2YgdGhlIGFjY29yZGlvbiBjb250ZW50IGVsZW1lbnRzXG5cdCAqL1xuXHRyZW1vdmVTdHlsZXMoKSB7XG5cdFx0dGhpcy4kYWNjb3JkaW9uQ29udGVudHMucmVtb3ZlQXR0cignc3R5bGUnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9zZSBhbGwgYWNjb3JkaW9uIGNvbnRlbnRzIGFuZCBhY3RpdmUgYnV0dG9uc1xuXHQgKlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRjbG9zZUFsbCgpIHtcblx0XHRIZWxwZXJzLmZvckVhY2godGhpcy4kYWNjb3JkaW9uQ29udGVudHMsIChpZHgsIGl0ZW0pID0+IHtcblx0XHRcdHRoaXMuc2xpZGVVcCgkKGl0ZW0pKTtcblx0XHR9KTtcblx0XHRIZWxwZXJzLmZvckVhY2godGhpcy4kYWNjb3JkaW9uQnRucywgKGlkeCwgaXRlbSkgPT4ge1xuXHRcdFx0dGhpcy5kZWFjdGl2YXRlQnRuKCQoaXRlbSkpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENsb3NlIGFsbCBhY2NvcmRpb24gY29udGVudHMgYW5kIGFjdGl2ZSBidXR0b25zXG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdG9wZW5BbGwoKSB7XG5cdFx0SGVscGVycy5mb3JFYWNoKHRoaXMuJGFjY29yZGlvbkNvbnRlbnRzLCAoaWR4LCBpdGVtKSA9PiB7XG5cdFx0XHR0aGlzLnNsaWRlRG93bigkKGl0ZW0pKTtcblx0XHR9KTtcblx0XHRIZWxwZXJzLmZvckVhY2godGhpcy4kYWNjb3JkaW9uQnRucywgKGlkeCwgaXRlbSkgPT4ge1xuXHRcdFx0dGhpcy5hY3RpdmF0ZUJ0bigkKGl0ZW0pKTtcblx0XHR9KTtcblx0fVxufVxuXG4vLyBSZXR1cm5zIGNvbnN0cnVjdG9yXG5leHBvcnQgZGVmYXVsdCBBY2NvcmRpb247IiwiLyoqXG4gKiBEZXNjcmlwdGlvbiBvZiBDb250ZW50Q29tcGFyZXIuXG4gKlxuICogQG1vZHVsZSBDb250ZW50Q29tcGFyZXJcbiAqIEB2ZXJzaW9uIHYzLjAuMFxuICpcbiAqIEBhdXRob3Iga29lbi56aWd0ZXJtYW5cbiAqL1xuXG5pbXBvcnQgeyBWZWFtcyB9IGZyb20gJ2FwcCc7XG5pbXBvcnQgVmVhbXNDb21wb25lbnQgZnJvbSAndmVhbXMvc3JjL2pzL2NvbW1vbi9jb21wb25lbnQnO1xuXG5jb25zdCAkID0gVmVhbXMuJDtcblxuY2xhc3MgQ29tcGFyZXIgZXh0ZW5kcyBWZWFtc0NvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RvciBmb3Igb3VyIGNsYXNzXG5cdCAqXG5cdCAqIEBzZWUgbW9kdWxlLmpzXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBPYmplY3Qgd2hpY2ggaXMgcGFzc2VkIHRvIG91ciBjbGFzc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqLmVsIC0gZWxlbWVudCB3aGljaCB3aWxsIGJlIHNhdmVkIGluIHRoaXMuZWxcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iai5vcHRpb25zIC0gb3B0aW9ucyB3aGljaCB3aWxsIGJlIHBhc3NlZCBpbiBhcyBKU09OIG9iamVjdFxuXHQgKi9cblx0Y29uc3RydWN0b3Iob2JqKSB7XG5cdFx0bGV0IG9wdGlvbnMgPSB7XG5cdFx0XHRoYW5kbGU6ICdbZGF0YS1qcy1pdGVtPVwiY29tcGFyZXItaGFuZGxlXCJdJyxcblx0XHRcdHRvcENvbnRhaW5lcjogJ1tkYXRhLWpzLWl0ZW09XCJjb21wYXJlci10b3AtY29udGFpbmVyXCJdJyxcblx0XHRcdHRvcENvbnRlbnQ6ICdbZGF0YS1qcy1pdGVtPVwiY29tcGFyZXItdG9wLWNvbnRlbnRcIl0nLFxuXHRcdFx0ZHJhZ2dDbGFzczogJ2lzLWRyYWdnaW5nJyxcblx0XHRcdGRyYWdNb2RlOiB0cnVlLFxuXHRcdFx0dG9wQ29udGVudFJpZ2h0OiBmYWxzZSxcblx0XHRcdGRpc2FibGVkOiB7XG5cdFx0XHRcdCdkZXNrdG9wJzogZmFsc2UsXG5cdFx0XHRcdCd0YWJsZXQtbGFyZ2UnOiBmYWxzZSxcblx0XHRcdFx0J3RhYmxldC1zbWFsbCc6IGZhbHNlLFxuXHRcdFx0XHQnbW9iaWxlLWxhcmdlJzogZmFsc2UsXG5cdFx0XHRcdCdtb2JpbGUtbWVkaXVtJzogZmFsc2UsXG5cdFx0XHRcdCdtb2JpbGUtc21hbGwnOiBmYWxzZVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRzdXBlcihvYmosIG9wdGlvbnMpO1xuXHR9XG5cblx0LyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogR0VUVEVSICYgU0VUVEVSXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cdC8qKlxuXHQgKiBHZXQgbW9kdWxlIGluZm9ybWF0aW9uXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IGluZm8oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHZlcnNpb246ICczLjAuMCdcblx0XHR9O1xuXHR9XG5cblx0LyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogRVZFTlRTXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cdC8qKlxuXHQgKiBTdWJzY3JpYmUgdG8gZ2xvYmFsIGV2ZW50cyBvZiBWZWFtcyBvciBBcHAgbmFtZXNwYWNlLlxuXHQgKi9cblx0Z2V0IHN1YnNjcmliZSgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0J3t7VmVhbXMuRVZFTlRTLnJlc2l6ZX19JzogJ3ByZVJlbmRlcicsXG5cdFx0XHQne3tWZWFtcy5FVkVOVFMubWVkaWFjaGFuZ2V9fSc6ICdyZW5kZXInXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kIGxvY2FsIGV2ZW50cyB0byB0aGlzLiRlbC5cblx0ICovXG5cdGdldCBldmVudHMoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdCdtb3VzZWRvd24ge3t0aGlzLm9wdGlvbnMuaGFuZGxlfX0nOiAnbW91c2VEb3duJyxcblx0XHRcdCdtb3VzZXVwJzogJ21vdXNlVXAnLFxuXHRcdFx0J3RvdWNoc3RhcnQge3t0aGlzLm9wdGlvbnMuaGFuZGxlfX0nOiAnbW91c2VEb3duJyxcblx0XHRcdCd0b3VjaGVuZCc6ICdtb3VzZVVwJyxcblx0XHRcdCdtb3VzZW1vdmUnOiAncmVzaXplQ29udGFpbmVyJ1xuXHRcdH07XG5cdH1cblxuXHQvKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBTVEFOREFSRCBNRVRIT0RTXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgdmlldyBhbmQgbWVyZ2Ugb3B0aW9uc1xuXHQgKlxuXHQgKi9cblx0aW5pdGlhbGl6ZSgpIHtcblx0XHR0aGlzLiR0b3BDb250YWluZXIgPSAkKHRoaXMub3B0aW9ucy50b3BDb250YWluZXIsIHRoaXMuJGVsKTtcblx0XHR0aGlzLiR0b3BDb250ZW50ID0gJCh0aGlzLm9wdGlvbnMudG9wQ29udGVudCwgdGhpcy4kZWwpO1xuXHRcdHRoaXMuJGhhbmRsZSA9ICQodGhpcy5vcHRpb25zLmhhbmRsZSwgdGhpcy4kZWwpO1xuXHR9XG5cblxuXHQvKipcblx0ICogUHJlLVJlbmRlciBtZXRob2Rcblx0ICovXG5cdHByZVJlbmRlcigpe1xuXHRcdC8vIFJldHVybiBpZiBtb2R1bGUgaXMgZGlzYWJsZWRcblx0XHRpZih0aGlzLmRpc2FibGVkKSByZXR1cm47XG5cblx0XHR0aGlzLmVsV2lkdGggPSB0aGlzLmVsLmNsaWVudFdpZHRoO1xuXHRcdHRoaXMuJHRvcENvbnRlbnQuY3NzKCd3aWR0aCcsIHRoaXMuZWxXaWR0aCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVyIG1ldGhvZFxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmKHRoaXMub3B0aW9ucy5kaXNhYmxlZFtWZWFtcy5jdXJyZW50TWVkaWFdICYmICF0aGlzLmRpc2FibGVkKXtcblx0XHRcdHRoaXMuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy5yZXNldFN0eWxlcygpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmRpc2FibGVkID0gdGhpcy5vcHRpb25zLmRpc2FibGVkW1ZlYW1zLmN1cnJlbnRNZWRpYV07XG5cdFx0fVxuXG5cdH1cblxuXHQvKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBDVVNUT00gQ09NUEFSRVIgTUVUSE9EU1xuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblx0bW91c2VEb3duKGUpIHtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHR0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcblx0XHR0aGlzLiRoYW5kbGUuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmRyYWdnQ2xhc3MpO1xuXHR9XG5cblx0bW91c2VVcCgpIHtcblx0XHR0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cdFx0dGhpcy4kaGFuZGxlLmFkZENsYXNzKHRoaXMub3B0aW9ucy5kcmFnZ0NsYXNzKTtcblx0fVxuXHQvKipcblx0ICogUmVzaXplIHRvcCBjb250YWluZXJcblx0ICovXG5cdHJlc2l6ZUNvbnRhaW5lcihlKSB7XG5cdFx0Ly8gUmV0dXJuIGlmIG1vZHVsZSBpcyBkaXNhYmxlZCBvciBpZiBpdCBpcyBub3QgZHJhZ2dpbmcgd2hlbiBkcmFnZ2luZyBtb2RlIGlzIGVuYWJsZWRcblx0XHRpZih0aGlzLmRpc2FibGVkIHx8ICF0aGlzLmRyYWdnaW5nICYmIHRoaXMub3B0aW9ucy5kcmFnTW9kZSApIHJldHVybjtcblxuXHRcdGxldCBtb3VzZVBvcyA9IHRoaXMuZ2V0TW91c2VQb3MoZSk7XG5cdFx0bGV0IGNvbnRlbnRXaWR0aCA9IHRoaXMub3B0aW9ucy50b3BDb250ZW50UmlnaHQgPyB0aGlzLmVsV2lkdGggLSBtb3VzZVBvcyA6IDAgKyBtb3VzZVBvcztcblxuXHRcdHRoaXMuJHRvcENvbnRhaW5lci5jc3MoJ3dpZHRoJywgY29udGVudFdpZHRoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNldCBzdHlsZXNcblx0ICovXG5cdHJlc2V0U3R5bGVzKCl7XG5cdFx0dGhpcy4kdG9wQ29udGVudC5yZW1vdmVBdHRyKCdzdHlsZScpO1xuXHRcdHRoaXMuJHRvcENvbnRhaW5lci5yZW1vdmVBdHRyKCdzdHlsZScpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBtb3VzZSBwb3NpdGlvblxuXHQgKi9cblx0Z2V0TW91c2VQb3MoZSkge1xuXHRcdHJldHVybiAoZS5wYWdlWCAtIHRoaXMuJGVsLm9mZnNldCgpLmxlZnQpO1xuXHR9XG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcGFyZXI7XG4iLCIvKipcbiAqIFJlcHJlc2VudHMgYSBidXR0b24gd2l0aCBjdXN0b20gY2xpY2sgaGFuZGxlcnMuXG4gKlxuICogQG1vZHVsZSBDVEFcbiAqIEB2ZXJzaW9uIHYzLjAuMlxuICpcbiAqIEBhdXRob3IgU2ViYXN0aWFuIEZpdHpuZXJcbiAqIEBhdXRob3IgQW5keSBHdXRzY2hlXG4gKi9cblxuLyoqXG4gKiBSZXF1aXJlbWVudHNcbiAqL1xuaW1wb3J0IHtWZWFtc30gZnJvbSAnYXBwJztcbmltcG9ydCBWZWFtc0NvbXBvbmVudCBmcm9tICd2ZWFtcy9zcmMvanMvY29tbW9uL2NvbXBvbmVudCc7XG5jb25zdCAkID0gVmVhbXMuJDtcblxuY2xhc3MgQ1RBIGV4dGVuZHMgVmVhbXNDb21wb25lbnQge1xuXHQvKipcblx0ICogQ29uc3RydWN0b3IgZm9yIG91ciBjbGFzc1xuXHQgKlxuXHQgKiBAc2VlIG1vZHVsZS5qc1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gT2JqZWN0IHdoaWNoIGlzIHBhc3NlZCB0byBvdXIgY2xhc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IG9iai5lbCAtIGVsZW1lbnQgd2hpY2ggd2lsbCBiZSBzYXZlZCBpbiB0aGlzLmVsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmoub3B0aW9ucyAtIG9wdGlvbnMgd2hpY2ggd2lsbCBiZSBwYXNzZWQgaW4gYXMgSlNPTiBvYmplY3Rcblx0ICovXG5cdGNvbnN0cnVjdG9yKG9iaikge1xuXHRcdGxldCBvcHRpb25zID0ge1xuXHRcdFx0YWN0aXZlQ2xhc3M6ICdpcy1hY3RpdmUnLFxuXHRcdFx0Y2xpY2tIYW5kbGVyOiAnY2xpY2snLFxuXHRcdFx0Y2xvc2VkTGFiZWw6IG51bGwsXG5cdFx0XHRjdGFDb250ZW50OiAnW2RhdGEtanMtaXRlbT1cImN0YS1jb250ZW50XCJdJyxcblx0XHRcdGdsb2JhbEV2ZW50OiAnY3RhOmNsaWNrJyxcblx0XHRcdG9wZW5lZExhYmVsOiBudWxsXG5cdFx0fTtcblxuXHRcdHN1cGVyKG9iaiwgb3B0aW9ucyk7XG5cdH1cblxuXHQvKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBHRVRURVIgJiBTRVRURVJcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblx0LyoqXG5cdCAqIEdldCBtb2R1bGUgaW5mb3JtYXRpb25cblx0ICovXG5cdHN0YXRpYyBnZXQgaW5mbygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dmVyc2lvbjogJzMuMC4yJyxcblx0XHRcdHZjOiB0cnVlLFxuXHRcdFx0bW9kOiBmYWxzZSAvLyBzZXQgdG8gdHJ1ZSBpZiBzb3VyY2Ugd2FzIG1vZGlmaWVkIGluIHByb2plY3Rcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBhbmQgc2V0IHRoZSBhY3RpdmUgc3RhdGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGUgLSBhY3RpdmUgc3RhdGVcblx0ICovXG5cdGdldCBhY3RpdmUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZTtcblx0fVxuXG5cdHNldCBhY3RpdmUoc3RhdGUpIHtcblx0XHR0aGlzLl9hY3RpdmUgPSBzdGF0ZTtcblx0fVxuXG5cdC8qKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIEVWRU5UU1xuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblx0Z2V0IGV2ZW50cygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0J3t7dGhpcy5vcHRpb25zLmNsaWNrSGFuZGxlcn19JzogJ29uQ2xpY2snXG5cdFx0fTtcblx0fVxuXG5cdC8qKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIFNUQU5EQVJEIE1FVEhPRFNcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXHQvKipcblx0ICogSW5pdGlhbGl6ZSB0aGUgdmlldyBhbmQgbWVyZ2Ugb3B0aW9uc1xuXHQgKlxuXHQgKi9cblx0aW5pdGlhbGl6ZSgpIHtcblx0XHR0aGlzLiRjdGFDb250ZW50ID0gJCh0aGlzLm9wdGlvbnMuY3RhQ29udGVudCwgdGhpcy4kZWwpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZWRMYWJlbCAmJiAhdGhpcy5vcHRpb25zLm9wZW5lZExhYmVsIHx8XG5cdFx0XHQhdGhpcy5vcHRpb25zLmNsb3NlZExhYmVsICYmIHRoaXMub3B0aW9ucy5vcGVuZWRMYWJlbCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdDVEE6IFlvdSBoYXZlIHRvIHNldCBjbG9zZWRMYWJlbCBhbmQgb3BlbmVkTGFiZWwgb3Igbm9uZS4nKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmNsb3NlZExhYmVsICYmIHRoaXMub3B0aW9ucy5vcGVuZWRMYWJlbCAmJiAhdGhpcy4kY3RhQ29udGVudC5sZW5ndGgpIHtcblx0XHRcdFx0Y29uc29sZS53YXJuKCdDVEE6IExhYmVscyBzZXQsIGJ1dCAnICsgdGhpcy5vcHRpb25zLmN0YUNvbnRlbnQgK1xuXHRcdFx0XHRcdCcgbm90IGZvdW5kLCBwbGVhc2UgbWFrZSBzdXJlIHNldHRpbmdzLmN0YUNvbnRlbnRKc0l0ZW0gaXMgc2V0IHRvIHRydWUgZm9yIGMtY3RhX19jb250ZW50LicpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLiRlbC5pcygnLicgKyB0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpKSB7XG5cdFx0XHR0aGlzLmFjdGl2ZSA9IHRydWU7XG5cdFx0fVxuXHR9XG5cblx0cmVuZGVyKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdC8qKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIENVU1RPTSBDVEEgTUVUSE9EU1xuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cdC8qKlxuXHQgKiBDbG9zZSBtZXRob2Rcblx0ICpcblx0ICogUmVtb3ZlIHRoZSBhY3RpdmUgY2xhc3MsIHNldCBsYWJlbCBhbmQgdHJpZ2dlciBnbG9iYWwgZXZlbnRcblx0ICpcblx0ICogQHB1YmxpY1xuXHQgKi9cblx0Y2xvc2UoKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbG9zZWRMYWJlbCkge1xuXHRcdFx0dGhpcy4kY3RhQ29udGVudC50ZXh0KHRoaXMub3B0aW9ucy5jbG9zZWRMYWJlbCk7XG5cdFx0XHR0aGlzLiRlbC5hdHRyKCd0aXRsZScsIHRoaXMub3B0aW9ucy5jbG9zZWRMYWJlbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy4kZWwucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHR0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIE9wZW4gbWV0aG9kXG5cdCAqXG5cdCAqIEFkZCB0aGUgYWN0aXZlIGNsYXNzLCBzZXQgbGFiZWwgYW5kIHRyaWdnZXIgZ2xvYmFsIGV2ZW50XG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdG9wZW4oKSB7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5vcGVuZWRMYWJlbCkge1xuXHRcdFx0dGhpcy4kY3RhQ29udGVudC50ZXh0KHRoaXMub3B0aW9ucy5vcGVuZWRMYWJlbCk7XG5cdFx0XHR0aGlzLiRlbC5hdHRyKCd0aXRsZScsIHRoaXMub3B0aW9ucy5vcGVuZWRMYWJlbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy4kZWwuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHR0aGlzLmFjdGl2ZSA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQ2xpY2sgZXZlbnQgbWV0aG9kXG5cdCAqXG5cdCAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZW4gd2hlbiB5b3Ugd2FudCB0byB1c2UgdGhlIGJ1dHRvbiB2aWV3XG5cdCAqIEBzZWUgYnV0dG9uLWluaXQuanNcblx0ICpcblx0ICogQHBhcmFtIHtldmVudH0gZSAtIGV2ZW50IG9iamVjdFxuXHQgKi9cblx0b25DbGljayhlKSB7XG5cdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cdFx0aWYgKHR5cGVvZiB0aGlzLmNsaWNrSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYgKHRoaXMuYWN0aXZlKSB7XG5cdFx0XHRcdHRoaXMuY2xvc2UoKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLm9wZW4oKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5jbGlja0hhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc29sZS53YXJuKCdDVEE6IFlvdSBuZWVkIHRvIGluaGVyaXQgZnJvbSAnICsgdGhpcyArXG5cdFx0XHRcdCcgYW5kIG92ZXJyaWRlIHRoZSBvbkNsaWNrIG1ldGhvZCBvciBwYXNzIGEgZnVuY3Rpb24gdG8gJyArXG5cdFx0XHRcdHRoaXMgKyAnLmNsaWNrSGFuZGxlciAhJyk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIENsaWNrIGhhbmRsZXJcblx0ICpcblx0ICogVGhpcyBtZXRob2QgaXMgcHVibGljIGFuZCBjYW4gYmUgb3ZlcnJpZGRlbiBieVxuXHQgKiBvdGhlciBpbnN0YW5jZXMgdG8gc3VwcG9ydCBhIGdlbmVyaWMgYnV0dG9uIG1vZHVsZVxuXHQgKlxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRjbGlja0hhbmRsZXIoKSB7XG5cdFx0VmVhbXMuVmVudC50cmlnZ2VyKHRoaXMub3B0aW9ucy5nbG9iYWxFdmVudCwge1xuXHRcdFx0ZWw6IHRoaXMuZWwsXG5cdFx0XHRpc0FjdGl2ZTogdGhpcy5hY3RpdmUsXG5cdFx0XHRvcHRpb25zOiB0aGlzLm9wdGlvbnNcblx0XHR9KTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBDVEE7XG4iLCIvKipcbiAqIFJlcHJlc2VudHMgYSBhamF4IGZvcm0gY2xhc3MuXG4gKlxuICogQG1vZHVsZSBGb3JtQWpheFxuICogQHZlcnNpb24gdjMuMC4xXG4gKlxuICogQGF1dGhvciBTZWJhc3RpYW4gRml0em5lclxuICovXG5pbXBvcnQgeyBWZWFtcyB9IGZyb20gJ2FwcCc7XG5pbXBvcnQgVmVhbXNDb21wb25lbnQgZnJvbSAndmVhbXMvc3JjL2pzL2NvbW1vbi9jb21wb25lbnQnO1xuY29uc3QgJCA9IFZlYW1zLiQ7XG5cbmNsYXNzIEZvcm1BamF4IGV4dGVuZHMgVmVhbXNDb21wb25lbnQge1xuXHQvKipcblx0ICogQ29uc3RydWN0b3IgZm9yIG91ciBjbGFzc1xuXHQgKlxuXHQgKiBAc2VlIG1vZHVsZS5qc1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gT2JqZWN0IHdoaWNoIGlzIHBhc3NlZCB0byBvdXIgY2xhc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IG9iai5lbCAtIGVsZW1lbnQgd2hpY2ggd2lsbCBiZSBzYXZlZCBpbiB0aGlzLmVsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmoub3B0aW9ucyAtIG9wdGlvbnMgd2hpY2ggd2lsbCBiZSBwYXNzZWQgaW4gYXMgSlNPTiBvYmplY3Rcblx0ICovXG5cdGNvbnN0cnVjdG9yKG9iaikge1xuXHRcdGxldCBvcHRpb25zID0ge1xuXHRcdFx0c3VibWl0T25Mb2FkOiBmYWxzZSxcblx0XHRcdHN1Ym1pdE9uQ2hhbmdlOiB0cnVlLFxuXHRcdFx0bG9hZGluZ0NsYXNzOiBudWxsLFxuXHRcdFx0c3VjY2Vzc0NsYXNzOiAnaXMtc3VjY2VzcycsXG5cdFx0XHRlcnJvckNsYXNzOiAnaXMtZXJyb3InLFxuXHRcdFx0ZXZlbnROYW1lOiBWZWFtcy5FVkVOVFMuZm9ybS5jb21wbGV0ZVxuXHRcdH07XG5cblx0XHRzdXBlcihvYmosIG9wdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBtb2R1bGUgaW5mb3JtYXRpb25cblx0ICovXG5cdHN0YXRpYyBnZXQgaW5mbygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dmVyc2lvbjogJzMuMC4xJyxcblx0XHRcdHZjOiB0cnVlLFxuXHRcdFx0bW9kOiBmYWxzZSAvLyBzZXQgdG8gdHJ1ZSBpZiBzb3VyY2Ugd2FzIG1vZGlmaWVkIGluIHByb2plY3Rcblx0XHR9O1xuXHR9XG5cblx0aW5pdGlhbGl6ZSgpIHtcblx0XHQvLyBzYXZlIHNvbWUgcmVmZXJlbmNlc1xuXHRcdHRoaXMuZmllbGRzID0gJCgnaW5wdXQnLCB0aGlzLiRlbCk7XG5cdFx0dGhpcy5zZWxlY3RzID0gJCgnc2VsZWN0JywgdGhpcy4kZWwpO1xuXG5cdFx0Ly8gRmV0Y2ggZGF0YSBpZiBvcHRpb24gaXMgdHJ1ZVxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc3VibWl0T25Mb2FkKSB7XG5cdFx0XHR0aGlzLmZldGNoRGF0YSh0aGlzLiRlbCk7XG5cdFx0fVxuXG5cdFx0Ly8gY2FsbCBzdXBlclxuXHRcdHN1cGVyLmluaXRpYWxpemUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kIGFsbCBldmVudGVcblx0ICovXG5cdGJpbmRFdmVudHMoKSB7XG5cdFx0bGV0IGZuRmV0Y2hEYXRhID0gdGhpcy5mZXRjaERhdGEuYmluZCh0aGlzKTtcblx0XHRsZXQgZm5SZXNldCA9IHRoaXMucmVzZXRGaWx0ZXJzLmJpbmQodGhpcyk7XG5cdFx0LyoqXG5cdFx0ICogT24gc3VibWl0IGV2ZW50IGZldGNoIGRhdGFcblx0XHQgKi9cblx0XHR0aGlzLiRlbC5vbihWZWFtcy5FVkVOVFMuc3VibWl0ICsgJyAnICsgVmVhbXMuRVZFTlRTLnJlc2V0LCBmbkZldGNoRGF0YSk7XG5cblx0XHQvKipcblx0XHQgKiBSZXNldCBmaWx0ZXJzIG9uIHJlc2V0IGV2ZW50XG5cdFx0ICovXG5cdFx0VmVhbXMuVmVudC5vbihWZWFtcy5FVkVOVFMuZm9ybS5yZXNldCwgZm5SZXNldCk7XG5cblx0XHQvKipcblx0XHQgKiBJZiBzdWJtaXRPbkNoYW5nZSBpcyB0cnVlXG5cdFx0ICpcblx0XHQgKiBmZXRjaCBkYXRhXG5cdFx0ICogc2hvdyByZXNldCBidXR0b25cblx0XHQgKlxuXHRcdCAqL1xuXHRcdGlmICh0aGlzLm9wdGlvbnMuc3VibWl0T25DaGFuZ2UpIHtcblx0XHRcdHRoaXMuJGVsLm9uKFZlYW1zLkVWRU5UUy5ibHVyICsgJyAnICsgVmVhbXMuRVZFTlRTLmNoYW5nZSwgdGhpcy5maWVsZHMsIGZuRmV0Y2hEYXRhKTtcblx0XHR9XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBBamF4IGNhbGwgdG8gZ2V0IGRhdGEgb2JqZWN0IHdpdGggcmVzdWx0cyBvciBlcnJvciBtZXNzYWdlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZSAtIG9iamVjdCBvciBldmVudC5cblx0ICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRUYXJnZXQgLSBUYXJnZXQgdG8gd2hpY2ggbGlzdGVuZXIgd2FzIGF0dGFjaGVkLlxuXHQgKi9cblx0ZmV0Y2hEYXRhKGUsIGN1cnJlbnRUYXJnZXQpIHtcblx0XHRsZXQgZWw7XG5cblx0XHRpZiAoZSAmJiB0eXBlb2YgZS5wcmV2ZW50RGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0ZWwgPSBjdXJyZW50VGFyZ2V0IHx8IGUuY3VycmVudFRhcmdldCA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsID0gZTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLmxvYWRpbmdDbGFzcykge1xuXHRcdFx0dGhpcy4kZWwuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRpbmdDbGFzcyk7XG5cdFx0fVxuXG5cdFx0bGV0IGFjdGlvbiA9IHRoaXMuJGVsLmF0dHIoJ2FjdGlvbicpO1xuXHRcdGxldCBtZXRob2QgPSB0aGlzLiRlbC5hdHRyKCdtZXRob2QnKTtcblx0XHRsZXQgc2VyaWFsaXplID0gdGhpcy4kZWwuc2VyaWFsaXplKCk7XG5cdFx0bGV0IHVybCA9IGFjdGlvbiArICc/JyArIHNlcmlhbGl6ZTtcblxuXHRcdCQuYWpheCh7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdGRhdGFUeXBlOiAnanNvbicsXG5cdFx0XHRzdWNjZXNzOiAoZGF0YSkgPT4ge1xuXHRcdFx0XHR0aGlzLm9uU3VjY2VzcyhkYXRhLCBlbCk7XG5cdFx0XHR9LFxuXHRcdFx0ZXJyb3I6IChzdGF0dXMsIHN0YXR1c1RleHQpID0+IHtcblx0XHRcdFx0dGhpcy5vbkVycm9yKHN0YXR1cywgc3RhdHVzVGV4dClcblx0XHRcdH1cblx0XHR9KTtcblxuXHR9XG5cblx0b25TdWNjZXNzKGRhdGEsIGVsKSB7XG5cdFx0dGhpcy5maWVsZHMgPSAkKCdpbnB1dCcsIHRoaXMuJGVsKTtcblx0XHR0aGlzLnNlbGVjdHMgPSAkKCdzZWxlY3QnLCB0aGlzLiRlbCk7XG5cblx0XHRWZWFtcy5WZW50LnRyaWdnZXIodGhpcy5vcHRpb25zLmV2ZW50TmFtZSwge1xuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdGVsOiBlbFxuXHRcdH0pO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5sb2FkaW5nQ2xhc3MpIHtcblx0XHRcdHRoaXMuJGVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sb2FkaW5nQ2xhc3MpO1xuXHRcdH1cblxuXHRcdHRoaXMuJGVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy5zdWNjZXNzQ2xhc3MpO1xuXHR9XG5cblx0b25FcnJvcihzdGF0dXMsIHN0YXR1c1RleHQpIHtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMubG9hZGluZ0NsYXNzKSB7XG5cdFx0XHR0aGlzLiRlbC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGluZ0NsYXNzKTtcblx0XHR9XG5cblx0XHR0aGlzLiRlbC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcyk7XG5cblx0XHRjb25zb2xlLndhcm4oJ0Zvcm1BamF4OicsIHN0YXR1c1RleHQsICcoJyArIHN0YXR1cyArICcpJyk7XG5cdH1cblxuXHQvKipcblx0ICogUmVzZXQgZmlsdGVycywgY3VycmVudGx5IHN1cHBvcnRlZFxuXHQgKlxuXHQgKiBjaGVja2JveGVzXG5cdCAqIHNlbGVjdHNcblx0ICovXG5cdHJlc2V0RmlsdGVycygpIHtcblx0XHR0aGlzLnJlc2V0Q2hlY2tzKCk7XG5cdFx0dGhpcy5yZXNldFNlbGVjdHMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNldCBjaGVja2JveGVzXG5cdCAqL1xuXHRyZXNldENoZWNrcygpIHtcblx0XHR0aGlzLmZpZWxkcy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdCQodGhpcykucHJvcCgnY2hlY2tlZCcsIGZhbHNlKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNlc3Qgc2VsZWN0c1xuXHQgKi9cblx0cmVzZXRTZWxlY3RzKCkge1xuXHRcdHRoaXMuc2VsZWN0cy5lYWNoKGZ1bmN0aW9uICgpIHtcblx0XHRcdCQodGhpcykucHJvcCgnc2VsZWN0ZWRJbmRleCcsIDApO1xuXHRcdH0pO1xuXHR9XG59XG5cbi8vIFJldHVybnMgY29uc3RydWN0b3JcbmV4cG9ydCBkZWZhdWx0IEZvcm1BamF4OyIsIi8qKlxuICogZm9ybSBjb21wb25lbnQgZGF0ZXBpY2tlclxuICpcbiAqIEBtb2R1bGUgRm9ybURhdGVwaWNrZXJcbiAqIEB2ZXJzaW9uIHYxLjAuMFxuICpcbiAqIEBhdXRob3IgU2FuZy1JbiBIYWV0emVsXG4gKiBAYXV0aG9yIFNlYmFzdGlhbiBGaXR6bmVyXG4gKi9cbnJlcXVpcmUoJ21vbWVudCcpO1xuaW1wb3J0IHsgVmVhbXMgfSBmcm9tICdhcHAnO1xuaW1wb3J0IFZlYW1zQ29tcG9uZW50IGZyb20gJ3ZlYW1zL3NyYy9qcy9jb21tb24vY29tcG9uZW50JztcbmNvbnN0ICQgPSBWZWFtcy4kO1xuY29uc3QgUGlrYWRheSA9IHJlcXVpcmUoJ3Bpa2FkYXknKTtcblxuY2xhc3MgRm9ybURhdGVwaWNrZXIgZXh0ZW5kcyBWZWFtc0NvbXBvbmVudCB7XG5cdC8qKlxuXHQgKiBDb25zdHJ1Y3RvciBmb3Igb3VyIGNsYXNzXG5cdCAqXG5cdCAqIEBzZWUgbW9kdWxlLmpzXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBPYmplY3Qgd2hpY2ggaXMgcGFzc2VkIHRvIG91ciBjbGFzc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqLmVsIC0gZWxlbWVudCB3aGljaCB3aWxsIGJlIHNhdmVkIGluIHRoaXMuZWxcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iai5vcHRpb25zIC0gb3B0aW9ucyB3aGljaCB3aWxsIGJlIHBhc3NlZCBpbiBhcyBKU09OIG9iamVjdFxuXHQgKi9cblx0Y29uc3RydWN0b3Iob2JqKSB7XG5cdFx0bGV0IG9wdGlvbnMgPSB7fTtcblx0XHRzdXBlcihvYmosIG9wdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdldCBtb2R1bGUgaW5mb3JtYXRpb25cblx0ICovXG5cdHN0YXRpYyBnZXQgaW5mbygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0bmFtZTogJ0Zvcm1EYXRlcGlja2VyJyxcblx0XHRcdHZlcnNpb246ICcxLjAuMCdcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIEdFVFRFUlMgQU5EIFNFVFRFUlNcblx0ICovXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBkYXRlXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBEYXRlXG5cdCAqL1xuXHRzZXQgZGF0ZShkYXRlKSB7XG5cdFx0dGhpcy5fZGF0ZSA9IGRhdGU7XG5cdFx0dGhpcy5kYXRldGltZXBpY2tlci5zZXREYXRlKHRoaXMuX2RhdGUsIHRydWUpO1xuXHR9XG5cblx0Z2V0IGRhdGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGU7XG5cdH1cblxuXHQvKipcblx0ICogaTE4blxuXHQgKi9cblx0Z2V0IGkxOG5GYWxsYmFjaygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0cHJldmlvdXNNb250aDogJ1ByZXZpb3VzIE1vbnRoJyxcblx0XHRcdG5leHRNb250aDogJ05leHQgTW9udGgnLFxuXHRcdFx0bW9udGhzOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXSxcblx0XHRcdHdlZWtkYXlzOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J10sXG5cdFx0XHR3ZWVrZGF5c1Nob3J0OiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuXHRcdFx0Y2FsZW5kYXJGb3JtYXQ6ICdERC5NTS5ZWVlZJ1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIGNsYXNzXG5cdCAqL1xuXHRpbml0aWFsaXplKCkge1xuXHRcdGxldCBpMThuID0gVmVhbXMuaTE4biAmJiBWZWFtcy5pMThuLmRhdGVwaWNrZXIgPyBWZWFtcy5pMThuLmRhdGVwaWNrZXIgOiB0aGlzLmkxOG5GYWxsYmFjaztcblxuXHRcdGxldCBfdGhpcyA9IHRoaXM7XG5cdFx0dGhpcy4kaW5wdXQgPSAkKCdpbnB1dCcsIHRoaXMuJGVsKTtcblx0XHR0aGlzLmRhdGVGb3JtYXQgPSBpMThuLmNhbGVuZGFyRm9ybWF0O1xuXHRcdHRoaXMuZGF0ZXRpbWVwaWNrZXIgPSBuZXcgUGlrYWRheSh7XG5cdFx0XHRmaWVsZDogdGhpcy4kaW5wdXRbMF0sXG5cdFx0XHRpMThuOiBpMThuLFxuXHRcdFx0Y29udGFpbmVyOiB0aGlzLmVsLFxuXHRcdFx0b25TZWxlY3Q6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X3RoaXMuZGF0ZSA9IHRoaXMuZ2V0TW9tZW50KCkuZm9ybWF0KF90aGlzLmRhdGVGb3JtYXQpO1xuXHRcdFx0XHRfdGhpcy4kaW5wdXQudmFsKF90aGlzLmRhdGUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59XG4vLyBSZXR1cm5zIGNvbnN0cnVjdG9yXG5leHBvcnQgZGVmYXVsdCBGb3JtRGF0ZXBpY2tlcjsiLCIvKipcbiAqIFJlcHJlc2VudHMgYW4gb3ZlcmxheSBtb2R1bGUuXG4gKlxuICogVGhpcyBtb2R1bGUgaXMgcmVzcG9uc2libGUgdG8gY3JlYXRlIGFuIG92ZXJsYXlcbiAqIHdpdGhvdXQgcHJlZGVmaW5pbmcgYW55IGlubmVyIG92ZXJsYXkgdGVtcGxhdGUuXG4gKlxuICogSXQgc2hvdWxkIGJlIHVzZWQgYnkgb3RoZXIgbW9kdWxlc1xuICogdG8gZGlzcGxheSB0aGVpciBjb250ZW50IGluIGFuIG92ZXJsYXkuXG4gKlxuICogQG1vZHVsZSBPdmVybGF5XG4gKiBAdmVyc2lvbiB2My4wLjBcbiAqXG4gKiBAYXV0aG9yIFNlYmFzdGlhbiBGaXR6bmVyXG4gKi9cbmltcG9ydCB7VmVhbXN9IGZyb20gJ2FwcCc7XG5pbXBvcnQgVmVhbXNDb21wb25lbnQgZnJvbSAndmVhbXMvc3JjL2pzL2NvbW1vbi9jb21wb25lbnQnO1xuY29uc3QgJCA9IFZlYW1zLiQ7XG5sZXQgVGVtcGxhdGUgPSBWZWFtcy50ZW1wbGF0ZXIudGVtcGxhdGVzO1xuXG5jbGFzcyBPdmVybGF5IGV4dGVuZHMgVmVhbXNDb21wb25lbnQge1xuXHQvKipcblx0ICogQ29uc3RydWN0b3IgZm9yIG91ciBjbGFzc1xuXHQgKlxuXHQgKiBAc2VlIG1vZHVsZS5qc1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gT2JqZWN0IHdoaWNoIGlzIHBhc3NlZCB0byBvdXIgY2xhc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IG9iai5lbCAtIGVsZW1lbnQgd2hpY2ggd2lsbCBiZSBzYXZlZCBpbiB0aGlzLmVsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmoub3B0aW9ucyAtIG9wdGlvbnMgd2hpY2ggd2lsbCBiZSBwYXNzZWQgaW4gYXMgSlNPTiBvYmplY3Rcblx0ICovXG5cdGNvbnN0cnVjdG9yKG9iaikge1xuXHRcdGxldCBvcHRpb25zID0ge1xuXHRcdFx0b3BlbkNsYXNzOiAnaXMtb3BlbicsXG5cdFx0XHRjbG9zZUJ0bjogJ1tkYXRhLWpzLWl0ZW09XCJvdmVybGF5LWNsb3NlXCJdJyxcblx0XHRcdG92ZXJsYXk6ICdbZGF0YS1qcy1pdGVtPVwib3ZlcmxheVwiXScsXG5cdFx0XHRyZWdpb25Db250ZW50OiAnW2RhdGEtanMtaXRlbT1cIm92ZXJsYXktY29udGVudFwiXScsXG5cdFx0XHR0ZW1wbGF0ZTogVGVtcGxhdGVbJ09WRVJMQVknXVxuXHRcdH07XG5cblx0XHRzdXBlcihvYmosIG9wdGlvbnMpO1xuXHR9XG5cblx0LyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogR0VUVEVSICYgU0VUVEVSXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cdC8qKlxuXHQgKiBHZXQgbW9kdWxlIGluZm9ybWF0aW9uXG5cdCAqL1xuXHRzdGF0aWMgZ2V0IGluZm8oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHZlcnNpb246ICczLjAuMCcsXG5cdFx0XHR2YzogdHJ1ZSxcblx0XHRcdG1vZDogZmFsc2UgLy8gc2V0IHRvIHRydWUgaWYgc291cmNlIHdhcyBtb2RpZmllZCBpbiBwcm9qZWN0XG5cdFx0fTtcblx0fVxuXG5cdC8vIHNldCBhbmQgZ2V0IG92ZXJsYXkgdGVtcGxhdGVcblx0Z2V0IHRlbXBsYXRlKCkge1xuXHRcdHJldHVybiB0aGlzLl90ZW1wbGF0ZTtcblx0fVxuXG5cdHNldCB0ZW1wbGF0ZSh0cGwpIHtcblx0XHR0aGlzLl90ZW1wbGF0ZSA9IHRwbDtcblx0fVxuXG5cdC8vIHNldCBhbmQgZ2V0IGluZm9zIGlmIG92ZXJsYXkgaXMgY3JlYXRlZFxuXHRnZXQgb3ZlcmxheUNyZWF0ZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX292ZXJsYXlDcmVhdGVkO1xuXHR9XG5cblx0c2V0IG92ZXJsYXlDcmVhdGVkKGJvbCkge1xuXHRcdHRoaXMuX292ZXJsYXlDcmVhdGVkID0gYm9sO1xuXHR9XG5cblx0Ly8gc2V0IGFuZCBnZXQgaW5mb3MgaWYgb3ZlcmxheSBpcyBvcGVuXG5cdGdldCBpc09wZW4oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lzT3Blbjtcblx0fVxuXG5cdHNldCBpc09wZW4oYm9sKSB7XG5cdFx0dGhpcy5faXNPcGVuID0gYm9sO1xuXHR9XG5cblx0Ly8gc2V0IGFuZCBnZXQgb3ZlcmxheSBlbGVtZW50IGFmdGVyIGNyZWF0aW9uXG5cdGdldCAkb3ZlcmxheSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fJG92ZXJsYXk7XG5cdH1cblxuXHRzZXQgJG92ZXJsYXkoZWwpIHtcblx0XHR0aGlzLl8kb3ZlcmxheSA9IGVsO1xuXHR9XG5cblx0Ly8gc2V0IGFuZCBnZXQgY2xvc2UgYnV0dG9uIGFmdGVyIGNyZWF0aW9uXG5cdGdldCAkY2xvc2VCdG4oKSB7XG5cdFx0cmV0dXJuIHRoaXMuXyRjbG9zZUJ0bjtcblx0fVxuXG5cdHNldCAkY2xvc2VCdG4oZWwpIHtcblx0XHR0aGlzLl8kY2xvc2VCdG4gPSBlbDtcblx0fVxuXG5cdC8vIHNldCBhbmQgZ2V0IGNvbnRlbnQgcmVnaW9uXG5cdGdldCAkcmVnaW9uQ29udGVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fJHJlZ2lvbkNvbnRlbnQ7XG5cdH1cblxuXHRzZXQgJHJlZ2lvbkNvbnRlbnQoZWwpIHtcblx0XHR0aGlzLl8kcmVnaW9uQ29udGVudCA9IGVsO1xuXHR9XG5cblx0LyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogRVZFTlRTXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cdGdldCBzdWJzY3JpYmUoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdCd7e1ZlYW1zLkVWRU5UUy5vdmVybGF5Lm9wZW59fSc6ICdyZW5kZXInXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kIGdsb2JhbCBldmVudHNcblx0ICpcblx0ICogTGlzdGVuIHRvIG9wZW4gYW5kIGNsb3NlIGV2ZW50c1xuXHQgKi9cblx0YmluZEV2ZW50cygpIHtcblx0XHQvLyBDbG9zZSBvdmVybGF5IHdpdGggRVNDXG5cdFx0JCh3aW5kb3cpLm9uKFZlYW1zLkVWRU5UUy5rZXl1cCwgKGUpID0+IHtcblx0XHRcdGlmIChlLmtleUNvZGUgPT0gMjcgJiYgdGhpcy5pc09wZW4pIHtcblx0XHRcdFx0dGhpcy5jbG9zZSgpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpbmQgbG9jYWwgZXZlbnRzXG5cdCAqL1xuXHRiaW5kTG9jYWxFdmVudHMoKSB7XG5cdFx0bGV0IGZuQ2xvc2UgPSB0aGlzLmNsb3NlLmJpbmQodGhpcyk7XG5cblx0XHQvLyBMb2NhbCBldmVudHNcblx0XHR0aGlzLiRjbG9zZUJ0bi5vbihWZWFtcy5FVkVOVFMuY2xpY2ssIGZuQ2xvc2UpO1xuXHR9XG5cblx0LyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogU1RBTkRBUkQgTUVUSE9EU1xuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIHZpZXcgYW5kIG1lcmdlIG9wdGlvbnNcblx0ICpcblx0ICovXG5cdGluaXRpYWxpemUoKSB7XG5cdFx0dGhpcy4kYm9keSA9ICQoJ2JvZHknKTtcblx0XHR0aGlzLnRlbXBsYXRlID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlO1xuXG5cdH1cblxuXHQvKipcblx0ICogUHJlLVJlbmRlciB0aGUgb3ZlcmxheSBhbmQgc2F2ZSByZWZlcmVuY2VzXG5cdCAqL1xuXHRwcmVSZW5kZXIoKSB7XG5cdFx0Ly8gQXBwZW5kIEZFIHRlbXBsYXRlXG5cdFx0dGhpcy4kYm9keS5hcHBlbmQodGhpcy50ZW1wbGF0ZSgpKTtcblxuXHRcdC8vIFNldCBzb21lIHJlZmVyZW5jZXNcblx0XHR0aGlzLiRvdmVybGF5ID0gJCh0aGlzLm9wdGlvbnMub3ZlcmxheSk7XG5cdFx0dGhpcy4kY2xvc2VCdG4gPSAkKHRoaXMub3B0aW9ucy5jbG9zZUJ0biwgdGhpcy4kb3ZlcmxheSk7XG5cdFx0dGhpcy4kcmVnaW9uQ29udGVudCA9ICQodGhpcy5vcHRpb25zLnJlZ2lvbkNvbnRlbnQsIHRoaXMuJG92ZXJsYXkpO1xuXG5cdFx0dGhpcy5vdmVybGF5Q3JlYXRlZCA9IHRydWU7XG5cdFx0dGhpcy5iaW5kTG9jYWxFdmVudHMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZW5kZXIgdGhlIG92ZXJsYXlcblx0ICovXG5cdHJlbmRlcihvYmopIHtcblx0XHRsZXQgZGF0YSA9IG9iai5kYXRhIHx8IChvYmoub3B0aW9ucyAmJiBvYmoub3B0aW9ucy5kYXRhKTtcblxuXHRcdC8vIENoZWNrIGlmIGRhdGEgb2JqZWN0IGlzIHByb3ZpZGVkXG5cdFx0aWYgKCFkYXRhKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ092ZXJsYXk6IFlvdSBoYXZlIHRvIHByb3ZpZGUgYW4gb2JqZWN0IHdpdGggZGF0YSAob2JqLmRhdGEgfHwgb2JqLm9wdGlvbnMuZGF0YSkhJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQXBwZW5kIGRhdGEgdG8gb3ZlcmxheSByZWdpb25cblx0XHR0aGlzLiRyZWdpb25Db250ZW50Lmh0bWwoZGF0YSk7XG5cblx0XHQvLyBPcGVuIG92ZXJsYXlcblx0XHR0aGlzLm9wZW4oKTtcblx0fVxuXG5cdC8qKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIENVU1RPTSBPVkVSTEFZIE1FVEhPRFNcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG5cdC8qKlxuXHQgKiBPcGVuIE92ZXJsYXlcblx0ICovXG5cdG9wZW4oKSB7XG5cdFx0dGhpcy4kb3ZlcmxheS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMub3BlbkNsYXNzKTtcblx0XHR0aGlzLmlzT3BlbiA9IHRydWU7XG5cdH1cblxuXHQvKipcblx0ICogQ2xvc2Ugb3ZlcmxheVxuXHQgKi9cblx0Y2xvc2UoKSB7XG5cdFx0dGhpcy4kb3ZlcmxheS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMub3BlbkNsYXNzKTtcblx0XHR0aGlzLmlzT3BlbiA9IGZhbHNlO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE92ZXJsYXk7IiwiLyoqXG4gKiBSZXByZXNlbnRzIGFuIGVsZW1lbnQgdGhhdCBzbGlkZXMgaW50byB2aWV3IHdoZW4gaXQncyBzY3JvbGxlZCBpbnRvIHZpZXdwb3J0LlxuICpcbiAqIEBtb2R1bGUgU2xpZGVGb3hcbiAqIEB2ZXJzaW9uIHYzLjAuMVxuICpcbiAqIEBhdXRob3IgQW5keSBHdXRzY2hlXG4gKiBAcmVmYWN0b3JpbmcgU2ViYXN0aWFuIEZpdHpuZXJcbiAqL1xuXG5pbXBvcnQgeyBWZWFtcyB9IGZyb20gJ2FwcCc7XG5pbXBvcnQgVmVhbXNDb21wb25lbnQgZnJvbSAndmVhbXMvc3JjL2pzL2NvbW1vbi9jb21wb25lbnQnO1xuaW1wb3J0IGlzSW5WaWV3cG9ydCBmcm9tICd2ZWFtcy9zcmMvanMvdXRpbHMvaGVscGVycy9pcy1pbi12aWV3cG9ydCc7XG5cbmNvbnN0ICQgPSBWZWFtcy4kO1xuY29uc3QgSGVscGVycyA9IFZlYW1zLmhlbHBlcnM7XG5cbmNsYXNzIFNsaWRlRm94IGV4dGVuZHMgVmVhbXNDb21wb25lbnQge1xuXHQvKipcblx0ICogQ29uc3RydWN0b3IgZm9yIG91ciBjbGFzc1xuXHQgKlxuXHQgKiBAc2VlIG1vZHVsZS5qc1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gT2JqZWN0IHdoaWNoIGlzIHBhc3NlZCB0byBvdXIgY2xhc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IG9iai5lbCAtIGVsZW1lbnQgd2hpY2ggd2lsbCBiZSBzYXZlZCBpbiB0aGlzLmVsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmoub3B0aW9ucyAtIG9wdGlvbnMgd2hpY2ggd2lsbCBiZSBwYXNzZWQgaW4gYXMgSlNPTiBvYmplY3Rcblx0ICovXG5cdGNvbnN0cnVjdG9yKG9iaikge1xuXHRcdGxldCBvcHRpb25zID0ge1xuXHRcdFx0dmlzaWJsZUNsYXNzOiAnaXMtdmlzaWJsZSdcblx0XHR9O1xuXG5cdFx0c3VwZXIob2JqLCBvcHRpb25zKTtcblx0fVxuXG5cdC8qKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIEdFVFRFUiAmIFNFVFRFUlxuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXHQvKipcblx0ICogR2V0IG1vZHVsZSBpbmZvcm1hdGlvblxuXHQgKi9cblx0c3RhdGljIGdldCBpbmZvKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHR2ZXJzaW9uOiAnMy4wLjEnLFxuXHRcdFx0dmM6IHRydWUsXG5cdFx0XHRtb2Q6IGZhbHNlIC8vIHNldCB0byB0cnVlIGlmIHNvdXJjZSB3YXMgbW9kaWZpZWQgaW4gcHJvamVjdFxuXHRcdH07XG5cdH1cblxuXHQvKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBFVkVOVFNcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblx0Z2V0IHN1YnNjcmliZSgpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0J3t7VmVhbXMuRVZFTlRTLnNjcm9sbH19JzogJ3JlbmRlcidcblx0XHR9O1xuXHR9XG5cblx0Ly8gYmluZEV2ZW50cygpIHtcblx0Ly8gXHRsZXQgZm5SZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpO1xuICAgIC8vXG5cdC8vIFx0JCh3aW5kb3cpLm9uKCdzY3JvbGwnLCBmblJlbmRlcik7XG5cdC8vIH1cblxuXHQvKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBTVEFOREFSRCBNRVRIT0RTXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXHRyZW5kZXIoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdpbml0YWxpemVkJyk7XG5cdFx0aXNJblZpZXdwb3J0KHRoaXMuZWwpID8gdGhpcy5zaG93U2xpZGVGb3goKSA6IHRoaXMuaGlkZVNsaWRlRm94KCk7XG5cdH1cblxuXHQvKiogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKiBDVVNUT00gU0xJREVGT1ggTUVUSE9EU1xuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblx0c2hvd1NsaWRlRm94KCkge1xuXHRcdHRoaXMuJGVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy52aXNpYmxlQ2xhc3MpO1xuXHR9XG5cblx0aGlkZVNsaWRlRm94KCkge1xuXHRcdHRoaXMuJGVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy52aXNpYmxlQ2xhc3MpO1xuXHR9XG5cblxufVxuXG4vLyBSZXR1cm5zIHRoZSBjb25zdHJ1Y3RvclxuZXhwb3J0IGRlZmF1bHQgU2xpZGVGb3g7XG4iLCIvKipcbiAqIFJlcHJlc2VudHMgYSByZXNwb25zaXZlIHNsaWRlciB3aGljaCBjYW4gYmUgdXNlZCBhcyByaWJib24uXG4gKlxuICogQG1vZHVsZSBTbGlkZXJcbiAqIEB2ZXJzaW9uIHYzLjAuM1xuICpcbiAqIEBhdXRob3IgU2ViYXN0aWFuIEZpdHpuZXJcbiAqIEBhdXRob3IgQW5keSBHdXRzY2hlXG4gKi9cblxuaW1wb3J0IHsgVmVhbXMgfSBmcm9tICdhcHAnO1xuaW1wb3J0IFZlYW1zQ29tcG9uZW50IGZyb20gJ3ZlYW1zL3NyYy9qcy9jb21tb24vY29tcG9uZW50JztcbmltcG9ydCB0cmFuc2l0aW9uRW5kRXZlbnQgZnJvbSAndmVhbXMvc3JjL2pzL3V0aWxzL2hlbHBlcnMvdHJhbnNpdGlvbi1lbmQtZXZlbnQnXG5cbmNvbnN0ICQgPSBWZWFtcy4kO1xuY29uc3QgSGVscGVycyA9IFZlYW1zLmhlbHBlcnM7XG5cbmNsYXNzIFNsaWRlciBleHRlbmRzIFZlYW1zQ29tcG9uZW50IHtcblx0LyoqXG5cdCAqIENvbnN0cnVjdG9yIGZvciBvdXIgY2xhc3Ncblx0ICpcblx0ICogQHNlZSBtb2R1bGUuanNcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIE9iamVjdCB3aGljaCBpcyBwYXNzZWQgdG8gb3VyIGNsYXNzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmouZWwgLSBlbGVtZW50IHdoaWNoIHdpbGwgYmUgc2F2ZWQgaW4gdGhpcy5lbFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqLm9wdGlvbnMgLSBvcHRpb25zIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGluIGFzIEpTT04gb2JqZWN0XG5cdCAqL1xuXHRjb25zdHJ1Y3RvcihvYmopIHtcblx0XHRsZXQgb3B0aW9ucyA9IHtcblx0XHRcdGFjdGl2ZUNsYXNzOiAnaXMtYWN0aXZlJywgLy8gQWN0aXZlIGNsYXNzIGZvciBzbGlkZXMgYW5kIHBhZ2luYXRpb24gaXRlbXNcblx0XHRcdGFjdGlvbnM6ICdbZGF0YS1qcy1pdGVtPVwic2xpZGVyLWFjdGlvbnNcIl0nLCAvLyBQcmV2aW91cyBCdXR0b25cblx0XHRcdGF1dG9QbGF5OiBmYWxzZSwgLy8gRW5hYmxlIGF1dG9wbGF5XG5cdFx0XHRhdXRvUGxheUludGVydmFsOiA0ODAwLCAvLyBBdXRvcGxheSBpbnRlcnZhbGwgaW4gbWlsbGlzZWNvbmRzXG5cdFx0XHRjbG9uZUNsYXNzOiAnaXMtY2xvbmVkJywgLy8gQ2xvbmUgY2xhc3MgZm9yIGNsb25lZCBpdGVtcyAob25seSB1c2VkIHdpdGggaW5maW5pdGUpXG5cdFx0XHRkaXNhYmxlUGFnaW5hdGlvbjogZmFsc2UsIC8vIERpc2FibGUgcGFnaW5hdGlvbiBkaXNwbGF5XG5cdFx0XHRlbmFibGVUb3VjaFN3aXBlOiB0cnVlLCAvLyBFbmFibGUvRGlzYWJsZSBzd2lwZSBzdXBwb3J0XG5cdFx0XHRncm91cFBhZ2luYXRpb25JdGVtczogZmFsc2UsIC8vIEdyb3VwIHRoZSBwYWdpbmF0aW9uIGVsZW1lbnRzICh1c2VmdWwgZm9yIG11bHRpcGxlIHZpc2libGUgaXRlbXMpXG5cdFx0XHRoaWRkZW5DbGFzczogJ2lzLWhpZGRlbicsIC8vIGhpZGRlbiBjbGFzcyBmb3IgcGFnaW5hdGlvblxuXHRcdFx0aW5maW5pdGU6IGZhbHNlLCAvLyBJbmZpbml0ZSBsb29waW5nIChvbmx5IHBvc3NpYmxlIHdpdGhvdXQgbXVsdGlwbGUgdmlzaWJsZSBpdGVtcylcblx0XHRcdGl0ZW1zOiAnW2RhdGEtanMtaXRlbT1cInNsaWRlci1pdGVtXCJdJywgLy8gU2xpZGUgSXRlbXNcblx0XHRcdG5leHQ6ICdbZGF0YS1qcy1pdGVtPVwic2xpZGVyLW5leHRcIl0nLCAvLyBOZXh0IEJ1dHRvblxuXHRcdFx0cHJldjogJ1tkYXRhLWpzLWl0ZW09XCJzbGlkZXItcHJldlwiXScsIC8vIFByZXZpb3VzIEJ1dHRvblxuXHRcdFx0cGFnaW5hdGlvbjogJ1tkYXRhLWpzLWl0ZW09XCJzbGlkZXItcGFnaW5hdGlvblwiXScsIC8vIFBhZ2luYXRpb25cblx0XHRcdHBhZ2luYXRpb25JdGVtQ2xhc3M6ICdzbGlkZXJfX3BhZ2luYXRpb24tbGlzdC1pdGVtJywgLy8gRGVmaW5lIHlvdXIgY2xhc3Mgd2hpY2ggd2UgdXNlIGluIG91ciBtaW5pIHRtcGxcblx0XHRcdHBhZ2luYXRpb25JdGVtSnNJdGVtOiAnc2xpZGVyLXBhZ2luYXRpb24taXRlbScsIC8vIGRhdGEtanMtaXRlbSBmb3IgcGFnaW5hdGlvbiBsaXN0IGl0ZW1cblx0XHRcdHBhZ2luYXRpb25MaXN0OiAnW2RhdGEtanMtaXRlbT1cInNsaWRlci1wYWdpbmF0aW9uLWxpc3RcIl0nLCAvLyBQYWdpbmF0aW9uIExpc3Rcblx0XHRcdHJpYmJvbjogJ1tkYXRhLWpzLWl0ZW09XCJzbGlkZXItcmliYm9uXCJdJywgLy8gUmliYm9uIGVsZW1lbnRcblx0XHRcdHBhdXNlT25Ib3ZlcjogdHJ1ZSwgLy8gVXNlZCB3aGVuIG9wdGlvbnMuYXV0b1BsYXkgaXMgdHJ1ZVxuXHRcdFx0c2xpZGVCeUl0ZW1OdW1iZXI6IGZhbHNlLCAvLyBVc2UgdGhlIG9wdGlvbiB0byBvdmVycmlkZSB0aGUgaW5pdGlhbCBzbGlkZSBzdGVwXG5cdFx0XHRzdGFydEF0SW5kZXg6IDAsIC8vIFN0YXJ0IGF0IGEgZGlmZmVyZW50IGluZGV4XG5cdFx0XHR1bnJlc29sdmVkQ2xhc3M6ICdpcy11bnJlc29sdmVkJywgLy8gVW5yZXNvbHZlZCBjbGFzcyB3aGljaCBnZXRzIHJlbW92ZWQgd2hlbiBpbml0aWFsaXplZFxuXHRcdFx0dmlzaWJsZUl0ZW1zOiB7IC8vIFZpc2libGUgaXRlbXMgcGVyIHZpZXdwb3J0XG5cdFx0XHRcdCdkZXNrdG9wJzogMSxcblx0XHRcdFx0J3RhYmxldC1sYXJnZSc6IDEsXG5cdFx0XHRcdCd0YWJsZXQtc21hbGwnOiAxLFxuXHRcdFx0XHQnbW9iaWxlLWxhcmdlJzogMSxcblx0XHRcdFx0J21vYmlsZS1tZWRpdW0nOiAxLFxuXHRcdFx0XHQnbW9iaWxlLXNtYWxsJzogMVxuXHRcdFx0fSxcblx0XHRcdHdyYXBwZXI6ICdbZGF0YS1qcy1pdGVtPVwic2xpZGVyLXdyYXBwZXJcIl0nIC8vIFdyYXBwZXIgZWxlbWVudFxuXHRcdH07XG5cblx0XHRzdXBlcihvYmosIG9wdGlvbnMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEN1c3RvbSBnZXR0ZXJzIGFuZCBzZXR0ZXJcblx0ICovXG5cblx0LyoqXG5cdCAqIEdldCBtb2R1bGUgaW5mb3JtYXRpb25cblx0ICovXG5cdHN0YXRpYyBnZXQgaW5mbygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dmVyc2lvbjogJzMuMC4zJyxcblx0XHRcdHZjOiB0cnVlLFxuXHRcdFx0bW9kOiBmYWxzZVxuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGFuZCBzZXQgdmlzaWJsZSBpdGVtcy5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZpc2libGUgLSBOdW1iZXIgb2YgdmlzaWJsZSBpdGVtc1xuXHQgKi9cblx0Z2V0IHZpc2libGVzKCkge1xuXHRcdHJldHVybiB0aGlzLl9udW1WaXNpYmxlO1xuXHR9XG5cblx0c2V0IHZpc2libGVzKHZpc2libGUpIHtcblx0XHR0aGlzLl9udW1WaXNpYmxlID0gdmlzaWJsZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBpdGVtcyBsZW5ndGggZm9yIHNsaWRlci5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGxlbiAtIE51bWJlciBvZiBpdGVtIGxlbmd0aFxuXHQgKi9cblx0Z2V0IGl0ZW1zTGVuZ3RoKCkge1xuXHRcdHJldHVybiB0aGlzLl9pdGVtTGVuZ3RoO1xuXHR9XG5cblx0c2V0IGl0ZW1zTGVuZ3RoKGxlbikge1xuXHRcdHRoaXMuX2l0ZW1MZW5ndGggPSBsZW47XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGFuZCBzZXQgdGhlIGluZGV4IG9mIHNsaWRlci5cblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGlkeCAtIGluZGV4IG51bWJlciBvZiBzbGlkZVxuXHQgKi9cblx0Z2V0IGluZGV4KCkge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleDtcblx0fVxuXG5cdHNldCBpbmRleChpZHgpIHtcblx0XHR0aGlzLl9pbmRleCA9IGlkeDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgcGF1c2VkIHByb3BlcnR5LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJvb2wgLSBwYXVzZSBzdGF0ZVxuXHQgKi9cblx0Z2V0IHBhdXNlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF1c2VkO1xuXHR9XG5cblx0c2V0IHBhdXNlZChib29sKSB7XG5cdFx0dGhpcy5fcGF1c2VkID0gYm9vbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgYXV0b1BsYXkgcHJvcGVydHkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYm9vbCAtIGF1dG9wbGF5IHN0YXRlXG5cdCAqL1xuXHRnZXQgYXV0b1BsYXkoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2F1dG9QbGF5O1xuXHR9XG5cblx0c2V0IGF1dG9QbGF5KGJvb2wpIHtcblx0XHR0aGlzLl9hdXRvUGxheSA9IGJvb2w7XG5cdH1cblxuXHQvKipcblx0ICogR2V0IGNvbnRyb2xzIGhlaWdodC5cblx0ICovXG5cdGdldCBjb250cm9sSGVpZ2h0KCkge1xuXHRcdHJldHVybiBIZWxwZXJzLmdldE91dGVySGVpZ2h0KHRoaXMuJHByZXYpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgZGVmaW5lZCBvcHRpb24gb3IgY3VycmVudCB2aXNpYmxlIGl0ZW1zXG5cdCAqIHdoaWNoIHdpbGwgYmUgdXNlZCBmb3IgdGhlIG5leHQgYW5kIHByZXZpb3VzIHNsaWRlIGFuaW1hdGlvbi5cblx0ICovXG5cdGdldCBzbGlkZUJ5KCkge1xuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc2xpZGVCeUl0ZW1OdW1iZXIgfHwgdGhpcy52aXNpYmxlcztcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgcmliYm9uIHdpZHRoLlxuXHQgKi9cblx0Z2V0IHJpYmJvbldpZHRoKCkge1xuXHRcdHJldHVybiB0aGlzLiRpdGVtcy5sZW5ndGggKiAodGhpcy50aHVtYldpZHRoKTtcblx0fVxuXG5cdC8qKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqIEVWRU5UU1xuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuXHQvKipcblx0ICogQmluZCBsb2NhbCBldmVudHMgdG8gdGhpcy4kZWwuXG5cdCAqL1xuXHRnZXQgZXZlbnRzKCkge1xuXHRcdHJldHVybiB7XG5cdFx0XHQnY2xpY2sge3t0aGlzLm9wdGlvbnMucHJldn19JzogJ3Nob3dQcmV2RWxlbWVudCcsXG5cdFx0XHQndG91Y2hzdGFydCB7e3RoaXMub3B0aW9ucy5wcmV2fX0nOiAnc2hvd1ByZXZFbGVtZW50Jyxcblx0XHRcdCdjbGljayB7e3RoaXMub3B0aW9ucy5uZXh0fX0nOiAnc2hvd05leHRFbGVtZW50Jyxcblx0XHRcdCd0b3VjaHN0YXJ0IHt7dGhpcy5vcHRpb25zLm5leHR9fSc6ICdzaG93TmV4dEVsZW1lbnQnLFxuXHRcdFx0J2NsaWNrIHt7dGhpcy5wYWdpbmF0aW9uSXRlbVNlbH19JzogJ25hdmlnYXRlVG9FbGVtZW50Jyxcblx0XHRcdCd0b3VjaHN0YXJ0IHt7dGhpcy5wYWdpbmF0aW9uSXRlbVNlbH19JzogJ25hdmlnYXRlVG9FbGVtZW50J1xuXHRcdH07XG5cdH1cblxuXHQvKipcblx0ICogU3Vic2NyaWJlIHRvIGdsb2JhbCBldmVudHMgb2YgVmVhbXMgb3IgQXBwIG5hbWVzcGFjZS5cblx0ICovXG5cdGdldCBzdWJzY3JpYmUoKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdCd7e1ZlYW1zLkVWRU5UUy5yZXNpemV9fSc6ICdyZW5kZXInXG5cdFx0fTtcblx0fVxuXHRcblx0LyoqXG5cdCAqIEJpbmQgYWxsIGV2ZW50c1xuXHQgKi9cblx0YmluZEV2ZW50cygpIHtcblx0XHRpZiAodGhpcy5hdXRvUGxheSAmJiB0aGlzLm9wdGlvbnMucGF1c2VPbkhvdmVyKSB7XG5cdFx0XHR0aGlzLnJlZ2lzdGVyRXZlbnQoJ3t7VmVhbXMuRVZFTlRTLm1vdXNlZW50ZXJ9fScsICdwYXVzZScpO1xuXHRcdFx0dGhpcy5yZWdpc3RlckV2ZW50KCd7e1ZlYW1zLkVWRU5UUy5tb3VzZWxlYXZlfX0nLCAncGxheScpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVbmJpbmQgYWxsIGV2ZW50c1xuXHQgKi9cblx0dW5iaW5kRXZlbnRzKCkge1xuXHRcdC8vIEdsb2JhbCBFdmVudHNcblx0XHRWZWFtcy5WZW50Lm9mZihWZWFtcy5FVkVOVFMucmVzaXplKTtcblxuXHRcdC8vIExvY2FsIEV2ZW50c1xuXHRcdHRoaXMuJGVsLm9mZihWZWFtcy5jbGlja0hhbmRsZXIpO1xuXHR9XG5cblx0LyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogU1RBTkRBUkQgTUVUSE9EU1xuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIHZpZXdcblx0ICovXG5cdGluaXRpYWxpemUoKSB7XG5cdFx0dGhpcy5pbmRleCA9IDA7XG5cdFx0dGhpcy4kcHJldiA9IHRoaXMuJGVsLmZpbmQodGhpcy5vcHRpb25zLnByZXYpO1xuXHRcdHRoaXMuJG5leHQgPSB0aGlzLiRlbC5maW5kKHRoaXMub3B0aW9ucy5uZXh0KTtcblx0XHR0aGlzLiRpdGVtcyA9IHRoaXMuJGVsLmZpbmQodGhpcy5vcHRpb25zLml0ZW1zKTtcblx0XHR0aGlzLiRpbml0aWFsSXRlbXMgPSB0aGlzLiRpdGVtcztcblx0XHR0aGlzLiR3cmFwcGVyID0gdGhpcy4kZWwuZmluZCh0aGlzLm9wdGlvbnMud3JhcHBlcik7XG5cdFx0dGhpcy4kcmliYm9uID0gdGhpcy4kZWwuZmluZCh0aGlzLm9wdGlvbnMucmliYm9uKTtcblx0XHR0aGlzLnN0YXJ0QXRJbmRleCA9IH5+dGhpcy5vcHRpb25zLnN0YXJ0QXRJbmRleDtcblx0XHR0aGlzLiRsYXN0SXRlbSA9IHRoaXMuJGl0ZW1zLmVxKHRoaXMuJGl0ZW1zLmxlbmd0aCAtIDEpO1xuXHRcdHRoaXMuJGZpcnN0SXRlbSA9IHRoaXMuJGl0ZW1zLmVxKDApO1xuXHRcdHRoaXMudHJhbnNpdGlvbiA9IHRoaXMuJHJpYmJvbi5jc3MoJ3RyYW5zaXRpb24nKTtcblx0XHR0aGlzLnBhZ2luYXRpb25EaXNhYmxlZCA9IHRoaXMub3B0aW9ucy5kaXNhYmxlUGFnaW5hdGlvbiB8fCB0aGlzLiRpdGVtcy5sZW5ndGggPCAyO1xuXHRcdHRoaXMuaW5maW5pdGUgPSB0aGlzLm9wdGlvbnMuaW5maW5pdGUgJiYgdGhpcy4kaXRlbXMubGVuZ3RoID4gMTtcblx0XHR0aGlzLnRvdWNoU3dpcGVFbmFibGVkID0gZmFsc2U7XG5cdFx0dGhpcy5jbGlja0hhbmRsZXIgPSB0cnVlO1xuXHRcdHRoaXMuYXV0b1BsYXkgPSB0aGlzLm9wdGlvbnMuYXV0b1BsYXkgJiYgdGhpcy5pbmZpbml0ZTtcblx0XHR0aGlzLnBhZ2luYXRpb25JdGVtU2VsID0gJ1tkYXRhLWpzLWl0ZW09XCInICsgdGhpcy5vcHRpb25zLnBhZ2luYXRpb25JdGVtSnNJdGVtICsgJ1wiXSc7XG5cblxuXHRcdGlmICghdGhpcy5wYWdpbmF0aW9uRGlzYWJsZWQpIHtcblx0XHRcdHRoaXMuJHBhZ2luYXRpb25MaXN0ID0gdGhpcy4kZWwuZmluZCh0aGlzLm9wdGlvbnMucGFnaW5hdGlvbkxpc3QpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkgJiYgIXRoaXMuaW5maW5pdGUpIHtcblx0XHRcdGNvbnNvbGUud2FybignU2xpZGVyOiBTb3JyeSAtIG9wdGlvbiBcImF1dG9QbGF5XCIgaGFzIG5vIGVmZmVjdCB3aGlsZSBvcHRpb24gXCJpbmZpbml0ZVwiIGlzIHNldCB0byBmYWxzZSEnKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5pbmZpbml0ZSkge1xuXG5cdFx0XHRmb3IgKGxldCBpdGVtIGluIHRoaXMub3B0aW9ucy52aXNpYmxlSXRlbXMpIHtcblx0XHRcdFx0aWYgKHRoaXMub3B0aW9ucy52aXNpYmxlSXRlbXMuaGFzT3duUHJvcGVydHkoaXRlbSkpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5vcHRpb25zLnZpc2libGVJdGVtc1tpdGVtXSA+IDEpIHtcblx0XHRcdFx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0XHRcdFx0J1NsaWRlcjogU29ycnkgLSBvcHRpb24gXCJ2aXNpYmxlSXRlbXNcIiBoYXMgbm8gZWZmZWN0IHdoaWxlIG9wdGlvbiBcImluZmluaXRlXCIgaXMgc2V0IHRvIHRydWUhJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVuZGVycyB0aGUgdmlldydzIHRlbXBsYXRlIHRvIHRoZSBVSVxuXHQgKi9cblx0cmVuZGVyKCkge1xuXHRcdGlmICghVmVhbXMuY3VycmVudE1lZGlhKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1NsaWRlcjogVmVhbXMuY3VycmVudE1lZGlhIGlzIG5lY2Vzc2FyeSB0byBzdXBwb3J0IHRoZSBzbGlkZXIgbW9kdWxlIScpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiRjbG9uZWRMYXN0ICYmIHRoaXMuJGNsb25lZEZpcnN0KSB7XG5cdFx0XHR0aGlzLiRjbG9uZWRMYXN0LnJlbW92ZSgpO1xuXHRcdFx0dGhpcy4kY2xvbmVkRmlyc3QucmVtb3ZlKCk7XG5cdFx0XHR0aGlzLiRpdGVtcyA9IHRoaXMuJGluaXRpYWxJdGVtcztcblx0XHR9XG5cblx0XHR0aGlzLnZpc2libGVzID0gdGhpcy5pbmZpbml0ZSA/IDEgOiB0aGlzLm9wdGlvbnMudmlzaWJsZUl0ZW1zW1ZlYW1zLmN1cnJlbnRNZWRpYV07XG5cdFx0dGhpcy5pdGVtc0xlbmd0aCA9IHRoaXMuJGl0ZW1zLmxlbmd0aDtcblxuXHRcdHRoaXMuaGFuZGxlVmlzaWJpbGl0eSgpO1xuXG5cdFx0aWYgKCF0aGlzLnBhZ2luYXRpb25EaXNhYmxlZCkge1xuXHRcdFx0dGhpcy5yZW1vdmVQYWdpbmF0aW9uKCk7XG5cdFx0XHR0aGlzLmFkZFBhZ2luYXRpb24oKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5pbmZpbml0ZSkge1xuXHRcdFx0dGhpcy5pbmZpbml0ZUxvb3AoKTtcblx0XHR9XG5cblx0XHR0aGlzLmJpbmRUcmFuc2l0aW9ucygpO1xuXHRcdHRoaXMuZ2V0QW5kU2V0RGltZW5zaW9ucygpO1xuXG5cdFx0aWYgKFZlYW1zLmRldGVjdGlvbnMudG91Y2ggJiYgdGhpcy5vcHRpb25zLmVuYWJsZVRvdWNoU3dpcGUgJiYgIXRoaXMudG91Y2hTd2lwZUVuYWJsZWQpIHtcblx0XHRcdHRoaXMuYmluZFN3aXBlcygpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7XG5cdFx0XHR0aGlzLmdvVG9JdGVtKHRoaXMuc3RhcnRBdEluZGV4ICsgdGhpcy52aXNpYmxlcyk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5nb1RvSXRlbSh0aGlzLnN0YXJ0QXRJbmRleCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuYXV0b1BsYXkgJiYgdGhpcy5wYXVzZWQpIHtcblx0XHRcdHRoaXMucGxheSgpO1xuXHRcdH1cblx0fVxuXHRcblx0LyoqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICogQ1VTVE9NIFNMSURFUiBNRVRIT0RTXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblx0XG5cdC8qKlxuXHQgKiBCaW5kIHRyYW5zaXRpb24gZXZlbnRzXG5cdCAqXG5cdCAqL1xuXHRiaW5kVHJhbnNpdGlvbnMoKSB7XG5cdFx0bGV0IG9uUmliYm9uVHJhbnNpdGlvbkVuZCA9IHRoaXMub25SaWJib25UcmFuc2l0aW9uRW5kLmJpbmQodGhpcyk7XG5cdFx0bGV0IG9uSXRlbXNUcmFuc2l0aW9uRW5kID0gdGhpcy5vbkl0ZW1zVHJhbnNpdGlvbkVuZC5iaW5kKHRoaXMpO1xuXG5cdFx0dGhpcy4kcmliYm9uLm9uKHRyYW5zaXRpb25FbmRFdmVudCgpLCBvblJpYmJvblRyYW5zaXRpb25FbmQpO1xuXHRcdHRoaXMuJGl0ZW1zLm9uKHRyYW5zaXRpb25FbmRFdmVudCgpLCBvbkl0ZW1zVHJhbnNpdGlvbkVuZCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVhY3QgdG8gdHJhbnNpdGlvbmVuZCBvbiByaWJib25cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGUgLSBFdmVudCBvYmplY3QuXG5cdCAqL1xuXHRvblJpYmJvblRyYW5zaXRpb25FbmQoZSkge1xuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cblx0XHRpZiAodGhpcy5hdXRvUGxheSAmJiB0aGlzLnBhdXNlZCkge1xuXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLnBhdXNlT25Ib3Zlcikge1xuXG5cdFx0XHRcdGlmICghdGhpcy4kZWwuaXMoJzpob3ZlcicpKSB7XG5cdFx0XHRcdFx0dGhpcy5wbGF5KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLnBsYXkoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy4kY2xvbmVkRmlyc3QgJiYgdGhpcy4kY2xvbmVkRmlyc3QuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSkge1xuXHRcdFx0dGhpcy4kY2xvbmVkRmlyc3QucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHRcdHRoaXMuaW5kZXggPSAxO1xuXG5cdFx0XHR0aGlzLmFuaW1hdGVTbGlkZSh7XG5cdFx0XHRcdGlkeDogdGhpcy5pbmRleCxcblx0XHRcdFx0YW5pbWF0ZTogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLiRjbG9uZWRMYXN0ICYmIHRoaXMuJGNsb25lZExhc3QuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSkge1xuXHRcdFx0dGhpcy4kY2xvbmVkTGFzdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXHRcdFx0dGhpcy5pbmRleCA9IHRoaXMuJGl0ZW1zLmxlbmd0aCAtIHRoaXMudmlzaWJsZXMgLSAxO1xuXG5cdFx0XHR0aGlzLmFuaW1hdGVTbGlkZSh7XG5cdFx0XHRcdGlkeDogdGhpcy5pbmRleCxcblx0XHRcdFx0YW5pbWF0ZTogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHRoaXMuY2xpY2tIYW5kbGVyID0gdHJ1ZTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFJlYWN0IHRvIHRyYW5zaXRpb25lbmQgb24gaXRlbXNcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGUgLSBFdmVudCBvYmplY3QuXG5cdCAqL1xuXHRvbkl0ZW1zVHJhbnNpdGlvbkVuZChlKSB7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9uZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50XG5cdCAqXG5cdCAqL1xuXHRpbmZpbml0ZUxvb3AoKSB7XG5cdFx0dGhpcy4kY2xvbmVkRmlyc3QgPSB0aGlzLiRmaXJzdEl0ZW0uY2xvbmUodHJ1ZSkuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNsb25lQ2xhc3MpO1xuXHRcdHRoaXMuJGNsb25lZExhc3QgPSB0aGlzLiRsYXN0SXRlbS5jbG9uZSh0cnVlKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY2xvbmVDbGFzcyk7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLmluZmluaXRlKSB7XG5cdFx0XHR0aGlzLiRjbG9uZWRGaXJzdC5maW5kKHRoaXMucGFnaW5hdGlvbkl0ZW1TZWwpLmF0dHIoJ2RhdGEtaW5kZXgnLCB0aGlzLml0ZW1zTGVuZ3RoKTtcblx0XHRcdHRoaXMuJGNsb25lZExhc3QuZmluZCh0aGlzLnBhZ2luYXRpb25JdGVtU2VsKS5hdHRyKCdkYXRhLWluZGV4JywgLTEpO1xuXHRcdH1cblxuXHRcdHRoaXMuJGZpcnN0SXRlbS5iZWZvcmUodGhpcy4kY2xvbmVkTGFzdCk7XG5cdFx0dGhpcy4kbGFzdEl0ZW0uYWZ0ZXIodGhpcy4kY2xvbmVkRmlyc3QpO1xuXG5cdFx0dGhpcy4kaXRlbXMgPSAkKHRoaXMub3B0aW9ucy5pdGVtcywgdGhpcy4kZWwpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFuaW1hdGUgc2xpZGVcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIGFuaW1hdGlvbiBwcm9wZXJ0eSBvYmplY3QuXG5cdCAqL1xuXHRhbmltYXRlU2xpZGUob2JqKSB7XG5cdFx0aWYgKCFvYmouYW5pbWF0ZSkge1xuXHRcdFx0dGhpcy4kcmliYm9uLmNzcygndHJhbnNpdGlvbicsICdub25lJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuJHJpYmJvbi5jc3MoJ3RyYW5zaXRpb24nLCB0aGlzLnRyYW5zaXRpb24pO1xuXHRcdH1cblxuXHRcdHRoaXMuJHJpYmJvbi5jc3MoJ2xlZnQnLCAtb2JqLmlkeCAqICh0aGlzLnRodW1iV2lkdGgpICsgJ3B4Jyk7XG5cdH1cblxuXHQvKipcblx0ICogQ2hlY2sgZmlyc3QvbGFzdCBzbGlkZSBjbGFzc2VzXG5cdCAqXG5cdCAqL1xuXHRjaGVja1NsaWRlcygpIHtcblxuXHRcdGlmICh0aGlzLiRjbG9uZWRGaXJzdC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpKSB7XG5cdFx0XHR0aGlzLiRmaXJzdEl0ZW0uYWRkQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuJGNsb25lZExhc3QuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKSkge1xuXHRcdFx0dGhpcy4kbGFzdEl0ZW0uYWRkQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogV2hlbiBpdGVtcyBsZW5ndGggaXMgMCB3ZSBoaWRlIHRoaXMgdmlldy5cblx0ICovXG5cdGhhbmRsZVZpc2liaWxpdHkoKSB7XG5cdFx0aWYgKHRoaXMuaXRlbXNMZW5ndGggPT09IDApIHtcblx0XHRcdHRoaXMuJGVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy5oaWRkZW5DbGFzcyk7XG5cdFx0XHRjb25zb2xlLndhcm4oJ1NsaWRlcjogVGhlcmUgaXMgbm8gaXRlbSB3ZSBjYW4gdXNlIGluIG91ciBzbGlkZXIgOignKTtcblx0XHR9XG5cblx0XHR0aGlzLiRlbC5jc3MoJ21heC13aWR0aCcsICdub25lJyk7XG5cdH1cblxuXHQvKipcblx0ICogRW1wdHkgcGFnaW5hdGlvbi5cblx0ICovXG5cdHJlbW92ZVBhZ2luYXRpb24oKSB7XG5cdFx0dGhpcy4kcGFnaW5hdGlvbkxpc3QuZW1wdHkoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgcGFnaW5hdGlvbiBlbGVtZW50cyB3aXRoIGEgc2ltcGxlIHN0cmluZyB0ZW1wbGF0ZSBhbmRcblx0ICogc2F2ZSBhIHBhZ2luYXRpb24gaXRlbSByZWZlcmVuY2UuXG5cdCAqL1xuXHRhZGRQYWdpbmF0aW9uKCkge1xuXHRcdGxldCB0bXBsID0gJyc7XG5cdFx0bGV0IGkgPSAwO1xuXHRcdGxldCBpdGVtID0gdGhpcy5vcHRpb25zLnBhZ2luYXRpb25JdGVtSnNJdGVtO1xuXHRcdGxldCBpdGVtQ2xhc3MgPSB0aGlzLm9wdGlvbnMucGFnaW5hdGlvbkl0ZW1DbGFzcztcblxuXHRcdGZvciAoaTsgaSA8IHRoaXMuJGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgaWR4ID0gaSArIDE7XG5cdFx0XHRsZXQgaGlkZGVuQ2xhc3MgPSAnJztcblxuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5ncm91cFBhZ2luYXRpb25JdGVtcykge1xuXHRcdFx0XHRoaWRkZW5DbGFzcyA9IGkgJSB0aGlzLnZpc2libGVzID09PSAwID8gJycgOiB0aGlzLm9wdGlvbnMuaGlkZGVuQ2xhc3M7XG5cdFx0XHR9XG5cblx0XHRcdHRtcGwgKz0gYFxuXHRcdFx0XHRcdDxsaSBjbGFzcz1cIiR7aXRlbUNsYXNzfSAke2hpZGRlbkNsYXNzfVwiIGRhdGEtanMtaXRlbT1cIiR7aXRlbX1cIiBkYXRhLWluZGV4PVwiJHtpfVwiPlxuXHRcdFx0XHRcdFx0PHN0cm9uZz4ke2lkeH08L3N0cm9uZz5cblx0XHRcdFx0XHQ8L2xpPlxuXHRcdFx0XHRcdGA7XG5cdFx0fVxuXG5cdFx0dGhpcy4kcGFnaW5hdGlvbkxpc3QuYXBwZW5kKHRtcGwpO1xuXHRcdHRoaXMuJHBhZ2luYXRpb25JdGVtcyA9ICQoJ1tkYXRhLWpzLWl0ZW09XCInICsgdGhpcy5vcHRpb25zLnBhZ2luYXRpb25JdGVtSnNJdGVtICsgJ1wiXScsIHRoaXMuJGVsKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBOYXZpZ2F0ZSB0byBhIHNwZWNpZmljIHNsaWRlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZSAtIEV2ZW50IG9iamVjdC5cblx0ICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRUYXJnZXQgLSBUYXJnZXQgdG8gd2hpY2ggbGlzdGVuZXIgd2FzIGF0dGFjaGVkLlxuXHQgKi9cblx0bmF2aWdhdGVUb0VsZW1lbnQoZSwgY3VycmVudFRhcmdldCkge1xuXHRcdGxldCAkY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQgPyAkKGN1cnJlbnRUYXJnZXQpIDogJChlLmN1cnJlbnRUYXJnZXQpO1xuXG5cdFx0aWYgKCRjdXJyZW50VGFyZ2V0Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsZXQgaWR4ID0gcGFyc2VJbnQoJGN1cnJlbnRUYXJnZXQuYXR0cignZGF0YS1pbmRleCcpLCAxMCkgfHwgJGN1cnJlbnRUYXJnZXQuaW5kZXgoKTtcblxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7XG5cdFx0XHRpZHggPSBpZHggKyB0aGlzLnNsaWRlQnk7XG5cdFx0fVxuXG5cdFx0dGhpcy5nb1RvSXRlbShpZHgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEdvIHRvIHRoZSBuZXh0IHNsaWRlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZSAtIEV2ZW50IG9iamVjdC5cblx0ICogQHBhcmFtIHtvYmplY3R9IGN1cnJlbnRUYXJnZXQgLSBUYXJnZXQgdG8gd2hpY2ggbGlzdGVuZXIgd2FzIGF0dGFjaGVkLlxuXHQgKi9cblx0c2hvd05leHRFbGVtZW50KGUsIGN1cnJlbnRUYXJnZXQpIHtcblx0XHRsZXQgJGN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0ID8gJChjdXJyZW50VGFyZ2V0KSA6ICQoZS5jdXJyZW50VGFyZ2V0KTtcblxuXHRcdGlmIChlICYmIHR5cGVvZiBlLnByZXZlbnREZWZhdWx0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKCRjdXJyZW50VGFyZ2V0LnByb3AoJ2Rpc2FibGVkJykpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5jbGlja0hhbmRsZXIpIHtcblx0XHRcdHRoaXMuZ29Ub0l0ZW0odGhpcy5pbmRleCArIHRoaXMuc2xpZGVCeSk7XG5cdFx0XHR0aGlzLmNsaWNrSGFuZGxlciA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBHbyB0byB0aGUgcHJldmlvdXMgc2xpZGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBlIC0gRXZlbnQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge29iamVjdH0gY3VycmVudFRhcmdldCAtIFRhcmdldCB0byB3aGljaCBsaXN0ZW5lciB3YXMgYXR0YWNoZWQuXG5cdCAqL1xuXHRzaG93UHJldkVsZW1lbnQoZSwgY3VycmVudFRhcmdldCkge1xuXHRcdGxldCAkY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQgPyAkKGN1cnJlbnRUYXJnZXQpIDogJChlLmN1cnJlbnRUYXJnZXQpO1xuXG5cdFx0aWYgKGUgJiYgdHlwZW9mIGUucHJldmVudERlZmF1bHQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cblx0XHRpZiAoJGN1cnJlbnRUYXJnZXQucHJvcCgnZGlzYWJsZWQnKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmNsaWNrSGFuZGxlcikge1xuXHRcdFx0dGhpcy5nb1RvSXRlbSh0aGlzLmluZGV4IC0gdGhpcy5zbGlkZUJ5KTtcblx0XHRcdHRoaXMuY2xpY2tIYW5kbGVyID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgZGlyZWN0aW9uIGBuZXh0YCBvciBgcHJldmAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIEluZGV4IG9mIHRoZSBwYWdpbmF0aW9uIGVsZW1lbnQuXG5cdCAqL1xuXHRnZXREaXJlY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gaW5kZXggPiB0aGlzLmluZGV4ID8gXCJuZXh0XCIgOiBcInByZXZcIjtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaW5kIGFsbCBzd2lwZSBnZXN0dXJlcy5cblx0ICovXG5cdGJpbmRTd2lwZXMoKSB7XG5cblx0XHRpZiAodGhpcy4kaXRlbXMubGVuZ3RoID4gdGhpcy52aXNpYmxlcykge1xuXHRcdFx0SGVscGVycy5kZXRlY3RTd2lwZSh0aGlzLmVsLCA3NSk7XG5cblx0XHRcdHRoaXMuJGVsLm9uKFZlYW1zLkVWRU5UUy5zd2lwZSwgKGUpID0+IHtcblx0XHRcdFx0bGV0IGRpcmVjdGlvbiA9IGUuZGV0YWlsLmRpcmVjdGlvbjtcblxuXHRcdFx0XHRpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcpIHtcblx0XHRcdFx0XHR0aGlzLmdvVG9JdGVtKHRoaXMuaW5kZXggKyB0aGlzLnZpc2libGVzKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChkaXJlY3Rpb24gPT09ICdyaWdodCcpIHtcblx0XHRcdFx0XHR0aGlzLmdvVG9JdGVtKHRoaXMuaW5kZXggLSB0aGlzLnZpc2libGVzKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMudG91Y2hTd2lwZUVuYWJsZWQgPSB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGVzIGJ1dHRvblxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gJGJ0biAtIGJ1dHRvbiBlbGVtZW50LlxuXHQgKi9cblx0ZW5hYmxlQnRuKCRidG4pIHtcblx0XHQkYnRuLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5oaWRkZW5DbGFzcyk7XG5cdFx0JGJ0bi5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcblx0XHQkYnRuLnJlbW92ZUF0dHIoJ2FyaWEtZGlzYWJsZWQnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlcyBidXR0b25cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9ICRidG4gLSBidXR0b24gZWxlbWVudC5cblx0ICovXG5cdGRpc2FibGVCdG4oJGJ0bikge1xuXHRcdCRidG4uYWRkQ2xhc3ModGhpcy5vcHRpb25zLmhpZGRlbkNsYXNzKTtcblx0XHQkYnRuLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XG5cdFx0JGJ0bi5hdHRyKCdhcmlhLWRpc2FibGVkJywgdHJ1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogSGFuZGxlcyB0aGUgbWV0aG9kIHRvIGdvIHRvIGEgc3BlY2lmaWMgaXRlbS5cblx0ICogRnVydGhlciB3ZSBoYW5kbGUgdGhlIGNsYXNzXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpIC0gSW5kZXggbnVtYmVyLlxuXHQgKi9cblx0Z29Ub0l0ZW0oaSkge1xuXHRcdGxldCBtYXhJbmRleCA9IHRoaXMuJGl0ZW1zLmxlbmd0aCAtIHRoaXMudmlzaWJsZXM7XG5cblx0XHRpZiAobWF4SW5kZXggPCAwKSB7XG5cdFx0XHRtYXhJbmRleCA9IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLnBhdXNlZCkge1xuXHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7XG5cdFx0XHRpZiAoaSA8IDApIHtcblx0XHRcdFx0aSA9IG1heEluZGV4O1xuXHRcdFx0fSBlbHNlIGlmIChpID4gbWF4SW5kZXgpIHtcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5lbmFibGVCdG4odGhpcy4kcHJldik7XG5cdFx0XHR0aGlzLmVuYWJsZUJ0bih0aGlzLiRuZXh0KTtcblxuXHRcdFx0aWYgKGkgPCAxKSB7XG5cdFx0XHRcdHRoaXMuZGlzYWJsZUJ0bih0aGlzLiRwcmV2KTtcblxuXHRcdFx0XHRpZiAoaSA8IDApIHtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaSA+IG1heEluZGV4IC0gMSkge1xuXHRcdFx0XHR0aGlzLmRpc2FibGVCdG4odGhpcy4kbmV4dCk7XG5cblx0XHRcdFx0aWYgKGkgPiBtYXhJbmRleCkge1xuXHRcdFx0XHRcdGkgPSBtYXhJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuYW5pbWF0ZVNsaWRlKHtcblx0XHRcdGlkeDogaSxcblx0XHRcdGFuaW1hdGU6ICF0aGlzLiRlbC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMudW5yZXNvbHZlZENsYXNzKVxuXHRcdH0pO1xuXG5cdFx0aWYgKHRoaXMuJGVsLmhhc0NsYXNzKHRoaXMub3B0aW9ucy51bnJlc29sdmVkQ2xhc3MpKSB7XG5cdFx0XHR0aGlzLiRlbC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMudW5yZXNvbHZlZENsYXNzKTtcblx0XHR9XG5cblx0XHR0aGlzLmluZGV4ID0gaTtcblxuXHRcdHRoaXMuaGFuZGxlQWN0aXZpdHkoKTtcblxuXHRcdGlmICh0aGlzLmluZmluaXRlKSB7XG5cdFx0XHR0aGlzLmNoZWNrU2xpZGVzKCk7XG5cdFx0fVxuXHR9XG5cblx0aGFuZGxlQWN0aXZpdHkoKSB7XG5cdFx0dGhpcy4kaXRlbXMucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblxuXHRcdGlmICghdGhpcy5wYWdpbmF0aW9uRGlzYWJsZWQgJiYgdGhpcy4kcGFnaW5hdGlvbkl0ZW1zICYmIHRoaXMuJHBhZ2luYXRpb25JdGVtcy5sZW5ndGgpIHtcblx0XHRcdHRoaXMuJHBhZ2luYXRpb25JdGVtcy5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoaXMgc2xpZGVyIGluc3RhbmNlIGlzbid0IGluZmluaXRlXG5cdFx0aWYgKCF0aGlzLmluZmluaXRlKSB7XG5cdFx0XHRmb3IgKGxldCBpZHggPSB0aGlzLmluZGV4OyBpZHggPCB0aGlzLmluZGV4ICsgdGhpcy52aXNpYmxlczsgaWR4KyspIHtcblxuXHRcdFx0XHQvLyBGaXJzdCBzZXQgYWN0aXZlIHNsaWRlIGVsZW1lbnQocylcblx0XHRcdFx0dGhpcy4kaXRlbXNcblx0XHRcdFx0XHQuZXEoaWR4KVxuXHRcdFx0XHRcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXG5cdFx0XHRcdC8vIERvIHRoYXQgYWxzbyBmb3IgcGFnaW5hdGlvbiBlbGVtZW50KHMpXG5cdFx0XHRcdGlmICghdGhpcy5wYWdpbmF0aW9uRGlzYWJsZWQpIHtcblx0XHRcdFx0XHR0aGlzLiRwYWdpbmF0aW9uSXRlbXNcblx0XHRcdFx0XHRcdC5lcShpZHgpXG5cdFx0XHRcdFx0XHQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGZvciAobGV0IGlkeCA9IHRoaXMuaW5kZXggLSAxOyBpZHggPCB0aGlzLmluZGV4IC0gMSArIHRoaXMudmlzaWJsZXM7IGlkeCsrKSB7XG5cdFx0XHRcdGxldCBzbGlkZUlkeCA9IGlkeDtcblx0XHRcdFx0dGhpcy4kaXRlbXNcblx0XHRcdFx0XHQuZXEoc2xpZGVJZHggKyAxKVxuXHRcdFx0XHRcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXG5cdFx0XHRcdGlmICghdGhpcy5wYWdpbmF0aW9uRGlzYWJsZWQpIHtcblx0XHRcdFx0XHRpZiAoaWR4ID49IHRoaXMuJHBhZ2luYXRpb25JdGVtcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdHNsaWRlSWR4ID0gMDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoaWR4IDwgMCkge1xuXHRcdFx0XHRcdFx0c2xpZGVJZHggPSB0aGlzLiRwYWdpbmF0aW9uSXRlbXMubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR0aGlzLiRwYWdpbmF0aW9uSXRlbXNcblx0XHRcdFx0XHRcdC5lcShzbGlkZUlkeClcblx0XHRcdFx0XHRcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFN0YXJ0IGF1dG9wbGF5LlxuXHQgKi9cblx0cGxheSgpIHtcblx0XHRjbGVhckludGVydmFsKHRoaXMuYXV0b1BsYXlJbnRlcnZhbCk7XG5cblx0XHR0aGlzLmF1dG9QbGF5SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG5cdFx0XHR0aGlzLmdvVG9JdGVtKHRoaXMuaW5kZXggKyB0aGlzLnZpc2libGVzKTtcblx0XHR9LCB0aGlzLm9wdGlvbnMuYXV0b1BsYXlJbnRlcnZhbCk7XG5cblx0XHR0aGlzLnBhdXNlZCA9IGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIFBhdXNlIGF1dG9wbGF5LlxuXHQgKi9cblx0cGF1c2UoKSB7XG5cdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLmF1dG9QbGF5SW50ZXJ2YWwpO1xuXHRcdHRoaXMucGF1c2VkID0gdHJ1ZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZXQgYW5kIHNldCBkaW1lbnNpb25zIGZvciBvdXIgcHJvamVjdCBwcm9ncmVzcy5cblx0ICovXG5cdGdldEFuZFNldERpbWVuc2lvbnMoKSB7XG5cdFx0dGhpcy5yZXNldFN0eWxlcygpO1xuXHRcdHRoaXMud2lkdGggPSB0aGlzLiR3cmFwcGVyLm91dGVyV2lkdGgoKTtcblx0XHR0aGlzLnRodW1iV2lkdGggPSB0aGlzLndpZHRoIC8gdGhpcy52aXNpYmxlcztcblx0XHR0aGlzLiR3cmFwcGVyLmNzcygnd2lkdGgnLCB0aGlzLndpZHRoICsgJ3B4Jyk7XG5cdFx0dGhpcy4kaXRlbXMuY3NzKCd3aWR0aCcsIHRoaXMudGh1bWJXaWR0aCArICdweCcpO1xuXG5cdFx0dGhpcy4kcmliYm9uLmNzcyh7XG5cdFx0XHR3aWR0aDogdGhpcy5yaWJib25XaWR0aCArICdweCdcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXNldCB3aWR0aCBzdHlsZXNcblx0ICovXG5cdHJlc2V0U3R5bGVzKCkge1xuXHRcdHRoaXMuJHdyYXBwZXJbMF0ucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuXHRcdHRoaXMuJGl0ZW1zLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG5cdFx0dGhpcy4kcmliYm9uLnJlbW92ZUF0dHIoJ3N0eWxlJyk7XG5cdH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgU2xpZGVyOyIsIi8qKlxuICogUmVwcmVzZW50cyBhIHNpbXBsZSB0b2dnbGVyIHdpdGggZ2xvYmFsIGV2ZW50IGJpbmRpbmcuXG4gKlxuICogQG1vZHVsZSBUb2dnbGVyXG4gKiBAdmVyc2lvbiB2My4wLjNcbiAqXG4gKiBAYXV0aG9yIEFuZHkgR3V0c2NoZVxuICovXG5cbi8vIEdsb2JhbCBkZXBlbmRlbmNpZXNcbmltcG9ydCB7VmVhbXN9IGZyb20gJ2FwcCc7XG5cbmltcG9ydCBWZWFtc0NvbXBvbmVudCBmcm9tICd2ZWFtcy9zcmMvanMvY29tbW9uL2NvbXBvbmVudCc7XG5cbmNvbnN0ICQgPSBWZWFtcy4kO1xuY29uc3QgSGVscGVycyA9IFZlYW1zLmhlbHBlcnM7XG5cbmNsYXNzIFRvZ2dsZXIgZXh0ZW5kcyBWZWFtc0NvbXBvbmVudCB7XG5cblxuXHQvKipcblx0ICogQ29uc3RydWN0b3IgZm9yIG91ciBjbGFzc1xuXHQgKlxuXHQgKiBAc2VlIG1vZHVsZS5qc1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gT2JqZWN0IHdoaWNoIGlzIHBhc3NlZCB0byBvdXIgY2xhc3Ncblx0ICogQHBhcmFtIHtPYmplY3R9IG9iai5lbCAtIGVsZW1lbnQgd2hpY2ggd2lsbCBiZSBzYXZlZCBpbiB0aGlzLmVsXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmoub3B0aW9ucyAtIG9wdGlvbnMgd2hpY2ggd2lsbCBiZSBwYXNzZWQgaW4gYXMgSlNPTiBvYmplY3Rcblx0ICovXG5cdGNvbnN0cnVjdG9yKG9iaikge1xuXG5cdFx0bGV0IG9wdGlvbnMgPSB7XG5cdFx0XHRhMTF5Rm9jdXNLZXlDbGFzczogJ2ExMXktZm9jdXMta2V5Jyxcblx0XHRcdGNhbGN1bGF0aW5nQ2xhc3M6ICdpcy1jYWxjdWxhdGluZycsXG5cdFx0XHRjbG9zZUNsYXNzOiAnaXMtY2xvc2VkJyxcblx0XHRcdGNvbnRleHQ6IGZhbHNlLFxuXHRcdFx0ZGF0YU1heEF0dHI6ICdkYXRhLWpzLWhlaWdodCcsXG5cdFx0XHRnbG9iYWxFdmVudDogJycsXG5cdFx0XHRnbG9iYWxFdmVudElkOiAnJyxcblx0XHRcdG9wZW5DbGFzczogJ2lzLW9wZW4nLFxuXHRcdFx0c2V0T3ZlcmZsb3c6IGZhbHNlLFxuXHRcdFx0dG9nZ2xlVGFiaW5kZXhFbGVtczogJydcblx0XHR9O1xuXG5cdFx0c3VwZXIob2JqLCBvcHRpb25zKTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIEdldCBtb2R1bGUgaW5mb3JtYXRpb25cblx0ICovXG5cdHN0YXRpYyBnZXQgaW5mbygpIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dmVyc2lvbjogJzMuMC4zJyxcblx0XHRcdHZjOiB0cnVlLFxuXHRcdFx0bW9kOiBmYWxzZSAvLyBzZXQgdG8gdHJ1ZSBpZiBzb3VyY2Ugd2FzIG1vZGlmaWVkIGluIHByb2plY3Rcblx0XHR9O1xuXHR9XG5cblxuXHRnZXQgaGVpZ2h0KCkge1xuXHRcdHJldHVybiB0aGlzLl9oZWlnaHQ7XG5cdH1cblxuXG5cdHNldCBoZWlnaHQoaGVpZ2h0KSB7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHR9XG5cblxuXHRnZXQgaXNPcGVuKCkge1xuXHRcdHJldHVybiB0aGlzLl9pc09wZW47XG5cdH1cblxuXG5cdHNldCBpc09wZW4oYm9vbCkge1xuXHRcdHRoaXMuX2lzT3BlbiA9IGJvb2w7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBHZXQgZ2xvYmFsIGV2ZW50c1xuXHQgKlxuXHQgKi9cblx0Z2V0IHN1YnNjcmliZSgpIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHQne3tWZWFtcy5FVkVOVFMucmVzaXplfX0nOiAnb25SZXNpemUnXG5cdFx0fTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemUgdGhlIHZpZXcgYW5kIG1lcmdlIG9wdGlvbnNcblx0ICpcblx0ICovXG5cdGluaXRpYWxpemUoKSB7XG5cdFx0bGV0IHNlbGZJbml0ID0gdGhpcy4kZWwuYXR0cignZGF0YS1qcy1tb2R1bGUnKSAmJiB0aGlzLiRlbC5hdHRyKCdkYXRhLWpzLW1vZHVsZScpLmluZGV4T2YoJ3RvZ2dsZXInKSA+IC0xO1xuXG5cdFx0aWYgKHNlbGZJbml0ICYmICF0aGlzLm9wdGlvbnMuZ2xvYmFsRXZlbnQpIHtcblx0XHRcdGNvbnNvbGUuaW5mbygnVG9nZ2xlcjogdGhpcy5vcHRpb25zLmdsb2JhbEV2ZW50IG5vdCBzZXQuJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5pc09wZW4gPSB0aGlzLiRlbC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMub3BlbkNsYXNzKTtcblxuXHRcdHRoaXMuY2FsY3VsYXRlSGVpZ2h0KCkudGhlbigoKSA9PiB7XG5cblx0XHRcdGlmICghdGhpcy5pc09wZW4pIHtcblx0XHRcdFx0dGhpcy5zZXRIZWlnaHQoMCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBCaW5kIGV2ZW50c1xuXHQgKlxuXHQgKiBMaXN0ZW4gdG8gb3BlbiBhbmQgY2xvc2UgZXZlbnRzXG5cdCAqL1xuXHRiaW5kRXZlbnRzKCkge1xuXG5cdFx0Ly8gR2xvYmFsIGV2ZW50c1xuXHRcdGlmICh0aGlzLm9wdGlvbnMuZ2xvYmFsRXZlbnQpIHtcblx0XHRcdHRoaXMucmVnaXN0ZXJFdmVudCgne3t0aGlzLm9wdGlvbnMuZ2xvYmFsRXZlbnR9fScsICd0b2dnbGUnLCB0cnVlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogaGFuZGxlIG9uIHJlc2l6ZSBldmVudFxuXHQgKlxuXHQgKiBjbG9zZSB0aGUgdG9nZ2xlclxuXHQgKlxuXHQgKi9cblx0b25SZXNpemUoKSB7XG5cblx0XHQvLyBnaXZlIGJyb3dzZXIgc29tZSB0aWUgdG8gcmVjYWxjdWxhdGVcblx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblxuXHRcdFx0dGhpcy5jYWxjdWxhdGVIZWlnaHQoKS50aGVuKCgpID0+IHtcblx0XHRcdFx0dGhpcy5zZXRIZWlnaHQoKTtcblx0XHRcdH0pO1xuXHRcdH0sIDIwMCk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBFbmFibGUgY2FsYyBtb2RlLlxuXHQgKlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZW5hYmxlQ2FsY01vZGUoKSB7XG5cblx0XHRpZiAoIXRoaXMuaXNPcGVuKSB7XG5cdFx0XHR0aGlzLiRlbC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMub3BlbkNsYXNzKTtcblx0XHRcdHRoaXMuJGVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jbG9zZUNsYXNzKTtcblx0XHR9XG5cblx0XHR0aGlzLiRlbC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY2FsY3VsYXRpbmdDbGFzcyk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlIGNhbGMgbW9kZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGRpc2FibGVDYWxjTW9kZSgpIHtcblxuXHRcdHRoaXMuJGVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jYWxjdWxhdGluZ0NsYXNzKTtcblxuXHRcdGlmICghdGhpcy5pc09wZW4pIHtcblx0XHRcdHRoaXMuJGVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jbG9zZUNsYXNzKTtcblx0XHRcdHRoaXMuJGVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5vcGVuQ2xhc3MpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuc2V0SGVpZ2h0KCk7XG5cdFx0fVxuXHR9XG5cblxuXHQvKipcblx0ICogU2V0IGhlaWdodCBvZiBjdXJyZW50IHZpZXcgZWxlbWVudCB0byBnaXZlbiB2YWx1ZSBvciBsYXRlc3QgY2FsY3VsYXRlZCB2YWx1ZS5cblx0ICpcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHRdIC0gaGVpZ2h0XG5cdCAqL1xuXHRzZXRIZWlnaHQoaGVpZ2h0KSB7XG5cdFx0dGhpcy4kZWwuY3NzKCdoZWlnaHQnLFxuXHRcdFx0dHlwZW9mIGhlaWdodCA9PT0gJ251bWJlcicgPyBoZWlnaHQgKyAncHgnIDogdGhpcy4kZWwuYXR0cih0aGlzLm9wdGlvbnMuZGF0YU1heEF0dHIpICsgJ3B4Jyk7XG5cdH1cblxuXG5cdC8qKlxuXHQgKiBDYWxjIHRoZSBoZWlnaHQgb2YgY3VycmVudCB2aWV3IGVsZW1lbnQuXG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRjYWxjSGVpZ2h0KCkge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0bGV0IHdhbnRlZEhlaWdodCA9IHRoaXMuJGVsLm91dGVySGVpZ2h0KCk7XG5cblx0XHRcdFx0dGhpcy4kZWwuYXR0cih0aGlzLm9wdGlvbnMuZGF0YU1heEF0dHIsIHdhbnRlZEhlaWdodCk7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gd2FudGVkSGVpZ2h0ICE9PSB0aGlzLmhlaWdodCA/IHdhbnRlZEhlaWdodCA6IHRoaXMuaGVpZ2h0O1xuXG5cdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdH0sIDEwKTtcblx0XHR9KTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIFNhdmUgYWxsIHN0eWxlcyBmcm9tIGN1cnJlbnQgdmlldyBlbGVtZW50XG5cdCAqXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRzYXZlU3R5bGVzKCkge1xuXHRcdHRoaXMuc2F2ZWRTdHlsZXMgPSB0aGlzLiRlbC5hdHRyKCdzdHlsZScpO1xuXHR9XG5cblxuXHQvKipcblx0ICogUmVzdG9yZSBhbGwgc3R5bGVzIGZyb20gY3VycmVudCB2aWV3IGVsZW1lbnRcblx0ICpcblx0ICogQHByaXZhdGVcblx0ICovXG5cdHJlc3RvcmVTdHlsZXMoKSB7XG5cdFx0dGhpcy4kZWwuYXR0cignc3R5bGUnLCB0aGlzLnNhdmVkU3R5bGVzKTtcblx0XHRkZWxldGUgdGhpcy5zYXZlZFN0eWxlcztcblx0fVxuXG5cblx0LyoqXG5cdCAqIFRvZ2dsZXMgY29udGVudFxuXHQgKlxuXHQgKiBAcHVibGljXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0aGUgZXZlbnQgZGF0YVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IG9iai5pc0FjdGl2ZSAtIGluZGljYXRlcyBpZiBwYW5lbCBzaG91bGQgb3BlbiBvciBjbG9zZSBpdHNlbGZcblx0ICogQHBhcmFtIHtTdHJpbmd9IG9iai5vcHRpb25zLnNldEZvY3VzIC0gZWxlbWVudCB0byBzZXQgZm9jdXMgb24gb3BlblxuXHQgKi9cblx0dG9nZ2xlKG9iaikge1xuXG5cdFx0Ly9jb25zb2xlLmxvZygnb2JqJywgb2JqKTtcblxuXHRcdC8vIGlmIGdsb2JhbEV2ZW50SWQgaXMgc2V0IG9uIGJvdGggKGN0YSBhbmQgdG9nZ2xlcilcblx0XHRpZiAodGhpcy5vcHRpb25zLmdsb2JhbEV2ZW50SWQgJiYgb2JqLm9wdGlvbnMgJiYgb2JqLm9wdGlvbnMuZ2xvYmFsRXZlbnRJZCkge1xuXG5cdFx0XHQvLyBzdG9wIGhlcmUgaWYgZ2xvYmFsIGV2ZW50IGlkIGRvbid0IG1hdGNoXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmdsb2JhbEV2ZW50SWQgIT09IG9iai5vcHRpb25zLmdsb2JhbEV2ZW50SWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblxuXG5cdFx0aWYgKG9iai5pc0FjdGl2ZSkge1xuXHRcdFx0dGhpcy5vcGVuKG9iaik7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5jbG9zZSgpO1xuXHRcdH1cblx0fVxuXG5cblx0LyoqXG5cdCAqIE9wZW4gY3VycmVudCB2aWV3IGVsZW1lbnRcblx0ICpcblx0ICogQHB1YmxpY1xuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29ial0gLSB0aGUgZXZlbnQgb2JqZWN0XG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW29iai5pc0FjdGl2ZV0gLSBpbmRpY2F0ZXMgaWYgcGFuZWwgc2hvdWxkIG9wZW4gb3IgY2xvc2UgaXRzZWxmXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbb2JqLm9wdGlvbnMuc2V0Rm9jdXNdIC0gZWxlbWVudCB0byBzZXQgZm9jdXMgb24gb3BlblxuXHQgKi9cblx0b3BlbihvYmopIHtcblx0XHR0aGlzLiRlbC5jc3MoJ2hlaWdodCcsIHRoaXMuJGVsLmF0dHIodGhpcy5vcHRpb25zLmRhdGFNYXhBdHRyKSArICdweCcpXG5cdFx0XHQuYXR0cignYXJpYS1oaWRkZW4nLCBmYWxzZSlcblx0XHRcdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuY2xvc2VDbGFzcylcblx0XHRcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMub3BlbkNsYXNzKTtcblxuXHRcdGlmIChvYmogJiYgb2JqLmZvY3VzRWwpIHtcblxuXHRcdFx0dGhpcy4kZWwub24oSGVscGVycy50cmFuc2l0aW9uRW5kRXZlbnQoKSwgKCkgPT4ge1xuXHRcdFx0XHRvYmouZm9jdXNFbC5mb2N1cygpO1xuXHRcdFx0XHR0aGlzLiRlbC5vZmYoSGVscGVycy50cmFuc2l0aW9uRW5kRXZlbnQoKSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRWZWFtcy5WZW50LnRyaWdnZXIoVmVhbXMuRVZFTlRTLnRvZ2dsZXIub3Blbiwge1xuXHRcdFx0Y29udGV4dDogdGhpcy5vcHRpb25zLmNvbnRleHRcblx0XHR9KTtcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuc2V0T3ZlcmZsb3cpIHtcblxuXHRcdFx0dGhpcy4kZWwub24oSGVscGVycy50cmFuc2l0aW9uRW5kRXZlbnQoKSwgKCkgPT4ge1xuXHRcdFx0XHR0aGlzLiRlbC5jc3MoJ292ZXJmbG93JywgJ3Zpc2libGUnKTtcblx0XHRcdFx0dGhpcy4kZWwub2ZmKEhlbHBlcnMudHJhbnNpdGlvbkVuZEV2ZW50KCkpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy50b2dnbGVUYWJpbmRleEVsZW1zKSB7XG5cdFx0XHQkKHRoaXMub3B0aW9ucy50b2dnbGVUYWJpbmRleEVsZW1zLCB0aGlzLmVsKS5hdHRyKCd0YWJpbmRleCcsIDApO1xuXHRcdH1cblxuXHRcdHRoaXMuaXNPcGVuID0gdHJ1ZTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIENsb3NlIGN1cnJlbnQgdmlldyBlbGVtZW50XG5cdCAqXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cdGNsb3NlKCkge1xuXHRcdHRoaXMuJGVsLmNzcygnaGVpZ2h0JywgMClcblx0XHRcdC5yZW1vdmVBdHRyKCdzdHlsZScpXG5cdFx0XHQuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpXG5cdFx0XHQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLm9wZW5DbGFzcylcblx0XHRcdC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY2xvc2VDbGFzcyk7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLnNldE92ZXJmbG93KSB7XG5cdFx0XHR0aGlzLiRlbC5jc3MoJ292ZXJmbG93JywgJ2hpZGRlbicpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLm9wdGlvbnMudG9nZ2xlVGFiaW5kZXhFbGVtcykge1xuXHRcdFx0JCh0aGlzLm9wdGlvbnMudG9nZ2xlVGFiaW5kZXhFbGVtcywgdGhpcy5lbCkuYXR0cigndGFiaW5kZXgnLCAtMSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5pc09wZW4gPSBmYWxzZTtcblx0fVxuXG5cblx0LyoqXG5cdCAqIGNhbGN1bGF0ZUhlaWdodCBjbGFzc1xuXHQgKi9cblx0Y2FsY3VsYXRlSGVpZ2h0KCkge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0XHRpZiAodGhpcy5lbCAmJiB0aGlzLmVsLmhhc0F0dHJpYnV0ZSgnc3R5bGUnKSkge1xuXHRcdFx0XHR0aGlzLnNhdmVTdHlsZXMoKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5lbmFibGVDYWxjTW9kZSh0cnVlKTtcblxuXHRcdFx0dGhpcy5jYWxjSGVpZ2h0KCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdGlmICh0aGlzLnNhdmVkU3R5bGVzKSB7XG5cdFx0XHRcdFx0dGhpcy5yZXN0b3JlU3R5bGVzKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLmRpc2FibGVDYWxjTW9kZSgpO1xuXG5cdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvZ2dsZXI7IiwiLy8gR2xvYmFsIGRlcGVuZGVuY2llcyBcbmltcG9ydCAkIGZyb20gJ2pxdWVyeSc7XG5pbXBvcnQgVmVhbXMgZnJvbSAndmVhbXMnO1xuXG5jb25zdCBIYW5kbGViYXJzID0gcmVxdWlyZSgnaGFuZGxlYmFycy9ydW50aW1lJyk7XG5jb25zdCBUZW1wbGF0ZXMgPSByZXF1aXJlKCcuL3RlbXBsYXRlcy90ZW1wbGF0ZXMnKTtcblxuaW1wb3J0IFZlYW1zTG9nZ2VyIGZyb20gJ3ZlYW1zLXBsdWdpbi1sb2dnZXInO1xuaW1wb3J0IFZlYW1zRE9NIGZyb20gJ3ZlYW1zLXBsdWdpbi1kb20nO1xuaW1wb3J0IFZlYW1zVmVudCBmcm9tICd2ZWFtcy1wbHVnaW4tdmVudCc7XG5pbXBvcnQgVmVhbXNNb2R1bGVzIGZyb20gJ3ZlYW1zLXBsdWdpbi1tb2R1bGVzJztcbmltcG9ydCBWZWFtc01lZGlhUXVlcnlIYW5kbGVyIGZyb20gJ3ZlYW1zLXBsdWdpbi1tZWRpYS1xdWVyeS1oYW5kbGVyJztcbi8vIGltcG9ydCBWZWFtc1N0b3JlIGZyb20gJ3ZlYW1zLXBsdWdpbi1zdG9yZSc7XG5pbXBvcnQgVmVhbXNUZW1wbGF0ZXIgZnJvbSAndmVhbXMtcGx1Z2luLXRlbXBsYXRlcic7XG5pbXBvcnQgRVZFTlRTIGZyb20gJy4vZXZlbnRzJztcblxuLy8gVHJpZ2dlciBnbG9iYWwgcmVzaXplIGV2ZW50XG53aW5kb3cub25zY3JvbGwgPSBWZWFtcy5oZWxwZXJzLnRocm90dGxlKChlKSA9PiB7XG4gICAgVmVhbXMuVmVudC50cmlnZ2VyKFZlYW1zLkVWRU5UUy5zY3JvbGwsIGUpO1xufSwgMjAwKTtcblxuXG5sZXQgQXBwID0ge307XG5BcHAuJCA9ICQ7XG5cbi8vIFZlcnNpb25pbmdcbkFwcC52ZXJzaW9uID0gXCIwLjAuMVwiO1xuXG4vLyBWZWFtc1xuVmVhbXMub25Jbml0aWFsaXplKCgpID0+IHtcblx0LyoqXG5cdCogVmVhbXMgUGx1Z2luc1xuXHQqL1xuXG5cdC8vIERvbSBQbHVnaW5cblx0VmVhbXMudXNlKFZlYW1zRE9NLCB7XG5cdFx0RE9NOiAkXG5cdH0pO1xuXG5cdC8vIFZlbnQgUGx1Z2luXG5cdFZlYW1zLnVzZShWZWFtc1ZlbnQsIHtcblx0XHRmdXJ0aGVyRXZlbnRzOiBFVkVOVFNcblx0fSk7XG5cblxuICAgIFZlYW1zLnVzZShWZWFtc1RlbXBsYXRlciwge1xuICAgICAgICB0ZW1wbGF0ZXM6IFRlbXBsYXRlcyxcbiAgICAgICAgZW5naW5lOiBIYW5kbGViYXJzXG4gICAgfSk7XG5cblxuICAgIC8vIExvZ2dlciBQbHVnaW4gZm9yIGRldm1vZGUgYW5kIGxvZ2dlclxuXHRWZWFtcy51c2UoVmVhbXNMb2dnZXIpO1xuXG5cdC8vIE1vZHVsZSBTeXN0ZW0gUGx1Z2luXG5cdFZlYW1zLnVzZShWZWFtc01vZHVsZXMsIHtcblx0XHR1c2VNdXRhdGlvbk9ic2VydmVyOiB0cnVlLFxuXHRcdGludGVybmFsQ2FjaGVPbmx5OiBmYWxzZVxuXHR9KTtcblxuXHQvLyBTdG9yZSBQbHVnaW5cblx0Ly8gVmVhbXMudXNlKFZlYW1zU3RvcmUsIHtcblx0Ly8gXHRyZWR1Y2VyOiByb290UmVkdWNlcixcblx0Ly8gXHRzdGF0ZTogSU5JVElBTF9TVEFURSxcblx0Ly8gXHRzdWJqZWN0czogc3ViamVjdHNcblx0Ly8gfSk7XG5cblx0Ly8gTWVkaWEgUXVlcnkgSGFuZGxlciBQbHVnaW5cblx0VmVhbXMudXNlKFZlYW1zTWVkaWFRdWVyeUhhbmRsZXIpO1xufSk7XG5cbmV4cG9ydCB7QXBwLCBWZWFtc307Il19
